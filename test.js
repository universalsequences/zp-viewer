(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  function setupGlobals(global) {
    global.Reflect = global.Reflect || {};
    global.Reflect.global = global.Reflect.global || global;
  }
  setupGlobals(global);
  var typeOf = function(x) {
    return typeof x;
  };
  global.$traceurRuntime = {
    options: {},
    setupGlobals: setupGlobals,
    typeof: typeOf
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__3 = $traceurRuntime,
      canonicalizeUrl = $__3.canonicalizeUrl,
      resolveUrl = $__3.resolveUrl,
      isAbsolute = $__3.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  }
  function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  }
  ModuleEvaluationError.prototype = Object.create(Error.prototype);
  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;
  ModuleEvaluationError.prototype.stripError = function(message) {
    return message.replace(/.*Error:/, this.constructor.name + ':');
  };
  ModuleEvaluationError.prototype.stripCause = function(cause) {
    if (!cause)
      return '';
    if (!cause.message)
      return cause + '';
    return this.stripError(cause.message);
  };
  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {
    this.stack += '\n loaded by ' + moduleName;
  };
  ModuleEvaluationError.prototype.stripStack = function(causeStack) {
    var stack = [];
    causeStack.split('\n').some(function(frame) {
      if (/UncoatedModuleInstantiator/.test(frame))
        return true;
      stack.push(frame);
    });
    stack[0] = this.stripError(stack[0]);
    return stack.join('\n');
  };
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  function UncoatedModuleInstantiator(url, func) {
    UncoatedModuleEntry.call(this, url, null);
    this.func = func;
  }
  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);
  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {
    var $__2 = this;
    if (this.value_)
      return this.value_;
    try {
      var relativeRequire;
      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {
        relativeRequire = $traceurRuntime.require.bind(null, this.url);
      }
      return this.value_ = this.func.call(global, relativeRequire);
    } catch (ex) {
      if (ex instanceof ModuleEvaluationError) {
        ex.loadedBy(this.url);
        throw ex;
      }
      if (ex.stack) {
        var lines = this.func.toString().split('\n');
        var evaled = [];
        ex.stack.split('\n').some(function(frame, index) {
          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
            return true;
          var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
          if (m) {
            var line = parseInt(m[2], 10);
            evaled = evaled.concat(beforeLines(lines, line));
            if (index === 1) {
              evaled.push(columnSpacing(m[3]) + '^ ' + $__2.url);
            } else {
              evaled.push(columnSpacing(m[3]) + '^');
            }
            evaled = evaled.concat(afterLines(lines, line));
            evaled.push('= = = = = = = = =');
          } else {
            evaled.push(frame);
          }
        });
        ex.stack = evaled.join('\n');
      }
      throw new ModuleEvaluationError(this.url, ex);
    }
  };
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    });
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {
        return module;
      });
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__2 = arguments;
            var depMap = {};
            deps.forEach(function(dep, index) {
              return depMap[dep] = $__2[index];
            });
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func(), liveModuleSentinel);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  $traceurRuntime.registerModule = ModuleStore.registerModule.bind(ModuleStore);
  $traceurRuntime.getModule = ModuleStore.get;
  $traceurRuntime.setModule = ModuleStore.set;
  $traceurRuntime.normalizeModuleName = ModuleStore.normalize;
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/new-unique-string.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/new-unique-string.js";
  var random = Math.random;
  var counter = Date.now() % 1e9;
  function newUniqueString() {
    return '__$' + (random() * 1e9 >>> 1) + '$' + ++counter + '$__';
  }
  return {get default() {
      return newUniqueString;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/has-native-symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/has-native-symbols.js";
  var v = !!Object.getOwnPropertySymbols && typeof Symbol === 'function';
  function hasNativeSymbol() {
    return v;
  }
  return {get default() {
      return hasNativeSymbol;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/symbols.js";
  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../new-unique-string.js", "traceur-runtime@0.0.111/src/runtime/modules/symbols.js")).default;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/modules/symbols.js")).default;
  var $create = Object.create;
  var $defineProperty = Object.defineProperty;
  var $freeze = Object.freeze;
  var $getOwnPropertyNames = Object.getOwnPropertyNames;
  var $keys = Object.keys;
  var $TypeError = TypeError;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  var SymbolImpl = function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof SymbolImpl))
      return value;
    throw new $TypeError('Symbol cannot be new\'ed');
  };
  $defineProperty(SymbolImpl.prototype, 'constructor', nonEnum(SymbolImpl));
  $defineProperty(SymbolImpl.prototype, 'toString', nonEnum(function() {
    var symbolValue = this[symbolDataProperty];
    return symbolValue[symbolInternalProperty];
  }));
  $defineProperty(SymbolImpl.prototype, 'valueOf', nonEnum(function() {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue)
      throw $TypeError('Conversion from symbol to string');
    return symbolValue[symbolInternalProperty];
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, {value: this});
    $defineProperty(this, symbolInternalProperty, {value: key});
    $defineProperty(this, symbolDescriptionProperty, {value: description});
    $freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(SymbolImpl));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: SymbolImpl.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: SymbolImpl.prototype.valueOf,
    enumerable: false
  });
  $freeze(SymbolValue.prototype);
  function isSymbolString(s) {
    return symbolValues[s];
  }
  function removeSymbolKeys(array) {
    var rv = [];
    for (var i = 0; i < array.length; i++) {
      if (!isSymbolString(array[i])) {
        rv.push(array[i]);
      }
    }
    return rv;
  }
  function getOwnPropertyNames(object) {
    return removeSymbolKeys($getOwnPropertyNames(object));
  }
  function keys(object) {
    return removeSymbolKeys($keys(object));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) {
        rv.push(symbol);
      }
    }
    return rv;
  }
  function polyfillSymbol(global) {
    var Object = global.Object;
    if (!hasNativeSymbol()) {
      global.Symbol = SymbolImpl;
      Object.getOwnPropertyNames = getOwnPropertyNames;
      Object.keys = keys;
      $defineProperty(Object, 'getOwnPropertySymbols', nonEnum(getOwnPropertySymbols));
    }
    if (!global.Symbol.iterator) {
      global.Symbol.iterator = global.Symbol('Symbol.iterator');
    }
    if (!global.Symbol.observer) {
      global.Symbol.observer = global.Symbol('Symbol.observer');
    }
  }
  var g = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : (void 0);
  polyfillSymbol(g);
  var typeOf = hasNativeSymbol() ? function(x) {
    return typeof x;
  } : function(x) {
    return x instanceof SymbolValue ? 'symbol' : typeof x;
  };
  return {get typeof() {
      return typeOf;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/typeof.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/typeof.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur-runtime@0.0.111/src/runtime/modules/typeof.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__.typeof;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/symbols.js";
  var t = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/typeof.js", "traceur-runtime@0.0.111/src/runtime/symbols.js")).default;
  $traceurRuntime.typeof = t;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createClass.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createClass.js";
  var $Object = Object;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty,
      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols;
  function forEachPropertyKey(object, f) {
    getOwnPropertyNames(object).forEach(f);
    if (getOwnPropertySymbols) {
      getOwnPropertySymbols(object).forEach(f);
    }
  }
  function getDescriptors(object) {
    var descriptors = {};
    forEachPropertyKey(object, function(key) {
      descriptors[key] = getOwnPropertyDescriptor(object, key);
      descriptors[key].enumerable = false;
    });
    return descriptors;
  }
  var nonEnum = {enumerable: false};
  function makePropertiesNonEnumerable(object) {
    forEachPropertyKey(object, function(key) {
      defineProperty(object, key, nonEnum);
    });
  }
  function createClass(ctor, object, staticObject, superClass) {
    defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = create(getProtoParent(superClass), getDescriptors(object));
    } else {
      makePropertiesNonEnumerable(object);
      ctor.prototype = object;
    }
    defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  return {get default() {
      return createClass;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superConstructor.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superConstructor.js";
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  return {get default() {
      return superConstructor;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superDescriptor.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superDescriptor.js";
  var $__0 = Object,
      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,
      getPrototypeOf = $__0.getPrototypeOf;
  function superDescriptor(homeObject, name) {
    var proto = getPrototypeOf(homeObject);
    do {
      var result = getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  return {get default() {
      return superDescriptor;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superGet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superGet.js";
  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur-runtime@0.0.111/src/runtime/modules/superGet.js")).default;
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      var value = descriptor.value;
      if (value)
        return value;
      if (!descriptor.get)
        return value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  return {get default() {
      return superGet;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superSet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superSet.js";
  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur-runtime@0.0.111/src/runtime/modules/superSet.js")).default;
  var $TypeError = TypeError;
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  return {get default() {
      return superSet;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/classes.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/classes.js";
  var createClass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createClass.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superConstructor.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superGet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superGet.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superSet.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/exportStar.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/exportStar.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      getOwnPropertyNames = $__1.getOwnPropertyNames;
  function exportStar(object) {
    var $__2 = arguments,
        $__3 = function(i) {
          var mod = $__2[i];
          var names = getOwnPropertyNames(mod);
          var $__5 = function(j) {
            var name = names[j];
            if (name === '__esModule' || name === 'default') {
              return 0;
            }
            defineProperty(object, name, {
              get: function() {
                return mod[name];
              },
              enumerable: true
            });
          },
              $__6;
          $__4: for (var j = 0; j < names.length; j++) {
            $__6 = $__5(j);
            switch ($__6) {
              case 0:
                continue $__4;
            }
          }
        };
    for (var i = 1; i < arguments.length; i++) {
      $__3(i);
    }
    return object;
  }
  return {get default() {
      return exportStar;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/exportStar.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/exportStar.js";
  var exportStar = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/exportStar.js", "traceur-runtime@0.0.111/src/runtime/exportStar.js")).default;
  $traceurRuntime.exportStar = exportStar;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private-symbol.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private-symbol.js";
  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./new-unique-string.js", "traceur-runtime@0.0.111/src/runtime/private-symbol.js")).default;
  var $Symbol = typeof Symbol === 'function' ? Symbol : undefined;
  var $getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var $create = Object.create;
  var privateNames = $create(null);
  function isPrivateSymbol(s) {
    return privateNames[s];
  }
  ;
  function createPrivateSymbol() {
    var s = ($Symbol || newUniqueString)();
    privateNames[s] = true;
    return s;
  }
  ;
  function hasPrivate(obj, sym) {
    return hasOwnProperty.call(obj, sym);
  }
  ;
  function deletePrivate(obj, sym) {
    if (!hasPrivate(obj, sym)) {
      return false;
    }
    delete obj[sym];
    return true;
  }
  ;
  function setPrivate(obj, sym, val) {
    obj[sym] = val;
  }
  ;
  function getPrivate(obj, sym) {
    var val = obj[sym];
    if (val === undefined)
      return undefined;
    return hasOwnProperty.call(obj, sym) ? val : undefined;
  }
  ;
  function init() {
    if ($getOwnPropertySymbols) {
      Object.getOwnPropertySymbols = function getOwnPropertySymbols(object) {
        var rv = [];
        var symbols = $getOwnPropertySymbols(object);
        for (var i = 0; i < symbols.length; i++) {
          var symbol = symbols[i];
          if (!isPrivateSymbol(symbol)) {
            rv.push(symbol);
          }
        }
        return rv;
      };
    }
  }
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    },
    get init() {
      return init;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private-weak-map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private-weak-map.js";
  var $WeakMap = typeof WeakMap === 'function' ? WeakMap : undefined;
  function isPrivateSymbol(s) {
    return false;
  }
  function createPrivateSymbol() {
    return new $WeakMap();
  }
  function hasPrivate(obj, sym) {
    return sym.has(obj);
  }
  function deletePrivate(obj, sym) {
    return sym.delete(obj);
  }
  function setPrivate(obj, sym, val) {
    sym.set(obj, val);
  }
  function getPrivate(obj, sym) {
    return sym.get(obj);
  }
  function init() {}
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    },
    get init() {
      return init;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private.js";
  var sym = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-symbol.js", "traceur-runtime@0.0.111/src/runtime/private.js"));
  var weak = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-weak-map.js", "traceur-runtime@0.0.111/src/runtime/private.js"));
  var hasWeakMap = typeof WeakMap === 'function';
  var m = hasWeakMap ? weak : sym;
  var isPrivateSymbol = m.isPrivateSymbol;
  var createPrivateSymbol = m.createPrivateSymbol;
  var hasPrivate = m.hasPrivate;
  var deletePrivate = m.deletePrivate;
  var setPrivate = m.setPrivate;
  var getPrivate = m.getPrivate;
  m.init();
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js")),
      getPrivate = $__0.getPrivate,
      setPrivate = $__0.setPrivate,
      createPrivateSymbol = $__0.createPrivateSymbol;
  var $apply = Function.prototype.call.bind(Function.prototype.apply);
  var CONTINUATION_TYPE = Object.create(null);
  var isTailRecursiveName = null;
  function createContinuation(operand, thisArg, argsArray) {
    return [CONTINUATION_TYPE, operand, thisArg, argsArray];
  }
  function isContinuation(object) {
    return object && object[0] === CONTINUATION_TYPE;
  }
  function $bind(operand, thisArg, args) {
    var argArray = [thisArg];
    for (var i = 0; i < args.length; i++) {
      argArray[i + 1] = args[i];
    }
    var func = $apply(Function.prototype.bind, operand, argArray);
    return func;
  }
  function $construct(func, argArray) {
    var object = new ($bind(func, null, argArray));
    return object;
  }
  function isTailRecursive(func) {
    return !!getPrivate(func, isTailRecursiveName);
  }
  function tailCall(func, thisArg, argArray) {
    var continuation = argArray[0];
    if (isContinuation(continuation)) {
      continuation = $apply(func, thisArg, continuation[3]);
      return continuation;
    }
    continuation = createContinuation(func, thisArg, argArray);
    while (true) {
      if (isTailRecursive(func)) {
        continuation = $apply(func, continuation[2], [continuation]);
      } else {
        continuation = $apply(func, continuation[2], continuation[3]);
      }
      if (!isContinuation(continuation)) {
        return continuation;
      }
      func = continuation[1];
    }
  }
  function construct() {
    var object;
    if (isTailRecursive(this)) {
      object = $construct(this, [createContinuation(null, null, arguments)]);
    } else {
      object = $construct(this, arguments);
    }
    return object;
  }
  function setupProperTailCalls() {
    isTailRecursiveName = createPrivateSymbol();
    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {
      var result = tailCall(function(thisArg) {
        var argArray = [];
        for (var i = 1; i < arguments.length; ++i) {
          argArray[i - 1] = arguments[i];
        }
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {
      var result = tailCall(function(thisArg, argArray) {
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
  }
  function initTailRecursiveFunction(func) {
    if (isTailRecursiveName === null) {
      setupProperTailCalls();
    }
    setPrivate(func, isTailRecursiveName, true);
    return func;
  }
  return {
    get createContinuation() {
      return createContinuation;
    },
    get tailCall() {
      return tailCall;
    },
    get construct() {
      return construct;
    },
    get initTailRecursiveFunction() {
      return initTailRecursiveFunction;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.initTailRecursiveFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/call.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/call.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/call.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.tailCall;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/continuation.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/continuation.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/continuation.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.createContinuation;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/construct.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/construct.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/construct.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.construct;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/properTailCalls.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/properTailCalls.js";
  var initTailRecursiveFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initTailRecursiveFunction.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var call = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/call.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var continuation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/continuation.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var construct = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/construct.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  $traceurRuntime.initTailRecursiveFunction = initTailRecursiveFunction;
  $traceurRuntime.call = call;
  $traceurRuntime.continuation = continuation;
  $traceurRuntime.construct = construct;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/relativeRequire.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/relativeRequire.js";
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/checkObjectCoercible.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/checkObjectCoercible.js";
  var $TypeError = TypeError;
  function checkObjectCoercible(v) {
    if (v === null || v === undefined) {
      throw new $TypeError('Value cannot be converted to an Object');
    }
    return v;
  }
  return {get default() {
      return checkObjectCoercible;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spread.js";
  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur-runtime@0.0.111/src/runtime/modules/spread.js")).default;
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[Symbol.iterator] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[Symbol.iterator]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  return {get default() {
      return spread;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/spread.js";
  var spread = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spread.js", "traceur-runtime@0.0.111/src/runtime/spread.js")).default;
  $traceurRuntime.spread = spread;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/iteratorToArray.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/iteratorToArray.js";
  function iteratorToArray(iter) {
    var rv = [];
    var i = 0;
    var tmp;
    while (!(tmp = iter.next()).done) {
      rv[i++] = tmp.value;
    }
    return rv;
  }
  return {get default() {
      return iteratorToArray;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/destructuring.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/destructuring.js";
  var iteratorToArray = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/iteratorToArray.js", "traceur-runtime@0.0.111/src/runtime/destructuring.js")).default;
  $traceurRuntime.iteratorToArray = iteratorToArray;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/async.js";
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/async.js")),
      createPrivateSymbol = $__12.createPrivateSymbol,
      getPrivate = $__12.getPrivate,
      setPrivate = $__12.setPrivate;
  var $__11 = Object,
      create = $__11.create,
      defineProperty = $__11.defineProperty;
  var observeName = createPrivateSymbol();
  function AsyncGeneratorFunction() {}
  function AsyncGeneratorFunctionPrototype() {}
  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;
  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;
  defineProperty(AsyncGeneratorFunctionPrototype, 'constructor', {enumerable: false});
  var AsyncGeneratorContext = function() {
    function AsyncGeneratorContext(observer) {
      var $__2 = this;
      this.decoratedObserver = createDecoratedGenerator(observer, function() {
        $__2.done = true;
      });
      this.done = false;
      this.inReturn = false;
    }
    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {
      throw: function(error) {
        if (!this.inReturn) {
          throw error;
        }
      },
      yield: function(value) {
        if (this.done) {
          this.inReturn = true;
          throw undefined;
        }
        var result;
        try {
          result = this.decoratedObserver.next(value);
        } catch (e) {
          this.done = true;
          throw e;
        }
        if (result === undefined) {
          return;
        }
        if (result.done) {
          this.done = true;
          this.inReturn = true;
          throw undefined;
        }
        return result.value;
      },
      yieldFor: function(observable) {
        var ctx = this;
        return observeForEach(observable[Symbol.observer].bind(observable), function(value) {
          if (ctx.done) {
            this.return();
            return;
          }
          var result;
          try {
            result = ctx.decoratedObserver.next(value);
          } catch (e) {
            ctx.done = true;
            throw e;
          }
          if (result === undefined) {
            return;
          }
          if (result.done) {
            ctx.done = true;
          }
          return result;
        });
      }
    }, {});
  }();
  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {
    var observe = getPrivate(this, observeName);
    var ctx = new AsyncGeneratorContext(observer);
    schedule(function() {
      return observe(ctx);
    }).then(function(value) {
      if (!ctx.done) {
        ctx.decoratedObserver.return(value);
      }
    }).catch(function(error) {
      if (!ctx.done) {
        ctx.decoratedObserver.throw(error);
      }
    });
    return ctx.decoratedObserver;
  };
  defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});
  function initAsyncGeneratorFunction(functionObject) {
    functionObject.prototype = create(AsyncGeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;
    return functionObject;
  }
  function createAsyncGeneratorInstance(observe, functionObject) {
    for (var args = [],
        $__10 = 2; $__10 < arguments.length; $__10++)
      args[$__10 - 2] = arguments[$__10];
    var object = create(functionObject.prototype);
    setPrivate(object, observeName, observe);
    return object;
  }
  function observeForEach(observe, next) {
    return new Promise(function(resolve, reject) {
      var generator = observe({
        next: function(value) {
          return next.call(generator, value);
        },
        throw: function(error) {
          reject(error);
        },
        return: function(value) {
          resolve(value);
        }
      });
    });
  }
  function schedule(asyncF) {
    return Promise.resolve().then(asyncF);
  }
  var generator = Symbol();
  var onDone = Symbol();
  var DecoratedGenerator = function() {
    function DecoratedGenerator(_generator, _onDone) {
      this[generator] = _generator;
      this[onDone] = _onDone;
    }
    return ($traceurRuntime.createClass)(DecoratedGenerator, {
      next: function(value) {
        var result = this[generator].next(value);
        if (result !== undefined && result.done) {
          this[onDone].call(this);
        }
        return result;
      },
      throw: function(error) {
        this[onDone].call(this);
        return this[generator].throw(error);
      },
      return: function(value) {
        this[onDone].call(this);
        return this[generator].return(value);
      }
    }, {});
  }();
  function createDecoratedGenerator(generator, onDone) {
    return new DecoratedGenerator(generator, onDone);
  }
  Array.prototype[Symbol.observer] = function(observer) {
    var done = false;
    var decoratedObserver = createDecoratedGenerator(observer, function() {
      return done = true;
    });
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      for (var $__4 = void 0,
          $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        var value = $__4.value;
        {
          decoratedObserver.next(value);
          if (done) {
            return;
          }
        }
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
    decoratedObserver.return();
    return decoratedObserver;
  };
  defineProperty(Array.prototype, Symbol.observer, {enumerable: false});
  return {
    get initAsyncGeneratorFunction() {
      return initAsyncGeneratorFunction;
    },
    get createAsyncGeneratorInstance() {
      return createAsyncGeneratorInstance;
    },
    get observeForEach() {
      return observeForEach;
    },
    get schedule() {
      return schedule;
    },
    get createDecoratedGenerator() {
      return createDecoratedGenerator;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.initAsyncGeneratorFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createAsyncGeneratorInstance;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.observeForEach;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/schedule.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/schedule.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/schedule.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.schedule;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createDecoratedGenerator;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/async.js";
  var initAsyncGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initAsyncGeneratorFunction.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var createAsyncGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createAsyncGeneratorInstance.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var observeForEach = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/observeForEach.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var schedule = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/schedule.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var createDecoratedGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createDecoratedGenerator.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;
  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;
  $traceurRuntime.observeForEach = observeForEach;
  $traceurRuntime.schedule = schedule;
  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/generators.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/generators.js")),
      createPrivateSymbol = $__2.createPrivateSymbol,
      getPrivate = $__2.getPrivate,
      setPrivate = $__2.setPrivate;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  var RETURN_SENTINEL = {};
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.oldReturnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    maybeUncatchable: function() {
      if (this.storedException === RETURN_SENTINEL) {
        throw RETURN_SENTINEL;
      }
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    },
    wrapYieldStar: function(iterator) {
      var ctx = this;
      return {
        next: function(v) {
          return iterator.next(v);
        },
        throw: function(e) {
          var result;
          if (e === RETURN_SENTINEL) {
            if (iterator.return) {
              result = iterator.return(ctx.returnValue);
              if (!result.done) {
                ctx.returnValue = ctx.oldReturnValue;
                return result;
              }
              ctx.returnValue = result.value;
            }
            throw e;
          }
          if (iterator.throw) {
            return iterator.throw(e);
          }
          iterator.return && iterator.return();
          throw $TypeError('Inner iterator does not have a throw method');
        }
      };
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        if (x === RETURN_SENTINEL) {
          return {
            value: ctx.returnValue,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          if (x === RETURN_SENTINEL) {
            return {
              value: ctx.returnValue,
              done: true
            };
          }
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value;
        try {
          value = moveNext(ctx);
        } catch (ex) {
          if (ex === RETURN_SENTINEL) {
            value = ctx;
          } else {
            throw ex;
          }
        }
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateSymbol();
  var moveNextName = createPrivateSymbol();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'throw', v);
    },
    return: function(v) {
      var ctx = getPrivate(this, ctxName);
      ctx.oldReturnValue = ctx.returnValue;
      ctx.returnValue = v;
      return nextOrThrow(ctx, getPrivate(this, moveNextName), 'throw', RETURN_SENTINEL);
    }
  };
  defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false},
    return: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = create(functionObject.prototype);
    setPrivate(object, ctxName, ctx);
    setPrivate(object, moveNextName, moveNext);
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return;
    }
    ctx.state = last.catch !== undefined ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  return {
    get createGeneratorInstance() {
      return createGeneratorInstance;
    },
    get initGeneratorFunction() {
      return initGeneratorFunction;
    },
    get asyncWrap() {
      return asyncWrap;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.asyncWrap;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.initGeneratorFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.createGeneratorInstance;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/generators.js";
  var asyncWrap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/asyncWrap.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  var initGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initGeneratorFunction.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  var createGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createGeneratorInstance.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spawn.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spawn.js";
  function spawn(self, args, gen) {
    return new Promise(function(resolve, reject) {
      function fulfill(v) {
        try {
          step(gen.next(v));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(v) {
        try {
          step(gen.throw(v));
        } catch (e) {
          reject(e);
        }
      }
      function step(res) {
        if (res.done) {
          resolve(res.value);
        } else {
          Promise.resolve(res.value).then(fulfill, rejected);
        }
      }
      step((gen = gen.apply(self, args)).next());
    });
  }
  return {get default() {
      return spawn;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/spawn.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/spawn.js";
  var spawn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spawn.js", "traceur-runtime@0.0.111/src/runtime/spawn.js")).default;
  $traceurRuntime.spawn = spawn;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/getTemplateObject.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/getTemplateObject.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      freeze = $__1.freeze;
  var slice = Array.prototype.slice;
  var map = Object.create(null);
  function getTemplateObject(raw) {
    var cooked = arguments[1];
    var key = raw.join('${}');
    var templateObject = map[key];
    if (templateObject)
      return templateObject;
    if (!cooked) {
      cooked = slice.call(raw);
    }
    return map[key] = freeze(defineProperty(cooked, 'raw', {value: freeze(raw)}));
  }
  return {get default() {
      return getTemplateObject;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/template.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/template.js";
  var getTemplateObject = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/getTemplateObject.js", "traceur-runtime@0.0.111/src/runtime/template.js")).default;
  $traceurRuntime.getTemplateObject = getTemplateObject;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spreadProperties.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spreadProperties.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols,
      propertyIsEnumerable = $__1.propertyIsEnumerable;
  function createDataProperty(o, p, v) {
    defineProperty(o, p, {
      configurable: true,
      enumerable: true,
      value: v,
      writable: true
    });
  }
  function copyDataProperties(target, source) {
    if (source == null) {
      return;
    }
    var copy = function(keys) {
      for (var i = 0; i < keys.length; i++) {
        var nextKey = keys[i];
        if (propertyIsEnumerable.call(source, nextKey)) {
          var propValue = source[nextKey];
          createDataProperty(target, nextKey, propValue);
        }
      }
    };
    copy(getOwnPropertyNames(source));
    copy(getOwnPropertySymbols(source));
  }
  var $__default = function() {
    var target = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      copyDataProperties(target, arguments[i]);
    }
    return target;
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/jsx.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/jsx.js";
  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spreadProperties.js", "traceur-runtime@0.0.111/src/runtime/jsx.js")).default;
  $traceurRuntime.spreadProperties = spreadProperties;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/runtime-modules.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/runtime-modules.js";
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./classes.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./exportStar.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./relativeRequire.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spread.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./destructuring.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spawn.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./template.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./jsx.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  return {};
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/runtime-modules.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/frozen-data.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/frozen-data.js";
  function findIndex(arr, key) {
    for (var i = 0; i < arr.length; i += 2) {
      if (arr[i] === key) {
        return i;
      }
    }
    return -1;
  }
  function setFrozen(arr, key, val) {
    var i = findIndex(arr, key);
    if (i === -1) {
      arr.push(key, val);
    }
  }
  function getFrozen(arr, key) {
    var i = findIndex(arr, key);
    if (i !== -1) {
      return arr[i + 1];
    }
    return undefined;
  }
  function hasFrozen(arr, key) {
    return findIndex(arr, key) !== -1;
  }
  function deleteFrozen(arr, key) {
    var i = findIndex(arr, key);
    if (i !== -1) {
      arr.splice(i, 2);
      return true;
    }
    return false;
  }
  return {
    get setFrozen() {
      return setFrozen;
    },
    get getFrozen() {
      return getFrozen;
    },
    get hasFrozen() {
      return hasFrozen;
    },
    get deleteFrozen() {
      return deleteFrozen;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var $TypeError = TypeError;
  var $Object = Object;
  function toObject(x) {
    if (x == null) {
      throw $TypeError();
    }
    return $Object(x);
  }
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach(function(f) {
      return f(global);
    });
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js";
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      createPrivateSymbol = $__16.createPrivateSymbol,
      getPrivate = $__16.getPrivate,
      setPrivate = $__16.setPrivate;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      deleteFrozen = $__17.deleteFrozen,
      getFrozen = $__17.getFrozen,
      setFrozen = $__17.setFrozen;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      isObject = $__18.isObject,
      registerPolyfill = $__18.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")).default;
  var $__9 = Object,
      defineProperty = $__9.defineProperty,
      getOwnPropertyDescriptor = $__9.getOwnPropertyDescriptor,
      hasOwnProperty = $__9.hasOwnProperty,
      isExtensible = $__9.isExtensible;
  var deletedSentinel = {};
  var counter = 1;
  var hashCodeName = createPrivateSymbol();
  function getHashCodeForObject(obj) {
    return getPrivate(obj, hashCodeName);
  }
  function getOrSetHashCodeForObject(obj) {
    var hash = getHashCodeForObject(obj);
    if (!hash) {
      hash = counter++;
      setPrivate(obj, hashCodeName, hash);
    }
    return hash;
  }
  function lookupIndex(map, key) {
    if (typeof key === 'string') {
      return map.stringIndex_[key];
    }
    if (isObject(key)) {
      if (!isExtensible(key)) {
        return getFrozen(map.frozenData_, key);
      }
      var hc = getHashCodeForObject(key);
      if (hc === undefined) {
        return undefined;
      }
      return map.objectIndex_[hc];
    }
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.frozenData_ = [];
    map.deletedCount_ = 0;
  }
  var Map = function() {
    function Map() {
      var $__11,
          $__12;
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Map called on incompatible type');
      if (hasOwnProperty.call(this, 'entries_')) {
        throw new TypeError('Map can not be reentrantly initialised');
      }
      initMap(this);
      if (iterable !== null && iterable !== undefined) {
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (iterable)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__10 = $__3.value,
                key = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
                value = ($__12 = $__11.next()).done ? void 0 : $__12.value;
            {
              this.set(key, value);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Map, {
      get size() {
        return this.entries_.length / 2 - this.deletedCount_;
      },
      get: function(key) {
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          return this.entries_[index + 1];
        }
      },
      set: function(key, value) {
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          this.entries_[index + 1] = value;
        } else {
          index = this.entries_.length;
          this.entries_[index] = key;
          this.entries_[index + 1] = value;
          if (isObject(key)) {
            if (!isExtensible(key)) {
              setFrozen(this.frozenData_, key, index);
            } else {
              var hash = getOrSetHashCodeForObject(key);
              this.objectIndex_[hash] = index;
            }
          } else if (typeof key === 'string') {
            this.stringIndex_[key] = index;
          } else {
            this.primitiveIndex_[key] = index;
          }
        }
        return this;
      },
      has: function(key) {
        return lookupIndex(this, key) !== undefined;
      },
      delete: function(key) {
        var index = lookupIndex(this, key);
        if (index === undefined) {
          return false;
        }
        this.entries_[index] = deletedSentinel;
        this.entries_[index + 1] = undefined;
        this.deletedCount_++;
        if (isObject(key)) {
          if (!isExtensible(key)) {
            deleteFrozen(this.frozenData_, key);
          } else {
            var hash = getHashCodeForObject(key);
            delete this.objectIndex_[hash];
          }
        } else if (typeof key === 'string') {
          delete this.stringIndex_[key];
        } else {
          delete this.primitiveIndex_[key];
        }
        return true;
      },
      clear: function() {
        initMap(this);
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        for (var i = 0; i < this.entries_.length; i += 2) {
          var key = this.entries_[i];
          var value = this.entries_[i + 1];
          if (key === deletedSentinel)
            continue;
          callbackFn.call(thisArg, value, key, this);
        }
      },
      entries: $traceurRuntime.initGeneratorFunction(function $__13() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return [key, value];
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__13, this);
      }),
      keys: $traceurRuntime.initGeneratorFunction(function $__14() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return key;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__14, this);
      }),
      values: $traceurRuntime.initGeneratorFunction(function $__15() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return value;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      })
    }, {});
  }();
  defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function needsPolyfill(global) {
    var $__10 = global,
        Map = $__10.Map,
        Symbol = $__10.Symbol;
    if (!Map || !hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {
      return true;
    }
    try {
      return new Map([[]]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillMap(global) {
    if (needsPolyfill(global)) {
      global.Map = Map;
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Map.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js";
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")),
      isObject = $__18.isObject,
      registerPolyfill = $__18.registerPolyfill;
  var Map = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Map.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")).Map;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")).default;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var Set = function() {
    function Set() {
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Set called on incompatible type');
      if (hasOwnProperty.call(this, 'map_')) {
        throw new TypeError('Set can not be reentrantly initialised');
      }
      this.map_ = new Map();
      if (iterable !== null && iterable !== undefined) {
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (iterable)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var item = $__4.value;
            {
              this.add(item);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Set, {
      get size() {
        return this.map_.size;
      },
      has: function(key) {
        return this.map_.has(key);
      },
      add: function(key) {
        this.map_.set(key, key);
        return this;
      },
      delete: function(key) {
        return this.map_.delete(key);
      },
      clear: function() {
        return this.map_.clear();
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        var $__2 = this;
        return this.map_.forEach(function(value, key) {
          callbackFn.call(thisArg, key, key, $__2);
        });
      },
      values: $traceurRuntime.initGeneratorFunction(function $__12() {
        var $__13,
            $__14;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__13 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__14.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__14.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__14.value;
              default:
                return $ctx.end();
            }
        }, $__12, this);
      }),
      entries: $traceurRuntime.initGeneratorFunction(function $__15() {
        var $__16,
            $__17;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__16 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__17 = $__16[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__17.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__17.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__17.value;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      })
    }, {});
  }();
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function needsPolyfill(global) {
    var $__11 = global,
        Set = $__11.Set,
        Symbol = $__11.Symbol;
    if (!Set || !hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {
      return true;
    }
    try {
      return new Set([1]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillSet(global) {
    if (needsPolyfill(global)) {
      global.Set = Set;
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Set.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  var toString = {}.toString;
  var vertxNext;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var browserWindow = (typeof window !== 'undefined') ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    var nextTick = process.nextTick;
    var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
      nextTick = setImmediate;
    }
    return function() {
      nextTick(flush);
    };
  }
  function useVertxTimer() {
    return function() {
      vertxNext(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  function attemptVertex() {
    try {
      var r = require;
      var vertx = r('vertx');
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }
  var scheduleFlush;
  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && typeof require === 'function') {
    scheduleFlush = attemptVertex();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return asap;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js";
  var async = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../../node_modules/rsvp/lib/rsvp/asap.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")).default;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")),
      isObject = $__9.isObject,
      registerPolyfill = $__9.registerPolyfill;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")),
      createPrivateSymbol = $__10.createPrivateSymbol,
      getPrivate = $__10.getPrivate,
      setPrivate = $__10.setPrivate;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: function(x) {
          promiseResolve(promise, x);
        },
        reject: function(r) {
          promiseReject(promise, r);
        }
      };
    } else {
      var result = {};
      result.promise = new C(function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      });
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function() {
    function Promise(resolver) {
      if (resolver === promiseRaw)
        return;
      if (typeof resolver !== 'function')
        throw new TypeError;
      var promise = promiseInit(this);
      try {
        resolver(function(x) {
          promiseResolve(promise, x);
        }, function(r) {
          promiseReject(promise, r);
        });
      } catch (e) {
        promiseReject(promise, e);
      }
    }
    return ($traceurRuntime.createClass)(Promise, {
      catch: function(onReject) {
        return this.then(undefined, onReject);
      },
      then: function(onResolve, onReject) {
        if (typeof onResolve !== 'function')
          onResolve = idResolveHandler;
        if (typeof onReject !== 'function')
          onReject = idRejectHandler;
        var that = this;
        var constructor = this.constructor;
        return chain(this, function(x) {
          x = promiseCoerce(constructor, x);
          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
        }, onReject);
      }
    }, {
      resolve: function(x) {
        if (this === $Promise) {
          if (isPromise(x)) {
            return x;
          }
          return promiseSet(new $Promise(promiseRaw), +1, x);
        } else {
          return new this(function(resolve, reject) {
            resolve(x);
          });
        }
      },
      reject: function(r) {
        if (this === $Promise) {
          return promiseSet(new $Promise(promiseRaw), -1, r);
        } else {
          return new this(function(resolve, reject) {
            reject(r);
          });
        }
      },
      all: function(values) {
        var deferred = getDeferred(this);
        var resolutions = [];
        try {
          var makeCountdownFunction = function(i) {
            return function(x) {
              resolutions[i] = x;
              if (--count === 0)
                deferred.resolve(resolutions);
            };
          };
          var count = 0;
          var i = 0;
          var $__4 = true;
          var $__5 = false;
          var $__6 = undefined;
          try {
            for (var $__2 = void 0,
                $__1 = (values)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
              var value = $__2.value;
              {
                var countdownFunction = makeCountdownFunction(i);
                this.resolve(value).then(countdownFunction, function(r) {
                  deferred.reject(r);
                });
                ++i;
                ++count;
              }
            }
          } catch ($__7) {
            $__5 = true;
            $__6 = $__7;
          } finally {
            try {
              if (!$__4 && $__1.return != null) {
                $__1.return();
              }
            } finally {
              if ($__5) {
                throw $__6;
              }
            }
          }
          if (count === 0) {
            deferred.resolve(resolutions);
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      },
      race: function(values) {
        var deferred = getDeferred(this);
        try {
          for (var i = 0; i < values.length; i++) {
            this.resolve(values[i]).then(function(x) {
              deferred.resolve(x);
            }, function(r) {
              deferred.reject(r);
            });
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      }
    });
  }();
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async(function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    });
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = createPrivateSymbol();
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        setPrivate(x, thenableSymbol, promise);
        return promise;
      }
      if (typeof then === 'function') {
        var p = getPrivate(x, thenableSymbol);
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          setPrivate(x, thenableSymbol, deferred.promise);
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js")),
      createIteratorResultObject = $__3.createIteratorResultObject,
      isObject = $__3.isObject;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function() {
    var $__1;
    function StringIterator() {}
    return ($traceurRuntime.createClass)(StringIterator, ($__1 = {}, Object.defineProperty($__1, "next", {
      value: function() {
        var o = this;
        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
          throw new TypeError('this must be a StringIterator object');
        }
        var s = o[iteratedString];
        if (s === undefined) {
          return createIteratorResultObject(undefined, true);
        }
        var position = o[stringIteratorNextIndex];
        var len = s.length;
        if (position >= len) {
          o[iteratedString] = undefined;
          return createIteratorResultObject(undefined, true);
        }
        var first = s.charCodeAt(position);
        var resultString;
        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
          resultString = String.fromCharCode(first);
        } else {
          var second = s.charCodeAt(position + 1);
          if (second < 0xDC00 || second > 0xDFFF) {
            resultString = String.fromCharCode(first);
          } else {
            resultString = String.fromCharCode(first) + String.fromCharCode(second);
          }
        }
        o[stringIteratorNextIndex] = position + resultString.length;
        return createIteratorResultObject(resultString, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1), {});
  }();
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[iteratedString] = s;
    iterator[stringIteratorNextIndex] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/String.js";
  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")).default;
  var createStringIterator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./StringIterator.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")).createStringIterator;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")),
      maybeAddFunctions = $__3.maybeAddFunctions,
      maybeAddIterator = $__3.maybeAddIterator,
      registerPolyfill = $__3.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint(_) {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/String.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js")),
      toObject = $__2.toObject,
      toUint32 = $__2.toUint32,
      createIteratorResultObject = $__2.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function() {
    var $__1;
    function ArrayIterator() {}
    return ($traceurRuntime.createClass)(ArrayIterator, ($__1 = {}, Object.defineProperty($__1, "next", {
      value: function() {
        var iterator = toObject(this);
        var array = iterator.iteratorObject_;
        if (!array) {
          throw new TypeError('Object is not an ArrayIterator');
        }
        var index = iterator.arrayIteratorNextIndex_;
        var itemKind = iterator.arrayIterationKind_;
        var length = toUint32(array.length);
        if (index >= length) {
          iterator.arrayIteratorNextIndex_ = Infinity;
          return createIteratorResultObject(undefined, true);
        }
        iterator.arrayIteratorNextIndex_ = index + 1;
        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
          return createIteratorResultObject(array[index], false);
        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
          return createIteratorResultObject([index, array[index]], false);
        return createIteratorResultObject(index, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1), {});
  }();
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js";
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrayIterator.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js")),
      entries = $__9.entries,
      keys = $__9.keys,
      jsValues = $__9.values;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js")),
      checkIterable = $__10.checkIterable,
      isCallable = $__10.isCallable,
      isConstructor = $__10.isConstructor,
      maybeAddFunctions = $__10.maybeAddFunctions,
      maybeAddIterator = $__10.maybeAddIterator,
      registerPolyfill = $__10.registerPolyfill,
      toInteger = $__10.toInteger,
      toLength = $__10.toLength,
      toObject = $__10.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = (items)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var item = $__1.value;
          {
            if (mapping) {
              arr[k] = mapFn.call(thisArg, item, k);
            } else {
              arr[k] = item;
            }
            k++;
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__7 = 0; $__7 < arguments.length; $__7++)
      items[$__7] = arguments[$__7];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__8 = global,
        Array = $__8.Array,
        Object = $__8.Object,
        Symbol = $__8.Symbol;
    var values = jsValues;
    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {
      values = Array.prototype[Symbol.iterator];
    }
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Array.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/assign.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/assign.js";
  var keys = Object.keys;
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p = void 0,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        target[name] = source[name];
      }
    }
    return target;
  }
  return {get default() {
      return assign;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js")),
      maybeAddFunctions = $__2.maybeAddFunctions,
      registerPolyfill = $__2.registerPolyfill;
  var assign = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./assign.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js")).default;
  var $__0 = Object,
      defineProperty = $__0.defineProperty,
      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__0.getOwnPropertyNames;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get assign() {
      return assign;
    },
    get is() {
      return is;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Object.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Number.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Number.js")),
      isNumber = $__1.isNumber,
      maybeAddConsts = $__1.maybeAddConsts,
      maybeAddFunctions = $__1.maybeAddFunctions,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Number.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/fround.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/fround.js";
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__0 = Math,
      LN2 = $__0.LN2,
      abs = $__0.abs,
      floor = $__0.floor,
      log = $__0.log,
      min = $__0.min,
      pow = $__0.pow;
  function packIEEE754(v, ebits, fbits) {
    var bias = (1 << (ebits - 1)) - 1,
        s,
        e,
        f,
        ln,
        i,
        bits,
        str,
        bytes;
    function roundToEven(n) {
      var w = floor(n),
          f = n - w;
      if (f < 0.5)
        return w;
      if (f > 0.5)
        return w + 1;
      return w % 2 ? w + 1 : w;
    }
    if (v !== v) {
      e = (1 << ebits) - 1;
      f = pow(2, fbits - 1);
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << ebits) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = abs(v);
      if (v >= pow(2, 1 - bias)) {
        e = min(floor(log(v) / LN2), 1023);
        f = roundToEven(v / pow(2, e) * pow(2, fbits));
        if (f / pow(2, fbits) >= 2) {
          e = e + 1;
          f = 1;
        }
        if (e > bias) {
          e = (1 << ebits) - 1;
          f = 0;
        } else {
          e = e + bias;
          f = f - pow(2, fbits);
        }
      } else {
        e = 0;
        f = roundToEven(v / pow(2, 1 - bias - fbits));
      }
    }
    bits = [];
    for (i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  }
  function unpackIEEE754(bytes, ebits, fbits) {
    var bits = [],
        i,
        j,
        b,
        str,
        bias,
        s,
        e,
        f;
    for (i = bytes.length; i; i -= 1) {
      b = bytes[i - 1];
      for (j = 8; j; j -= 1) {
        bits.push(b % 2 ? 1 : 0);
        b = b >> 1;
      }
    }
    bits.reverse();
    str = bits.join('');
    bias = (1 << (ebits - 1)) - 1;
    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    e = parseInt(str.substring(1, 1 + ebits), 2);
    f = parseInt(str.substring(1 + ebits), 2);
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    } else if (e > 0) {
      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
    } else if (f !== 0) {
      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
    } else {
      return s < 0 ? -0 : 0;
    }
  }
  function unpackF32(b) {
    return unpackIEEE754(b, 8, 23);
  }
  function packF32(v) {
    return packIEEE754(v, 8, 23);
  }
  function fround(x) {
    if (x === 0 || !$isFinite(x) || $isNaN(x)) {
      return x;
    }
    return unpackF32(packF32(Number(x)));
  }
  return {get fround() {
      return fround;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Math.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js";
  var jsFround = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./fround.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js")).fround;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js")),
      maybeAddFunctions = $__3.maybeAddFunctions,
      registerPolyfill = $__3.registerPolyfill,
      toUint32 = $__3.toUint32;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__0 = Math,
      abs = $__0.abs,
      ceil = $__0.ceil,
      exp = $__0.exp,
      floor = $__0.floor,
      log = $__0.log,
      pow = $__0.pow,
      sqrt = $__0.sqrt;
  function clz32(x) {
    x = toUint32(+x);
    if (x == 0)
      return 32;
    var result = 0;
    if ((x & 0xFFFF0000) === 0) {
      x <<= 16;
      result += 16;
    }
    ;
    if ((x & 0xFF000000) === 0) {
      x <<= 8;
      result += 8;
    }
    ;
    if ((x & 0xF0000000) === 0) {
      x <<= 4;
      result += 4;
    }
    ;
    if ((x & 0xC0000000) === 0) {
      x <<= 2;
      result += 2;
    }
    ;
    if ((x & 0x80000000) === 0) {
      x <<= 1;
      result += 1;
    }
    ;
    return result;
  }
  function imul(x, y) {
    x = toUint32(+x);
    y = toUint32(+y);
    var xh = (x >>> 16) & 0xffff;
    var xl = x & 0xffff;
    var yh = (y >>> 16) & 0xffff;
    var yl = y & 0xffff;
    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;
  }
  function sign(x) {
    x = +x;
    if (x > 0)
      return 1;
    if (x < 0)
      return -1;
    return x;
  }
  function log10(x) {
    return log(x) * 0.434294481903251828;
  }
  function log2(x) {
    return log(x) * 1.442695040888963407;
  }
  function log1p(x) {
    x = +x;
    if (x < -1 || $isNaN(x)) {
      return NaN;
    }
    if (x === 0 || x === Infinity) {
      return x;
    }
    if (x === -1) {
      return -Infinity;
    }
    var result = 0;
    var n = 50;
    if (x < 0 || x > 1) {
      return log(1 + x);
    }
    for (var i = 1; i < n; i++) {
      if ((i % 2) === 0) {
        result -= pow(x, i) / i;
      } else {
        result += pow(x, i) / i;
      }
    }
    return result;
  }
  function expm1(x) {
    x = +x;
    if (x === -Infinity) {
      return -1;
    }
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return exp(x) - 1;
  }
  function cosh(x) {
    x = +x;
    if (x === 0) {
      return 1;
    }
    if ($isNaN(x)) {
      return NaN;
    }
    if (!$isFinite(x)) {
      return Infinity;
    }
    if (x < 0) {
      x = -x;
    }
    if (x > 21) {
      return exp(x) / 2;
    }
    return (exp(x) + exp(-x)) / 2;
  }
  function sinh(x) {
    x = +x;
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  }
  function tanh(x) {
    x = +x;
    if (x === 0)
      return x;
    if (!$isFinite(x))
      return sign(x);
    var exp1 = exp(x);
    var exp2 = exp(-x);
    return (exp1 - exp2) / (exp1 + exp2);
  }
  function acosh(x) {
    x = +x;
    if (x < 1)
      return NaN;
    if (!$isFinite(x))
      return x;
    return log(x + sqrt(x + 1) * sqrt(x - 1));
  }
  function asinh(x) {
    x = +x;
    if (x === 0 || !$isFinite(x))
      return x;
    if (x > 0)
      return log(x + sqrt(x * x + 1));
    return -log(-x + sqrt(x * x + 1));
  }
  function atanh(x) {
    x = +x;
    if (x === -1) {
      return -Infinity;
    }
    if (x === 1) {
      return Infinity;
    }
    if (x === 0) {
      return x;
    }
    if ($isNaN(x) || x < -1 || x > 1) {
      return NaN;
    }
    return 0.5 * log((1 + x) / (1 - x));
  }
  function hypot(x, y) {
    var length = arguments.length;
    var args = new Array(length);
    var max = 0;
    for (var i = 0; i < length; i++) {
      var n = arguments[i];
      n = +n;
      if (n === Infinity || n === -Infinity)
        return Infinity;
      n = abs(n);
      if (n > max)
        max = n;
      args[i] = n;
    }
    if (max === 0)
      max = 1;
    var sum = 0;
    var compensation = 0;
    for (var i = 0; i < length; i++) {
      var n = args[i] / max;
      var summand = n * n - compensation;
      var preliminary = sum + summand;
      compensation = (preliminary - sum) - summand;
      sum = preliminary;
    }
    return sqrt(sum) * max;
  }
  function trunc(x) {
    x = +x;
    if (x > 0)
      return floor(x);
    if (x < 0)
      return ceil(x);
    return x;
  }
  var fround,
      f32;
  if (typeof Float32Array === 'function') {
    f32 = new Float32Array(1);
    fround = function(x) {
      f32[0] = Number(x);
      return f32[0];
    };
  } else {
    fround = jsFround;
  }
  function cbrt(x) {
    x = +x;
    if (x === 0)
      return x;
    var negate = x < 0;
    if (negate)
      x = -x;
    var result = pow(x, 1 / 3);
    return negate ? -result : result;
  }
  function polyfillMath(global) {
    var Math = global.Math;
    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);
  }
  registerPolyfill(polyfillMath);
  return {
    get clz32() {
      return clz32;
    },
    get imul() {
      return imul;
    },
    get sign() {
      return sign;
    },
    get log10() {
      return log10;
    },
    get log2() {
      return log2;
    },
    get log1p() {
      return log1p;
    },
    get expm1() {
      return expm1;
    },
    get cosh() {
      return cosh;
    },
    get sinh() {
      return sinh;
    },
    get tanh() {
      return tanh;
    },
    get acosh() {
      return acosh;
    },
    get asinh() {
      return asinh;
    },
    get atanh() {
      return atanh;
    },
    get hypot() {
      return hypot;
    },
    get trunc() {
      return trunc;
    },
    get fround() {
      return fround;
    },
    get cbrt() {
      return cbrt;
    },
    get polyfillMath() {
      return polyfillMath;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Math.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      createPrivateSymbol = $__5.createPrivateSymbol,
      deletePrivate = $__5.deletePrivate,
      getPrivate = $__5.getPrivate,
      hasPrivate = $__5.hasPrivate,
      setPrivate = $__5.setPrivate;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      deleteFrozen = $__6.deleteFrozen,
      getFrozen = $__6.getFrozen,
      hasFrozen = $__6.hasFrozen,
      setFrozen = $__6.setFrozen;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      isObject = $__7.isObject,
      registerPolyfill = $__7.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")).default;
  var $__2 = Object,
      defineProperty = $__2.defineProperty,
      getOwnPropertyDescriptor = $__2.getOwnPropertyDescriptor,
      isExtensible = $__2.isExtensible;
  var $TypeError = TypeError;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var sentinel = {};
  var WeakMap = function() {
    function WeakMap() {
      this.name_ = createPrivateSymbol();
      this.frozenData_ = [];
    }
    return ($traceurRuntime.createClass)(WeakMap, {
      set: function(key, value) {
        if (!isObject(key))
          throw new $TypeError('key must be an object');
        if (!isExtensible(key)) {
          setFrozen(this.frozenData_, key, value);
        } else {
          setPrivate(key, this.name_, value);
        }
        return this;
      },
      get: function(key) {
        if (!isObject(key))
          return undefined;
        if (!isExtensible(key)) {
          return getFrozen(this.frozenData_, key);
        }
        return getPrivate(key, this.name_);
      },
      delete: function(key) {
        if (!isObject(key))
          return false;
        if (!isExtensible(key)) {
          return deleteFrozen(this.frozenData_, key);
        }
        return deletePrivate(key, this.name_);
      },
      has: function(key) {
        if (!isObject(key))
          return false;
        if (!isExtensible(key)) {
          return hasFrozen(this.frozenData_, key);
        }
        return hasPrivate(key, this.name_);
      }
    }, {});
  }();
  function needsPolyfill(global) {
    var $__4 = global,
        WeakMap = $__4.WeakMap,
        Symbol = $__4.Symbol;
    if (!WeakMap || !hasNativeSymbol()) {
      return true;
    }
    try {
      var o = {};
      var wm = new WeakMap([[o, false]]);
      return wm.get(o);
    } catch (e) {
      return false;
    }
  }
  function polyfillWeakMap(global) {
    if (needsPolyfill(global)) {
      global.WeakMap = WeakMap;
    }
  }
  registerPolyfill(polyfillWeakMap);
  return {
    get WeakMap() {
      return WeakMap;
    },
    get polyfillWeakMap() {
      return polyfillWeakMap;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      createPrivateSymbol = $__5.createPrivateSymbol,
      deletePrivate = $__5.deletePrivate,
      getPrivate = $__5.getPrivate,
      hasPrivate = $__5.hasPrivate,
      setPrivate = $__5.setPrivate;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      deleteFrozen = $__6.deleteFrozen,
      getFrozen = $__6.getFrozen,
      setFrozen = $__6.setFrozen;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      isObject = $__7.isObject,
      registerPolyfill = $__7.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")).default;
  var $__2 = Object,
      defineProperty = $__2.defineProperty,
      isExtensible = $__2.isExtensible;
  var $TypeError = TypeError;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var WeakSet = function() {
    function WeakSet() {
      this.name_ = createPrivateSymbol();
      this.frozenData_ = [];
    }
    return ($traceurRuntime.createClass)(WeakSet, {
      add: function(value) {
        if (!isObject(value))
          throw new $TypeError('value must be an object');
        if (!isExtensible(value)) {
          setFrozen(this.frozenData_, value, value);
        } else {
          setPrivate(value, this.name_, true);
        }
        return this;
      },
      delete: function(value) {
        if (!isObject(value))
          return false;
        if (!isExtensible(value)) {
          return deleteFrozen(this.frozenData_, value);
        }
        return deletePrivate(value, this.name_);
      },
      has: function(value) {
        if (!isObject(value))
          return false;
        if (!isExtensible(value)) {
          return getFrozen(this.frozenData_, value) === value;
        }
        return hasPrivate(value, this.name_);
      }
    }, {});
  }();
  function needsPolyfill(global) {
    var $__4 = global,
        WeakSet = $__4.WeakSet,
        Symbol = $__4.Symbol;
    if (!WeakSet || !hasNativeSymbol()) {
      return true;
    }
    try {
      var o = {};
      var wm = new WeakSet([[o]]);
      return !wm.has(o);
    } catch (e) {
      return false;
    }
  }
  function polyfillWeakSet(global) {
    if (needsPolyfill(global)) {
      global.WeakSet = WeakSet;
    }
  }
  registerPolyfill(polyfillWeakSet);
  return {
    get WeakSet() {
      return WeakSet;
    },
    get polyfillWeakSet() {
      return polyfillWeakSet;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js";
  var polyfillAll = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js")).polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js" + '');
;$traceurRuntime.registerModule("src/base/CooldownThrottle.js", [], function() {
  "use strict";
  var __moduleName = "src/base/CooldownThrottle.js";
  var CooldownThrottle = function() {
    function CooldownThrottle(action, cooldownMs) {
      var slowActionCooldownPumpUpFactor = arguments[2] !== (void 0) ? arguments[2] : 0;
      var waitWithRequestAnimationFrame = arguments[3] !== (void 0) ? arguments[3] : false;
      this.action = action;
      this.cooldownDuration = cooldownMs;
      this.slowActionCooldownPumpupFactor = slowActionCooldownPumpUpFactor;
      this._waitWithRequestAnimationFrame = waitWithRequestAnimationFrame;
      this._state = 'idle';
      this._cooldownStartTime = -Infinity;
    }
    return ($traceurRuntime.createClass)(CooldownThrottle, {
      _triggerIdle: function() {
        var remainingCooldownDuration = this.cooldownDuration - (performance.now() - this._cooldownStartTime);
        if (remainingCooldownDuration > 0) {
          this._forceIdleTriggerAfter(remainingCooldownDuration);
          return;
        }
        this._state = 'running';
        var t0 = performance.now();
        try {
          this.action();
        } finally {
          var dt = performance.now() - t0;
          this._cooldownStartTime = performance.now() + (dt * this.slowActionCooldownPumpupFactor);
          if (this._state === 'running-and-triggered') {
            this._forceIdleTriggerAfter(this.cooldownDuration);
          } else {
            this._state = 'idle';
          }
        }
      },
      trigger: function() {
        switch (this._state) {
          case 'idle':
            this._triggerIdle();
            break;
          case 'waiting':
            break;
          case 'running':
            this._state = 'running-and-triggered';
            break;
          case 'running-and-triggered':
            break;
          default:
            throw new Error('Unrecognized throttle state: ' + this._state);
        }
      },
      _forceIdleTriggerAfter: function(duration) {
        var $__1 = this;
        this._state = 'waiting';
        if (this._waitWithRequestAnimationFrame) {
          var iter;
          var start = performance.now();
          iter = function() {
            if (performance.now() < start + duration) {
              requestAnimationFrame(iter);
              return;
            }
            $__1._state = 'idle';
            $__1._cooldownStartTime = -Infinity;
            $__1.trigger();
          };
          iter();
        } else {
          setTimeout(function() {
            $__1._state = 'idle';
            $__1._cooldownStartTime = -Infinity;
            $__1.trigger();
          }, duration);
        }
      }
    }, {});
  }();
  return {get CooldownThrottle() {
      return CooldownThrottle;
    }};
});
//# sourceURL=src/base/CooldownThrottle.js
;$traceurRuntime.registerModule("src/base/Describe.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Describe.js";
  var COLLECTION_CUTOFF = 1000;
  var BAD_TO_STRING_RESULT = new (function() {})().toString();
  var RECURSE_LIMIT_DESCRIPTION = "!recursion-limit!";
  var DEFAULT_RECURSION_LIMIT = 10;
  function try_describe_atomic(value) {
    if (value === null) {
      return "null";
    }
    if (value === undefined) {
      return "undefined";
    }
    if (typeof value === "string") {
      return ("\"" + value + "\"");
    }
    if (typeof value === "number") {
      return "" + value;
    }
    return undefined;
  }
  function try_describe_collection(value, recursionLimit) {
    if (recursionLimit === 0) {
      return RECURSE_LIMIT_DESCRIPTION;
    }
    if (value instanceof Map) {
      return describe_Map(value, recursionLimit);
    }
    if (value instanceof Set) {
      return describe_Set(value, recursionLimit);
    }
    if (value[Symbol.iterator] !== undefined) {
      return describe_Iterable(value, recursionLimit);
    }
    return undefined;
  }
  function describe_fallback(value, recursionLimit) {
    var defaultString = String(value);
    if (defaultString !== BAD_TO_STRING_RESULT) {
      return defaultString;
    }
    return describe_Object(value, recursionLimit);
  }
  function describe(value) {
    var recursionLimit = arguments[1] !== (void 0) ? arguments[1] : DEFAULT_RECURSION_LIMIT;
    return try_describe_atomic(value) || try_describe_collection(value, recursionLimit) || describe_fallback(value, recursionLimit);
  }
  function describe_Map(map, limit) {
    var $__9,
        $__10;
    var entries = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (map.entries())[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var $__8 = $__2.value,
            k = ($__9 = $__8[Symbol.iterator](), ($__10 = $__9.next()).done ? void 0 : $__10.value),
            v = ($__10 = $__9.next()).done ? void 0 : $__10.value;
        {
          if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
          }
          var keyDesc = describe(k, limit - 1);
          var valDesc = describe(v, limit - 1);
          entries.push((keyDesc + ": " + valDesc));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return ("Map{" + entries.join(", ") + "}");
  }
  function describe_Set(set, limit) {
    var entries = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (set)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var e = $__2.value;
        {
          if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
          }
          entries.push(describe(e, limit - 1));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return ("Set{" + entries.join(", ") + "}");
  }
  function describe_Iterable(seq, limit) {
    var entries = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (seq)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var e = $__2.value;
        {
          if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
          }
          entries.push(describe(e, limit - 1));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var prefix = Array.isArray(seq) ? "" : seq.constructor.name;
    return (prefix + "[" + entries.join(", ") + "]");
  }
  function describe_Object(value, limit) {
    var entries = [];
    for (var k in value) {
      if (!value.hasOwnProperty(k)) {
        continue;
      }
      if (entries.length > COLLECTION_CUTOFF) {
        entries.push("[...]");
        break;
      }
      var v = value[k];
      var keyDesc = describe(k, limit - 1);
      var valDesc = describe(v, limit - 1);
      entries.push((keyDesc + ": " + valDesc));
    }
    var typeName = value.constructor.name;
    var prefix = typeName === {}.constructor.name ? "" : ("(Type: " + typeName + ")");
    return (prefix + "{" + entries.join(", ") + "}");
  }
  return {get describe() {
      return describe;
    }};
});
//# sourceURL=src/base/Describe.js
;$traceurRuntime.registerModule("src/base/DetailedError.js", [], function() {
  "use strict";
  var __moduleName = "src/base/DetailedError.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Describe.js", "src/base/DetailedError.js")).describe;
  var CONSTRUCTOR_CALLS_NESTING = 0;
  var DetailedError = function($__super) {
    function DetailedError(message, detailsObj) {
      $traceurRuntime.superConstructor(DetailedError).call(this, message);
      this.detailsObj = detailsObj;
      this.name = 'Error';
      this.message = message;
      this.stack = new Error().stack;
      if (this.stack !== undefined) {
        this.stack = this.stack.replace(/^Error\n\s+at new DetailedError (\S+)\s?\n\s+at /, '\n    ');
      }
      CONSTRUCTOR_CALLS_NESTING++;
      try {
        this.details = CONSTRUCTOR_CALLS_NESTING === 1 ? describe(this.detailsObj) : "(failed to describe detailsObj due to possibly re-entrancy)";
      } catch (ex) {
        console.error(ex);
        this.details = "(failed to describe detailsObj, see the console for details)";
      } finally {
        CONSTRUCTOR_CALLS_NESTING--;
      }
    }
    return ($traceurRuntime.createClass)(DetailedError, {toString: function() {
        return ($traceurRuntime.superGet(this, DetailedError.prototype, "toString").call(this) + "\nDetails: " + this.details);
      }}, {}, $__super);
  }(Error);
  return {get DetailedError() {
      return DetailedError;
    }};
});
//# sourceURL=src/base/DetailedError.js
;$traceurRuntime.registerModule("src/base/Equate.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Equate.js";
  function equate(subject, other) {
    if (subject === other || (isExactlyNaN(subject) && isExactlyNaN(other))) {
      return true;
    }
    var customEquality = tryEquate_custom(subject, other);
    if (customEquality !== undefined) {
      return customEquality;
    }
    if (isAtomic(subject) || isAtomic(other) || !eqType(subject, other)) {
      return false;
    }
    if (subject instanceof Map) {
      return equate_Maps(subject, other);
    }
    if (subject instanceof Set) {
      return equate_Sets(subject, other);
    }
    if (isIndexable(subject)) {
      return equate_Indexables(subject, other);
    }
    return equate_Objects(subject, other);
  }
  var GENERIC_ARRAY_TYPES = [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray];
  function isExactlyNaN(v) {
    return typeof v === "number" && isNaN(v);
  }
  function tryEquate_custom(subject, other) {
    if (!isAtomic(subject) && subject.constructor.prototype.hasOwnProperty("isEqualTo")) {
      return subject.isEqualTo(other);
    }
    if (!isAtomic(other) && other.constructor.prototype.hasOwnProperty("isEqualTo")) {
      return other.isEqualTo(subject);
    }
    return undefined;
  }
  function isAtomic(value) {
    return value === null || value === undefined || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
  }
  function isIndexable(value) {
    return Array.isArray(value) || !GENERIC_ARRAY_TYPES.every(function(t) {
      return !(value instanceof t);
    });
  }
  function eqType(subject, other) {
    return subject.constructor.name === other.constructor.name;
  }
  function equate_Indexables(subject, other) {
    if (subject.length !== other.length) {
      return false;
    }
    for (var i = 0; i < subject.length; i++) {
      if (!equate(subject[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function equate_Iterables(subject, other) {
    var otherIter = other[Symbol.iterator]();
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (subject)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var subjectItem = $__1.value;
        {
          var otherItemDone = otherIter.next();
          if (otherItemDone.done || !equate(subjectItem, otherItemDone.value)) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    return otherIter.next().done;
  }
  function equate_Maps(subject, other) {
    var $__8,
        $__9;
    if (subject.size !== other.size) {
      return false;
    }
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (subject)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var $__7 = $__1.value,
            k = ($__8 = $__7[Symbol.iterator](), ($__9 = $__8.next()).done ? void 0 : $__9.value),
            v = ($__9 = $__8.next()).done ? void 0 : $__9.value;
        {
          if (!other.has(k)) {
            return false;
          }
          var otherV = other.get(k);
          if (!equate(v, otherV)) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    return true;
  }
  function equate_Sets(subject, other) {
    if (subject.size !== other.size) {
      return false;
    }
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (subject)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var k = $__1.value;
        {
          if (!other.has(k)) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    return true;
  }
  function objectKeys(obj) {
    var result = new Set();
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        result.add(k);
      }
    }
    return result;
  }
  function equate_Objects(subject, other) {
    var keys = objectKeys(subject);
    if (!equate_Sets(keys, objectKeys(other))) {
      return false;
    }
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (keys)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var k = $__1.value;
        {
          if (k === Symbol.iterator) {
            continue;
          }
          if (!equate(subject[k], other[k])) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    var hasSubjectIter = subject[Symbol.iterator] !== undefined;
    var hasOtherIter = other[Symbol.iterator] !== undefined;
    if (hasSubjectIter !== hasOtherIter) {
      return false;
    }
    if (hasSubjectIter && hasOtherIter) {
      if (!equate_Iterables(subject, other)) {
        return false;
      }
    }
    return true;
  }
  return {
    get equate() {
      return equate;
    },
    get equate_Maps() {
      return equate_Maps;
    }
  };
});
//# sourceURL=src/base/Equate.js
;$traceurRuntime.registerModule("src/base/Format.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Format.js";
  var Format = function() {
    function Format(allowAbbreviation, maxAbbreviationError, fixedDigits, itemSeparator) {
      this.allowAbbreviation = allowAbbreviation;
      this.maxAbbreviationError = maxAbbreviationError;
      this.fixedDigits = fixedDigits;
      this.itemSeparator = itemSeparator;
    }
    return ($traceurRuntime.createClass)(Format, {formatFloat: function(f) {
        if (this.allowAbbreviation) {
          return abbreviateFloat(f, this.maxAbbreviationError, this.fixedDigits);
        }
        if (this.fixedDigits !== undefined) {
          return f.toFixed(this.fixedDigits);
        }
        return f + "";
      }}, {
      parseFloat: function(text) {
        if (text.length === 0) {
          throw new Error("Not a number: '" + text + "'");
        }
        if (text[0] === "-") {
          return -Format.parseFloat(text.substr(1));
        }
        if (text[0] === "\u221A") {
          return Math.sqrt(Format.parseFloat(text.substr(1)));
        }
        var fraction = match(UNICODE_FRACTIONS, function(e) {
          return e.character === text;
        });
        if (fraction !== undefined) {
          return fraction.value;
        }
        var result = parseFloat(text);
        if (isNaN(result)) {
          throw new Error("Not a number: '" + text + "'");
        }
        return result;
      },
      simplifyByRounding: function(value, epsilon) {
        if (value < 0) {
          return -Format.simplifyByRounding(-value, epsilon);
        }
        var r = value % 1;
        if (r <= epsilon || 1 - r <= epsilon) {
          return Math.round(value);
        }
        var fraction = match(UNICODE_FRACTIONS, function(e) {
          return Math.abs(e.value - value) <= epsilon;
        });
        if (fraction !== undefined) {
          return fraction.value;
        }
        var rootFraction = match(UNICODE_FRACTIONS, function(e) {
          return Math.abs(Math.sqrt(e.value) - value) <= epsilon;
        });
        if (rootFraction !== undefined) {
          return Math.sqrt(rootFraction.value);
        }
        return value;
      }
    });
  }();
  var UNICODE_FRACTIONS = [{
    character: "\u00BD",
    ref: "½",
    expanded: "1/2",
    value: 1 / 2
  }, {
    character: "\u00BC",
    ref: "¼",
    expanded: "1/4",
    value: 1 / 4
  }, {
    character: "\u00BE",
    ref: "¾",
    expanded: "3/4",
    value: 3 / 4
  }, {
    character: "\u2153",
    ref: "⅓",
    expanded: "1/3",
    value: 1 / 3
  }, {
    character: "\u2154",
    ref: "⅔",
    expanded: "2/3",
    value: 2 / 3
  }, {
    character: "\u2155",
    ref: "⅕",
    expanded: "1/5",
    value: 1 / 5
  }, {
    character: "\u2156",
    ref: "⅖",
    expanded: "2/5",
    value: 2 / 5
  }, {
    character: "\u2157",
    ref: "⅗",
    expanded: "3/5",
    value: 3 / 5
  }, {
    character: "\u2158",
    ref: "⅘",
    expanded: "4/5",
    value: 4 / 5
  }, {
    character: "\u2159",
    ref: "⅙",
    expanded: "1/6",
    value: 1 / 6
  }, {
    character: "\u215A",
    ref: "⅚",
    expanded: "5/6",
    value: 5 / 6
  }, {
    character: "\u2150",
    ref: "⅐",
    expanded: "1/7",
    value: 1 / 7
  }, {
    character: "\u215B",
    ref: "⅛",
    expanded: "1/8",
    value: 1 / 8
  }, {
    character: "\u215C",
    ref: "⅜",
    expanded: "3/8",
    value: 3 / 8
  }, {
    character: "\u215D",
    ref: "⅝",
    expanded: "5/8",
    value: 5 / 8
  }, {
    character: "\u215E",
    ref: "⅞",
    expanded: "7/8",
    value: 7 / 8
  }, {
    character: "\u2151",
    ref: "⅑",
    expanded: "1/9",
    value: 1 / 9
  }, {
    character: "\u2152",
    ref: "⅒",
    expanded: "1/10",
    value: 1 / 10
  }];
  var match = function(array, predicate) {
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      for (var $__3 = void 0,
          $__2 = (array)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        var item = $__3.value;
        {
          if (predicate(item)) {
            return item;
          }
        }
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    return undefined;
  };
  function abbreviateFloat(value) {
    var epsilon = arguments[1] !== (void 0) ? arguments[1] : 0;
    var digits = arguments[2];
    if (Math.abs(value) < epsilon) {
      return "0";
    }
    if (value < 0) {
      return "-" + abbreviateFloat(-value, epsilon, digits);
    }
    var fraction = match(UNICODE_FRACTIONS, function(e) {
      return Math.abs(e.value - value) <= epsilon;
    });
    if (fraction !== undefined) {
      return fraction.character;
    }
    var rootFraction = match(UNICODE_FRACTIONS, function(e) {
      return Math.abs(Math.sqrt(e.value) - value) <= epsilon;
    });
    if (rootFraction !== undefined) {
      return "\u221A" + rootFraction.character;
    }
    if (value % 1 !== 0 && digits !== undefined) {
      return value.toFixed(digits);
    }
    return value.toString();
  }
  Format.EXACT = new Format(true, 0, undefined, ", ");
  Format.MINIFIED = new Format(true, 0, undefined, ",");
  Format.SIMPLIFIED = new Format(true, 0.0005, 3, ", ");
  Format.CONSISTENT = new Format(false, 0, 2, ", ");
  return {
    get Format() {
      return Format;
    },
    get UNICODE_FRACTIONS() {
      return UNICODE_FRACTIONS;
    }
  };
});
//# sourceURL=src/base/Format.js
;$traceurRuntime.registerModule("src/base/Obs.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Obs.js";
  var CooldownThrottle = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CooldownThrottle.js", "src/base/Obs.js")).CooldownThrottle;
  var Observable = function() {
    function Observable(subscribe) {
      this._subscribe = subscribe;
    }
    return ($traceurRuntime.createClass)(Observable, {
      subscribe: function(observer) {
        return this._subscribe(observer);
      },
      snapshot: function() {
        var result = [];
        var unsub = this.subscribe(function(e) {
          return result.push(e);
        });
        unsub();
        return result;
      },
      map: function(transformFunc) {
        var $__3 = this;
        return new Observable(function(observer) {
          return $__3.subscribe(function(item) {
            return observer(transformFunc(item));
          });
        });
      },
      filter: function(predicate) {
        var $__3 = this;
        return new Observable(function(observer) {
          return $__3.subscribe(function(item) {
            if (predicate(item)) {
              observer(item);
            }
          });
        });
      },
      zipLatest: function(other, mergeFunc) {
        var $__3 = this;
        return new Observable(function(observer) {
          var has1 = false;
          var has2 = false;
          var last1;
          var last2;
          var unreg1 = $__3.subscribe(function(e1) {
            last1 = e1;
            has1 = true;
            if (has2) {
              observer(mergeFunc(last1, last2));
            }
          });
          var unreg2 = other.subscribe(function(e2) {
            last2 = e2;
            has2 = true;
            if (has1) {
              observer(mergeFunc(last1, last2));
            }
          });
          return function() {
            unreg1();
            unreg2();
          };
        });
      },
      flattenLatest: function() {
        var $__3 = this;
        return new Observable(function(observer) {
          var unregLatest = function() {};
          var isDone = false;
          var unregAll = $__3.subscribe(function(subObservable) {
            if (isDone) {
              return;
            }
            var prevUnreg = unregLatest;
            unregLatest = subObservable.subscribe(observer);
            prevUnreg();
          });
          return function() {
            isDone = true;
            unregLatest();
            unregAll();
          };
        });
      },
      peek: function(action) {
        return this.map(function(e) {
          action(e);
          return e;
        });
      },
      flatten: function() {
        var $__3 = this;
        return new Observable(function(observer) {
          var unsubs = [];
          unsubs.push($__3.subscribe(function(observable) {
            return unsubs.push(observable.subscribe(observer));
          }));
          return function() {
            var $__7 = true;
            var $__8 = false;
            var $__9 = undefined;
            try {
              for (var $__5 = void 0,
                  $__4 = (unsubs)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
                var unsub = $__5.value;
                {
                  unsub();
                }
              }
            } catch ($__10) {
              $__8 = true;
              $__9 = $__10;
            } finally {
              try {
                if (!$__7 && $__4.return != null) {
                  $__4.return();
                }
              } finally {
                if ($__8) {
                  throw $__9;
                }
              }
            }
          };
        });
      },
      throttleLatest: function(cooldownMillis) {
        var $__3 = this;
        return new Observable(function(observer) {
          var latest = undefined;
          var isKilled = false;
          var throttle = new CooldownThrottle(function() {
            if (!isKilled) {
              observer(latest);
            }
          }, cooldownMillis);
          var unsub = $__3.subscribe(function(e) {
            latest = e;
            throttle.trigger();
          });
          return function() {
            isKilled = true;
            unsub();
          };
        });
      },
      skip: function(count) {
        var $__3 = this;
        return new Observable(function(observer) {
          var remaining = count;
          return $__3.subscribe(function(item) {
            if (remaining > 0) {
              remaining -= 1;
            } else {
              observer(item);
            }
          });
        });
      },
      whenDifferent: function() {
        var equater = arguments[0];
        var $__3 = this;
        var eq = equater || (function(e1, e2) {
          return e1 === e2;
        });
        return new Observable(function(observer) {
          var hasLast = false;
          var last = undefined;
          return $__3.subscribe(function(item) {
            if (!hasLast || !eq(last, item)) {
              last = item;
              hasLast = true;
              observer(item);
            }
          });
        });
      }
    }, {
      of: function() {
        for (var items = [],
            $__11 = 0; $__11 < arguments.length; $__11++)
          items[$__11] = arguments[$__11];
        return new Observable(function(observer) {
          var $__7 = true;
          var $__8 = false;
          var $__9 = undefined;
          try {
            for (var $__5 = void 0,
                $__4 = (items)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
              var item = $__5.value;
              {
                observer(item);
              }
            }
          } catch ($__10) {
            $__8 = true;
            $__9 = $__10;
          } finally {
            try {
              if (!$__7 && $__4.return != null) {
                $__4.return();
              }
            } finally {
              if ($__8) {
                throw $__9;
              }
            }
          }
          return function() {};
        });
      },
      requestAnimationTicker: function() {
        return new Observable(function(observer) {
          var iter;
          var isDone = false;
          iter = function() {
            if (!isDone) {
              observer(undefined);
              window.requestAnimationFrame(iter);
            }
          };
          iter();
          return function() {
            isDone = true;
          };
        });
      },
      elementEvent: function(element, eventKey) {
        return new Observable(function(observer) {
          element.addEventListener(eventKey, observer);
          return function() {
            return element.removeEventListener(eventKey, observer);
          };
        });
      }
    });
  }();
  var ObservableSource = function() {
    function ObservableSource() {
      var $__3 = this;
      this._observers = [];
      this._observable = new Observable(function(observer) {
        $__3._observers.push(observer);
        var didRun = false;
        return function() {
          if (!didRun) {
            didRun = true;
            $__3._observers.splice($__3._observers.indexOf(observer), 1);
          }
        };
      });
    }
    return ($traceurRuntime.createClass)(ObservableSource, {
      observable: function() {
        return this._observable;
      },
      send: function(eventValue) {
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._observers)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var obs = $__5.value;
            {
              obs(eventValue);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
      }
    }, {});
  }();
  var ObservableValue = function() {
    function ObservableValue() {
      var initialValue = arguments[0];
      var $__3 = this;
      this._value = initialValue;
      this._source = new ObservableSource();
      this._observable = new Observable(function(observer) {
        observer($__3._value);
        return $__3._source.observable().subscribe(observer);
      });
    }
    return ($traceurRuntime.createClass)(ObservableValue, {
      observable: function() {
        return this._observable;
      },
      set: function(newValue) {
        this._value = newValue;
        this._source.send(newValue);
      },
      get: function() {
        return this._value;
      }
    }, {});
  }();
  return {
    get Observable() {
      return Observable;
    },
    get ObservableSource() {
      return ObservableSource;
    },
    get ObservableValue() {
      return ObservableValue;
    }
  };
});
//# sourceURL=src/base/Obs.js
;$traceurRuntime.registerModule("src/base/RestartableRng.js", [], function() {
  "use strict";
  var __moduleName = "src/base/RestartableRng.js";
  var RestartableRng = function() {
    function RestartableRng() {
      this._cache = [];
      this._next = 0;
    }
    return ($traceurRuntime.createClass)(RestartableRng, {
      restarted: function() {
        var result = new RestartableRng();
        result._cache = this._cache;
        return result;
      },
      random: function() {
        var p = this._next++;
        if (p >= this._cache.length) {
          this._cache.push(Math.random());
        }
        return this._cache[p];
      }
    }, {});
  }();
  return {get RestartableRng() {
      return RestartableRng;
    }};
});
//# sourceURL=src/base/RestartableRng.js
;$traceurRuntime.registerModule("src/base/Revision.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Revision.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Describe.js", "src/base/Revision.js")).describe;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Equate.js", "src/base/Revision.js")).equate;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DetailedError.js", "src/base/Revision.js")).DetailedError;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Obs.js", "src/base/Revision.js")),
      ObservableSource = $__5.ObservableSource,
      ObservableValue = $__5.ObservableValue;
  var Revision = function() {
    function Revision(history, index, isWorkingOnCommit) {
      if (index < 0 || index >= history.length) {
        throw new DetailedError("Bad index", {
          history: history,
          index: index,
          isWorkingOnCommit: isWorkingOnCommit
        });
      }
      if (!Array.isArray(history)) {
        throw new DetailedError("Bad history", {
          history: history,
          index: index,
          isWorkingOnCommit: isWorkingOnCommit
        });
      }
      this.history = history;
      this.index = index;
      this.isWorkingOnCommit = isWorkingOnCommit;
      this._changes = new ObservableSource();
      this._latestActiveCommit = new ObservableValue(this.history[this.index]);
    }
    return ($traceurRuntime.createClass)(Revision, {
      changes: function() {
        return this._changes.observable();
      },
      latestActiveCommit: function() {
        return this._latestActiveCommit.observable();
      },
      peekActiveCommit: function() {
        return this._latestActiveCommit.get();
      },
      isAtBeginningOfHistory: function() {
        return this.index === 0 && !this.isWorkingOnCommit;
      },
      isAtEndOfHistory: function() {
        return this.index === this.history.length - 1;
      },
      clear: function(state) {
        this.history = [state];
        this.index = 0;
        this.isWorkingOnCommit = false;
        this._changes.send(state);
        this._latestActiveCommit.set(state);
      },
      startedWorkingOnCommit: function() {
        this.isWorkingOnCommit = true;
        this._changes.send(undefined);
      },
      cancelCommitBeingWorkedOn: function() {
        this.isWorkingOnCommit = false;
        var result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
      },
      commit: function(newCheckpoint) {
        if (newCheckpoint === this.history[this.index]) {
          this.cancelCommitBeingWorkedOn();
          return;
        }
        this.isWorkingOnCommit = false;
        this.index += 1;
        this.history.splice(this.index, this.history.length - this.index);
        this.history.push(newCheckpoint);
        this._changes.send(newCheckpoint);
        this._latestActiveCommit.set(newCheckpoint);
      },
      undo: function() {
        if (!this.isWorkingOnCommit) {
          if (this.index === 0) {
            return undefined;
          }
          this.index -= 1;
        }
        this.isWorkingOnCommit = false;
        var result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
      },
      redo: function() {
        if (this.index + 1 === this.history.length) {
          return undefined;
        }
        this.index += 1;
        this.isWorkingOnCommit = false;
        var result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
      },
      toString: function() {
        return 'Revision(' + describe({
          index: this.index,
          count: this.history.length,
          workingOnCommit: this.isWorkingOnCommit,
          head: this.history[this.index]
        }) + ')';
      },
      isEqualTo: function(other) {
        return other instanceof Revision && this.index === other.index && this.isWorkingOnCommit === other.isWorkingOnCommit && equate(this.history, other.history);
      }
    }, {startingAt: function(state) {
        return new Revision([state], 0, false);
      }});
  }();
  return {get Revision() {
      return Revision;
    }};
});
//# sourceURL=src/base/Revision.js
;$traceurRuntime.registerModule("src/base/Seq.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Seq.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DetailedError.js", "src/base/Seq.js")).DetailedError;
  var THROW_IF_EMPTY = {if_same_instance_as_this_then_throw: true};
  var EMPTY_SYGIL = {not_a_normal_value: true};
  var GENERIC_ARRAY_TYPES = [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray];
  var isIterable = function(obj) {
    return typeof Object(obj)[Symbol.iterator] === 'function';
  };
  var emptyFallback = function(result, alternative, errorMessage) {
    if (result !== EMPTY_SYGIL) {
      return result;
    }
    if (alternative === THROW_IF_EMPTY) {
      throw new Error(errorMessage);
    }
    return alternative;
  };
  var Seq = function() {
    function Seq(obj) {
      var isIteratorFunction = arguments[1] !== (void 0) ? arguments[1] : false;
      var $__3;
      var iterable;
      var iterator;
      if (obj instanceof Seq) {
        iterable = obj._iterable;
        iterator = obj[Symbol.iterator];
      } else if (isIteratorFunction) {
        iterable = ($__3 = {}, Object.defineProperty($__3, Symbol.iterator, {
          value: obj,
          configurable: true,
          enumerable: true,
          writable: true
        }), $__3);
        iterator = obj;
      } else {
        if (!isIterable(obj)) {
          throw new Error(("Not iterable: " + obj));
        }
        iterable = obj;
        iterator = obj[Symbol.iterator].bind(obj);
      }
      this._iterable = iterable;
      this[Symbol.iterator] = iterator;
    }
    return ($traceurRuntime.createClass)(Seq, {
      isEqualTo: function(other) {
        var comparator = arguments[1] !== (void 0) ? arguments[1] : function(e1, e2) {
          return e1 === e2;
        };
        if (!isIterable(other)) {
          return false;
        }
        if (other === this) {
          return true;
        }
        var iter2 = other[Symbol.iterator]();
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e1 = $__5.value;
            {
              var e2 = iter2.next();
              if (e2.done || !comparator(e1, e2.value)) {
                return false;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return iter2.next().done;
      },
      toArray: function() {
        return Array.from(this._iterable);
      },
      toFloat32Array: function() {
        var n = this.tryPeekCount();
        if (n === undefined) {
          return new Float32Array(this.toArray());
        }
        var buf = new Float32Array(n);
        var i = 0;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              buf[i++] = item;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return buf;
      },
      toSet: function() {
        return new Set(this._iterable);
      },
      join: function(joiner) {
        return this.toArray().join(joiner);
      },
      toString: function() {
        return ("Seq[" + this.join(", ") + "]");
      },
      solidify: function() {
        var knownSolidTypes = [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array];
        if (Array.isArray(this._iterable)) {
          return this;
        }
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (knownSolidTypes)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var t = $__5.value;
            {
              if (this._iterable instanceof t) {
                return this;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return new Seq(this.toArray());
      },
      map: function(projection) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 24;
                  break;
                case 24:
                  $ctx.pushTry(10, 11);
                  $ctx.state = 13;
                  break;
                case 13:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 5 : 7;
                  break;
                case 4:
                  $__7 = true;
                  $ctx.state = 9;
                  break;
                case 5:
                  e = $__5.value;
                  $ctx.state = 6;
                  break;
                case 6:
                  $ctx.state = 2;
                  return projection(e);
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 7:
                  $ctx.popTry();
                  $ctx.state = 11;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 16;
                  break;
                case 16:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 11;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 11:
                  $ctx.popTry();
                  $ctx.state = 22;
                  break;
                case 22:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 20;
                  break;
                case 20:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      mapWithIndex: function(projection) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return projection(e, i);
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i += 1;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      flatMap: function(sequenceProjection) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__13,
              $__14,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.pushTry(18, 19);
                  $ctx.state = 21;
                  break;
                case 21:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 17;
                  break;
                case 17:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 13 : 15;
                  break;
                case 10:
                  $__7 = true;
                  $ctx.state = 17;
                  break;
                case 13:
                  e = $__5.value;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__13 = $ctx.wrapYieldStar(sequenceProjection(e)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__14.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__14.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__14.value;
                case 15:
                  $ctx.popTry();
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 24;
                  break;
                case 24:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 19:
                  $ctx.popTry();
                  $ctx.state = 30;
                  break;
                case 30:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      filter: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.pushTry(11, 12);
                  $ctx.state = 14;
                  break;
                case 14:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 10;
                  break;
                case 10:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 6 : 8;
                  break;
                case 4:
                  $__7 = true;
                  $ctx.state = 10;
                  break;
                case 6:
                  e = $__5.value;
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (predicate(e)) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 8:
                  $ctx.popTry();
                  $ctx.state = 12;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 11:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 17;
                  break;
                case 17:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 12;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 23;
                  break;
                case 23:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 21;
                  break;
                case 21:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      filterWithIndex: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (predicate(e, i)) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      fold: function(combiner) {
        var emptyErrorAlternative = arguments[1] !== (void 0) ? arguments[1] : THROW_IF_EMPTY;
        var accumulator = EMPTY_SYGIL;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              accumulator = accumulator === EMPTY_SYGIL ? e : combiner(accumulator, e);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return emptyFallback(accumulator, emptyErrorAlternative, "Folded empty sequence without providing an alternative result.");
      },
      aggregate: function(seed, aggregator) {
        var accumulator = seed;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              accumulator = aggregator(accumulator, e);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return accumulator;
      },
      zip: function(other, combiner) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var iter2,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              item1,
              item2,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  iter2 = other[Symbol.iterator]();
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.pushTry(15, 16);
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 10 : 12;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 14;
                  break;
                case 10:
                  item1 = $__5.value;
                  $ctx.state = 11;
                  break;
                case 11:
                  item2 = iter2.next();
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (item2.done) ? 12 : 2;
                  break;
                case 2:
                  $ctx.state = 5;
                  return combiner(item1, item2.value);
                case 5:
                  $ctx.maybeThrow();
                  $ctx.state = 7;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 15:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 21;
                  break;
                case 21:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.state = 27;
                  break;
                case 27:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      max: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        return this.fold(function(e1, e2) {
          return e1 < e2 ? e2 : e1;
        }, emptyErrorAlternative);
      },
      min: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        return this.fold(function(e1, e2) {
          return e1 < e2 ? e1 : e2;
        }, emptyErrorAlternative);
      },
      maxBy: function(projection) {
        var emptyErrorAlternative = arguments[1] !== (void 0) ? arguments[1] : THROW_IF_EMPTY;
        var isALessThanBComparator = arguments[2] !== (void 0) ? arguments[2] : function(e1, e2) {
          return e1 < e2;
        };
        var curMaxItem = EMPTY_SYGIL;
        var curMaxScore = EMPTY_SYGIL;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              if (curMaxItem === EMPTY_SYGIL) {
                curMaxItem = item;
                continue;
              }
              if (curMaxScore === EMPTY_SYGIL) {
                curMaxScore = projection(curMaxItem);
              }
              var score = projection(item);
              if (isALessThanBComparator(curMaxScore, score)) {
                curMaxItem = item;
                curMaxScore = score;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return emptyFallback(curMaxItem, emptyErrorAlternative, "Can't maxBy an empty sequence.");
      },
      minBy: function(projection) {
        var emptyErrorAlternative = arguments[1] !== (void 0) ? arguments[1] : THROW_IF_EMPTY;
        var isALessThanBComparator = arguments[2] !== (void 0) ? arguments[2] : function(e1, e2) {
          return e1 < e2;
        };
        return this.maxBy(projection, emptyErrorAlternative, function(e1, e2) {
          return isALessThanBComparator(e2, e1);
        });
      },
      any: function(predicate) {
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              if (predicate(e)) {
                return true;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return false;
      },
      every: function(predicate) {
        return !this.any(function(e) {
          return !predicate(e);
        });
      },
      contains: function(value) {
        return this.any(function(e) {
          return e === value;
        });
      },
      sum: function() {
        var total = 0;
        var first = true;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              total = first ? e : total + e;
              first = false;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return total;
      },
      product: function() {
        return this.fold(function(a, e) {
          return a * e;
        }, 1);
      },
      scan: function(seed, aggregator) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var accumulator,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  accumulator = seed;
                  $ctx.state = 30;
                  break;
                case 30:
                  $ctx.state = 2;
                  return accumulator;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.pushTry(16, 17);
                  $ctx.state = 19;
                  break;
                case 19:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 15;
                  break;
                case 15:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 11 : 13;
                  break;
                case 8:
                  $__7 = true;
                  $ctx.state = 15;
                  break;
                case 11:
                  e = $__5.value;
                  $ctx.state = 12;
                  break;
                case 12:
                  accumulator = aggregator(accumulator, e);
                  $ctx.state = 10;
                  break;
                case 10:
                  $ctx.state = 6;
                  return accumulator;
                case 6:
                  $ctx.maybeThrow();
                  $ctx.state = 8;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 17;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 17;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 17:
                  $ctx.popTry();
                  $ctx.state = 28;
                  break;
                case 28:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      reverse: function() {
        return new Seq(this.toArray().reverse());
      },
      flatten: function() {
        var seqSeq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              seq$__11,
              $__15,
              $__16,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.pushTry(18, 19);
                  $ctx.state = 21;
                  break;
                case 21:
                  $__5 = void 0, $__4 = (seqSeq)[Symbol.iterator]();
                  $ctx.state = 17;
                  break;
                case 17:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 13 : 15;
                  break;
                case 10:
                  $__7 = true;
                  $ctx.state = 17;
                  break;
                case 13:
                  seq$__11 = $__5.value;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__15 = $ctx.wrapYieldStar(seq$__11[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__16 = $__15[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__16.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__16.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__16.value;
                case 15:
                  $ctx.popTry();
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 24;
                  break;
                case 24:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 19:
                  $ctx.popTry();
                  $ctx.state = 30;
                  break;
                case 30:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      concat: function(other) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__17,
              $__18,
              $__19,
              $__20;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__17 = $ctx.wrapYieldStar(seq[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__18 = $__17[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__18.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__18.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__18.value;
                case 10:
                  $__19 = $ctx.wrapYieldStar(other[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 24;
                  break;
                case 24:
                  $__20 = $__19[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 21;
                  break;
                case 21:
                  $ctx.state = ($__20.done) ? 15 : 14;
                  break;
                case 15:
                  $ctx.sent = $__20.value;
                  $ctx.state = -2;
                  break;
                case 14:
                  $ctx.state = 24;
                  return $__20.value;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      withOverlayedItem: function(index, overlayedItem) {
        if (index < 0) {
          throw new Error("needed index >= 0");
        }
        var self = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  if (self.tryPeekCount() !== undefined && index >= self.tryPeekCount()) {
                    throw new Error("needed index <= count");
                  }
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (self._iterable)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return i === index ? overlayedItem : e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 17:
                  if (i <= index) {
                    throw new Error("sequence ended before overlay " + "[withOverlayedItem(${index}, ${overlayedItem})]");
                  }
                  $ctx.state = -2;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      withTransformedItem: function(index, itemTransformation) {
        if (index < 0) {
          throw new Error("needed index >= 0");
        }
        var self = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  if (self.tryPeekCount() !== undefined && index >= self.tryPeekCount()) {
                    throw new Error("needed index <= count");
                  }
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (self._iterable)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return i === index ? itemTransformation(e) : e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 17:
                  if (i <= index) {
                    throw new Error("sequence ended before transformation " + "[withTransformedItem(${index}, ${itemTransformation})]");
                  }
                  $ctx.state = -2;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      withInsertedItem: function(index, item) {
        if (index < 0) {
          throw new Error("needed index >= 0");
        }
        var self = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  if (self.tryPeekCount() !== undefined && index > self.tryPeekCount()) {
                    throw new Error("needed index <= count");
                  }
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 36;
                  break;
                case 36:
                  $ctx.pushTry(17, 18);
                  $ctx.state = 20;
                  break;
                case 20:
                  $__5 = void 0, $__4 = (self._iterable)[Symbol.iterator]();
                  $ctx.state = 16;
                  break;
                case 16:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 12 : 14;
                  break;
                case 9:
                  $__7 = true;
                  $ctx.state = 16;
                  break;
                case 12:
                  e = $__5.value;
                  $ctx.state = 13;
                  break;
                case 13:
                  $ctx.state = (i === index) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return item;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = 7;
                  return e;
                case 7:
                  $ctx.maybeThrow();
                  $ctx.state = 9;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 17:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 23;
                  break;
                case 23:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.state = 29;
                  break;
                case 29:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 27;
                  break;
                case 22:
                  $ctx.state = (i === index) ? 30 : 33;
                  break;
                case 30:
                  $ctx.state = 31;
                  return item;
                case 31:
                  $ctx.maybeThrow();
                  $ctx.state = 33;
                  break;
                case 33:
                  if (i < index) {
                    throw new Error("sequence ended before insertion [withInsertedItem(${index}, ${item})]");
                  }
                  $ctx.state = -2;
                  break;
                case 27:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      takeWhile: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (!predicate(e)) ? 10 : 2;
                  break;
                case 2:
                  $ctx.state = 5;
                  return e;
                case 5:
                  $ctx.maybeThrow();
                  $ctx.state = 7;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      skipTailWhile: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var tail,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__21,
              $__22,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  tail = [];
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.pushTry(27, 28);
                  $ctx.state = 30;
                  break;
                case 30:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 22 : 24;
                  break;
                case 20:
                  $__7 = true;
                  $ctx.state = 26;
                  break;
                case 22:
                  e = $__5.value;
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (predicate(e)) ? 19 : 11;
                  break;
                case 19:
                  tail.push(e);
                  $ctx.state = 20;
                  break;
                case 11:
                  $__21 = $ctx.wrapYieldStar(tail[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__22 = $__21[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__22.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__22.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__22.value;
                case 10:
                  tail = [];
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.state = 14;
                  return e;
                case 14:
                  $ctx.maybeThrow();
                  $ctx.state = 20;
                  break;
                case 24:
                  $ctx.popTry();
                  $ctx.state = 28;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 27:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 33;
                  break;
                case 33:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 28;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 28:
                  $ctx.popTry();
                  $ctx.state = 39;
                  break;
                case 39:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 37;
                  break;
                case 37:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      skipWhile: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var matched,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  matched = true;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 4:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  matched = matched && predicate(e);
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (!matched) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      take: function(maxTakeCount) {
        if (maxTakeCount < 0) {
          throw new Error("needed maxTakeCount >= 0");
        }
        if (maxTakeCount === 0) {
          return new Seq([]);
        }
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.pushTry(15, 16);
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 10 : 12;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 14;
                  break;
                case 10:
                  e = $__5.value;
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (i >= maxTakeCount) ? 12 : 6;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 15:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 21;
                  break;
                case 21:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.state = 27;
                  break;
                case 27:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      skip: function(maxSkipCount) {
        if (maxSkipCount < 0) {
          throw new Error("needed maxSkipCount >= 0");
        }
        if (maxSkipCount === 0) {
          return this;
        }
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (i >= maxSkipCount) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      distinctBy: function(keySelector) {
        var seq = this;
        return Seq.fromGenerator(function() {
          var keySet = new Set();
          return seq.filter(function(e) {
            var key = keySelector(e);
            if (keySet.has(key)) {
              return false;
            }
            keySet.add(key);
            return true;
          })[Symbol.iterator]();
        });
      },
      distinct: function() {
        return this.distinctBy(function(e) {
          return e;
        });
      },
      segmentBy: function(keySelector) {
        var seq = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var group,
              lastKey,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              item,
              itemKey,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  group = [];
                  lastKey = undefined;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 36;
                  break;
                case 36:
                  $ctx.pushTry(17, 18);
                  $ctx.state = 20;
                  break;
                case 20:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 16;
                  break;
                case 16:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 12 : 14;
                  break;
                case 11:
                  $__7 = true;
                  $ctx.state = 16;
                  break;
                case 12:
                  item = $__5.value;
                  $ctx.state = 13;
                  break;
                case 13:
                  itemKey = keySelector(item);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (group.length > 0 && itemKey !== lastKey) ? 1 : 6;
                  break;
                case 1:
                  $ctx.state = 2;
                  return group;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  group = [];
                  $ctx.state = 6;
                  break;
                case 6:
                  group.push(item);
                  lastKey = itemKey;
                  $ctx.state = 11;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 17:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 23;
                  break;
                case 23:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.state = 29;
                  break;
                case 29:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 27;
                  break;
                case 22:
                  $ctx.state = (group.length > 0) ? 30 : -2;
                  break;
                case 30:
                  $ctx.state = 31;
                  return group;
                case 31:
                  $ctx.maybeThrow();
                  $ctx.state = -2;
                  break;
                case 27:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      single: function() {
        var emptyManyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        var iter = this[Symbol.iterator]();
        var first = iter.next();
        if (!first.done && iter.next().done) {
          return first.value;
        }
        if (emptyManyErrorAlternative === THROW_IF_EMPTY) {
          if (first.done) {
            throw new Error("Empty sequence doesn't contain a single item.");
          } else {
            throw new Error("Sequence contains more than a single item.");
          }
        }
        return emptyManyErrorAlternative;
      },
      first: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        var iter = this[Symbol.iterator]();
        var first = iter.next();
        if (!first.done) {
          return first.value;
        }
        if (emptyErrorAlternative === THROW_IF_EMPTY) {
          throw new Error("Empty sequence has no first item.");
        }
        return emptyErrorAlternative;
      },
      last: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        var result = EMPTY_SYGIL;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              result = e;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return emptyFallback(result, emptyErrorAlternative, "Empty sequence has no last item.");
      },
      tryPeekCount: function() {
        var $__2 = this;
        if (Array.isArray(this._iterable) || !GENERIC_ARRAY_TYPES.every(function(t) {
          return !($__2._iterable instanceof t);
        })) {
          return this._iterable.length;
        }
        if (this._iterable instanceof Map || this._iterable instanceof Set) {
          return this._iterable.size;
        }
        return undefined;
      },
      count: function() {
        var known = this.tryPeekCount();
        if (known !== undefined) {
          return known;
        }
        var n = 0;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var _ = $__5.value;
            {
              n++;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return n;
      },
      padded: function(minCount) {
        var paddingItem = arguments[1];
        if (minCount < 0) {
          throw new Error("needed minCount >= 0");
        }
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var remaining,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  remaining = minCount;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 33;
                  break;
                case 33:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  remaining -= 1;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 17:
                  $ctx.state = (remaining > 0) ? 25 : -2;
                  break;
                case 25:
                  $ctx.state = 26;
                  return paddingItem;
                case 26:
                  $ctx.maybeThrow();
                  $ctx.state = 28;
                  break;
                case 28:
                  remaining -= 1;
                  $ctx.state = 17;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      sorted: function() {
        return seq(this.toArray().sort());
      },
      sortedBy: function(keySelector) {
        return seq(this.toArray().sort(function(e1, e2) {
          var out1 = keySelector(e1);
          var out2 = keySelector(e2);
          return out1 < out2 ? -1 : out1 > out2 ? +1 : 0;
        }));
      },
      ifThen: function(condition, sequenceTransformation) {
        return condition ? new Seq(sequenceTransformation(this)) : this;
      },
      toMap: function(keySelector, valueSelector) {
        var map = new Map();
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              var key = keySelector(item);
              var val = valueSelector(item);
              if (map.has(key)) {
                throw new Error(("Duplicate key <" + key + ">. Came from item <" + item + ">."));
              }
              map.set(key, val);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return map;
      },
      keyedBy: function(keySelector) {
        return this.toMap(keySelector, function(e) {
          return e;
        });
      },
      groupBy: function(keySelector) {
        var map = new Map();
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              var key = keySelector(item);
              if (!map.has(key)) {
                map.set(key, []);
              }
              map.get(key).push(item);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return map;
      },
      partitioned: function(partitionSize) {
        if (partitionSize <= 0) {
          throw new Error("need partitionSize > 0");
        }
        var seq = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var buffer,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              item,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  buffer = [];
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 34;
                  break;
                case 34:
                  $ctx.pushTry(15, 16);
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 10 : 12;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 14;
                  break;
                case 10:
                  item = $__5.value;
                  $ctx.state = 11;
                  break;
                case 11:
                  buffer.push(item);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (buffer.length >= partitionSize) ? 1 : 6;
                  break;
                case 1:
                  $ctx.state = 2;
                  return buffer;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  buffer = [];
                  $ctx.state = 6;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = 20;
                  break;
                case 15:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 21;
                  break;
                case 21:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = 20;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.state = 27;
                  break;
                case 27:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 25;
                  break;
                case 20:
                  $ctx.state = (buffer.length > 0) ? 28 : -2;
                  break;
                case 28:
                  $ctx.state = 29;
                  return buffer;
                case 29:
                  $ctx.maybeThrow();
                  $ctx.state = -2;
                  break;
                case 25:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      stride: function(stepSize) {
        return this.filterWithIndex(function(e, i) {
          return i % stepSize === 0;
        });
      },
      breadthFirstSearch: function(neighborSelector) {
        var keySelector = arguments[1] !== (void 0) ? arguments[1] : function(e) {
          return e;
        };
        var seq = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var visited,
              schedule,
              i,
              e,
              k,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              neighbor;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  visited = new Set();
                  schedule = seq.toArray();
                  $ctx.state = 16;
                  break;
                case 16:
                  i = 0;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (i < schedule.length) ? 8 : -2;
                  break;
                case 7:
                  i++;
                  $ctx.state = 14;
                  break;
                case 8:
                  e = schedule[i];
                  k = keySelector(e);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (visited.has(k)) ? 7 : 2;
                  break;
                case 2:
                  visited.add(k);
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  try {
                    for ($__5 = void 0, $__4 = (neighborSelector(e))[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
                      neighbor = $__5.value;
                      {
                        schedule.push(neighbor);
                      }
                    }
                  } catch ($__10) {
                    $__8 = true;
                    $__9 = $__10;
                  } finally {
                    try {
                      if (!$__7 && $__4.return != null) {
                        $__4.return();
                      }
                    } finally {
                      if ($__8) {
                        throw $__9;
                      }
                    }
                  }
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = 5;
                  return e;
                case 5:
                  $ctx.maybeThrow();
                  $ctx.state = 7;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      }
    }, {
      fromGenerator: function(generatorFunction) {
        return new Seq(generatorFunction, true);
      },
      range: function(count) {
        if (!Number.isInteger(count) || count < 0) {
          throw new DetailedError("bad count", {count: count});
        }
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (i < count) ? 1 : -2;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 1:
                  $ctx.state = 2;
                  return i;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      naturals: function() {
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (true) ? 1 : -2;
                  break;
                case 1:
                  $ctx.state = 2;
                  return i;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 9;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      repeat: function(item, repeatCount) {
        if (repeatCount < 0) {
          throw new Error("needed repeatCount >= 0");
        }
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (i < repeatCount) ? 1 : -2;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 1:
                  $ctx.state = 2;
                  return item;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      }
    });
  }();
  var seq = function(iterable) {
    return new Seq(iterable);
  };
  return {
    get THROW_IF_EMPTY() {
      return THROW_IF_EMPTY;
    },
    get seq() {
      return seq;
    },
    get Seq() {
      return Seq;
    }
  };
});
//# sourceURL=src/base/Seq.js
;$traceurRuntime.registerModule("src/base/Util.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Util.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DetailedError.js", "src/base/Util.js")).DetailedError;
  var Util = function() {
    function Util() {}
    return ($traceurRuntime.createClass)(Util, {}, {
      need: function(expression, message, args) {
        if (expression !== true) {
          var argDesc = args === undefined ? "(not provided)" : ("[" + Array.prototype.slice.call(args).join(", ") + "]");
          var msgDesc = message === undefined ? "(not provided)" : message;
          var msg = "Precondition failed" + "\n\nMessage: " + msgDesc + "\n\nArgs: " + argDesc;
          throw new Error(msg);
        }
      },
      numberOfSetBits: function(i) {
        if (i < 0) {
          throw new Error("i < 0");
        }
        if (!Number.isInteger(i)) {
          throw new Error("!Number.isInteger(i)");
        }
        if (i > 0xFFFFFFFF) {
          throw new Error("i > 0xFFFFFFFF");
        }
        i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
        i = (i + (i >> 4)) & 0x0F0F0F0F;
        i += i >> 8;
        i += i >> 16;
        return i & 0xFF;
      },
      bin: function(number, fixedLen) {
        return ("0".repeat(fixedLen) + number.toString(2)).slice(-fixedLen).split("").join("");
      },
      notNull: function(v) {
        Util.need(v !== null, "notNull");
        return v;
      },
      isPowerOf2: function(i) {
        return i > 0 && ((i - 1) & i) === 0;
      },
      bitSize: function(n) {
        Util.need(n >= 0, "bitSize: n >= 0");
        if (n === 0) {
          return 0;
        }
        return Util.floorLg2(n) + 1;
      },
      ceilingPowerOf2: function(n) {
        if (n <= 1) {
          return 1;
        }
        return 1 << Util.ceilLg2(n);
      },
      ceilLg2: function(n) {
        if (n <= 1) {
          return 0;
        }
        var p = Math.ceil(Math.log2(n));
        if (1 << p < n) {
          return p + 1;
        }
        if (n <= 1 << (p - 1)) {
          return p - 1;
        }
        return p;
      },
      floorLg2: function(n) {
        if (n <= 1) {
          return 0;
        }
        var p = Math.floor(Math.log2(n));
        if (1 << (p + 1) <= n) {
          return p + 1;
        }
        if (n < 1 << p) {
          return p - 1;
        }
        return p;
      },
      popcnt: function(i) {
        if (i < 0) {
          return Math.POSITIVE_INFINITY;
        }
        var t = 0;
        while (i > 0) {
          i &= i - 1;
          t++;
        }
        return t;
      },
      powerOfTwoness: function(i) {
        var zeroResult = arguments[1] !== (void 0) ? arguments[1] : Math.POSITIVE_INFINITY;
        if (i === 0) {
          return zeroResult;
        }
        if (i < 0) {
          return Util.powerOfTwoness(-i, zeroResult);
        }
        return Math.round(Math.log2(i & ~(i - 1)));
      },
      reverseGroupMap: function(groupMap) {
        var $__25,
            $__26;
        var includeGroupsForOriginalKeysEvenIfEmpty = arguments[1] !== (void 0) ? arguments[1] : false;
        var result = new Map();
        if (includeGroupsForOriginalKeysEvenIfEmpty) {
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (groupMap.keys())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var e = $__3.value;
              {
                result.set(e, []);
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }
        var $__19 = true;
        var $__20 = false;
        var $__21 = undefined;
        try {
          for (var $__17 = void 0,
              $__16 = (groupMap)[Symbol.iterator](); !($__19 = ($__17 = $__16.next()).done); $__19 = true) {
            var $__24 = $__17.value,
                k = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value),
                g = ($__26 = $__25.next()).done ? void 0 : $__26.value;
            {
              var $__12 = true;
              var $__13 = false;
              var $__14 = undefined;
              try {
                for (var $__10 = void 0,
                    $__9 = (g)[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
                  var e$__33 = $__10.value;
                  {
                    if (!result.has(e$__33)) {
                      result.set(e$__33, []);
                    }
                    result.get(e$__33).push(k);
                  }
                }
              } catch ($__15) {
                $__13 = true;
                $__14 = $__15;
              } finally {
                try {
                  if (!$__12 && $__9.return != null) {
                    $__9.return();
                  }
                } finally {
                  if ($__13) {
                    throw $__14;
                  }
                }
              }
            }
          }
        } catch ($__22) {
          $__20 = true;
          $__21 = $__22;
        } finally {
          try {
            if (!$__19 && $__16.return != null) {
              $__16.return();
            }
          } finally {
            if ($__20) {
              throw $__21;
            }
          }
        }
        return result;
      },
      binarySearchForTransitionFromTrueToFalse: function(max, argIsBeforeTransitionFunc) {
        var min = 0;
        while (max > min) {
          var med = min + Math.floor((max - min) / 2);
          if (argIsBeforeTransitionFunc(med)) {
            min = med + 1;
          } else {
            max = med;
          }
        }
        return min;
      },
      breakLine: function(text, maxWidth, measureWidth) {
        if (text === "") {
          return [""];
        }
        var lines = [];
        var p = 0;
        while (p < text.length) {
          var maxKeepLength = Util.binarySearchForTransitionFromTrueToFalse(text.length - p + 1, function(i) {
            return measureWidth(text.substr(p, i)) <= maxWidth;
          }) - 1;
          maxKeepLength = Math.max(1, maxKeepLength);
          var maxChunk = text.substr(p, maxKeepLength);
          var hitBoundary = p + maxKeepLength === text.length || text.substr(p + maxKeepLength, 1).match(/\s/) !== null;
          if (!hitBoundary) {
            var niceRegex = /^(.*\S)(\s+)\S*$/;
            var niceChunkMatch = niceRegex.exec(maxChunk);
            if (niceChunkMatch !== null) {
              var keepChunk = niceChunkMatch[1];
              var skipChunk = niceChunkMatch[2];
              lines.push(keepChunk.trim());
              p += keepChunk.length + skipChunk.length;
              continue;
            }
          }
          lines.push(maxChunk.trim());
          p += maxChunk.length;
          p += text.substr(p).match(/^\s*/)[0].length;
        }
        return lines;
      },
      decomposeObjectValues: function(object) {
        var result = [];
        var decomposeValueOrArray;
        decomposeValueOrArray = function(val) {
          if (Array.isArray(val)) {
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (val)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var item = $__3.value;
                {
                  decomposeValueOrArray(item);
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
          } else {
            result.push(val);
          }
        };
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (Object.keys(object).sort())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              decomposeValueOrArray(object[key], result);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return result;
      },
      recomposedObjectValues: function(originalObject, newFieldValues) {
        var result = {};
        var i = 0;
        var recomposeValueOrArray;
        recomposeValueOrArray = function(originalVal) {
          if (Array.isArray(originalVal)) {
            var arr = [];
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (originalVal)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var item = $__3.value;
                {
                  arr.push(recomposeValueOrArray(item));
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
            return arr;
          }
          return newFieldValues[i++];
        };
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (Object.keys(originalObject).sort())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              result[key] = recomposeValueOrArray(originalObject[key]);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        Util.need(i === newFieldValues.length, "Mismatched field value count.");
        return result;
      },
      objectifyArrayFunc: function(func) {
        return function(arg) {
          return Util.recomposedObjectValues(arg, func(Util.decomposeObjectValues(arg)));
        };
      },
      snappedCosSin: function(radians) {
        var unit = Math.PI / 4;
        var i = Math.round(radians / unit);
        if (i * unit === radians) {
          var s = Math.sqrt(0.5);
          var snaps = [[1, 0], [s, s], [0, 1], [-s, s], [-1, 0], [-s, -s], [0, -1], [s, -s]];
          return snaps[i & 7];
        }
        return [Math.cos(radians), Math.sin(radians)];
      },
      properMod: function(numerator, denominator) {
        if (denominator <= 0) {
          throw new DetailedError("denominator <= 0", {
            numerator: numerator,
            denominator: denominator
          });
        }
        var result = numerator % denominator;
        return result + (result < 0 ? denominator : 0);
      },
      mergeMaps: function() {
        var $__25,
            $__26;
        for (var maps = [],
            $__23 = 0; $__23 < arguments.length; $__23++)
          maps[$__23] = arguments[$__23];
        var result = new Map();
        var $__12 = true;
        var $__13 = false;
        var $__14 = undefined;
        try {
          for (var $__10 = void 0,
              $__9 = (maps)[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
            var map = $__10.value;
            {
              var $__5 = true;
              var $__6 = false;
              var $__7 = undefined;
              try {
                for (var $__3 = void 0,
                    $__2 = (map.entries())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                  var $__24 = $__3.value,
                      key = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value),
                      val = ($__26 = $__25.next()).done ? void 0 : $__26.value;
                  {
                    result.set(key, val);
                  }
                }
              } catch ($__8) {
                $__6 = true;
                $__7 = $__8;
              } finally {
                try {
                  if (!$__5 && $__2.return != null) {
                    $__2.return();
                  }
                } finally {
                  if ($__6) {
                    throw $__7;
                  }
                }
              }
            }
          }
        } catch ($__15) {
          $__13 = true;
          $__14 = $__15;
        } finally {
          try {
            if (!$__12 && $__9.return != null) {
              $__9.return();
            }
          } finally {
            if ($__13) {
              throw $__14;
            }
          }
        }
        return result;
      },
      modular_multiplicative_inverse: function(value, modulus) {
        var $__24 = Util.extended_gcd(value, modulus),
            x = $__24.x,
            gcd = $__24.gcd;
        if (gcd !== 1) {
          return undefined;
        }
        x %= modulus;
        if (x < 0) {
          x += modulus;
        }
        return x;
      },
      extended_gcd: function(a, b) {
        var $__24,
            $__25,
            $__26,
            $__27,
            $__28,
            $__29,
            $__30,
            $__31,
            $__32;
        var s = 0;
        var t = 1;
        var r = b;
        var old_s = 1;
        var old_t = 0;
        var old_r = a;
        while (r !== 0) {
          var q = Math.floor(old_r / r);
          ($__24 = [r, old_r - q * r], old_r = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value), r = ($__26 = $__25.next()).done ? void 0 : $__26.value, $__24);
          ($__27 = [s, old_s - q * s], old_s = ($__28 = $__27[Symbol.iterator](), ($__29 = $__28.next()).done ? void 0 : $__29.value), s = ($__29 = $__28.next()).done ? void 0 : $__29.value, $__27);
          ($__30 = [t, old_t - q * t], old_t = ($__31 = $__30[Symbol.iterator](), ($__32 = $__31.next()).done ? void 0 : $__32.value), t = ($__32 = $__31.next()).done ? void 0 : $__32.value, $__30);
        }
        return {
          x: old_s,
          y: old_t,
          gcd: old_r
        };
      },
      digits_to_superscript_digits: function(text) {
        var digits = "0123456789";
        var superscript_digits = "⁰¹²³⁴⁵⁶⁷⁸⁹";
        for (var i = 0; i < 10; i++) {
          text = text.split(digits[i]).join(superscript_digits[i]);
        }
        return text;
      }
    });
  }();
  Util.STRICT_EQUALITY = function(e1, e2) {
    return e1 === e2;
  };
  Util.CUSTOM_IS_EQUAL_TO_EQUALITY = function(e1, e2) {
    return e1 === null ? e2 === null : e1 === undefined ? e2 === undefined : e1.isEqualTo(e2);
  };
  return {get Util() {
      return Util;
    }};
});
//# sourceURL=src/base/Util.js
;$traceurRuntime.registerModule("src/browser/Clipboard.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/Clipboard.js";
  function selectAndCopyToClipboard(element) {
    if (document.selection) {
      var range = document.body.createTextRange();
      range.moveToElementText(element);
      range.select();
    } else if (window.getSelection) {
      var range$__0 = document.createRange();
      range$__0.selectNodeContents(element);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range$__0);
    }
    if (!document.execCommand('copy')) {
      throw new Error("execCommand failed");
    }
  }
  return {get selectAndCopyToClipboard() {
      return selectAndCopyToClipboard;
    }};
});
//# sourceURL=src/browser/Clipboard.js
;$traceurRuntime.registerModule("src/browser/EventUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/EventUtil.js";
  var Observable = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Obs.js", "src/browser/EventUtil.js")).Observable;
  function textEditObservable(textBox) {
    return Observable.of(Observable.elementEvent(textBox, 'change'), Observable.elementEvent(textBox, 'keyup'), Observable.elementEvent(textBox, 'click'), Observable.elementEvent(textBox, 'paste'), Observable.elementEvent(textBox, 'input')).flatten().map(function(e) {
      return textBox.value;
    }).whenDifferent();
  }
  return {get textEditObservable() {
      return textEditObservable;
    }};
});
//# sourceURL=src/browser/EventUtil.js
;$traceurRuntime.registerModule("src/browser/HistoryPusher.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/HistoryPusher.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/browser/HistoryPusher.js")).DetailedError;
  var HistoryPusher = function() {
    function HistoryPusher() {
      this._historyActionsNotWorking = false;
      this._currentMemorableStateObj = undefined;
    }
    return ($traceurRuntime.createClass)(HistoryPusher, {
      currentStateIsMemorableButUnknown: function() {
        this._currentMemorableStateObj = {wont_equal_this: true};
      },
      currentStateIsMemorableAndEqualTo: function(stateObj) {
        this._currentMemorableStateObj = stateObj;
      },
      currentStateIsNotMemorable: function() {
        this._currentMemorableStateObj = undefined;
      },
      stateChange: function(stateObj, stateUrlHash) {
        if (!stateUrlHash.startsWith('#')) {
          throw new DetailedError("Expected a hash URL.", {
            stateObj: stateObj,
            stateUrlHash: stateUrlHash
          });
        }
        if (this._currentMemorableStateObj === stateObj) {
          return;
        }
        if (this._historyActionsNotWorking) {
          document.location.hash = stateUrlHash;
          return;
        }
        try {
          if (this._currentMemorableStateObj === undefined) {
            history.replaceState(stateObj, "", stateUrlHash);
          } else {
            history.pushState(stateObj, "", stateUrlHash);
            this._currentMemorableStateObj = undefined;
          }
        } catch (ex) {
          console.warn("Calling 'history.replaceState/pushState' failed. Falling back to setting location.hash.", ex);
          this._historyActionsNotWorking = true;
          document.location.hash = stateUrlHash;
        }
      }
    }, {});
  }();
  return {get HistoryPusher() {
      return HistoryPusher;
    }};
});
//# sourceURL=src/browser/HistoryPusher.js
;$traceurRuntime.registerModule("src/browser/MouseWatcher.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/MouseWatcher.js";
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/browser/MouseWatcher.js")).Point;
  var ALLOW_REGRAB_WATCHDOG_TIME_MS = 5000;
  var MOUSE_ID = "mouse!";
  var isLeftClicking = function(ev) {
    return (window.TouchEvent !== undefined && ev instanceof TouchEvent) || ev.which === 1;
  };
  var isMiddleClicking = function(ev) {
    return ev.which === 2;
  };
  function eventPosRelativeTo(ev, element) {
    var b = element.getBoundingClientRect();
    return new Point(ev.clientX - b.left, ev.clientY - b.top);
  }
  function watchDrags(element, grabHandler, cancelHandler, dragHandler, dropHandler) {
    return new DragWatcher(element, grabHandler, cancelHandler, dragHandler, dropHandler).addListenersUntilResultInvoked();
  }
  var addListenerUntilResultInvoked = function(target, type, listener) {
    target.addEventListener(type, listener);
    return function() {
      return target.removeEventListener(type, listener);
    };
  };
  var DragWatcher = function() {
    function DragWatcher(element, grabHandler, cancelHandler, dragHandler, dropHandler) {
      this._element = element;
      this._grabHandler = grabHandler;
      this._cancelHandler = cancelHandler;
      this._dragHandler = dragHandler;
      this._dropHandler = dropHandler;
      this._grabPointerId = undefined;
      this._grabActivityTime = window.performance.now();
      this._lastPos = undefined;
      this._lastEv = undefined;
    }
    return ($traceurRuntime.createClass)(DragWatcher, {
      addListenersUntilResultInvoked: function() {
        var $__1 = this;
        var e = this._element;
        var unregCalls = [addListenerUntilResultInvoked(e, 'mousedown', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onDown);
        }), addListenerUntilResultInvoked(document, 'mousemove', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onMove);
        }), addListenerUntilResultInvoked(document, 'mouseup', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onUp);
        }), addListenerUntilResultInvoked(document, 'mouseleave', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onLeave);
        }), addListenerUntilResultInvoked(document, 'mouseenter', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onEnter);
        }), addListenerUntilResultInvoked(e, 'touchstart', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onDown);
        }), addListenerUntilResultInvoked(e, 'touchmove', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onMove);
        }), addListenerUntilResultInvoked(e, 'touchend', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onUp);
        }), addListenerUntilResultInvoked(e, 'touchcancel', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onCancel);
        })];
        return function() {
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (unregCalls)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var unregCall = $__3.value;
              {
                unregCall();
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        };
      },
      canRegrab: function() {
        return window.performance.now() >= this._grabActivityTime + ALLOW_REGRAB_WATCHDOG_TIME_MS;
      },
      onDown: function(pt, id, ev) {
        if (!isLeftClicking(ev)) {
          return;
        }
        if (this._grabPointerId !== undefined) {
          if (!this.canRegrab()) {
            return;
          }
          this._dropHandler(this._lastPos, this._lastEv);
        }
        this._grabPointerId = id;
        this._grabActivityTime = window.performance.now();
        this._lastPos = pt;
        this._lastEv = ev;
        this._grabHandler(pt, ev);
      },
      onMove: function(pt, id, ev) {
        if (this._grabPointerId !== id) {
          return;
        }
        if (!isLeftClicking(ev)) {
          this._lastPos = undefined;
          this._lastEv = undefined;
          this._grabPointerId = undefined;
          this._dropHandler(undefined, ev);
          return;
        }
        this._grabActivityTime = window.performance.now();
        this._lastPos = pt;
        this._lastEv = ev;
        this._dragHandler(pt, ev);
      },
      onCancel: function(pt, id, ev) {
        if (this._grabPointerId !== id) {
          return;
        }
        this._lastPos = undefined;
        this._lastEv = undefined;
        this._grabPointerId = undefined;
        this._cancelHandler(ev);
      },
      onUp: function(pt, id, ev) {
        if (!isLeftClicking(ev) || this._grabPointerId !== id) {
          return;
        }
        this._lastPos = undefined;
        this._lastEv = undefined;
        this._grabPointerId = undefined;
        this._dropHandler(pt, ev);
      },
      onLeave: function(pt, id, ev) {
        if (!isLeftClicking(ev) || this._grabPointerId !== id) {
          return;
        }
        this._grabActivityTime = window.performance.now();
        this._lastPos = undefined;
        this._lastEv = ev;
        this._dragHandler(undefined, ev);
      },
      onEnter: function(pt, id, ev) {
        if (isLeftClicking(ev) || this._grabPointerId !== id) {
          return;
        }
        this._lastPos = undefined;
        this._lastEv = undefined;
        this._grabPointerId = undefined;
        this._dropHandler(undefined, ev);
      },
      relativeEventPos: function(ev) {
        return eventPosRelativeTo(ev, this._element);
      },
      handleTouchEventWith: function(ev, handler) {
        for (var i = 0; i < ev.changedTouches.length; i++) {
          var touch = ev.changedTouches[i];
          handler.call(this, this.relativeEventPos(touch), touch.identifier, ev);
        }
      },
      handleMouseEventWith: function(ev, handler) {
        handler.call(this, this.relativeEventPos(ev), MOUSE_ID, ev);
      }
    }, {});
  }();
  return {
    get watchDrags() {
      return watchDrags;
    },
    get isLeftClicking() {
      return isLeftClicking;
    },
    get isMiddleClicking() {
      return isMiddleClicking;
    },
    get eventPosRelativeTo() {
      return eventPosRelativeTo;
    }
  };
});
//# sourceURL=src/browser/MouseWatcher.js
;$traceurRuntime.registerModule("src/browser/Polyfills.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/Polyfills.js";
  Float32Array.prototype.slice = Float32Array.prototype.slice || function(a, b) {
    return new Float32Array(Array.from(this).slice(a, b));
  };
  Float64Array.prototype.slice = Float64Array.prototype.slice || function(a, b) {
    return new Float64Array(Array.from(this).slice(a, b));
  };
  Uint32Array.prototype.slice = Uint32Array.prototype.slice || function(a, b) {
    return new Uint32Array(Array.from(this).slice(a, b));
  };
  Int32Array.prototype.slice = Int32Array.prototype.slice || function(a, b) {
    return new Int32Array(Array.from(this).slice(a, b));
  };
  Uint16Array.prototype.slice = Uint16Array.prototype.slice || function(a, b) {
    return new Uint16Array(Array.from(this).slice(a, b));
  };
  Int16Array.prototype.slice = Int16Array.prototype.slice || function(a, b) {
    return new Int16Array(Array.from(this).slice(a, b));
  };
  Uint8Array.prototype.slice = Uint8Array.prototype.slice || function(a, b) {
    return new Uint8Array(Array.from(this).slice(a, b));
  };
  Int8Array.prototype.slice = Int8Array.prototype.slice || function(a, b) {
    return new Int8Array(Array.from(this).slice(a, b));
  };
  var ARRAY_ITER = function() {
    var self = this;
    return $traceurRuntime.initGeneratorFunction(function $__8() {
      var i;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 7;
              break;
            case 7:
              $ctx.state = (i < self.length) ? 1 : -2;
              break;
            case 4:
              i++;
              $ctx.state = 7;
              break;
            case 1:
              $ctx.state = 2;
              return self[i];
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__8, this);
    })();
  };
  Float32Array.prototype[Symbol.iterator] = Float32Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Float64Array.prototype[Symbol.iterator] = Float64Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Uint32Array.prototype[Symbol.iterator] = Uint32Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Uint16Array.prototype[Symbol.iterator] = Uint16Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Uint8Array.prototype[Symbol.iterator] = Uint8Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Int32Array.prototype[Symbol.iterator] = Int32Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Int16Array.prototype[Symbol.iterator] = Int16Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Int8Array.prototype[Symbol.iterator] = Int8Array.prototype[Symbol.iterator] || ARRAY_ITER;
  window.performance = window.performance || {};
  window.performance.now = window.performance.now || (function() {
    return Date.now();
  });
  var GL = WebGLRenderingContext;
  if (GL !== undefined && GL.INVALID_ENUM === undefined) {
    var keys = ['ARRAY_BUFFER', 'CLAMP_TO_EDGE', 'COLOR_ATTACHMENT0', 'COMPILE_STATUS', 'ELEMENT_ARRAY_BUFFER', 'FLOAT', 'FRAGMENT_SHADER', 'FRAMEBUFFER', 'FRAMEBUFFER_COMPLETE', 'HIGH_FLOAT', 'LINK_STATUS', 'MAX_TEXTURE_IMAGE_UNITS', 'MAX_TEXTURE_SIZE', 'MEDIUM_FLOAT', 'NEAREST', 'NO_ERROR', 'RGBA', 'STATIC_DRAW', 'TEXTURE_2D', 'TEXTURE_MAG_FILTER', 'TEXTURE_MIN_FILTER', 'TEXTURE_WRAP_S', 'TEXTURE_WRAP_T', 'TEXTURE0', 'TRIANGLES', 'UNSIGNED_SHORT', 'UNSIGNED_BYTE', 'VALIDATE_STATUS', 'VERTEX_SHADER'];
    var gl = document.createElement('canvas').getContext('webgl');
    if (gl !== null && gl !== undefined) {
      var $__4 = true;
      var $__5 = false;
      var $__6 = undefined;
      try {
        for (var $__2 = void 0,
            $__1 = (keys)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
          var key = $__2.value;
          {
            GL[key] = GL[key] || gl[key];
          }
        }
      } catch ($__7) {
        $__5 = true;
        $__6 = $__7;
      } finally {
        try {
          if (!$__4 && $__1.return != null) {
            $__1.return();
          }
        } finally {
          if ($__5) {
            throw $__6;
          }
        }
      }
    }
  }
  return {};
});
//# sourceURL=src/browser/Polyfills.js
;$traceurRuntime.registerModule("src/browser/SaveFile.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/SaveFile.js";
  function saveFile(name, content) {
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(new Blob([content], {type: 'text/html;charset=UTF-8'}), name);
      return;
    }
    var anchor = document.createElement("a");
    anchor.href = window.URL !== undefined ? window.URL.createObjectURL(new Blob([content], {type: 'text/html;charset=UTF-8'})) : 'data:application/octet-stream,' + encodeURI(moddedHtml);
    anchor.download = name;
    try {
      document.body.appendChild(anchor);
      anchor.click();
    } finally {
      document.body.removeChild(anchor);
    }
  }
  return {get saveFile() {
      return saveFile;
    }};
});
//# sourceURL=src/browser/SaveFile.js
;$traceurRuntime.registerModule("src/browser/TouchScrollBlocker.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/TouchScrollBlocker.js";
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/browser/TouchScrollBlocker.js")).Rect;
  var TouchScrollBlocker = function() {
    function TouchScrollBlocker(parentElement) {
      this._parentElement = parentElement;
      this._curBlockers = [];
      this._curShowing = 0;
    }
    return ($traceurRuntime.createClass)(TouchScrollBlocker, {setBlockers: function(desiredBlockers, overrideCursorStyle) {
        while (this._curBlockers.length < desiredBlockers.length) {
          var blockerDiv = document.createElement('div');
          blockerDiv.style.touchAction = 'none';
          blockerDiv.style.position = 'absolute';
          blockerDiv.style.opacity = 0.0001;
          this._parentElement.appendChild(blockerDiv);
          this._curBlockers.push({
            div: blockerDiv,
            area: undefined
          });
        }
        for (var i = 0; i < desiredBlockers.length; i++) {
          var desiredArea = desiredBlockers[i].rect;
          var desiredCursor = overrideCursorStyle || desiredBlockers[i].cursor || 'auto';
          var cur = this._curBlockers[i];
          var style = cur.div.style;
          if (!desiredArea.isEqualTo(cur.area)) {
            cur.area = desiredArea;
            style.left = desiredArea.x + "px";
            style.top = desiredArea.y + "px";
            style.width = desiredArea.w + "px";
            style.height = desiredArea.h + "px";
          }
          if (style.cursor !== desiredCursor) {
            style.cursor = desiredCursor;
          }
        }
        while (this._curShowing < desiredBlockers.length) {
          this._curBlockers[this._curShowing].div.style.display = 'inline';
          this._curShowing++;
        }
        while (this._curShowing > desiredBlockers.length) {
          this._curShowing--;
          this._curBlockers[this._curShowing].div.style.display = 'none';
        }
      }}, {});
  }();
  return {get TouchScrollBlocker() {
      return TouchScrollBlocker;
    }};
});
//# sourceURL=src/browser/TouchScrollBlocker.js
;$traceurRuntime.registerModule("src/circuit/CircuitComputeUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitComputeUtil.js";
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitEvalContext.js", "src/circuit/CircuitComputeUtil.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitShaders.js", "src/circuit/CircuitComputeUtil.js")).CircuitShaders;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/CircuitComputeUtil.js")).DetailedError;
  var KetTextureUtil = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./KetTextureUtil.js", "src/circuit/CircuitComputeUtil.js")).KetTextureUtil;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Controls.js", "src/circuit/CircuitComputeUtil.js")).Controls;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Gate.js", "src/circuit/CircuitComputeUtil.js")).GateBuilder;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/AllGates.js", "src/circuit/CircuitComputeUtil.js")).Gates;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/CircuitComputeUtil.js")).Util;
  function setGateBuilderEffectToCircuit(builder, circuitDefinition) {
    return builder.setActualEffectToUpdateFunc(function(ctx) {
      return advanceStateWithCircuit(ctx, circuitDefinition.withDisabledReasonsForEmbeddedContext(ctx.row, ctx.customContextFromGates), false);
    }).setKnownEffectToCircuit(circuitDefinition).setExtraDisableReasonFinder(function(args) {
      var def = circuitDefinition.withDisabledReasonsForEmbeddedContext(args.outerRow, args.context);
      for (var row = 0; row < def.numWires; row++) {
        for (var col = 0; col < def.columns.length; col++) {
          var r = def.gateAtLocIsDisabledReason(col, row);
          if (r !== undefined) {
            return r;
          }
          if (def.gateInSlot(col, row) === Gates.Special.Measurement) {
            return "hidden\nmeasure\nbroken";
          }
        }
      }
      return undefined;
    });
  }
  function advanceStateWithCircuit(ctx, circuitDefinition, collectStats) {
    var colQubitDensities = [];
    var customStats = [];
    var colNorms = [];
    var customStatsMap = [];
    var statsCallback = function(col) {
      return function(statArgs) {
        if (!collectStats) {
          return;
        }
        var $__8 = _extractStateStatsNeededByCircuitColumn(statArgs, circuitDefinition, col),
            qubitDensities = $__8.qubitDensities,
            norm = $__8.norm,
            customGateStats = $__8.customGateStats;
        colQubitDensities.push(qubitDensities);
        colNorms.push(norm);
        var $__4 = true;
        var $__5 = false;
        var $__6 = undefined;
        try {
          for (var $__2 = void 0,
              $__1 = (customGateStats)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
            var $__9 = $__2.value,
                row = $__9.row,
                stat = $__9.stat;
            {
              customStatsMap.push({
                col: col,
                row: row,
                out: customStats.length
              });
              customStats.push(stat);
            }
          }
        } catch ($__7) {
          $__5 = true;
          $__6 = $__7;
        } finally {
          try {
            if (!$__4 && $__1.return != null) {
              $__1.return();
            }
          } finally {
            if ($__5) {
              throw $__6;
            }
          }
        }
      };
    };
    circuitDefinition.applyInitialStateOperations(ctx);
    for (var col = 0; col < circuitDefinition.columns.length; col++) {
      _advanceStateWithCircuitDefinitionColumn(ctx, circuitDefinition, col, statsCallback(col));
    }
    if (collectStats) {
      var allWiresMask = (1 << circuitDefinition.numWires) - 1;
      colQubitDensities.push(KetTextureUtil.superpositionToQubitDensities(ctx.stateTrader.currentTexture, Controls.NONE, allWiresMask));
    }
    return {
      colQubitDensities: colQubitDensities,
      colNorms: colNorms,
      customStats: customStats,
      customStatsMap: customStatsMap
    };
  }
  function _extractStateStatsNeededByCircuitColumn(ctx, circuitDefinition, col) {
    var customGateStats = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (circuitDefinition.customStatRowsInCol(col))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var row = $__2.value;
        {
          var statCtx = new CircuitEvalContext(ctx.time, row, circuitDefinition.numWires, ctx.controls, ctx.controlsTexture, ctx.controls, ctx.stateTrader, Util.mergeMaps(ctx.customContextFromGates, circuitDefinition.colCustomContextFromGates(col, row)));
          var stat = circuitDefinition.columns[col].gates[row].customStatTexturesMaker(statCtx);
          customGateStats.push({
            row: row,
            stat: stat
          });
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var qubitDensities = KetTextureUtil.superpositionToQubitDensities(ctx.stateTrader.currentTexture, ctx.controls, circuitDefinition.colDesiredSingleQubitStatsMask(col));
    var normMayHaveChanged = circuitDefinition.columns[col].indexOfNonUnitaryGate() !== undefined;
    var norm = KetTextureUtil.superpositionToNorm(ctx.stateTrader.currentTexture, normMayHaveChanged);
    return {
      qubitDensities: qubitDensities,
      norm: norm,
      customGateStats: customGateStats
    };
  }
  function _advanceStateWithCircuitDefinitionColumn(ctx, circuitDefinition, col, statsCallback) {
    var controls = ctx.controls.and(circuitDefinition.colControls(col).shift(ctx.row));
    var controlTex = CircuitShaders.controlMask(controls).toBoolTexture(ctx.wireCount);
    var colContext = Util.mergeMaps(ctx.customContextFromGates, circuitDefinition.colCustomContextFromGates(col, ctx.row));
    var trader = ctx.stateTrader;
    var aroundCtx = new CircuitEvalContext(ctx.time, ctx.row, ctx.wireCount, ctx.controls, ctx.controlsTexture, controls, trader, colContext);
    var mainCtx = new CircuitEvalContext(ctx.time, ctx.row, ctx.wireCount, controls, controlTex, controls, trader, colContext);
    circuitDefinition.applyBeforeOperationsInCol(col, aroundCtx);
    circuitDefinition.applyMainOperationsInCol(col, mainCtx);
    statsCallback(mainCtx);
    circuitDefinition.applyAfterOperationsInCol(col, aroundCtx);
    controlTex.deallocByDepositingInPool("controlTex in _advanceStateWithCircuitDefinitionColumn");
  }
  return {
    get setGateBuilderEffectToCircuit() {
      return setGateBuilderEffectToCircuit;
    },
    get advanceStateWithCircuit() {
      return advanceStateWithCircuit;
    }
  };
});
//# sourceURL=src/circuit/CircuitComputeUtil.js
;$traceurRuntime.registerModule("src/circuit/CircuitDefinition.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitDefinition.js";
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitShaders.js", "src/circuit/CircuitDefinition.js")).CircuitShaders;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/circuit/CircuitDefinition.js")).Config;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Controls.js", "src/circuit/CircuitDefinition.js")).Controls;
  var CustomGateSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CustomGateSet.js", "src/circuit/CircuitDefinition.js")).CustomGateSet;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/CircuitDefinition.js")).DetailedError;
  var equate_Maps = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Equate.js", "src/circuit/CircuitDefinition.js")).equate_Maps;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Gate.js", "src/circuit/CircuitDefinition.js")).Gate;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GateColumn.js", "src/circuit/CircuitDefinition.js")).GateColumn;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GateShaders.js", "src/circuit/CircuitDefinition.js")).GateShaders;
  var $__39 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/AllGates.js", "src/circuit/CircuitDefinition.js")),
      Gates = $__39.Gates,
      INITIAL_STATES_TO_GATES = $__39.INITIAL_STATES_TO_GATES;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/circuit/CircuitDefinition.js")).Point;
  var $__41 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/circuit/CircuitDefinition.js")),
      seq = $__41.seq,
      Seq = $__41.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/CircuitDefinition.js")).Util;
  var CircuitDefinition = function() {
    function CircuitDefinition(numWires, columns) {
      var $__18,
          $__19;
      var outerRowOffset = arguments[2] !== (void 0) ? arguments[2] : 0;
      var outerContext = arguments[3] !== (void 0) ? arguments[3] : new Map();
      var customGateSet = arguments[4] !== (void 0) ? arguments[4] : new CustomGateSet();
      var isNested = arguments[5] !== (void 0) ? arguments[5] : false;
      var customInitialValues = arguments[6] !== (void 0) ? arguments[6] : new Map();
      if (numWires < 0) {
        throw new DetailedError("Bad numWires", {numWires: numWires});
      }
      if (!Array.isArray(columns)) {
        throw new DetailedError("Bad columns", {
          numWires: numWires,
          columns: columns
        });
      }
      if (!columns.every(function(e) {
        return e instanceof GateColumn;
      })) {
        throw new DetailedError("Not a GateColumn", {columns: columns});
      }
      if (!columns.every(function(e) {
        return e.gates.length === numWires;
      })) {
        throw new DetailedError("Wrong gate count in a column", {
          numWires: numWires,
          columns: columns
        });
      }
      this.numWires = numWires;
      this.columns = columns;
      this.customGateSet = customGateSet;
      this.outerRowOffset = outerRowOffset;
      this.outerContext = outerContext;
      this.isNested = isNested;
      this.customInitialValues = new Map();
      var $__6 = true;
      var $__7 = false;
      var $__8 = undefined;
      try {
        for (var $__4 = void 0,
            $__3 = (customInitialValues.entries())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
          var $__17 = $__4.value,
              k = ($__18 = $__17[Symbol.iterator](), ($__19 = $__18.next()).done ? void 0 : $__19.value),
              v = ($__19 = $__18.next()).done ? void 0 : $__19.value;
          {
            if (!Number.isInteger(k) || k < 0) {
              throw new DetailedError('Initial state key out of range.', {
                customInitialValues: customInitialValues,
                numWires: numWires
              });
            }
            if (k >= this.numWires) {
              continue;
            }
            this.customInitialValues.set(k, v);
          }
        }
      } catch ($__9) {
        $__7 = true;
        $__8 = $__9;
      } finally {
        try {
          if (!$__6 && $__3.return != null) {
            $__3.return();
          }
        } finally {
          if ($__7) {
            throw $__8;
          }
        }
      }
      this._colRowDisabledReason = [];
      this._measureMasks = [0];
      var mask = 0;
      var prevStickyCtx = new Map();
      var $__13 = true;
      var $__14 = false;
      var $__15 = undefined;
      try {
        for (var $__11 = void 0,
            $__10 = (columns)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
          var col = $__11.value;
          {
            var $__20 = col.perRowDisabledReasons(mask, outerRowOffset, outerContext, prevStickyCtx, isNested),
                rowReasons = $__20.allReasons,
                stickyCtx = $__20.stickyCtx;
            mask = col.nextMeasureMask(mask, rowReasons);
            this._colRowDisabledReason.push(rowReasons);
            this._measureMasks.push(mask);
            prevStickyCtx = stickyCtx;
          }
        }
      } catch ($__16) {
        $__14 = true;
        $__15 = $__16;
      } finally {
        try {
          if (!$__13 && $__10.return != null) {
            $__10.return();
          }
        } finally {
          if ($__14) {
            throw $__15;
          }
        }
      }
      this._gateSlotCoverMap = this._computeGateSlotCoverMap();
      this._cachedColumnContexts = new Map();
    }
    return ($traceurRuntime.createClass)(CircuitDefinition, {
      gateWeight: function() {
        return seq(this.columns).flatMap(function(e) {
          return e.gates;
        }).filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.knownCircuit === undefined ? 1 : e.knownCircuit.gateWeight();
        }).sum();
      },
      hasControls: function() {
        return !this.columns.every(function(e) {
          return !e.hasControl(-1);
        });
      },
      withSwitchedInitialStateOn: function(wire) {
        var newStateIndex = arguments[1];
        var m = new Map($traceurRuntime.spread(this.customInitialValues.entries()));
        var v = m.get(wire);
        var cycle = $traceurRuntime.spread(INITIAL_STATES_TO_GATES.keys());
        var newVal = cycle[(cycle.indexOf(v) + 1) % cycle.length];
        if (newStateIndex !== undefined) {
          newVal = newStateIndex;
        }
        if (newVal === undefined || newVal === 0) {
          m.delete(wire);
        } else {
          m.set(wire, newVal);
        }
        return this.withInitialStates(m);
      },
      withInitialStates: function(map) {
        return new CircuitDefinition(this.numWires, this.columns, this.outerRowOffset, this.outerContext, this.customGateSet, this.isNested, map);
      },
      hasOnlyUnitaryGates: function() {
        return this.columns.every(function(e) {
          return e.indexOfNonUnitaryGate() === undefined;
        });
      },
      hasNonControlGates: function() {
        var colHasNonControl = function(col) {
          return !col.gates.every(function(e) {
            return e === undefined || e.isControl();
          });
        };
        return !this.columns.every(function(e) {
          return !colHasNonControl(e);
        });
      },
      countGatesUpTo: function(max) {
        var n = 0;
        var $__13 = true;
        var $__14 = false;
        var $__15 = undefined;
        try {
          for (var $__11 = void 0,
              $__10 = (this.columns)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
            var c = $__11.value;
            {
              var $__6 = true;
              var $__7 = false;
              var $__8 = undefined;
              try {
                for (var $__4 = void 0,
                    $__3 = (c.gates)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                  var g = $__4.value;
                  {
                    if (g !== undefined) {
                      n++;
                      if (n >= max) {
                        return n;
                      }
                    }
                  }
                }
              } catch ($__9) {
                $__7 = true;
                $__8 = $__9;
              } finally {
                try {
                  if (!$__6 && $__3.return != null) {
                    $__3.return();
                  }
                } finally {
                  if ($__7) {
                    throw $__8;
                  }
                }
              }
            }
          }
        } catch ($__16) {
          $__14 = true;
          $__15 = $__16;
        } finally {
          try {
            if (!$__13 && $__10.return != null) {
              $__10.return();
            }
          } finally {
            if ($__14) {
              throw $__15;
            }
          }
        }
        return n;
      },
      getUnmetContextKeys: function() {
        var result = new Set();
        for (var c = 0; c < this.columns.length; c++) {
          var col = this.columns[c];
          var ctx = this.colCustomContextFromGates(c, 0);
          var $__13 = true;
          var $__14 = false;
          var $__15 = undefined;
          try {
            for (var $__11 = void 0,
                $__10 = (col.gates)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
              var gate = $__11.value;
              {
                var $__6 = true;
                var $__7 = false;
                var $__8 = undefined;
                try {
                  for (var $__4 = void 0,
                      $__3 = (gate === undefined ? [] : gate.getUnmetContextKeys())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                    var key = $__4.value;
                    {
                      var altKey = key.replace('Input Range ', 'Input Default ').replace('Input NO_DEFAULT Range ', 'Input Range ');
                      if (!ctx.has(key) && !ctx.has(altKey)) {
                        result.add(key);
                      }
                    }
                  }
                } catch ($__9) {
                  $__7 = true;
                  $__8 = $__9;
                } finally {
                  try {
                    if (!$__6 && $__3.return != null) {
                      $__3.return();
                    }
                  } finally {
                    if ($__7) {
                      throw $__8;
                    }
                  }
                }
              }
            }
          } catch ($__16) {
            $__14 = true;
            $__15 = $__16;
          } finally {
            try {
              if (!$__13 && $__10.return != null) {
                $__10.return();
              }
            } finally {
              if ($__14) {
                throw $__15;
              }
            }
          }
        }
        return result;
      },
      withDisabledReasonsForEmbeddedContext: function(outerRowOffset, outerContext) {
        return new CircuitDefinition(this.numWires, this.columns, outerRowOffset, outerContext, this.customGateSet, true, this.customInitialValues);
      },
      _computeGateSlotCoverMap: function() {
        var result = new Map();
        for (var col = 0; col < this.columns.length; col++) {
          for (var row = 0; row < this.numWires; row++) {
            var gate = this.columns[col].gates[row];
            if (gate !== undefined) {
              for (var i = 0; i < gate.width; i++) {
                for (var j = 0; j < gate.height; j++) {
                  result.set((col + i) + ":" + (row + j), {
                    col: col,
                    row: row,
                    gate: gate
                  });
                }
              }
            }
          }
        }
        return result;
      },
      isEmpty: function() {
        return this.columns.length === 0;
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof CircuitDefinition && this.numWires === other.numWires && seq(this.columns).isEqualTo(seq(other.columns), Util.CUSTOM_IS_EQUAL_TO_EQUALITY) && equate_Maps(this.customInitialValues, other.customInitialValues);
      },
      toString: function() {
        var $__2 = this;
        var wire = function(n) {
          return "─".repeat(n);
        };
        var wireAround = function(n, s) {
          return wire(Math.floor(n - s.length) / 2) + s + wire(Math.ceil(n - s.length) / 2);
        };
        var colWidths = Seq.range(this.columns.length).map(function(c) {
          return seq($__2.columns[c].gates).map(function(e) {
            return e === undefined ? 0 : e.serializedId.length;
          }).max();
        }).toArray();
        return ("CircuitDefinition (" + this.numWires + " wires, " + this.columns.length + " cols):\n\t") + Seq.range(this.numWires).map(function(r) {
          return wire(1) + Seq.range($__2.columns.length).map(function(c) {
            var g = $__2.columns[c].gates[r];
            var label = g === undefined ? "" : g.serializedId;
            return wireAround(colWidths[c], label);
          }).join(wire(1)) + wire(1);
        }).join('\n\t');
      },
      stableDuration: function() {
        return seq(this.columns).flatMap(function(c) {
          return c.gates;
        }).filter(function(g) {
          return g !== undefined;
        }).map(function(g) {
          return g.stableDuration();
        }).min(Infinity);
      },
      readableHash: function() {
        var allGates = seq(this.columns).flatMap(function(e) {
          return e.gates;
        }).filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.symbol;
        }).toArray();
        if (allGates.length === 0) {
          return Config.EMPTY_CIRCUIT_TITLE;
        }
        var allGatesString = (this.numWires + " wires, " + allGates.length + " ops, " + allGates.join("").split("^").join(""));
        if (allGatesString.length <= 40) {
          return allGatesString;
        }
        return allGatesString.substring(0, 40) + "…";
      },
      withColumns: function(cols) {
        return new CircuitDefinition(this.numWires, cols, this.outerRowOffset, this.outerContext, this.customGateSet, false, this.customInitialValues);
      },
      _usedColumns: function() {
        var usedCols = new Set();
        for (var col = 0; col < this.columns.length; col++) {
          for (var i = 0; i < this.columns[col].maximumGateWidth(); i++) {
            usedCols.add(col + i);
          }
        }
        return usedCols;
      },
      _findWidthWiseOverlapInRect: function(col, row, width, height) {
        for (var i = 1; i < width && col + i < this.columns.length; i++) {
          for (var j = 0; j < height; j++) {
            var otherGate = this.findGateCoveringSlot(col + i, row + j);
            if (otherGate === undefined || otherGate.col === col) {
              continue;
            }
            return {
              col: otherGate.col,
              row: otherGate.row
            };
          }
        }
        return undefined;
      },
      withWidthOverlapsFixed: function() {
        var $__2 = this;
        var newCols = [];
        var $__23 = this,
            $__24 = function(col) {
              var paddingRequired = Seq.range($__23.numWires).map(function(row) {
                var gate = $__2.columns[col].gates[row];
                if (gate === undefined) {
                  return 0;
                }
                var f = $__2._findWidthWiseOverlapInRect(col, row, gate.width, gate.height);
                if (f === undefined) {
                  return 0;
                }
                return gate.width - (f.col - col);
              }).max(0);
              newCols.push($__23.columns[col]);
              for (var i = 0; i < paddingRequired; i++) {
                newCols.push(GateColumn.empty($__23.numWires));
              }
            };
        for (var col = 0; col < this.columns.length; col++) {
          $__24(col);
        }
        return this.withColumns(newCols);
      },
      _findHeightWiseOverlapsInCol: function(col) {
        var pushedGates = new Set();
        var h = 0;
        for (var row = 0; row < this.numWires; row++) {
          h -= 1;
          var gate = this.gateInSlot(col, row);
          if (gate !== undefined) {
            if (h > 0) {
              pushedGates.add(row);
            }
            h = Math.max(h, gate.height);
          }
        }
        return pushedGates;
      },
      withHeightOverlapsFixed: function() {
        var recurseLimit = arguments[0] !== (void 0) ? arguments[0] : 5;
        var newCols = [];
        var $__26 = this,
            $__27 = function(col) {
              var pushedGateIndexes = $__26._findHeightWiseOverlapsInCol(col);
              if (pushedGateIndexes.size === 0) {
                newCols.push($__26.columns[col]);
                return 0;
              }
              var keptGates = seq($__26.columns[col].gates).mapWithIndex(function(g, row) {
                return pushedGateIndexes.has(row) ? undefined : g;
              }).toArray();
              var pushedGates = seq($__26.columns[col].gates).mapWithIndex(function(g, row) {
                return g !== undefined && (g.isControl() || pushedGateIndexes.has(row)) ? g : undefined;
              }).toArray();
              newCols.push(new GateColumn(keptGates));
              newCols.push(new GateColumn(pushedGates));
            },
            $__28;
        $__25: for (var col = 0; col < this.columns.length; col++) {
          $__28 = $__27(col);
          switch ($__28) {
            case 0:
              continue $__25;
          }
        }
        var result = this.withColumns(newCols);
        if (newCols.length > this.columns.length && recurseLimit > 0) {
          result = result.withHeightOverlapsFixed(recurseLimit - 1);
        }
        return result;
      },
      withTrailingSpacersIncluded: function() {
        var extra = arguments[0] !== (void 0) ? arguments[0] : 0;
        return this.withColumns($traceurRuntime.spread(this.columns, new Array(Math.max(0, this.minimumRequiredColCount() + extra - this.columns.length)).fill(GateColumn.empty(this.numWires))));
      },
      trimEmptyColumnsAtEndIgnoringGateWidths: function() {
        for (var n = this.columns.length; ; n--) {
          if (n === 0 || !this.columns[n - 1].isEmpty()) {
            return this.withColumns(this.columns.slice(0, n));
          }
        }
      },
      withUncoveredColumnsRemoved: function() {
        var used = this._usedColumns();
        return new CircuitDefinition(this.numWires, seq(this.columns).filterWithIndex(function(e, i) {
          return used.has(i);
        }).toArray(), this.outerRowOffset, this.outerContext, this.customGateSet, false, this.customInitialValues);
      },
      withWireCount: function(newWireCount) {
        if (newWireCount === this.numWires) {
          return this;
        }
        return new CircuitDefinition(newWireCount, this.columns.map(function(c) {
          return new GateColumn($traceurRuntime.spread(c.gates.slice(0, newWireCount), new Array(Math.max(0, newWireCount - c.gates.length)).fill(undefined)));
        }), this.outerRowOffset, this.outerContext, this.customGateSet, false, this.customInitialValues);
      },
      minimumRequiredWireCount: function() {
        var best = 1;
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.columns)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var c = $__4.value;
            {
              best = Math.max(best, c.minimumRequiredWireCount());
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        var $__13 = true;
        var $__14 = false;
        var $__15 = undefined;
        try {
          for (var $__11 = void 0,
              $__10 = (this.customInitialValues.keys())[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
            var usedWire = $__11.value;
            {
              best = Math.max(best, usedWire + 1);
            }
          }
        } catch ($__16) {
          $__14 = true;
          $__15 = $__16;
        } finally {
          try {
            if (!$__13 && $__10.return != null) {
              $__10.return();
            }
          } finally {
            if ($__14) {
              throw $__15;
            }
          }
        }
        return best;
      },
      withMinimumWireCount: function() {
        return this.withWireCount(this.minimumRequiredWireCount());
      },
      minimumRequiredColCount: function() {
        var best = 0;
        for (var col = 0; col < this.columns.length; col++) {
          best = Math.max(best, this.columns[col].maximumGateWidth() + col);
        }
        return best;
      },
      colIsMeasuredMask: function(col) {
        if (col < 0) {
          return 0;
        }
        return this._measureMasks[Math.min(col, this.columns.length)];
      },
      colDesiredSingleQubitStatsMask: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return 0;
        }
        var c = this.columns[col];
        var total = 0;
        for (var row = 0; row < c.gates.length; row++) {
          if (c.gates[row] !== undefined && c.gates[row].isSingleQubitDisplay && this.gateAtLocIsDisabledReason(col, row) === undefined) {
            total |= 1 << row;
          }
        }
        return total;
      },
      colCustomContextFromGates: function(col, outerRowOffset) {
        if (col < 0 || col >= this.columns.length) {
          return new Map();
        }
        var key = "" + outerRowOffset;
        var result = this._cachedColumnContexts.get(key);
        if (result === undefined) {
          result = this._uncached_customContextFromGates(outerRowOffset);
          this._cachedColumnContexts.set(key, result);
        }
        return result[col];
      },
      _uncached_customContextFromGates: function(outerRowOffset) {
        var results = [];
        var stickyCtx = new Map();
        for (var col = 0; col < this.columns.length; col++) {
          var ctx = new Map(stickyCtx);
          var c = this.columns[col];
          for (var row = 0; row < c.gates.length; row++) {
            var g = c.gates[row];
            if (g === undefined || this.gateAtLocIsDisabledReason(col, row) !== undefined) {
              continue;
            }
            var $__6 = true;
            var $__7 = false;
            var $__8 = undefined;
            try {
              for (var $__4 = void 0,
                  $__3 = (g.customColumnContextProvider(outerRowOffset + row, g))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                var $__17 = $__4.value,
                    key = $__17.key,
                    val = $__17.val;
                {
                  ctx.set(key, val);
                  if (!g.isContextTemporary) {
                    stickyCtx.set(key, val);
                  }
                }
              }
            } catch ($__9) {
              $__7 = true;
              $__8 = $__9;
            } finally {
              try {
                if (!$__6 && $__3.return != null) {
                  $__3.return();
                }
              } finally {
                if ($__7) {
                  throw $__8;
                }
              }
            }
          }
          results.push(ctx);
        }
        return results;
      },
      locIsMeasured: function(pt) {
        var row = pt.y;
        if (row < 0 || row >= this.numWires) {
          return false;
        }
        return (this.colIsMeasuredMask(pt.x) & (1 << row)) !== 0;
      },
      locClassifyMeasuredIncludingGateExtension: function(pt) {
        var row = pt.y;
        if (row < 0 || row >= this.numWires) {
          return false;
        }
        var gate = this.columns[pt.x].gates[row];
        var h = gate === undefined ? 1 : gate.height;
        var r = (this.colIsMeasuredMask(pt.x) >> row) & ((1 << h) - 1);
        return r === 0 ? false : r === (1 << h) - 1 ? true : undefined;
      },
      gateInSlot: function(col, row) {
        if (col < 0 || col >= this.columns.length || row < 0 || row >= this.numWires) {
          return undefined;
        }
        var gate = this.columns[col].gates[row];
        return gate === undefined ? undefined : gate;
      },
      findGateCoveringSlot: function(col, row) {
        var key = col + ":" + row;
        if (!this._gateSlotCoverMap.has(key)) {
          return undefined;
        }
        return this._gateSlotCoverMap.get(key);
      },
      locIsControlWireStarter: function(pt) {
        var gate = this.gateInSlot(pt.x, pt.y);
        return gate !== undefined && gate.isControlWireSource;
      },
      locStartsSingleControlWire: function(pt) {
        return this.locIsControlWireStarter(pt) && this.locClassifyMeasuredIncludingGateExtension(pt) !== true && this.gateAtLocIsDisabledReason(pt.x, pt.y) === undefined;
      },
      locStartsDoubleControlWire: function(pt) {
        return this.locIsControlWireStarter(pt) && this.locClassifyMeasuredIncludingGateExtension(pt) !== false && this.gateAtLocIsDisabledReason(pt.x, pt.y) === undefined;
      },
      colGetEnabledSwapGate: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return undefined;
        }
        var locs = [];
        for (var row = 0; row < this.numWires; row++) {
          if (this.gateInSlot(col, row) === Gates.Special.SwapHalf) {
            if (this.gateAtLocIsDisabledReason(col, row) !== undefined) {
              return undefined;
            }
            locs.push(row);
          }
        }
        if (locs.length !== 2) {
          return undefined;
        }
        return locs;
      },
      locProvidesStat: function(pt, key) {
        var g = this.gateInSlot(pt.x, pt.y);
        return g !== undefined && !g.customColumnContextProvider(0, g).every(function(e) {
          return e.key !== key;
        });
      },
      locNeedsStat: function(pt, key) {
        var g = this.gateInSlot(pt.x, pt.y);
        return g !== undefined && g.getUnmetContextKeys().has(key);
      },
      locHasControllableGate: function(pt) {
        var g = this.gateInSlot(pt.x, pt.y);
        return g !== undefined && g.interestedInControls;
      },
      colHasControls: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return false;
        }
        return this.columns[col].hasControl();
      },
      colHasSingleWireControl: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return false;
        }
        return this.columns[col].hasCoherentControl(this._measureMasks[col]);
      },
      colHasDoubleWireControl: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return false;
        }
        return this.columns[col].hasMeasuredControl(this._measureMasks[col]);
      },
      colControls: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return Controls.NONE;
        }
        var column = this.columns[col];
        var includeMask = 0;
        var desireMask = 0;
        var parityMask = 0;
        for (var i = 0; i < column.gates.length; i++) {
          var gate = column.gates[i];
          if (gate !== undefined && this.gateAtLocIsDisabledReason(col, i) === undefined) {
            var bit = gate.controlBit();
            if (bit === 'parity') {
              parityMask |= 1 << i;
            } else if (bit !== undefined) {
              includeMask |= 1 << i;
              if (bit) {
                desireMask |= 1 << i;
              }
            }
          }
        }
        if (parityMask !== 0) {
          var parityBit = parityMask & ~(parityMask - 1);
          desireMask |= parityBit;
          includeMask |= parityBit;
        }
        return new Controls(includeMask, desireMask, parityMask);
      },
      gateAtLocIsDisabledReason: function(col, row) {
        if (col < 0 || row < 0 || col >= this._colRowDisabledReason.length || row >= this.numWires) {
          return undefined;
        }
        return this._colRowDisabledReason[col][row];
      },
      applyInitialStateOperations: function(ctx) {
        for (var wire = 0; wire < this.numWires; wire++) {
          var state = this.customInitialValues.get(wire);
          if (!INITIAL_STATES_TO_GATES.has(state)) {
            throw new DetailedError('Unrecognized initial state.', {state: state});
          }
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (INITIAL_STATES_TO_GATES.get(state))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var gate = $__4.value;
              {
                GateShaders.applyMatrixOperation(ctx.withRow(ctx.row + wire), gate.knownMatrixAt(ctx.time));
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
        }
      },
      applyMainOperationsInCol: function(colIndex, ctx) {
        var $__20,
            $__18;
        if (colIndex < 0 || colIndex >= this.columns.length) {
          return;
        }
        this._applyOpsInCol(colIndex, ctx, function(gate) {
          if (gate.definitelyHasNoEffect() || gate === Gates.Special.SwapHalf) {
            return undefined;
          }
          if (gate.customOperation !== undefined) {
            return gate.customOperation;
          }
          return function(ctx) {
            return GateShaders.applyMatrixOperation(ctx, gate.knownMatrixAt(ctx.time));
          };
        });
        var swapRows = this.colGetEnabledSwapGate(colIndex);
        if (swapRows !== undefined) {
          var $__17 = swapRows,
              i = ($__20 = $__17[Symbol.iterator](), ($__18 = $__20.next()).done ? void 0 : $__18.value),
              j = ($__18 = $__20.next()).done ? void 0 : $__18.value;
          ctx.applyOperation(CircuitShaders.swap(ctx.withRow(i + ctx.row), j + ctx.row));
        }
      },
      applyBeforeOperationsInCol: function(colIndex, ctx) {
        this._applyOpsInCol(colIndex, ctx, function(g) {
          return g.customBeforeOperation;
        });
      },
      applyAfterOperationsInCol: function(colIndex, ctx) {
        this._applyOpsInCol(colIndex, ctx, function(g) {
          return g.customAfterOperation;
        });
      },
      _applyOpsInCol: function(colIndex, ctx, opGetter) {
        if (colIndex < 0 || colIndex >= this.columns.length) {
          return;
        }
        var col = this.columns[colIndex];
        for (var row = 0; row < this.numWires; row++) {
          var gate = col.gates[row];
          if (gate === undefined || this.gateAtLocIsDisabledReason(colIndex, row) !== undefined) {
            continue;
          }
          var op = opGetter(gate);
          if (op !== undefined) {
            op(ctx.withRow(ctx.row + row));
          }
        }
      },
      customStatRowsInCol: function(colIndex) {
        if (colIndex < 0 || colIndex >= this.columns.length) {
          return [];
        }
        var col = this.columns[colIndex];
        var result = [];
        for (var row = 0; row < col.gates.length; row++) {
          if (col.gates[row] !== undefined && col.gates[row].customStatTexturesMaker !== undefined && this.gateAtLocIsDisabledReason(colIndex, row) === undefined) {
            result.push(row);
          }
        }
        return result;
      },
      isSlotRectCoveredByGateInSameColumn: function(col, row, height) {
        for (var j = 0; j < height; j++) {
          var f = this.findGateCoveringSlot(col, row + j);
          if (f !== undefined && f.col === col) {
            return true;
          }
        }
        return false;
      },
      withCustomGate: function(gate) {
        return new CircuitDefinition(this.numWires, this.columns, this.outerRowOffset, this.outerContext, this.customGateSet.withGate(gate), false, this.customInitialValues);
      },
      controlLinesRanges: function(columnIndex) {
        var $__2 = this;
        var col = this.columns[columnIndex];
        var n = col.gates.length;
        var swapRows = this.colGetEnabledSwapGate(columnIndex);
        var pt = function(i) {
          return new Point(columnIndex, i);
        };
        var hasControllable = function(i) {
          return $__2.locHasControllableGate(pt(i));
        };
        var hasCoherentControl = function(i) {
          return $__2.locStartsSingleControlWire(pt(i));
        };
        var hasMeasuredControl = function(i) {
          return $__2.locStartsDoubleControlWire(pt(i));
        };
        var hasSwap = function(i) {
          return swapRows !== undefined && swapRows.indexOf(i) !== -1;
        };
        var coversCoherentWire = function(i) {
          return $__2.locClassifyMeasuredIncludingGateExtension(pt(i)) !== true;
        };
        var coversMeasuredWire = function(i) {
          return $__2.locClassifyMeasuredIncludingGateExtension(pt(i)) !== false;
        };
        var result = [srcDstMatchInRange(n, hasSwap, hasSwap, false), srcDstMatchInRange(n, hasControllable, hasCoherentControl, false), srcDstMatchInRange(n, hasControllable, hasMeasuredControl, true)];
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          var $__29 = function() {
            var letter = $__4.value;
            {
              var key = ("Input Range " + letter);
              var altInKey = ("Input Default " + letter);
              var altOutKey = ("Input NO_DEFAULT Range " + letter);
              var isInput = function(i) {
                return $__2.locProvidesStat(pt(i), key) || $__2.locProvidesStat(pt(i), altInKey);
              };
              var isOutput = function(i) {
                return $__2.locNeedsStat(pt(i), key) || $__2.locNeedsStat(pt(i), altOutKey);
              };
              result.push(srcDstMatchInRange(n, function(i) {
                return isInput(i) && coversCoherentWire(i);
              }, isOutput, false), srcDstMatchInRange(n, function(i) {
                return isInput(i) && coversMeasuredWire(i);
              }, isOutput, true));
            }
          };
          for (var $__4 = void 0,
              $__3 = (Gates.InputGates.Letters)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            $__29();
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return result.filter(function(e) {
          return e !== undefined;
        });
      }
    }, {fromTextDiagram: function(gateMap, diagram) {
        var lines = seq(diagram.split('\n')).map(function(e) {
          return e.trim();
        }).filter(function(e) {
          return e !== '';
        }).toArray();
        if (seq(lines.map(function(e) {
          return e.length;
        })).distinct().count() > 1) {
          throw new DetailedError("Uneven diagram", {diagram: diagram});
        }
        var rowCount = lines.length;
        var colCount = lines.length > 0 ? lines[0].length : 0;
        var spanAt = function(col, row) {
          for (var d = 1; row + d < lines.length; d++) {
            if (gateMap.get(lines[row + d][col]) !== null) {
              return d;
            }
          }
          return lines.length - row;
        };
        return new CircuitDefinition(rowCount, Seq.range(colCount).map(function(col) {
          return new GateColumn(seq(lines).mapWithIndex(function(line, row) {
            var char = line[col];
            if (!gateMap.has(char)) {
              throw new DetailedError("Unspecified gate", {char: char});
            }
            var gateOrFamily = gateMap.get(char);
            if (gateOrFamily === null || gateOrFamily === undefined) {
              return undefined;
            }
            if (gateOrFamily.hasOwnProperty('ofSize')) {
              return gateOrFamily.ofSize(spanAt(col, row));
            }
            if (gateOrFamily instanceof Gate) {
              return gateOrFamily;
            }
            throw new DetailedError("Not a gate", gateOrFamily);
          }).toArray());
        }).toArray());
      }});
  }();
  function srcDstMatchInRange(rangeLen, srcPredicate, dstPredicate, measured) {
    var $__20,
        $__18,
        $__21,
        $__22;
    var $__17 = firstLastMatchInRange(rangeLen, srcPredicate),
        src1 = ($__20 = $__17[Symbol.iterator](), ($__18 = $__20.next()).done ? void 0 : $__18.value),
        src2 = ($__18 = $__20.next()).done ? void 0 : $__18.value;
    var $__19 = firstLastMatchInRange(rangeLen, dstPredicate),
        dst1 = ($__21 = $__19[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
        dst2 = ($__22 = $__21.next()).done ? void 0 : $__22.value;
    if (dst1 === undefined || src1 === undefined) {
      return undefined;
    }
    return {
      first: Math.min(src1, dst1),
      last: Math.max(src2, dst2),
      measured: measured
    };
  }
  function firstLastMatchInRange(rangeLen, predicate) {
    var first = undefined;
    var last = undefined;
    for (var i = 0; i < rangeLen; i++) {
      if (predicate(i)) {
        if (first === undefined) {
          first = i;
        }
        last = i;
      }
    }
    return [first, last];
  }
  CircuitDefinition.EMPTY = new CircuitDefinition(0, []);
  return {get CircuitDefinition() {
      return CircuitDefinition;
    }};
});
//# sourceURL=src/circuit/CircuitDefinition.js
;$traceurRuntime.registerModule("src/circuit/CircuitEvalContext.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitEvalContext.js";
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/circuit/CircuitEvalContext.js")).WglConfiguredShader;
  var CircuitEvalContext = function() {
    function CircuitEvalContext(time, qubitRow, wireCount, controls, controlsTexture, rawControls, stateTrader, customContextFromGates) {
      this.time = time;
      this.row = qubitRow;
      this.wireCount = wireCount;
      this.controls = controls;
      this.rawControls = rawControls;
      this.controlsTexture = controlsTexture;
      this.stateTrader = stateTrader;
      this.customContextFromGates = customContextFromGates;
    }
    return ($traceurRuntime.createClass)(CircuitEvalContext, {
      applyOperation: function(operation) {
        var configuredShader = operation instanceof WglConfiguredShader ? operation : operation(this);
        this.stateTrader.shadeAndTrade(configuredShader);
      },
      _clone: function() {
        return new CircuitEvalContext(this.time, this.row, this.wireCount, this.controls, this.controlsTexture, this.rawControls, this.stateTrader, this.customContextFromGates);
      },
      withRow: function(row) {
        var r = this._clone();
        r.row = row;
        return r;
      },
      withInputSetToRange: function(letter, offset, length) {
        var r = this._clone();
        r.customContextFromGates = new Map(r.customContextFromGates);
        r.customContextFromGates.set(("Input Range " + letter), {
          offset: offset,
          length: length
        });
        return r;
      },
      withInputSetToConstant: function(letter, value) {
        var r = this._clone();
        r.customContextFromGates = new Map(r.customContextFromGates);
        r.customContextFromGates.delete(("Input Range " + letter));
        r.customContextFromGates.set(("Input Default " + letter), value);
        return r;
      },
      withInputSetToOtherInput: function(letter, other) {
        var r = this._clone();
        r.customContextFromGates = new Map(r.customContextFromGates);
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (['Range', 'Default'])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              var otherVal = r.customContextFromGates.get(("Input " + key + " " + other));
              if (otherVal !== undefined) {
                r.customContextFromGates.set(("Input " + key + " " + letter), otherVal);
              } else {
                r.customContextFromGates.delete(("Input " + key + " " + letter));
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return r;
      }
    }, {});
  }();
  return {get CircuitEvalContext() {
      return CircuitEvalContext;
    }};
});
//# sourceURL=src/circuit/CircuitEvalContext.js
;$traceurRuntime.registerModule("src/circuit/CircuitShaders.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitShaders.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/circuit/CircuitShaders.js")).Config;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Controls.js", "src/circuit/CircuitShaders.js")).Controls;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./KetShaderUtil.js", "src/circuit/CircuitShaders.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/circuit/CircuitShaders.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/CircuitShaders.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/circuit/CircuitShaders.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/circuit/CircuitShaders.js")).WglConfiguredShader;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/circuit/CircuitShaders.js")),
      currentShaderCoder = $__9.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__9.makePseudoShaderWithInputsAndOutputAndCode,
      Inputs = $__9.Inputs,
      Outputs = $__9.Outputs;
  var CircuitShaders = function() {
    function CircuitShaders() {}
    return ($traceurRuntime.createClass)(CircuitShaders, {}, {});
  }();
  CircuitShaders.classicalState = function(stateBitMask) {
    return SET_SINGLE_PIXEL_SHADER(WglArg.float("state", stateBitMask));
  };
  var SET_SINGLE_PIXEL_SHADER = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec2(), "\n    uniform float state;\n    vec2 outputFor(float k) {\n        return vec2(float(k == state), 0.0);\n    }");
  CircuitShaders.linearOverlay = function(offset, foregroundTexture, backgroundTexture) {
    return LINEAR_OVERLAY_SHADER(backgroundTexture, foregroundTexture, WglArg.float("offset", offset));
  };
  var LINEAR_OVERLAY_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('back'), Inputs.vec4('fore')], Outputs.vec4(), "\n    uniform float offset;\n    vec4 outputFor(float k) {\n        // Note: can't use multiplication to combine because it spreads NaNs from the background into the foreground.\n        return k >= offset && k < offset + len_fore() ? read_fore(k - offset) : read_back(k);\n    }");
  CircuitShaders.controlMask = function(controlMask) {
    if (controlMask.isEqualTo(Controls.NONE)) {
      return Shaders.color(1, 0, 0, 0);
    }
    return CONTROL_MASK_SHADER(WglArg.float('used', controlMask.inclusionMask), WglArg.float('desired', controlMask.desiredValueMask));
  };
  var CONTROL_MASK_SHADER = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.bool(), ("\n    uniform float used;\n    uniform float desired;\n\n    bool outputFor(float k) {\n        float pass = 1.0;\n        float bit = 1.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float v = mod(floor(k/bit), 2.0);\n            float u = mod(floor(used/bit), 2.0);\n            float d = mod(floor(desired/bit), 2.0);\n            pass *= 1.0 - abs(v-d)*u;\n            bit *= 2.0;\n        }\n        return pass == 1.0;\n    }"));
  CircuitShaders.controlSelect = function(controlMask, dataTexture) {
    if (controlMask.isEqualTo(Controls.NONE)) {
      return Shaders.passthrough(dataTexture);
    }
    return CONTROL_SELECT_SHADER(dataTexture, WglArg.float('used', controlMask.inclusionMask), WglArg.float('desired', controlMask.desiredValueMask));
  };
  var CONTROL_SELECT_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), ("\n    uniform float used;\n    uniform float desired;\n\n    /**\n     * Inserts bits from the given value into the holes between used bits in the desired mask.\n     */\n    float scatter(float k) {\n        float maskPos = 1.0;\n        float coordPos = 1.0;\n        float result = 0.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float v = mod(floor(k/coordPos), 2.0);\n            float u = mod(floor(used/maskPos), 2.0);\n            float d = mod(floor(desired/maskPos), 2.0);\n            result += (v + u*(d-v)) * maskPos;\n            coordPos *= 2.0-u;\n            maskPos *= 2.0;\n        }\n        return result;\n    }\n\n    vec2 outputFor(float k) {\n        return read_input(scatter(k));\n    }"));
  CircuitShaders.swap = function(ctx, otherRow) {
    var $__1;
    return ($__1 = SWAP_QUBITS_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, otherRow - ctx.row + 1)));
  };
  var SWAP_QUBITS_SHADER = ketShaderPermute('', "\n    float low_bit = mod(out_id, 2.0);\n    float mid_bits = floor(mod(out_id, span*0.5)*0.5);\n    float high_bit = floor(out_id*2.0/span);\n    return high_bit + mid_bits*2.0 + low_bit*span*0.5;");
  CircuitShaders.qubitDensities = function(inputTexture) {
    var keptBitMask = arguments[1];
    if (keptBitMask === undefined) {
      keptBitMask = (1 << currentShaderCoder().vec2.arrayPowerSizeOfTexture(inputTexture)) - 1;
    }
    var keptCount = Util.ceilingPowerOf2(Util.numberOfSetBits(keptBitMask));
    return QUBIT_DENSITIES_SHADER(inputTexture, WglArg.float('keptCount', keptCount), WglArg.float('keptBitMask', keptBitMask));
  };
  var QUBIT_DENSITIES_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec4(), ("\n    uniform float keptCount;\n    uniform float keptBitMask;\n\n    float scatter(float val, float used) {\n        float result = 0.0;\n        float posUsed = 1.0;\n        float posVal = 1.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float u = mod(floor(used/posUsed), 2.0);\n            float v = mod(floor(val/posVal), 2.0);\n            result += u * v * posUsed;\n            posVal *= 1.0+u;\n            posUsed *= 2.0;\n        }\n        return result;\n    }\n\n    vec4 outputFor(float k) {\n        float bitIndex = mod(k, keptCount);\n        float otherBits = floor(k / keptCount);\n        float bit = scatter(exp2(bitIndex), keptBitMask);\n\n        // Indices of the two complex values making up the current conditional ket.\n        float srcIndex0 = mod(otherBits, bit) + floor(otherBits / bit) * bit * 2.0;\n        float srcIndex1 = srcIndex0 + bit;\n\n        // Grab the two complex values.\n        vec2 w1 = read_input(srcIndex0);\n        vec2 w2 = read_input(srcIndex1);\n\n        // Compute density matrix components.\n        float a = dot(w1, w1);\n        float br = dot(w1, w2);\n        float bi = dot(vec2(-w1.y, w1.x), w2);\n        float d = dot(w2, w2);\n\n        return vec4(a, br, bi, d);\n    }"));
  return {get CircuitShaders() {
      return CircuitShaders;
    }};
});
//# sourceURL=src/circuit/CircuitShaders.js
;$traceurRuntime.registerModule("src/circuit/CircuitStats.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitStats.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitDefinition.js", "src/circuit/CircuitStats.js")).CircuitDefinition;
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitEvalContext.js", "src/circuit/CircuitStats.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitShaders.js", "src/circuit/CircuitStats.js")).CircuitShaders;
  var KetTextureUtil = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./KetTextureUtil.js", "src/circuit/CircuitStats.js")).KetTextureUtil;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Controls.js", "src/circuit/CircuitStats.js")).Controls;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/CircuitStats.js")).DetailedError;
  var $__21 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/circuit/CircuitStats.js")),
      Matrix = $__21.Matrix,
      complexVectorToReadableJson = $__21.complexVectorToReadableJson;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/circuit/CircuitStats.js")).Shaders;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Serializer.js", "src/circuit/CircuitStats.js")).Serializer;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/CircuitStats.js")).Util;
  var notifyAboutRecoveryFromUnexpectedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../fallback.js", "src/circuit/CircuitStats.js")).notifyAboutRecoveryFromUnexpectedError;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitComputeUtil.js", "src/circuit/CircuitStats.js")).advanceStateWithCircuit;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/circuit/CircuitStats.js")).currentShaderCoder;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTextureTrader.js", "src/circuit/CircuitStats.js")).WglTextureTrader;
  var CircuitStats = function() {
    function CircuitStats(circuitDefinition, time, survivalRates, singleQubitDensities, finalState, customStatsProcessed) {
      this.circuitDefinition = circuitDefinition;
      this.time = time;
      this._survivalRates = survivalRates;
      this._qubitDensities = singleQubitDensities;
      this.finalState = finalState;
      this._customStatsProcessed = customStatsProcessed;
    }
    return ($traceurRuntime.createClass)(CircuitStats, {
      qubitDensityMatrix: function(colIndex, wireIndex) {
        if (wireIndex < 0) {
          throw new DetailedError("Bad wireIndex", {
            wireIndex: wireIndex,
            colIndex: colIndex
          });
        }
        if (colIndex < 0 || wireIndex >= this.circuitDefinition.numWires) {
          if (wireIndex >= this.circuitDefinition.numWires && this.qubitDensityMatrix(colIndex, 0).hasNaN()) {
            return Matrix.zero(2, 2).times(NaN);
          }
          var buf = new Float32Array(8);
          buf[0] = 1;
          return new Matrix(2, 2, buf);
        }
        var col = Math.min(colIndex, this._qubitDensities.length - 1);
        if (col < 0 || wireIndex >= this._qubitDensities[col].length) {
          return Matrix.zero(2, 2).times(NaN);
        }
        return this._qubitDensities[col][wireIndex];
      },
      toReadableJson: function() {
        var includeOutputAmplitudes = arguments[0] !== (void 0) ? arguments[0] : true;
        var result = {
          time_parameter: this.time,
          circuit: Serializer.toJson(this.circuitDefinition),
          chance_of_surviving_to_each_column: this._survivalRates,
          computed_bloch_vectors_by_column_then_wire: this._qubitDensities.map(function(col) {
            return col.map(singleQubitDensityMatrixToReadableJson);
          }),
          displays: this._customStatsToReadableJson()
        };
        if (includeOutputAmplitudes) {
          result['output_amplitudes'] = complexVectorToReadableJson(this.finalState.getColumn(0));
        }
        return result;
      },
      _customStatsToReadableJson: function() {
        var $__10,
            $__11,
            $__13,
            $__14;
        var result = [];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (this._customStatsProcessed.entries())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                key = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
                data = ($__11 = $__10.next()).done ? void 0 : $__11.value;
            {
              var $__12 = key.split(':'),
                  col = ($__13 = $__12[Symbol.iterator](), ($__14 = $__13.next()).done ? void 0 : $__14.value),
                  row = ($__14 = $__13.next()).done ? void 0 : $__14.value;
              row = parseInt(row);
              col = parseInt(col);
              var gate = this.circuitDefinition.columns[col].gates[row];
              if (gate.processedStatsToJsonFunc !== undefined) {
                data = gate.processedStatsToJsonFunc(data);
              }
              result.push({
                location: {
                  wire: row,
                  column: col
                },
                type: {
                  serialized_id: gate.serializedId,
                  name: gate.name
                },
                data: data
              });
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return result;
      },
      survivalRate: function(colIndex) {
        colIndex = Math.min(colIndex, this._survivalRates.length - 1);
        return colIndex < 0 ? 1 : this._survivalRates[colIndex];
      },
      customStatsForSlot: function(col, row) {
        var key = col + ":" + row;
        return this._customStatsProcessed.has(key) ? this._customStatsProcessed.get(key) : undefined;
      },
      controlledWireProbabilityJustAfter: function(wireIndex, colIndex) {
        return this.qubitDensityMatrix(colIndex, wireIndex).rawBuffer()[6];
      },
      withTime: function(time) {
        return new CircuitStats(this.circuitDefinition, time, this._survivalRates, this._qubitDensities, this.finalState, this._customStatsProcessed);
      }
    }, {
      withNanDataFromCircuitAtTime: function(circuitDefinition, time) {
        return new CircuitStats(circuitDefinition, time, [1], [], Matrix.zero(1, 1 << circuitDefinition.numWires).times(NaN), new Map());
      },
      fromCircuitAtTime: function(circuitDefinition, time) {
        try {
          return CircuitStats._fromCircuitAtTime_noFallback(circuitDefinition, time);
        } catch (ex) {
          notifyAboutRecoveryFromUnexpectedError("Defaulted to NaN results. Computing circuit values failed.", {circuitDefinition: Serializer.toJson(circuitDefinition)}, ex);
          return CircuitStats.withNanDataFromCircuitAtTime(circuitDefinition, time);
        }
      },
      decohereMeasuredBitsInDensityMatrix: function(densityMatrix, isMeasuredMask) {
        if (isMeasuredMask === 0) {
          return densityMatrix;
        }
        var buf = new Float32Array(densityMatrix.rawBuffer());
        var n = densityMatrix.width();
        for (var row = 0; row < n; row++) {
          for (var col = 0; col < n; col++) {
            if (((row ^ col) & isMeasuredMask) !== 0) {
              var k = (row * n + col) * 2;
              buf[k] = 0;
              buf[k + 1] = 0;
            }
          }
        }
        return new Matrix(n, n, buf);
      },
      scatterAndDecohereDensities: function(rawMatrices, numWires, qubitSpan, isMeasuredMask, hasDisplayMask) {
        var nanMatrix = Matrix.zero(1 << qubitSpan, 1 << qubitSpan).times(NaN);
        var used = 0;
        var result = [];
        for (var row = 0; row < numWires - qubitSpan + 1; row++) {
          if ((hasDisplayMask & (1 << row)) === 0) {
            result.push(nanMatrix);
          } else {
            result.push(CircuitStats.decohereMeasuredBitsInDensityMatrix(rawMatrices[used++], (isMeasuredMask >> row) & ((1 << qubitSpan) - 1)));
          }
        }
        return result;
      },
      _extractColumnQubitStatsFromPixelDatas: function(circuitDefinition, colQubitDensitiesPixelData) {
        var qubitDensityGrid = [];
        for (var col = 0; col < colQubitDensitiesPixelData.length; col++) {
          var dataHasStatsMask = col === circuitDefinition.columns.length ? -1 : circuitDefinition.colDesiredSingleQubitStatsMask(col);
          qubitDensityGrid.push(CircuitStats.scatterAndDecohereDensities(KetTextureUtil.pixelsToQubitDensityMatrices(colQubitDensitiesPixelData[col]), circuitDefinition.numWires, 1, circuitDefinition.colIsMeasuredMask(col), dataHasStatsMask));
        }
        return qubitDensityGrid;
      },
      _extractColumnSurvivalRateStatsFromPixelDatas: function(normsPixelData) {
        var curSurvivalRate = 1;
        var survivalRates = [];
        for (var col = 0; col < normsPixelData.length; col++) {
          if (normsPixelData[col].length > 0) {
            curSurvivalRate = normsPixelData[col][0];
          }
          survivalRates.push(curSurvivalRate);
        }
        return survivalRates;
      },
      _fromCircuitAtTime_noFallback: function(circuitDefinition, time) {
        circuitDefinition = circuitDefinition.withMinimumWireCount();
        var numWires = circuitDefinition.numWires;
        var stateTrader = new WglTextureTrader(CircuitShaders.classicalState(0).toVec2Texture(numWires));
        var controlTex = CircuitShaders.controlMask(Controls.NONE).toBoolTexture(numWires);
        var $__9 = advanceStateWithCircuit(new CircuitEvalContext(time, 0, numWires, Controls.NONE, controlTex, Controls.NONE, stateTrader, new Map()), circuitDefinition, true),
            colQubitDensities = $__9.colQubitDensities,
            colNorms = $__9.colNorms,
            customStats = $__9.customStats,
            customStatsMap = $__9.customStatsMap;
        controlTex.deallocByDepositingInPool("controlTex in _fromCircuitAtTime_noFallback");
        if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
          stateTrader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
        }
        var pixelData = Util.objectifyArrayFunc(KetTextureUtil.mergedReadFloats)({
          output: stateTrader.currentTexture,
          colQubitDensities: colQubitDensities,
          colNorms: colNorms,
          customStats: customStats
        });
        var qubitDensities = CircuitStats._extractColumnQubitStatsFromPixelDatas(circuitDefinition, pixelData.colQubitDensities);
        var survivalRates = CircuitStats._extractColumnSurvivalRateStatsFromPixelDatas(pixelData.colNorms);
        var outputSuperposition = KetTextureUtil.pixelsToAmplitudes(pixelData.output, survivalRates.length === 0 ? 1 : survivalRates[survivalRates.length - 1]);
        var customStatsProcessed = new Map();
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (customStatsMap)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__12 = $__3.value,
                col = $__12.col,
                row = $__12.row,
                out = $__12.out;
            {
              var func = circuitDefinition.gateInSlot(col, row).customStatPostProcesser || (function(e) {
                return e;
              });
              customStatsProcessed.set(col + ":" + row, func(pixelData.customStats[out], circuitDefinition, col, row));
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return new CircuitStats(circuitDefinition, time, survivalRates, qubitDensities, outputSuperposition, customStatsProcessed);
      }
    });
  }();
  function singleQubitDensityMatrixToReadableJson(matrix) {
    var $__12,
        $__10;
    if (matrix.hasNaN()) {
      return null;
    }
    var $__9 = matrix.qubitDensityMatrixToBlochVector(),
        x = ($__12 = $__9[Symbol.iterator](), ($__10 = $__12.next()).done ? void 0 : $__10.value),
        y = ($__10 = $__12.next()).done ? void 0 : $__10.value,
        z = ($__10 = $__12.next()).done ? void 0 : $__10.value;
    x *= -1;
    z *= -1;
    return {
      x: x,
      y: y,
      z: z
    };
  }
  CircuitStats.EMPTY = CircuitStats.withNanDataFromCircuitAtTime(CircuitDefinition.EMPTY, 0);
  return {get CircuitStats() {
      return CircuitStats;
    }};
});
//# sourceURL=src/circuit/CircuitStats.js
;$traceurRuntime.registerModule("src/circuit/Controls.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/Controls.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/Controls.js")).DetailedError;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/circuit/Controls.js")).Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/Controls.js")).Util;
  var Controls = function() {
    function Controls(inclusionMask, desiredValueMask) {
      var parityMask = arguments[2] !== (void 0) ? arguments[2] : 0;
      if ((desiredValueMask & ~inclusionMask) !== 0) {
        throw new DetailedError("Desired un-included bits", {
          inclusionMask: inclusionMask,
          desiredValueMask: desiredValueMask
        });
      }
      if (parityMask !== 0 && Util.popcnt(inclusionMask & parityMask) !== 1) {
        throw new DetailedError("Exactly one parity bit must be in the inclusion mask", {
          inclusionMask: inclusionMask,
          parityMask: parityMask
        });
      }
      this.inclusionMask = inclusionMask;
      this.desiredValueMask = desiredValueMask;
      this.parityMask = parityMask;
    }
    return ($traceurRuntime.createClass)(Controls, {
      isEqualTo: function(other) {
        return other instanceof Controls && this.inclusionMask === other.inclusionMask && this.desiredValueMask === other.desiredValueMask && this.parityMask === other.parityMask;
      },
      toString: function() {
        var $__2 = this;
        if (this.inclusionMask === 0) {
          return "No Controls";
        }
        var range = Seq.naturals().takeWhile(function(i) {
          return (1 << i) <= ($__2.inclusionMask | $__2.parityMask);
        });
        var result = "Controls: ...__" + range.map(function(e) {
          return $__2.desiredValueFor(e);
        }).map(function(e) {
          return e === undefined ? "_" : e ? "1" : "0";
        }).reverse().join("");
        if (this.parityMask !== 0) {
          result += "\n  parity: ...__" + range.map(function(e) {
            return $__2.parityMask & (1 << e);
          }).map(function(e) {
            return e ? "1" : "_";
          }).reverse().join("");
        }
        return result;
      },
      allowsState: function(stateIndex) {
        return (this.inclusionMask & stateIndex) === this.desiredValueMask;
      },
      desiredValueFor: function(bitIndex) {
        if ((this.inclusionMask & (1 << bitIndex)) === 0) {
          return undefined;
        }
        return (this.desiredValueMask & (1 << bitIndex)) !== 0;
      },
      includedBitCount: function() {
        if (this.inclusionMask < 0) {
          return Infinity;
        }
        return Util.numberOfSetBits(this.inclusionMask);
      },
      and: function(other) {
        if ((other.desiredValueMask & this.inclusionMask) !== (this.desiredValueMask & other.inclusionMask)) {
          throw new DetailedError("Contradictory controls.", {
            "this": this,
            other: other
          });
        }
        if ((other.parityMask & this.inclusionMask) !== 0 || (this.parityMask & other.inclusionMask) !== 0) {
          throw new DetailedError("Can't intersect parity controls.", {
            "this": this,
            other: other
          });
        }
        return new Controls(this.inclusionMask | other.inclusionMask, this.desiredValueMask | other.desiredValueMask, this.parityMask | other.parityMask);
      },
      shift: function(offset) {
        return new Controls(this.inclusionMask << offset, this.desiredValueMask << offset, this.parityMask << offset);
      }
    }, {bit: function(bitIndex, desiredValue) {
        if (bitIndex < 0) {
          throw new DetailedError("Out of range", {bitIndex: bitIndex});
        }
        return new Controls(1 << bitIndex, desiredValue ? (1 << bitIndex) : 0);
      }});
  }();
  Controls.NONE = new Controls(0, 0);
  return {get Controls() {
      return Controls;
    }};
});
//# sourceURL=src/circuit/Controls.js
;$traceurRuntime.registerModule("src/circuit/CustomGateSet.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CustomGateSet.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/CustomGateSet.js")).DetailedError;
  var CustomGateSet = function() {
    function CustomGateSet() {
      for (var gates = [],
          $__9 = 0; $__9 < arguments.length; $__9++)
        gates[$__9] = arguments[$__9];
      this.gates = gates;
    }
    return ($traceurRuntime.createClass)(CustomGateSet, {
      withGate: function(gate) {
        if (!gate.serializedId.startsWith("~")) {
          throw new DetailedError("Custom gates' serialized id must start with '~'.", {
            id: gate.serializedId,
            gate: gate
          });
        }
        if (this.findGateWithSerializedId(gate.serializedId)) {
          throw new DetailedError("Duplicate serialized id.", {gate: gate});
        }
        return new (Function.prototype.bind.apply(CustomGateSet, $traceurRuntime.spread([null], this.gates, [gate])))();
      },
      findGateWithSerializedId: function(id) {
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (this.gates)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var g = $__3.value;
            {
              if (g.serializedId === id) {
                return g;
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return undefined;
      }
    }, {});
  }();
  return {get CustomGateSet() {
      return CustomGateSet;
    }};
});
//# sourceURL=src/circuit/CustomGateSet.js
;$traceurRuntime.registerModule("src/circuit/Gate.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/Gate.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/Gate.js")).DetailedError;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GateDrawParams.js", "src/circuit/Gate.js")).GateDrawParams;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/circuit/Gate.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/circuit/Gate.js")).Matrix;
  var Gate = function() {
    function Gate() {
      this.symbol = '';
      this.serializedId = '';
      this.name = '';
      this.blurb = '';
      this.width = 1;
      this.height = 1;
      this.param = undefined;
      this._withParamRecomputeFunc = function(g) {};
      this.customDrawer = undefined;
      this.onClickGateFunc = undefined;
      this.tag = undefined;
      this.customBeforeOperation = undefined;
      this.customOperation = undefined;
      this.customAfterOperation = undefined;
      this.customStatTexturesMaker = undefined;
      this.customStatPostProcesser = undefined;
      this.processedStatsToJsonFunc = undefined;
      this.gateFamily = [this];
      this.interestedInControls = true;
      this._stableDuration = undefined;
      this._knownMatrix = undefined;
      this._knownMatrixFunc = undefined;
      this._hasNoEffect = false;
      this._effectPermutesStates = undefined;
      this._effectCreatesSuperpositions = undefined;
      this.isControlWireSource = false;
      this.knownCircuit = undefined;
      this.knownCircuitNested = undefined;
      this._requiredContextKeys = [];
      this.isSingleQubitDisplay = false;
      this._controlBit = undefined;
      this._isClassicalControl = false;
      this._isDefinitelyUnitary = false;
      this.alternate = this;
      this.customColumnContextProvider = function(qubit, gate) {
        return [];
      };
      this.isContextTemporary = true;
      this.customDisableReasonFinder = function(args) {
        return undefined;
      };
      this.knownBitPermutationFunc = undefined;
      this.knownBitPermutationGroupMasks = undefined;
      this.knownPhaseTurnsFunc = undefined;
      this.knownPermutationFuncTakingInputs = undefined;
      this._showAsReachesOtherWires = false;
    }
    return ($traceurRuntime.createClass)(Gate, {
      _copy: function() {
        var g = new Gate();
        g.symbol = this.symbol;
        g.name = this.name;
        g.blurb = this.blurb;
        g.alternate = this.alternate;
        g.serializedId = this.serializedId;
        g.onClickGateFunc = this.onClickGateFunc;
        g.tag = this.tag;
        g.param = this.param;
        g.customDrawer = this.customDrawer;
        g.interestedInControls = this.interestedInControls;
        g.customBeforeOperation = this.customBeforeOperation;
        g.knownBitPermutationFunc = this.knownBitPermutationFunc;
        g.customOperation = this.customOperation;
        g.customAfterOperation = this.customAfterOperation;
        g.customStatTexturesMaker = this.customStatTexturesMaker;
        g.customStatPostProcesser = this.customStatPostProcesser;
        g.processedStatsToJsonFunc = this.processedStatsToJsonFunc;
        g.width = this.width;
        g.height = this.height;
        g.isSingleQubitDisplay = this.isSingleQubitDisplay;
        g._knownMatrix = this._knownMatrix;
        g.knownCircuit = this.knownCircuit;
        g._showAsReachesOtherWires = this._showAsReachesOtherWires;
        g.isContextTemporary = this.isContextTemporary;
        g.knownCircuitNested = this.knownCircuitNested;
        g._requiredContextKeys = this._requiredContextKeys;
        g._knownMatrixFunc = this._knownMatrixFunc;
        g._stableDuration = this._stableDuration;
        g._withParamRecomputeFunc = this._withParamRecomputeFunc;
        g._hasNoEffect = this._hasNoEffect;
        g._effectPermutesStates = this._effectPermutesStates;
        g._effectCreatesSuperpositions = this._effectCreatesSuperpositions;
        g._affectsOtherWires = this._affectsOtherWires;
        g._controlBit = this._controlBit;
        g._isClassicalControl = this._isClassicalControl;
        g.isControlWireSource = this.isControlWireSource;
        g._isDefinitelyUnitary = this._isDefinitelyUnitary;
        g.knownPhaseTurnsFunc = this.knownPhaseTurnsFunc;
        g.knownPermutationFuncTakingInputs = this.knownPermutationFuncTakingInputs;
        g.customColumnContextProvider = this.customColumnContextProvider;
        g.customDisableReasonFinder = this.customDisableReasonFinder;
        g.knownBitPermutationGroupMasks = this.knownBitPermutationGroupMasks;
        return g;
      },
      withParam: function(value) {
        var g = this._copy();
        g.param = value;
        g._withParamRecomputeFunc(g);
        return g;
      },
      getUnmetContextKeys: function() {
        var result = new Set(this._requiredContextKeys);
        if (this.knownCircuit !== undefined) {
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (this.knownCircuit.getUnmetContextKeys())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var key = $__4.value;
              {
                result.add(key);
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
        }
        return result;
      },
      shouldShowAsHavingGlobalEffect: function() {
        return this._showAsReachesOtherWires || !this._isDefinitelyUnitary;
      },
      canChangeInSize: function() {
        return this.gateFamily.length > 1;
      },
      canIncreaseInSize: function() {
        var $__2 = this;
        return !this.gateFamily.every(function(e) {
          return e.height !== $__2.height + 1;
        });
      },
      canDecreaseInSize: function() {
        var $__2 = this;
        return !this.gateFamily.every(function(e) {
          return e.height !== $__2.height - 1;
        });
      },
      knownMatrixAt: function(time) {
        return this._knownMatrix !== undefined ? this._knownMatrix : this._knownMatrixFunc !== undefined ? this._knownMatrixFunc(time, this.param) : undefined;
      },
      isControl: function() {
        return this._controlBit !== undefined;
      },
      isClassicalControl: function() {
        return this._isClassicalControl;
      },
      controlBit: function() {
        return this._controlBit;
      },
      effectMightPermutesStates: function() {
        return this._effectPermutesStates !== undefined ? this._effectPermutesStates : this._knownMatrix !== undefined ? !this._knownMatrix.isDiagonal() : true;
      },
      effectMightCreateSuperpositions: function() {
        return this._effectCreatesSuperpositions !== undefined ? this._effectCreatesSuperpositions : this._knownMatrix !== undefined ? !this._knownMatrix.isPhasedPermutation() : true;
      },
      definitelyHasNoEffect: function() {
        return this._hasNoEffect;
      },
      isDefinitelyUnitary: function() {
        return this._isDefinitelyUnitary;
      },
      stableDuration: function() {
        return this._stableDuration !== undefined ? this._stableDuration : this._knownMatrix !== undefined || this._hasNoEffect ? Infinity : 0;
      },
      toString: function() {
        return ("Gate(" + this.symbol + ")");
      }
    }, {
      fromKnownMatrix: function(symbol, matrix) {
        var name = arguments[2] !== (void 0) ? arguments[2] : '';
        var blurb = arguments[3] !== (void 0) ? arguments[3] : '';
        var serializedId = arguments[4];
        var alternate = arguments[5];
        if (!(matrix instanceof Matrix)) {
          throw new DetailedError("Bad matrix.", {
            symbol: symbol,
            matrix: matrix,
            name: name,
            blurb: blurb
          });
        }
        var builder = new GateBuilder().setSymbol(symbol).setSerializedId(serializedId === undefined ? symbol : serializedId).setTitle(name).setBlurb(blurb).setKnownEffectToMatrix(matrix);
        if (alternate !== undefined) {
          builder = builder.setAlternate(alternate);
        }
        return builder.gate;
      },
      buildFamily: function(minSize, maxSize, gateBuildFunc) {
        var gates = [];
        for (var span = minSize; span <= maxSize; span++) {
          var builder = new GateBuilder();
          builder.setHeight(span);
          gateBuildFunc(span, builder);
          builder.gate.gateFamily = gates;
          gates.push(builder.gate);
        }
        var ofSize = function(h) {
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (gates)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var g = $__4.value;
              {
                if (g.height === h) {
                  return g;
                }
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
          return undefined;
        };
        return {
          all: gates,
          ofSize: ofSize
        };
      }
    });
  }();
  var GateBuilder = function() {
    function GateBuilder() {
      this.gate = new Gate();
    }
    return ($traceurRuntime.createClass)(GateBuilder, {
      setSerializedIdAndSymbol: function(id) {
        this.gate.symbol = id;
        this.gate.serializedId = id;
        return this;
      },
      setSymbol: function(symbol) {
        this.gate.symbol = symbol;
        return this;
      },
      setAlternateFromFamily: function(alternateFamily) {
        return this.setAlternate(alternateFamily.ofSize(this.gate.height));
      },
      setAlternate: function(alternate) {
        if (alternate === undefined) {
          throw new Error("alternate === undefined");
        }
        if (alternate.height !== this.gate.height) {
          throw new Error("alternate.height !== this.gate.height");
        }
        if (alternate.alternate !== alternate) {
          throw new Error("alternate.alternate !== alternate");
        }
        alternate.alternate = this.gate;
        this.gate.alternate = alternate;
        return this;
      },
      setSerializedId: function(serializedId) {
        this.gate.serializedId = serializedId;
        return this;
      },
      setTitle: function(title) {
        this.gate.name = title;
        return this;
      },
      setBlurb: function(blurb) {
        this.gate.blurb = blurb;
        return this;
      },
      setHeight: function(height) {
        this.gate.height = height;
        return this;
      },
      setWidth: function(width) {
        this.gate.width = width;
        return this;
      },
      setDrawer: function(drawer) {
        this.gate.customDrawer = drawer;
        return this;
      },
      setOnClickGateFunc: function(gateFunc) {
        this.gate.onClickGateFunc = gateFunc;
        return this;
      },
      setKnownEffectToMatrix: function(matrix) {
        if (!(matrix instanceof Matrix)) {
          throw new DetailedError("Bad matrix.", {matrix: matrix});
        }
        this.gate._isDefinitelyUnitary = matrix.isUnitary(0.01);
        this.gate._hasNoEffect = matrix.isIdentity();
        this.gate._stableDuration = Infinity;
        this.gate._knownMatrix = matrix;
        return this;
      },
      setKnownEffectToPermutation: function(permutationFunc) {
        var $__2 = this;
        this.gate.knownPermutationFuncTakingInputs = permutationFunc;
        this.gate._knownMatrixFunc = function(_) {
          return Matrix.generateTransition(1 << $__2.gate.height, permutationFunc);
        };
        this.gate._stableDuration = Infinity;
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = true;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      setKnownEffectToBitPermutation: function(knownBitPermutationFunc) {
        this.gate.knownBitPermutationFunc = knownBitPermutationFunc;
        this.gate.knownBitPermutationGroupMasks = permutationGrouping(knownBitPermutationFunc, this.gate.height);
        this.gate._isDefinitelyUnitary = true;
        this.gate._stableDuration = Infinity;
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = true;
        this.gate._effectCreatesSuperpositions = false;
        return this;
      },
      setKnownEffectToTimeVaryingPermutation: function(timeVaryingPermutationFunc) {
        var g = this.gate;
        g._stableDuration = 0;
        g._knownMatrixFunc = function(t) {
          return Matrix.generateTransition(1 << g.height, function(i) {
            return timeVaryingPermutationFunc(t, i);
          });
        };
        g._hasNoEffect = false;
        g._effectPermutesStates = true;
        g._effectCreatesSuperpositions = false;
        g._isDefinitelyUnitary = true;
        return this;
      },
      setKnownEffectToParametrizedPermutation: function(permutationFunc) {
        var g = this.gate;
        g.knownPermutationFuncTakingInputs = permutationFunc;
        g._knownMatrixFunc = undefined;
        g._stableDuration = Infinity;
        g._hasNoEffect = false;
        g._effectPermutesStates = true;
        g._effectCreatesSuperpositions = false;
        g._isDefinitelyUnitary = true;
        return this;
      },
      setKnownEffectToPhaser: function(phaseTurnsFunc) {
        var $__2 = this;
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        this.gate._stableDuration = Infinity;
        this.gate.knownPhaseTurnsFunc = phaseTurnsFunc;
        this.gate._knownMatrixFunc = function() {
          return Matrix.generateDiagonal(1 << $__2.gate.height, function(k) {
            return Complex.polar(1, Math.PI * 2 * phaseTurnsFunc(k));
          });
        };
        return this;
      },
      setTooltipMatrixFunc: function(matrixFunc) {
        this.gate._knownMatrixFunc = function(_) {
          return matrixFunc();
        };
        this.gate._stableDuration = Infinity;
        return this;
      },
      setKnownEffectToCircuit: function(circuitDefinition) {
        this.gate.knownCircuit = circuitDefinition;
        this.gate.knownCircuitNested = circuitDefinition.withDisabledReasonsForEmbeddedContext(0, new Map());
        this.gate._isDefinitelyUnitary = circuitDefinition.hasOnlyUnitaryGates();
        this.gate._stableDuration = circuitDefinition.stableDuration();
        this.gate.height = circuitDefinition.numWires;
        return this;
      },
      setEffectToTimeVaryingMatrix: function(timeToMatrixFunc) {
        this.gate._stableDuration = 0;
        this.gate._knownMatrixFunc = timeToMatrixFunc;
        this.gate._hasNoEffect = false;
        return this;
      },
      setWithParamPropertyRecomputeFunc: function(withParamRecomputeFunc) {
        this.gate._withParamRecomputeFunc = withParamRecomputeFunc;
        return this;
      },
      setActualEffectToUpdateFunc: function(circuitUpdateFunc) {
        if (circuitUpdateFunc !== undefined && typeof circuitUpdateFunc !== "function") {
          throw new DetailedError("Bad customOperation", {circuitUpdateFunc: circuitUpdateFunc});
        }
        this.gate.customOperation = circuitUpdateFunc;
        return this;
      },
      setActualEffectToShaderProvider: function(shaderFunc) {
        return this.setActualEffectToUpdateFunc(function(ctx) {
          return ctx.applyOperation(shaderFunc);
        });
      },
      promiseEffectOnlyPermutesAndPhases: function() {
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = true;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      promiseEffectIsDiagonal: function() {
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        return this;
      },
      promiseEffectOnlyPhases: function() {
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      promiseEffectIsUnitary: function() {
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      promiseEffectIsStable: function() {
        this.gate._stableDuration = Infinity;
        return this;
      },
      promiseHasNoNetEffectOnStateVector: function() {
        this.gate._stableDuration = Infinity;
        this.gate._hasNoEffect = true;
        this.gate._isDefinitelyUnitary = true;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        return this;
      },
      promiseHasNoNetEffectOnStateVectorButStillRequiresDynamicRedraw: function() {
        this.promiseHasNoNetEffectOnStateVector();
        this.gate._stableDuration = 0;
        return this;
      },
      markAsNotInterestedInControls: function() {
        this.gate.interestedInControls = false;
        return this;
      },
      markAsControlExpecting: function(bit) {
        var guaranteedClassical = arguments[1] !== (void 0) ? arguments[1] : false;
        this.gate._controlBit = bit;
        this.gate.isControlWireSource = true;
        this.gate.interestedInControls = false;
        this.gate._isClassicalControl = guaranteedClassical;
        return this;
      },
      markAsReachingOtherWires: function() {
        this.gate._showAsReachesOtherWires = true;
        return this;
      },
      markAsDrawerNeedsSingleQubitDensityStats: function() {
        this.gate.isSingleQubitDisplay = true;
        return this;
      },
      setRequiredContextKeys: function() {
        for (var keys = [],
            $__10 = 0; $__10 < arguments.length; $__10++)
          keys[$__10] = arguments[$__10];
        this.gate._requiredContextKeys = keys;
        return this;
      },
      setContextProvider: function(customColumnContextProvider) {
        this.gate.customColumnContextProvider = customColumnContextProvider;
        this.gate.isContextTemporary = true;
        return this;
      },
      setStickyContextProvider: function(customColumnContextProvider) {
        this.gate.customColumnContextProvider = customColumnContextProvider;
        this.gate.isContextTemporary = false;
        return this;
      },
      setSetupCleanupEffectsToShaderProviders: function(beforeColumnShaderFunc, afterColumnShaderFunc) {
        return this.setSetupCleanupEffectToUpdateFunc(beforeColumnShaderFunc === undefined ? undefined : function(ctx) {
          return ctx.applyOperation(beforeColumnShaderFunc);
        }, afterColumnShaderFunc === undefined ? undefined : function(ctx) {
          return ctx.applyOperation(afterColumnShaderFunc);
        });
      },
      setSetupCleanupEffectToUpdateFunc: function(beforeColumnUpdateFunc, afterColumnUpdateFunc) {
        if (beforeColumnUpdateFunc !== undefined && typeof beforeColumnUpdateFunc !== "function") {
          throw new DetailedError("Bad beforeColumnUpdateFunc", {customOperation: customOperation});
        }
        if (afterColumnUpdateFunc !== undefined && typeof afterColumnUpdateFunc !== "function") {
          throw new DetailedError("Bad afterColumnUpdateFunc", {customOperation: customOperation});
        }
        this.gate.customBeforeOperation = beforeColumnUpdateFunc;
        this.gate.customAfterOperation = afterColumnUpdateFunc;
        return this;
      },
      setExtraDisableReasonFinder: function(customDisableReasonFinder) {
        this.gate.customDisableReasonFinder = customDisableReasonFinder;
        return this;
      },
      setStatTexturesMaker: function(statTexturesMaker) {
        this.gate.customStatTexturesMaker = statTexturesMaker;
        return this;
      },
      setStatPixelDataPostProcessor: function(pixelFunc) {
        this.gate.customStatPostProcesser = pixelFunc;
        return this;
      },
      setProcessedStatsToJsonFunc: function(jsonFunc) {
        this.gate.processedStatsToJsonFunc = jsonFunc;
        return this;
      },
      setTag: function(tag) {
        this.gate.tag = tag;
        return this;
      }
    }, {});
  }();
  function permutationGrouping(knownBitPermutationFunc, height) {
    var seen = new Set();
    var result = [];
    for (var i = 0; i < height; i++) {
      var mask = 0;
      var j = i;
      while (!seen.has(j)) {
        seen.add(j);
        mask |= 1 << j;
        j = knownBitPermutationFunc(j);
      }
      if (mask !== 0) {
        result.push(mask);
      }
    }
    return result;
  }
  return {
    get Gate() {
      return Gate;
    },
    get GateBuilder() {
      return GateBuilder;
    }
  };
});
//# sourceURL=src/circuit/Gate.js
;$traceurRuntime.registerModule("src/circuit/GateCheckArgs.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/GateCheckArgs.js";
  var GateCheckArgs = function() {
    function GateCheckArgs(gate, innerColumn, outerRow, measuredMask, context, isNested) {
      this.gate = gate;
      this.innerColumn = innerColumn;
      this.outerRow = outerRow;
      this.measuredMask = measuredMask;
      this.context = context;
      this.isNested = isNested;
    }
    return ($traceurRuntime.createClass)(GateCheckArgs, {}, {});
  }();
  return {get GateCheckArgs() {
      return GateCheckArgs;
    }};
});
//# sourceURL=src/circuit/GateCheckArgs.js
;$traceurRuntime.registerModule("src/circuit/GateColumn.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/GateColumn.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/GateColumn.js")).DetailedError;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Gate.js", "src/circuit/GateColumn.js")).Gate;
  var GateCheckArgs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GateCheckArgs.js", "src/circuit/GateColumn.js")).GateCheckArgs;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/AllGates.js", "src/circuit/GateColumn.js")).Gates;
  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/circuit/GateColumn.js")),
      seq = $__15.seq,
      Seq = $__15.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/GateColumn.js")).Util;
  var GateColumn = function() {
    function GateColumn(gates) {
      this.gates = gates;
    }
    return ($traceurRuntime.createClass)(GateColumn, {
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof GateColumn && seq(this.gates).isEqualTo(seq(other.gates), Util.STRICT_EQUALITY);
      },
      stableDuration: function() {
        var $__10;
        return ($__10 = Math).min.apply($__10, $traceurRuntime.spread([Infinity], this.gates.filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.stableDuration();
        })));
      },
      isEmpty: function() {
        return this.gates.every(function(e) {
          return e === undefined;
        });
      },
      hasControl: function() {
        var inputMeasureMask = arguments[0] !== (void 0) ? arguments[0] : 0;
        var ignoreMask = arguments[1] !== (void 0) ? arguments[1] : 0;
        return this.hasCoherentControl(inputMeasureMask | ignoreMask) || this.hasMeasuredControl(inputMeasureMask & ~ignoreMask);
      },
      hasCoherentControl: function() {
        var inputMeasureMask = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var i = 0; i < this.gates.length; i++) {
          if ((inputMeasureMask & (1 << i)) === 0 && this.gates[i] !== undefined && this.gates[i].isControl() && !this.gates[i].isClassicalControl()) {
            return true;
          }
        }
        return false;
      },
      hasMeasuredControl: function() {
        var inputMeasureMask = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var i = 0; i < this.gates.length; i++) {
          if ((inputMeasureMask & (1 << i)) !== 0 && this.gates[i] !== undefined && this.gates[i].definitelyHasNoEffect() && this.gates[i].isControl()) {
            return true;
          }
        }
        return false;
      },
      controlMask: function() {
        var mask = 0;
        for (var i = 0; i < this.gates.length; i++) {
          if (this.gates[i] !== undefined && this.gates[i].definitelyHasNoEffect() && this.gates[i].isControl()) {
            mask |= 1 << i;
          }
        }
        return mask;
      },
      _disabledReason: function(inputMeasureMask, row, outerRowOffset, context, isNested) {
        var g = this.gates[row];
        if (g === undefined) {
          return undefined;
        }
        var args = new GateCheckArgs(g, this, outerRowOffset + row, inputMeasureMask, context, isNested);
        return g.customDisableReasonFinder(args) || GateColumn._disabledReason_inputs(args) || this._disabledReason_controlInside(row) || this._disabledReason_remixing(row, inputMeasureMask) || this._disabledReason_overlappingTags(outerRowOffset, row);
      },
      _disabledReason_overlappingTags: function(outerRow, row) {
        var keys = new Set(this.gates[row].customColumnContextProvider(outerRow + row, this.gates[row]).map(function(e) {
          return e.key;
        }));
        if (keys.length === 0) {
          return undefined;
        }
        for (var i = 0; i < row; i++) {
          var g = this.gates[i];
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (g === undefined ? [] : g.customColumnContextProvider(outerRow + i, g))[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var otherKey = $__3.value.key;
              {
                if (keys.has(otherKey)) {
                  return "already\ndefined";
                }
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }
        return undefined;
      },
      _disabledReason_remixing: function(row, inputMeasureMask) {
        var g = this.gates[row];
        var mask = ((1 << g.height) - 1) << row;
        var maskMeasured = mask & inputMeasureMask;
        if (maskMeasured !== 0 && g.knownBitPermutationFunc === undefined) {
          if (g.effectMightCreateSuperpositions()) {
            return "no\nremix\n(sorry)";
          }
          if (g.effectMightPermutesStates()) {
            if (maskMeasured !== mask || this.hasCoherentControl(inputMeasureMask)) {
              return "no\nremix\n(sorry)";
            }
          }
        }
        if (g.knownBitPermutationGroupMasks !== undefined) {
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (g.knownBitPermutationGroupMasks)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var maskGroup = $__3.value;
              {
                var isSingleton = ((maskGroup - 1) & maskGroup) === 0;
                if (isSingleton) {
                  continue;
                }
                maskGroup <<= row;
                var hasCoherentQubits = (maskGroup & inputMeasureMask) !== maskGroup;
                var hasMeasuredQubits = (maskGroup & inputMeasureMask) !== 0;
                var coherentControl = this.hasCoherentControl(inputMeasureMask);
                var controlled = this.hasControl(inputMeasureMask);
                var coherentControlledMixingOfMeasured = hasMeasuredQubits && coherentControl;
                var controlledMixingOfCoherentAndMeasured = hasCoherentQubits && hasMeasuredQubits && controlled;
                if (coherentControlledMixingOfMeasured || controlledMixingOfCoherentAndMeasured) {
                  return "no\nremix\n(sorry)";
                }
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }
        return undefined;
      },
      hasGatesWithGlobalEffects: function() {
        for (var i = 0; i < this.gates.length; i++) {
          var gate = this.gates[i];
          if (gate !== undefined && gate.shouldShowAsHavingGlobalEffect()) {
            return true;
          }
        }
        return false;
      },
      indexOfNonUnitaryGate: function() {
        for (var i = 0; i < this.gates.length; i++) {
          var gate = this.gates[i];
          if (gate !== undefined && !gate.isDefinitelyUnitary()) {
            return i;
          }
        }
        return undefined;
      },
      _disabledReason_controlInside: function(row) {
        var g = this.gates[row];
        for (var j = 1; j < g.height && row + j < this.gates.length; j++) {
          if (this.gates[row + j] !== undefined && this.gates[row + j].isControl()) {
            return "control\ninside";
          }
        }
        return undefined;
      },
      minimumRequiredWireCount: function() {
        var best = 0;
        for (var i = 0; i < this.gates.length; i++) {
          if (this.gates[i] !== undefined) {
            best = Math.max(best, this.gates[i].height + i);
          }
        }
        return best;
      },
      maximumGateWidth: function() {
        var best = -Infinity;
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (this.gates)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var g = $__3.value;
            {
              if (g !== undefined) {
                best = Math.max(best, g.width);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return best;
      },
      perRowDisabledReasons: function(inputMeasureMask, outerRowOffset, outerContext, prevStickyCtx, isNested) {
        var context = Util.mergeMaps(outerContext, prevStickyCtx);
        var stickyCtx = new Map(prevStickyCtx);
        for (var row = this.gates.length - 1; row >= 0; row--) {
          var g = this.gates[row];
          if (g !== undefined) {
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (g.customColumnContextProvider(row + outerRowOffset, g))[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var $__9 = $__3.value,
                    key = $__9.key,
                    val = $__9.val;
                {
                  context.set(key, val);
                  if (!g.isContextTemporary) {
                    stickyCtx.set(key, val);
                  }
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
          }
        }
        var allReasons = [];
        for (var i = 0; i < this.gates.length; i++) {
          allReasons.push(this._disabledReason(inputMeasureMask, i, outerRowOffset, context, isNested));
        }
        return {
          allReasons: allReasons,
          stickyCtx: stickyCtx
        };
      },
      _updateMeasureMask_gateStep: function(state, row, disabledReasons) {
        if (disabledReasons[row] !== undefined) {
          return;
        }
        var gate = this.gates[row];
        if (gate === undefined) {
          return;
        }
        if (gate === Gates.Special.Measurement) {
          state.measureMask |= 1 << row;
          return;
        }
        var hasSingleResult = gate === Gates.PostSelectionGates.PostSelectOn || gate === Gates.PostSelectionGates.PostSelectOff || gate === Gates.Detectors.ZDetector || gate === Gates.Detectors.ZDetectControlClear;
        if (!this.hasControl(0, 1 << row) && hasSingleResult) {
          state.measureMask &= ~(1 << row);
          return;
        }
        GateColumn._updateMeasureMask_swapGate(gate, state, row);
        GateColumn._updateMeasureMask_customPermute(gate, state, row);
      },
      nextMeasureMask: function(inputMeasureMask, disabledReasons) {
        var state = {
          measureMask: inputMeasureMask,
          earlierRowWithSwapGate: undefined
        };
        for (var row = 0; row < this.gates.length; row++) {
          this._updateMeasureMask_gateStep(state, row, disabledReasons);
        }
        return state.measureMask;
      },
      withGatesAdded: function(startIndex, insertedCol) {
        if (!Number.isInteger(startIndex) || startIndex < 0 || startIndex > this.gates.length - insertedCol.gates.length) {
          throw new DetailedError("Bad start index", {
            baseCol: this,
            startIndex: startIndex,
            insertedCol: insertedCol
          });
        }
        var gates = this.gates.map(function(e) {
          return e;
        });
        for (var i = 0; i < insertedCol.gates.length; i++) {
          gates[startIndex + i] = insertedCol.gates[i];
        }
        return new GateColumn(gates);
      }
    }, {
      empty: function(qubitCount) {
        return new GateColumn(new Array(qubitCount).fill(undefined));
      },
      _disabledReason_inputs: function(args) {
        var rangeVals = [];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (args.gate.getUnmetContextKeys())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              if (key.startsWith("Input Range ") && args.context.has(key)) {
                rangeVals.push(args.context.get(key));
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return GateColumn._disabledReason_inputs_missing(args) || GateColumn._disabledReason_inputs_inside(args, rangeVals) || GateColumn._disabledReason_inputs_coherenceMismatch(args, rangeVals);
      },
      _disabledReason_inputs_missing: function(args) {
        var missing = [];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (args.gate.getUnmetContextKeys())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              var altKey = key.replace("Input Range ", "Input Default ").replace("Input NO_DEFAULT Range ", "Input Range ");
              if (!args.context.has(key) && !args.context.has(altKey) && !args.isNested) {
                missing.push(key);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        if (missing.length > 0) {
          return "Need\nInput\n " + missing.map(function(e) {
            return e.replace("Input NO_DEFAULT Range ", "").replace("Input Range ", "");
          }).join(", ");
        }
        return undefined;
      },
      _disabledReason_inputs_inside: function(args, rangeVals) {
        var row = args.outerRow;
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (rangeVals)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                offset = $__9.offset,
                length = $__9.length;
            {
              if (offset + length > row && row + args.gate.height > offset) {
                return "input\ninside";
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return undefined;
      },
      _disabledReason_inputs_coherenceMismatch: function(args, rangeVals) {
        var row = args.outerRow;
        if (args.gate.effectMightPermutesStates()) {
          var hasMeasuredOutputs = ((args.measuredMask >> row) & ((1 << args.gate.height) - 1)) !== 0;
          if (hasMeasuredOutputs) {
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (rangeVals)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var $__9 = $__3.value,
                    offset = $__9.offset,
                    length = $__9.length;
                {
                  if (((~args.measuredMask >> offset) & ((1 << length) - 1)) !== 0) {
                    return "no\nremix\n(sorry)";
                  }
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
          }
        }
        return undefined;
      },
      _updateMeasureMask_swapGate: function(gate, state, row) {
        if (gate !== Gates.Special.SwapHalf) {
          return;
        }
        if (state.earlierRowWithSwapGate === undefined) {
          state.earlierRowWithSwapGate = row;
          return;
        }
        var other = 1 << state.earlierRowWithSwapGate;
        var d = row - state.earlierRowWithSwapGate;
        var bit = 1 << row;
        state.measureMask = (state.measureMask & ~(other | bit)) | ((state.measureMask & other) << d) | ((state.measureMask & bit) >> d);
        state.earlierRowWithSwapGate = undefined;
      },
      _updateMeasureMask_customPermute: function(gate, state, row) {
        if (gate.knownBitPermutationFunc === undefined) {
          return;
        }
        var mask = ((1 << gate.height) - 1) << row;
        var prev = state.measureMask & mask;
        state.measureMask &= ~mask;
        for (var i = 0; i < gate.height; i++) {
          var prevBit = 1 << (row + i);
          if ((prev & prevBit) !== 0) {
            var nextBit = 1 << (row + gate.knownBitPermutationFunc(i));
            state.measureMask |= nextBit;
          }
        }
      }
    });
  }();
  return {get GateColumn() {
      return GateColumn;
    }};
});
//# sourceURL=src/circuit/GateColumn.js
;$traceurRuntime.registerModule("src/circuit/GateShaders.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/GateShaders.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/GateShaders.js")).DetailedError;
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./KetShaderUtil.js", "src/circuit/GateShaders.js")),
      ketArgs = $__8.ketArgs,
      ketShader = $__8.ketShader;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/circuit/GateShaders.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/circuit/GateShaders.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/GateShaders.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/circuit/GateShaders.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/circuit/GateShaders.js")).WglConfiguredShader;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/circuit/GateShaders.js")),
      Inputs = $__14.Inputs,
      Outputs = $__14.Outputs,
      currentShaderCoder = $__14.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__14.makePseudoShaderWithInputsAndOutputAndCode;
  var GateShaders = function() {
    function GateShaders() {}
    return ($traceurRuntime.createClass)(GateShaders, {}, {});
  }();
  function _applySingleQubitOperationFunc(ctx, matrix) {
    var $__5;
    var $__3,
        $__4;
    if (matrix.width() !== 2 || matrix.height() !== 2) {
      throw new DetailedError("Not a single-qubit operation.", {matrix: matrix});
    }
    var $__2 = matrix.rawBuffer(),
        ar = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        ai = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        br = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        bi = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        cr = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        ci = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        dr = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        di = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    ctx.applyOperation(($__5 = CUSTOM_SINGLE_QUBIT_OPERATION_SHADER).withArgs.apply($__5, $traceurRuntime.spread(ketArgs(ctx), [WglArg.vec2("a", ar, ai), WglArg.vec2("b", br, bi), WglArg.vec2("c", cr, ci), WglArg.vec2("d", dr, di)])));
  }
  var CUSTOM_SINGLE_QUBIT_OPERATION_SHADER = ketShader('uniform vec2 a, b, c, d;', 'return cmul(inp(0.0), a+(c-a)*out_id) + cmul(inp(1.0), b+(d-b)*out_id);', 1);
  var hugeQubitOperationMaker = function(qubitCount) {
    return ketShader('', ("\n        vec2 t = vec2(0.0, 0.0);\n        for (int k = 0; k < " + (1 << qubitCount) + "; k++) {\n            t += cmul(inp(float(k)),\n                      read_coefs(out_id * " + (1 << qubitCount) + ".0 + float(k)));\n        }\n        return t;\n    "), qubitCount, [Inputs.vec2('coefs')]);
  };
  var multiQubitOperationMaker = function(qubitCount) {
    return ketShader(("uniform vec4 coefs[" + (1 << (2 * qubitCount - 1)) + "];"), ("\n        int row = int(out_id);\n        vec2 t = vec2(0.0, 0.0);\n        for (int d = 0; d < " + (1 << qubitCount) + "; d++) {\n            // Can't index by row, since it's not a constant, so we do a const brute force loop searching for it.\n            if (d == row) {\n                for (int k = 0; k < " + (1 << (qubitCount - 1)) + "; k++) {\n                    vec4 u = coefs[d*" + (1 << (qubitCount - 1)) + " + k];\n                    t += cmul(inp(float(k*2)), u.xy);\n                    t += cmul(inp(float(k*2+1)), u.zw);\n                }\n            }\n        }\n        return t;\n    "), qubitCount);
  };
  var matrix_operation_shaders = [undefined, undefined, multiQubitOperationMaker(2), multiQubitOperationMaker(3), hugeQubitOperationMaker(4)];
  GateShaders.applyMatrixOperation = function(ctx, matrix) {
    var $__5,
        $__6;
    if (!Util.isPowerOf2(matrix.width())) {
      throw new DetailedError("Matrix size isn't a power of 2.", {
        ctx: ctx,
        matrix: matrix
      });
    }
    if (matrix.width() === 2) {
      _applySingleQubitOperationFunc(ctx, matrix);
      return;
    }
    var sizePower = Math.round(Math.log2(matrix.width()));
    if (sizePower <= 3) {
      ctx.applyOperation(($__5 = matrix_operation_shaders[sizePower]).withArgs.apply($__5, $traceurRuntime.spread(ketArgs(ctx), [WglArg.vec4_array("coefs", matrix.rawBuffer())])));
      return;
    }
    if (sizePower <= 4) {
      var tex = Shaders.data(currentShaderCoder().vec2.dataToPixels(matrix.rawBuffer())).toVec2Texture(sizePower * 2);
      try {
        ctx.applyOperation(($__6 = matrix_operation_shaders[sizePower]).withArgs.apply($__6, $traceurRuntime.spread([tex], ketArgs(ctx))));
      } finally {
        tex.deallocByDepositingInPool();
      }
      return;
    }
    throw new DetailedError("Matrix is past 4 qubits. Too expensive.", {
      ctx: ctx,
      matrix: matrix
    });
  };
  GateShaders.cycleAllBits = function(inputTexture, shiftAmount) {
    var size = currentShaderCoder().vec2.arrayPowerSizeOfTexture(inputTexture);
    return CYCLE_ALL_SHADER_VEC2(inputTexture, WglArg.float("shiftAmount", 1 << Util.properMod(-shiftAmount, size)));
  };
  var CYCLE_ALL_SHADER_VEC2 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "\n    uniform float shiftAmount;\n\n    vec2 outputFor(float k) {\n        float span = len_input();\n        float shiftedState = k * shiftAmount;\n        float cycledState = mod(shiftedState, span) + floor(shiftedState / span);\n        return read_input(cycledState);\n    }");
  GateShaders.cycleAllBitsFloat = function(inputTexture, shiftAmount) {
    var size = currentShaderCoder().float.arrayPowerSizeOfTexture(inputTexture);
    return CYCLE_ALL_SHADER_FLOAT(inputTexture, WglArg.float("shiftAmount", 1 << Util.properMod(-shiftAmount, size)));
  };
  var CYCLE_ALL_SHADER_FLOAT = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.float(), "\n    uniform float shiftAmount;\n\n    float outputFor(float k) {\n        float span = len_input();\n        float shiftedState = k * shiftAmount;\n        float cycledState = mod(shiftedState, span) + floor(shiftedState / span);\n        return read_input(cycledState);\n    }");
  return {get GateShaders() {
      return GateShaders;
    }};
});
//# sourceURL=src/circuit/GateShaders.js
;$traceurRuntime.registerModule("src/circuit/KetShaderUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/KetShaderUtil.js";
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/circuit/KetShaderUtil.js")).WglArg;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/circuit/KetShaderUtil.js")),
      makePseudoShaderWithInputsAndOutputAndCode = $__10.makePseudoShaderWithInputsAndOutputAndCode,
      Inputs = $__10.Inputs,
      Outputs = $__10.Outputs;
  var ketShader = function(head, body) {
    var span = arguments[2] !== (void 0) ? arguments[2] : null;
    var inputs = arguments[3] !== (void 0) ? arguments[3] : [];
    return ({withArgs: makePseudoShaderWithInputsAndOutputAndCode($traceurRuntime.spread(inputs, [Inputs.vec2('ketgen_ket'), Inputs.bool('ketgen_control')]), Outputs.vec2(), ("\n    uniform float _ketgen_step;\n    " + (span === null ? 'uniform float span;' : '') + "\n    float _ketgen_off;\n    float full_out_id;\n\n    " + (body.match(/\bcmul\b/) ? 'vec2 cmul(vec2 c1, vec2 c2) { return mat2(c1.x, c1.y, -c1.y, c1.x) * c2; }' : '') + "\n    " + (body.match(/\binp\b/) ? 'vec2 inp(float k) { return read_ketgen_ket(_ketgen_off + _ketgen_step*k); }' : '') + "\n\n    " + head + "\n\n    vec2 _ketgen_output_for(float out_id, vec2 amp) {\n        " + body + "\n    }\n\n    vec2 outputFor(float k) {\n        full_out_id = k;\n\n        float relevant_out_id = mod(floor(full_out_id / _ketgen_step), " + (span === null ? 'span' : (1 << span) + '.0') + ");\n        _ketgen_off = full_out_id - relevant_out_id*_ketgen_step;\n\n        float c = read_ketgen_control(full_out_id);\n        vec2 vc = read_ketgen_ket(full_out_id);\n        vec2 vt = _ketgen_output_for(relevant_out_id, vc);\n        return (1.0-c)*vc + c*vt;\n    }"))});
  };
  var ketShaderPermute = function(head, body) {
    var span = arguments[2] !== (void 0) ? arguments[2] : null;
    return ketShader(head + ("float _ketgen_input_for(float out_id) { " + body + " }"), 'return inp(_ketgen_input_for(out_id));', span);
  };
  var ketShaderPhase = function(head, body) {
    var span = arguments[2] !== (void 0) ? arguments[2] : null;
    return ketShader((head + "\n        float _ketgen_phase_for(float out_id) {\n            " + body + "\n        }\n    "), "\n        float angle = _ketgen_phase_for(out_id);\n        return cmul(amp, vec2(cos(angle), sin(angle)));\n    ", span);
  };
  function ketArgs(ctx) {
    var $__8;
    var span = arguments[1];
    var input_letters = arguments[2] !== (void 0) ? arguments[2] : [];
    var result = [ctx.stateTrader.currentTexture, ctx.controlsTexture, WglArg.float("_ketgen_step", 1 << ctx.row)];
    if (span !== undefined) {
      result.push(WglArg.float('span', 1 << span));
    }
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (input_letters)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var letter = $__2.value;
        {
          ($__8 = result).push.apply($__8, $traceurRuntime.spread(ketInputGateArgs(ctx, letter)));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return result;
  }
  function ketInputGateShaderCode(letter) {
    return ("\n        //////// INPUT GATE " + letter + " ////////\n        uniform float _gen_input_default_" + letter + ";\n        uniform float _gen_input_offset_" + letter + ";\n        uniform float _gen_input_span_" + letter + ";\n        \n        float read_input_" + letter + "() {\n            return _gen_input_span_" + letter + " == 0.0\n                ? _gen_input_default_" + letter + "\n                : mod(floor(full_out_id / _gen_input_offset_" + letter + "), _gen_input_span_" + letter + ");\n        }");
  }
  function ketInputGateArgs(ctx, letter) {
    var offset = 0;
    var length = -1;
    var defaultVal = ctx.customContextFromGates.get(("Input Default " + letter)) || 0;
    var inputCtx = ctx.customContextFromGates.get(("Input Range " + letter));
    if (inputCtx !== undefined) {
      offset = inputCtx.offset;
      length = inputCtx.length;
    }
    return [WglArg.float(("_gen_input_default_" + letter), defaultVal), WglArg.float(("_gen_input_offset_" + letter), 1 << offset), WglArg.float(("_gen_input_span_" + letter), length === -1 ? 0 : 1 << length)];
  }
  return {
    get ketArgs() {
      return ketArgs;
    },
    get ketShader() {
      return ketShader;
    },
    get ketShaderPermute() {
      return ketShaderPermute;
    },
    get ketShaderPhase() {
      return ketShaderPhase;
    },
    get ketInputGateShaderCode() {
      return ketInputGateShaderCode;
    },
    get ketInputGateArgs() {
      return ketInputGateArgs;
    }
  };
});
//# sourceURL=src/circuit/KetShaderUtil.js
;$traceurRuntime.registerModule("src/circuit/KetTextureUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/KetTextureUtil.js";
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitShaders.js", "src/circuit/KetTextureUtil.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Controls.js", "src/circuit/KetTextureUtil.js")).Controls;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/KetTextureUtil.js")).DetailedError;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/circuit/KetTextureUtil.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/circuit/KetTextureUtil.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/KetTextureUtil.js")).Util;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTexture.js", "src/circuit/KetTextureUtil.js")).WglTexture;
  var $__25 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/circuit/KetTextureUtil.js")),
      seq = $__25.seq,
      Seq = $__25.Seq;
  var $__26 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/circuit/KetTextureUtil.js")),
      outputShaderCoder = $__26.outputShaderCoder,
      currentShaderCoder = $__26.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__26.makePseudoShaderWithInputsAndOutputAndCode,
      Inputs = $__26.Inputs,
      Outputs = $__26.Outputs;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTexturePool.js", "src/circuit/KetTextureUtil.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTextureTrader.js", "src/circuit/KetTextureUtil.js")).WglTextureTrader;
  var KetTextureUtil = function() {
    function KetTextureUtil() {}
    return ($traceurRuntime.createClass)(KetTextureUtil, {}, {});
  }();
  KetTextureUtil.tradeTextureForVec2Output = function(trader) {
    if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
      trader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
    }
    return KetTextureUtil.tradeTextureForVec4Output(trader);
  };
  KetTextureUtil.tradeTextureForVec4Output = function(trader) {
    if (outputShaderCoder() === currentShaderCoder()) {
      var result$__16 = currentShaderCoder().vec4.pixelsToData(trader.currentTexture.readPixels());
      trader.currentTexture.deallocByDepositingInPool("tradeTextureForVec4Output");
      return result$__16;
    }
    var sizePower = currentShaderCoder().vec4.arrayPowerSizeOfTexture(trader.currentTexture);
    var adjustedSizePower = sizePower + outputShaderCoder().vec4.powerSizeOverhead;
    trader.shadeAndTrade(Shaders.convertVec4CodingForOutput, WglTexturePool.take(adjustedSizePower, outputShaderCoder().vec4.pixelType));
    var result = outputShaderCoder().vec4.pixelsToData(trader.currentTexture.readPixels());
    trader.currentTexture.deallocByDepositingInPool("tradeTextureForVec4Output");
    return result;
  };
  KetTextureUtil.mergedReadFloats = function(textures) {
    var len = function(tex) {
      return tex.width === 0 ? 0 : 1 << currentShaderCoder().vec4.arrayPowerSizeOfTexture(tex);
    };
    var totalPowerSize = Math.round(Math.log2(Util.ceilingPowerOf2(seq(textures).map(len).sum())));
    var trader = new WglTextureTrader(Shaders.color(0, 0, 0, 0).toVec4Texture(totalPowerSize));
    var offset = 0;
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      var $__17 = function() {
        var tex = $__3.value;
        {
          if (tex.width > 0) {
            trader.shadeAndTrade(function(acc) {
              return CircuitShaders.linearOverlay(offset, tex, acc);
            });
          }
          offset += len(tex);
        }
      };
      for (var $__3 = void 0,
          $__2 = (textures)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        $__17();
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    var combinedPixels = KetTextureUtil.tradeTextureForVec4Output(trader);
    var result = [];
    var pixelOffset = 0;
    var $__12 = true;
    var $__13 = false;
    var $__14 = undefined;
    try {
      for (var $__10 = void 0,
          $__9 = (textures)[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
        var tex = $__10.value;
        {
          var pixelLen = len(tex) << 2;
          result.push(combinedPixels.subarray(pixelOffset, pixelOffset + pixelLen));
          pixelOffset += pixelLen;
          tex.deallocByDepositingInPool();
        }
      }
    } catch ($__15) {
      $__13 = true;
      $__14 = $__15;
    } finally {
      try {
        if (!$__12 && $__9.return != null) {
          $__9.return();
        }
      } finally {
        if ($__13) {
          throw $__14;
        }
      }
    }
    return result;
  };
  KetTextureUtil.pixelsToAmplitudes = function(pixels, unity) {
    if (unity < 0.000001) {
      unity = NaN;
    }
    var d = Math.sqrt(unity);
    var n = pixels.length >> 1;
    var buf = new Float32Array(n * 2);
    for (var i = 0; i < pixels.length; i++) {
      buf[i] = pixels[i] / d;
    }
    return new Matrix(1, n, buf);
  };
  KetTextureUtil.superpositionToQubitDensities = function(stateTex, controls, keptBitMask) {
    if (keptBitMask === 0) {
      return new WglTexture(0, 0, currentShaderCoder().vec4.pixelType);
    }
    var hasControls = !controls.isEqualTo(Controls.NONE);
    var trader = new WglTextureTrader(stateTex);
    trader.dontDeallocCurrentTexture();
    if (hasControls) {
      var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(stateTex) - controls.includedBitCount();
      trader.shadeAndTrade(function(t) {
        return CircuitShaders.controlSelect(controls, t);
      }, WglTexturePool.takeVec2Tex(n));
    }
    var p = 1;
    for (var i = 1; i <= controls.inclusionMask; i <<= 1) {
      if ((controls.inclusionMask & i) === 0) {
        p <<= 1;
      } else {
        keptBitMask = (keptBitMask & (p - 1)) | ((keptBitMask & ~(p - 1)) >> 1);
      }
    }
    _superpositionTexToUnsummedQubitDensitiesTex(trader, keptBitMask);
    var keptQubitCount = Util.numberOfSetBits(keptBitMask);
    _sumDownVec4(trader, keptQubitCount);
    return trader.currentTexture;
  };
  function _superpositionTexToUnsummedQubitDensitiesTex(trader, keptBitMask) {
    if (keptBitMask === 0) {
      throw new DetailedError("keptBitMask === 0", {
        trader: trader,
        keptBitMask: keptBitMask
      });
    }
    var startingQubitCount = currentShaderCoder().vec2.arrayPowerSizeOfTexture(trader.currentTexture);
    var remainingQubitCount = Util.numberOfSetBits(keptBitMask);
    trader.shadeAndTrade(function(tex) {
      return CircuitShaders.qubitDensities(tex, keptBitMask);
    }, WglTexturePool.takeVec4Tex(startingQubitCount - 1 + Util.ceilLg2(remainingQubitCount)));
  }
  function _sumDownVec4(trader, outCount) {
    var outputSizePower = Util.ceilLg2(outCount);
    var curSizePower = currentShaderCoder().vec4.arrayPowerSizeOfTexture(trader.currentTexture);
    while (curSizePower > outputSizePower) {
      trader.shadeHalveAndTrade(Shaders.sumFoldVec4);
      curSizePower -= 1;
    }
  }
  KetTextureUtil.pixelsToQubitDensityMatrices = function(buffer) {
    var qubitCount = buffer.length / 4;
    return Seq.range(qubitCount).map(function(i) {
      var a = buffer[i * 4];
      var d = buffer[i * 4 + 3];
      var unity = a + d;
      if (unity < 0.0000001 || isNaN(unity)) {
        return new Matrix(2, 2, new Float32Array([NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN]));
      }
      var br = buffer[i * 4 + 1] / unity;
      var bi = buffer[i * 4 + 2] / unity;
      return new Matrix(2, 2, new Float32Array([a / unity, 0, br, bi, br, -bi, d / unity, 0]));
    }).toArray();
  };
  var amplitudesToProbabilities = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.float(), "float outputFor(float k) {\n        vec2 amp = read_input(k);\n        return dot(amp, amp);\n    }");
  KetTextureUtil.superpositionToNorm = function(stateTex, mayHaveChanged) {
    if (!mayHaveChanged) {
      return new WglTexture(0, 0, currentShaderCoder().vec4.pixelType);
    }
    var trader = new WglTextureTrader(stateTex);
    trader.dontDeallocCurrentTexture();
    var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(stateTex);
    trader.shadeAndTrade(amplitudesToProbabilities, WglTexturePool.takeVecFloatTex(n));
    while (n > 0) {
      n -= 1;
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    trader.shadeAndTrade(Shaders.packFloatIntoVec4, WglTexturePool.takeVec4Tex(0));
    return trader.currentTexture;
  };
  return {get KetTextureUtil() {
      return KetTextureUtil;
    }};
});
//# sourceURL=src/circuit/KetTextureUtil.js
;$traceurRuntime.registerModule("src/circuit/Serializer.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/Serializer.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitDefinition.js", "src/circuit/Serializer.js")).CircuitDefinition;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/circuit/Serializer.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/circuit/Serializer.js")).Config;
  var CustomGateSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CustomGateSet.js", "src/circuit/Serializer.js")).CustomGateSet;
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Describe.js", "src/circuit/Serializer.js")).describe;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/circuit/Serializer.js")).DetailedError;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/circuit/Serializer.js")).Format;
  var $__20 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Gate.js", "src/circuit/Serializer.js")),
      Gate = $__20.Gate,
      GateBuilder = $__20.GateBuilder;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GateColumn.js", "src/circuit/Serializer.js")).GateColumn;
  var $__22 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/AllGates.js", "src/circuit/Serializer.js")),
      Gates = $__22.Gates,
      INITIAL_STATES_TO_GATES = $__22.INITIAL_STATES_TO_GATES;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/circuit/Serializer.js")).Matrix;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/circuit/Serializer.js")).Util;
  var notifyAboutRecoveryFromUnexpectedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../fallback.js", "src/circuit/Serializer.js")).notifyAboutRecoveryFromUnexpectedError;
  var $__26 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/Joke_MysteryGate.js", "src/circuit/Serializer.js")),
      MysteryGateSymbol = $__26.MysteryGateSymbol,
      MysteryGateMakerWithMatrix = $__26.MysteryGateMakerWithMatrix;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/circuit/Serializer.js")).seq;
  var setGateBuilderEffectToCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CircuitComputeUtil.js", "src/circuit/Serializer.js")).setGateBuilderEffectToCircuit;
  var matrixDrawer = undefined;
  var circuitDrawer = undefined;
  var labelDrawer = undefined;
  var locationIndependentDrawer = undefined;
  function initSerializer(gateLabelDrawer, gateMatrixDrawer, gateCircuitDrawer, locationIndependentGateDrawer) {
    labelDrawer = gateLabelDrawer;
    matrixDrawer = gateMatrixDrawer;
    circuitDrawer = gateCircuitDrawer;
    locationIndependentDrawer = locationIndependentGateDrawer;
  }
  var Serializer = function() {
    function Serializer() {}
    return ($traceurRuntime.createClass)(Serializer, {}, {
      toJson: function(value) {
        var $__10,
            $__11;
        var context = arguments[1];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (BINDINGS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                type = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
                toJ = ($__11 = $__10.next()).done ? void 0 : $__11.value,
                _ = ($__11 = $__10.next()).done ? void 0 : $__11.value;
            {
              if (value instanceof type) {
                return toJ(value, context);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        throw new Error(("Don't know how to convert " + describe(value) + " to JSON."));
      },
      fromJson: function(expectedType, json) {
        var $__10,
            $__11;
        var context = arguments[2];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (BINDINGS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                type = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
                _ = ($__11 = $__10.next()).done ? void 0 : $__11.value,
                fromJ = ($__11 = $__10.next()).done ? void 0 : $__11.value;
            {
              if (type === expectedType) {
                return fromJ(json, context);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        throw new Error(("Don't know how to deserialize JSON " + describe(json) + " into an instance of " + expectedType + "."));
      }
    });
  }();
  var toJson_Complex = function(v) {
    return v.toString(Format.MINIFIED);
  };
  var fromJson_Complex = function(json) {
    if (typeof json === "string") {
      return Complex.parse(json);
    }
    throw new Error("Not a packed complex string: " + json);
  };
  var toJson_Matrix = function(v) {
    return v.toString(Format.MINIFIED);
  };
  var fromJson_Matrix = function(json) {
    if (typeof json !== "string") {
      throw new Error("Not a packed matrix string: " + json);
    }
    return Matrix.parse(json);
  };
  var toJson_Gate = function(gate) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    var found = Gates.findKnownGateById(gate.serializedId, context);
    if (found === gate) {
      return gate.serializedId;
    }
    if (found !== undefined && found.param !== undefined) {
      return {
        id: gate.serializedId,
        arg: gate.param
      };
    }
    if (gate.name === "Parse Error") {
      return gate.tag;
    }
    var result = {};
    if (gate.serializedId !== "") {
      result.id = gate.serializedId;
    }
    if (gate.serializedId.startsWith("~") ? gate.symbol !== '' : gate.symbol !== gate.serializedId) {
      result.name = gate.symbol;
    }
    if (gate.stableDuration() === Infinity && gate.knownMatrixAt(0) !== undefined) {
      result.matrix = toJson_Matrix(gate.knownMatrixAt(0.25));
    } else if (gate.knownCircuit !== undefined) {
      result.circuit = toJson_CircuitDefinition(gate.knownCircuit, context);
    } else {
      throw new DetailedError("Don't known how to serialize gate's function.", {gate: gate});
    }
    return result;
  };
  function _getGateId(json) {
    var symbol = typeof json === "string" ? json : json["id"];
    if (symbol === undefined) {
      return "";
    }
    if (typeof symbol !== "string") {
      return describe(symbol);
    }
    return symbol;
  }
  function _parseGateMatrix(matrixProp) {
    if (matrixProp === undefined) {
      throw new Error("Unrecognized gate id, but no matrix specified.");
    }
    var matrix = fromJson_Matrix(matrixProp);
    if (matrix.width() !== matrix.height()) {
      throw new Error("Gate matrix must be square.");
    }
    if (matrix.width() < 2 || matrix.width() > 1 << 4 || !Util.isPowerOf2(matrix.width())) {
      throw new Error("Supported gate matrix sizes are 2, 4, 8, and 16.");
    }
    return matrix;
  }
  var fromJson_Gate_props = function(json) {
    var id = _getGateId(json);
    var matrix = json["matrix"];
    var circuit = json["circuit"];
    var param = json["arg"];
    var symbol = json.name !== undefined ? json.name : id.startsWith('~') ? '' : id;
    var name = id.startsWith('~') ? ((symbol || 'Custom') + " Gate [" + id.substring(1) + "]") : symbol !== '' ? symbol : id;
    return {
      id: id,
      matrix: matrix,
      circuit: circuit,
      symbol: symbol,
      name: name,
      param: param
    };
  };
  var fromJson_Gate_Matrix = function(props) {
    var mat = _parseGateMatrix(props.matrix);
    if (props.id === MysteryGateSymbol) {
      return MysteryGateMakerWithMatrix(mat);
    }
    var height = Math.round(Math.log2(mat.height()));
    var width = props.symbol === '' ? height : 1;
    var matrix = _parseGateMatrix(props.matrix);
    var builder = new GateBuilder().setSerializedId(props.id).setSymbol(props.symbol).setTitle(props.name).setHeight(height).setWidth(width).setDrawer(props.symbol === "" ? matrixDrawer : matrix.isIdentity() ? labelDrawer : matrix.isScaler() ? locationIndependentDrawer : undefined).setKnownEffectToMatrix(matrix);
    if (matrix.isIdentity()) {
      builder.markAsNotInterestedInControls();
    }
    return builder.gate;
  };
  var fromJson_Gate_Circuit = function(props, context) {
    var circuit = fromJson_CircuitDefinition(props.circuit, context).withMinimumWireCount();
    return setGateBuilderEffectToCircuit(new GateBuilder(), circuit).setSerializedId(props.id).setSymbol(props.symbol).setTitle(props.name).setDrawer(circuitDrawer).gate;
  };
  var fromJson_Gate = function(json) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    var props = fromJson_Gate_props(json);
    try {
      if (props.matrix !== undefined) {
        return fromJson_Gate_Matrix(props);
      }
      if (props.circuit !== undefined) {
        return fromJson_Gate_Circuit(props, context);
      }
      var match = Gates.findKnownGateById(props.id, context);
      if (match === undefined) {
        throw new DetailedError(("No gate with the id '" + props.id + "'."), {json: json});
      }
      if (props.param !== undefined) {
        if (match.param === undefined) {
          throw new DetailedError("Arg for gate without arg.", {json: json});
        }
        match = match.withParam(props.param);
      }
      return match;
    } catch (ex) {
      notifyAboutRecoveryFromUnexpectedError("Defaulted to a do-nothing 'parse error' gate. Failed to understand the json defining a gate.", {gate_json: json}, ex);
      return new GateBuilder().setSerializedIdAndSymbol(props.id).setTitle("Parse Error").setBlurb(describe(ex)).promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function() {
        return "parse\nerror";
      }).setTag(json).gate;
    }
  };
  function toJson_GateColumn(v) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    return v.gates.map(function(e) {
      return e === undefined ? 1 : toJson_Gate(e, context);
    });
  }
  var fromJson_GateColumn = function(json) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    if (!Array.isArray(json)) {
      throw new Error(("GateColumn json should be an array. Json: " + describe(json)));
    }
    return new GateColumn(json.map(function(e) {
      return e === 1 || e === undefined ? undefined : fromJson_Gate(e, context);
    }));
  };
  function toJson_CustomGateSet(v) {
    var result = [];
    for (var i = 0; i < v.gates.length; i++) {
      result.push(toJson_Gate(v.gates[i], new (Function.prototype.bind.apply(CustomGateSet, $traceurRuntime.spread([null], v.gates.slice(0, i))))()));
    }
    return result;
  }
  function fromJson_CustomGateSet(json) {
    if (!Array.isArray(json)) {
      throw new DetailedError("Expected an array of gates.", {json: json});
    }
    var gatesSoFar = new CustomGateSet();
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      for (var $__3 = void 0,
          $__2 = (json)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        var e = $__3.value;
        {
          gatesSoFar = gatesSoFar.withGate(fromJson_Gate(e, gatesSoFar));
        }
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    return gatesSoFar;
  }
  var toJson_CircuitDefinition = function(v, context) {
    var result = {cols: v.trimEmptyColumnsAtEndIgnoringGateWidths().columns.map(function(e) {
        return toJson_GateColumn(e, context || v.customGateSet);
      }).map(function(c) {
        return seq(c).skipTailWhile(function(e) {
          return e === 1;
        }).toArray();
      })};
    if (context === undefined && v.customGateSet.gates.length > 0) {
      result.gates = toJson_CustomGateSet(v.customGateSet);
    }
    if (v.customInitialValues.size > 0) {
      result.init = [];
      var maxInit = seq(v.customInitialValues.keys()).max();
      for (var i = 0; i <= maxInit; i++) {
        var s = v.customInitialValues.get(i);
        result.init.push(s === undefined ? 0 : s === '1' ? 1 : s);
      }
    }
    return result;
  };
  var _cachedCircuit = undefined;
  var _cachedCircuit_Arg = undefined;
  function fromJsonText_CircuitDefinition(jsonText) {
    if (_cachedCircuit_Arg === jsonText) {
      return _cachedCircuit;
    }
    _cachedCircuit_Arg = jsonText;
    _cachedCircuit = fromJson_CircuitDefinition(JSON.parse(jsonText), undefined);
    return _cachedCircuit;
  }
  function _fromJson_InitialState(json) {
    var init = json.init;
    if (init === undefined) {
      return new Map();
    }
    if (!Array.isArray(init)) {
      throw new DetailedError('Initial states must be an array.', {json: json});
    }
    var result = new Map();
    for (var i = 0; i < init.length; i++) {
      var v = init[i];
      if (v === 0) {} else if (v === 1) {
        result.set(i, '1');
      } else if (INITIAL_STATES_TO_GATES.has(v)) {
        result.set(i, v);
      } else {
        throw new DetailedError('Unrecognized initial state key.', {
          v: v,
          json: json
        });
      }
    }
    return result;
  }
  function fromJson_CircuitDefinition(json) {
    var $__12;
    var context = arguments[1];
    var cols = json.cols;
    var customGateSet = context || (json.gates === undefined ? new CustomGateSet() : fromJson_CustomGateSet(json.gates));
    if (!Array.isArray(cols)) {
      throw new Error(("CircuitDefinition json should contain an array of cols. Json: " + describe(json)));
    }
    var gateCols = cols.map(function(e) {
      return fromJson_GateColumn(e, customGateSet);
    });
    var initialValues = _fromJson_InitialState(json);
    var numWires = 0;
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      for (var $__3 = void 0,
          $__2 = (gateCols)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        var col = $__3.value;
        {
          numWires = Math.max(numWires, col.minimumRequiredWireCount());
        }
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    numWires = ($__12 = Math).max.apply($__12, $traceurRuntime.spread([Config.MIN_WIRE_COUNT, Math.min(numWires, Config.MAX_WIRE_COUNT)], $traceurRuntime.spread(initialValues.keys()).map(function(e) {
      return e + 1;
    })));
    gateCols = gateCols.map(function(col) {
      return new GateColumn($traceurRuntime.spread(col.gates, new Array(Math.max(0, numWires - col.gates.length)).fill(undefined)).slice(0, numWires));
    });
    return new CircuitDefinition(numWires, gateCols, undefined, undefined, customGateSet, false, initialValues).withTrailingSpacersIncluded();
  }
  var BINDINGS = [[Complex, toJson_Complex, fromJson_Complex], [Gate, toJson_Gate, fromJson_Gate], [Matrix, toJson_Matrix, fromJson_Matrix], [GateColumn, toJson_GateColumn, fromJson_GateColumn], [CircuitDefinition, toJson_CircuitDefinition, fromJson_CircuitDefinition]];
  return {
    get Serializer() {
      return Serializer;
    },
    get initSerializer() {
      return initSerializer;
    },
    get fromJsonText_CircuitDefinition() {
      return fromJsonText_CircuitDefinition;
    }
  };
});
//# sourceURL=src/circuit/Serializer.js
;$traceurRuntime.registerModule("src/Config.js", [], function() {
  "use strict";
  var __moduleName = "src/Config.js";
  var Config = function() {
    function Config() {}
    return ($traceurRuntime.createClass)(Config, {}, {});
  }();
  Config.EMPTY_CIRCUIT_TITLE = 'Quirk: Quantum Circuit Simulator';
  Config.MAX_WIRE_COUNT = 16;
  Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD = 14;
  Config.MIN_WIRE_COUNT = 2;
  Config.MIN_COL_COUNT = 5;
  Config.URL_CIRCUIT_PARAM_KEY = 'circuit';
  Config.GATE_FILL_COLOR = 'white';
  Config.HIGHLIGHTED_GATE_FILL_COLOR = '#FB7';
  Config.TIME_DEPENDENT_HIGHLIGHT_COLOR = '#FFC';
  Config.DISPLAY_GATE_IN_TOOLBOX_FILL_COLOR = '#4F4';
  Config.DISPLAY_GATE_BACK_COLOR = '#EFE';
  Config.DISPLAY_GATE_FORE_COLOR = '#3F3';
  Config.OPERATION_BACK_COLOR = '#FFE';
  Config.OPERATION_FORE_COLOR = '#FF0';
  Config.SUPERPOSITION_BACK_COLOR = '#EFF';
  Config.SUPERPOSITION_MID_COLOR = '#8FF';
  Config.SUPERPOSITION_FORE_COLOR = '#0BB';
  Config.CYCLE_DURATION_MS = 8000;
  Config.TIME_CACHE_GRANULARITY = 196;
  Config.REDRAW_COOLDOWN_MILLIS = 10;
  Config.GATE_RADIUS = 20;
  Config.WIRE_SPACING = 50;
  Config.BACKGROUND_COLOR = 'white';
  Config.BACKGROUND_COLOR_CIRCUIT = 'white';
  Config.BACKGROUND_COLOR_TOOLBOX = '#CCC';
  Config.TOOLBOX_GATE_SPACING = 2;
  Config.TOOLBOX_GROUP_SPACING = 24 - Config.TOOLBOX_GATE_SPACING;
  Config.TOOLBOX_GATE_SPAN = Config.GATE_RADIUS * 2 + Config.TOOLBOX_GATE_SPACING;
  Config.TOOLBOX_GROUP_SPAN = Config.TOOLBOX_GATE_SPAN * 2 + Config.TOOLBOX_GROUP_SPACING;
  Config.TOOLBOX_MARGIN_X = 35;
  Config.TOOLBOX_MARGIN_Y = 18;
  Config.MINIMUM_CANVAS_HEIGHT = 400;
  Config.SUPPRESSED_GLSL_WARNING_PATTERNS = [];
  Config.DEFAULT_FILL_COLOR = 'white';
  Config.DEFAULT_STROKE_COLOR = 'black';
  Config.DEFAULT_TEXT_COLOR = 'black';
  Config.DEFAULT_FONT_SIZE = 12;
  Config.DEFAULT_FONT_FAMILY = 'sans-serif';
  Config.DEFAULT_STROKE_THICKNESS = 1;
  Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS = false;
  Config.SEMI_STABLE_RANDOM_VALUE_LIFETIME_MILLIS = 300;
  Config.IGNORED_WEBGL_INFO_TERMS = [];
  return {get Config() {
      return Config;
    }};
});
//# sourceURL=src/Config.js
;$traceurRuntime.registerModule("src/draw/CachablePainting.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/CachablePainting.js";
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Painter.js", "src/draw/CachablePainting.js")).Painter;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/RestartableRng.js", "src/draw/CachablePainting.js")).RestartableRng;
  var fixedRng = new RestartableRng();
  var CachablePainting = function() {
    function CachablePainting(sizeFunc, drawingFunc) {
      this.sizeFunc = sizeFunc;
      this._drawingFunc = drawingFunc;
      this._cachedCanvases = new Map();
    }
    return ($traceurRuntime.createClass)(CachablePainting, {paint: function(x, y, painter) {
        var key = arguments[3];
        if (!this._cachedCanvases.has(key)) {
          var canvas = document.createElement('canvas');
          var $__1 = this.sizeFunc(key),
              width = $__1.width,
              height = $__1.height;
          canvas.width = width;
          canvas.height = height;
          this._drawingFunc(new Painter(canvas, fixedRng.restarted()), key);
          this._cachedCanvases.set(key, canvas);
        }
        painter.ctx.drawImage(this._cachedCanvases.get(key), x, y);
      }}, {});
  }();
  return {get CachablePainting() {
      return CachablePainting;
    }};
});
//# sourceURL=src/draw/CachablePainting.js
;$traceurRuntime.registerModule("src/draw/GateDrawParams.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/GateDrawParams.js";
  var GateDrawParams = function() {
    function GateDrawParams(painter, hand, isInToolbox, isHighlighted, isResizeShowing, isResizeHighlighted, rect, gate, stats, positionInCircuit, focusPoints, customStatsForCircuitPos) {
      this.painter = painter;
      this.hand = hand;
      this.isInToolbox = isInToolbox;
      this.isHighlighted = isHighlighted;
      this.isResizeShowing = isResizeShowing;
      this.isResizeHighlighted = isResizeHighlighted;
      this.rect = rect;
      this.gate = gate;
      this.stats = stats;
      this.positionInCircuit = positionInCircuit;
      this.focusPoints = focusPoints;
      this.customStats = customStatsForCircuitPos;
    }
    return ($traceurRuntime.createClass)(GateDrawParams, {getGateContext: function(key) {
        if (this.positionInCircuit === undefined) {
          return undefined;
        }
        return this.stats.circuitDefinition.colCustomContextFromGates(this.positionInCircuit.col, 0).get(key);
      }}, {});
  }();
  return {get GateDrawParams() {
      return GateDrawParams;
    }};
});
//# sourceURL=src/draw/GateDrawParams.js
;$traceurRuntime.registerModule("src/draw/GatePainting.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/GatePainting.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/draw/GatePainting.js")).Config;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GateDrawParams.js", "src/draw/GatePainting.js")).GateDrawParams;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MathPainter.js", "src/draw/GatePainting.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/draw/GatePainting.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/draw/GatePainting.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/draw/GatePainting.js")).Util;
  var GatePainting = function() {
    function GatePainting() {}
    return ($traceurRuntime.createClass)(GatePainting, {}, {});
  }();
  var GATE_SYMBOL_FONT = '16px sans-serif';
  GatePainting.paintOutline = function(args) {
    if (args.isInToolbox) {
      var r = args.rect.shiftedBy(0.5, 0.5);
      args.painter.strokeLine(r.topRight(), r.bottomRight());
      args.painter.strokeLine(r.bottomLeft(), r.bottomRight());
    }
    args.painter.strokeRect(args.rect, 'black');
  };
  GatePainting.paintBackground = function(args) {
    var toolboxFillColor = arguments[1] !== (void 0) ? arguments[1] : Config.GATE_FILL_COLOR;
    var normalFillColor = arguments[2] !== (void 0) ? arguments[2] : Config.GATE_FILL_COLOR;
    var backColor = args.isInToolbox ? toolboxFillColor : normalFillColor;
    if (args.isHighlighted) {
      backColor = Config.HIGHLIGHTED_GATE_FILL_COLOR;
    }
    args.painter.fillRect(args.rect, backColor);
  };
  GatePainting.LABEL_DRAWER = function(args) {
    if (args.positionInCircuit === undefined || args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    var cut = Math.max(0, args.rect.h - Config.GATE_RADIUS * 2) / 2;
    args.painter.fillRect(args.rect.skipTop(cut).skipBottom(cut), Config.GATE_FILL_COLOR);
    GatePainting.paintGateSymbol(args);
  };
  GatePainting.MAKE_HIGHLIGHTED_DRAWER = function() {
    var toolboxFillColor = arguments[0] !== (void 0) ? arguments[0] : Config.GATE_FILL_COLOR;
    var normalFillColor = arguments[1] !== (void 0) ? arguments[1] : Config.GATE_FILL_COLOR;
    return function(args) {
      GatePainting.paintBackground(args, toolboxFillColor, normalFillColor);
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
      GatePainting.paintGateSymbol(args);
    };
  };
  GatePainting.DEFAULT_DRAWER = GatePainting.MAKE_HIGHLIGHTED_DRAWER();
  GatePainting.rectForResizeTab = function(gateRect) {
    var overlap = Math.min(Config.GATE_RADIUS, gateRect.h / 4);
    return new Rect(gateRect.x, gateRect.bottom() - overlap, gateRect.w, Config.GATE_RADIUS * 2);
  };
  GatePainting.paintResizeTab = function(args) {
    if (!args.isResizeShowing || !args.gate.canChangeInSize()) {
      return;
    }
    var d = Config.GATE_RADIUS;
    var rect = GatePainting.rectForResizeTab(args.rect);
    var trimRect = rect.skipLeft(2).skipRight(2);
    var $__16 = trimRect.center(),
        cx = $__16.x,
        cy = $__16.y;
    var backColor = args.isResizeHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR;
    var foreColor = args.isResizeHighlighted ? '#222' : 'gray';
    args.painter.ctx.save();
    args.painter.ctx.globalAlpha *= args.isResizeHighlighted ? 1 : 0.7;
    args.painter.fillRect(trimRect, backColor);
    args.painter.strokeRect(trimRect, 'gray');
    args.painter.ctx.restore();
    args.painter.print('resize', cx, cy, 'center', 'middle', foreColor, 'monospace', trimRect.w - 4, trimRect.h - 4);
    args.painter.trace(function(tracer) {
      var arrowDirs = [args.gate.canIncreaseInSize() ? +1 : -1, args.gate.canDecreaseInSize() ? -1 : +1];
      var arrowOffsets = [+1, -1];
      var $__5 = true;
      var $__6 = false;
      var $__7 = undefined;
      try {
        for (var $__3 = void 0,
            $__2 = ([-1, +1])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
          var sx = $__3.value;
          {
            for (var k = 0; k < 2; k++) {
              var by = cy + d * arrowOffsets[k] * 5 / 8;
              var y1 = by + d * arrowDirs[k] / 8;
              var y2 = by - d * arrowDirs[k] / 8;
              tracer.line(cx, y1, cx + d * sx * 0.3, y2);
            }
          }
        }
      } catch ($__8) {
        $__6 = true;
        $__7 = $__8;
      } finally {
        try {
          if (!$__5 && $__2.return != null) {
            $__2.return();
          }
        } finally {
          if ($__6) {
            throw $__7;
          }
        }
      }
    }).thenStroke(foreColor);
  };
  GatePainting.paintGateSymbol = function(args) {
    var $__18,
        $__19;
    var symbolOverride = arguments[1];
    var allowExponent = arguments[2] !== (void 0) ? arguments[2] : true;
    var painter = args.painter;
    var rect = args.rect.paddedBy(-2);
    if (symbolOverride === undefined) {
      symbolOverride = args.gate.symbol;
    }
    var $__16 = _paintSymbolHandleLines(args.painter, symbolOverride, rect),
        symbol = $__16.symbol,
        offsetY = $__16.offsetY;
    painter.ctx.font = GATE_SYMBOL_FONT;
    var splitIndex = allowExponent ? symbol.indexOf('^') : -1;
    var parts = splitIndex === -1 ? [symbol] : [symbol.substr(0, splitIndex), symbol.substr(splitIndex + 1)];
    if (parts.length !== 2 || parts[0] === "" || parts[1] === "") {
      painter.print(symbol, rect.x + rect.w / 2, rect.y + rect.h / 2 + offsetY, 'center', 'middle', 'black', GATE_SYMBOL_FONT, rect.w, rect.h);
      return;
    }
    var $__17 = parts,
        baseText = ($__18 = $__17[Symbol.iterator](), ($__19 = $__18.next()).done ? void 0 : $__19.value),
        expText = ($__19 = $__18.next()).done ? void 0 : $__19.value;
    var lines = baseText.split('\n');
    baseText = lines[0];
    var baseWidth = painter.ctx.measureText(baseText).width;
    var expWidth = painter.ctx.measureText(expText).width;
    var scaleDown = Math.min(rect.w, baseWidth + expWidth) / (baseWidth + expWidth);
    var divider = rect.w / 2 + (baseWidth - expWidth) * scaleDown / 2;
    painter.print(baseText, rect.x + divider, rect.y + rect.h / 2 + offsetY, 'right', 'hanging', 'black', GATE_SYMBOL_FONT, divider, rect.h);
    painter.print(expText, rect.x + divider, rect.y + rect.h / 2 + offsetY, 'left', 'alphabetic', 'black', GATE_SYMBOL_FONT, rect.w - divider, rect.h);
  };
  function _paintSymbolHandleLines(painter, symbol, rect) {
    var lines = symbol.split('\n');
    for (var i = 1; i < lines.length; i++) {
      painter.print(lines[i], rect.x + rect.w / 2, rect.y + rect.h / 2 + 9 * i, 'center', 'hanging', 'black', GATE_SYMBOL_FONT, rect.w, 16);
    }
    return {
      symbol: lines[0],
      offsetY: lines.length > 1 ? -5 : 0
    };
  }
  GatePainting.traceLocationIndependentOutline = function(args, tracer) {
    var $__17,
        $__18;
    var $__16 = [args.rect.x, args.rect.right(), args.rect.y, args.rect.bottom()],
        x1 = ($__17 = $__16[Symbol.iterator](), ($__18 = $__17.next()).done ? void 0 : $__18.value),
        x2 = ($__18 = $__17.next()).done ? void 0 : $__18.value,
        y1 = ($__18 = $__17.next()).done ? void 0 : $__18.value,
        y2 = ($__18 = $__17.next()).done ? void 0 : $__18.value;
    var diameter = Math.min(args.rect.h, args.rect.w, Config.GATE_RADIUS * 2);
    var clip = diameter / (2 + Math.sqrt(2));
    tracer.polygon([x1, y1 + clip, x1 + clip, y1, x2 - clip, y1, x2, y1 + clip, x2, y2 - clip, x2 - clip, y2, x1 + clip, y2, x1, y2 - clip]);
  };
  GatePainting.paintLocationIndependentFrame = function(args) {
    var normalFillColor = arguments[1] !== (void 0) ? arguments[1] : Config.GATE_FILL_COLOR;
    var toolboxFillColor = arguments[2] !== (void 0) ? arguments[2] : Config.GATE_FILL_COLOR;
    if (args.isInToolbox) {
      GatePainting.paintBackground(args, toolboxFillColor, normalFillColor);
      GatePainting.paintOutline(args);
      return;
    }
    var backColor = args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : normalFillColor;
    args.painter.trace(function(tracer) {
      return GatePainting.traceLocationIndependentOutline(args, tracer);
    }).thenFill(backColor).thenStroke('black');
  };
  GatePainting.makeLocationIndependentGateDrawer = function(normalFillColor) {
    return function(args) {
      GatePainting.paintLocationIndependentFrame(args, normalFillColor);
      GatePainting.paintGateSymbol(args);
    };
  };
  GatePainting.LOCATION_INDEPENDENT_GATE_DRAWER = GatePainting.makeLocationIndependentGateDrawer(Config.GATE_FILL_COLOR);
  GatePainting.SECTIONED_DRAWER_MAKER = function(labels, dividers) {
    return function(args) {
      if (args.isInToolbox) {
        GatePainting.DEFAULT_DRAWER(args);
        return;
      }
      var backColor = args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR;
      var font = '16px sans-serif';
      args.painter.fillRect(args.rect, backColor);
      var p = 0;
      for (var i = 0; i < labels.length; i++) {
        var p2 = void 0;
        if (i < labels.length - 1) {
          p2 = p + dividers[i];
          var cy = args.rect.y + args.rect.h * p2;
          args.painter.strokeLine(new Point(args.rect.x, cy), new Point(args.rect.right(), cy), '#BBB');
        } else {
          p2 = 1;
        }
        args.painter.print(labels[i], args.rect.x + args.rect.w / 2, args.rect.y + args.rect.h * (p + p2) / 2, 'center', 'middle', 'black', font, args.rect.w - 2, args.rect.h * (p2 - p));
        p = p2;
      }
      args.painter.strokeRect(args.rect);
      GatePainting.paintResizeTab(args);
    };
  };
  var DISPLAY_GATE_DEFAULT_DRAWER = GatePainting.MAKE_HIGHLIGHTED_DRAWER(Config.DISPLAY_GATE_IN_TOOLBOX_FILL_COLOR);
  GatePainting.makeDisplayDrawer = function(statePainter) {
    return function(args) {
      if (args.positionInCircuit === undefined) {
        DISPLAY_GATE_DEFAULT_DRAWER(args);
        return;
      }
      GatePainting.paintResizeTab(args);
      statePainter(args);
      if (args.isHighlighted) {
        args.painter.strokeRect(args.rect, 'black', 1.5);
      }
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.25;
      GatePainting.paintResizeTab(args);
      args.painter.ctx.restore();
    };
  };
  GatePainting.MATRIX_DRAWER = function(args) {
    var m = args.gate.knownMatrixAt(args.stats.time);
    if (m === undefined) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    args.painter.fillRect(args.rect, args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR);
    MathPainter.paintMatrix(args.painter, m, args.rect, Config.OPERATION_FORE_COLOR, 'black', undefined, Config.OPERATION_BACK_COLOR, undefined, 'transparent');
    if (args.isHighlighted) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.9;
      args.painter.fillRect(args.rect, Config.HIGHLIGHTED_GATE_FILL_COLOR);
      args.painter.ctx.restore();
    }
    GatePainting.paintOutline(args);
  };
  GatePainting.makeCycleDrawer = function() {
    var xScale = arguments[0] !== (void 0) ? arguments[0] : 1;
    var yScale = arguments[1] !== (void 0) ? arguments[1] : 1;
    var tScale = arguments[2] !== (void 0) ? arguments[2] : 1;
    var zeroAngle = arguments[3] !== (void 0) ? arguments[3] : 0;
    return function(args) {
      GatePainting.MAKE_HIGHLIGHTED_DRAWER(Config.TIME_DEPENDENT_HIGHLIGHT_COLOR)(args);
      if (args.isInToolbox && !args.isHighlighted) {
        return;
      }
      GatePainting.paintCycleState(args, args.stats.time * 2 * Math.PI * tScale, xScale, yScale, zeroAngle);
    };
  };
  GatePainting.paintCycleState = function(args, angle) {
    var xScale = arguments[2] !== (void 0) ? arguments[2] : 1;
    var yScale = arguments[3] !== (void 0) ? arguments[3] : 1;
    var zeroAngle = arguments[4] !== (void 0) ? arguments[4] : 0;
    var t = Util.properMod(-angle, 2 * Math.PI);
    var c = args.rect.center();
    var r = 16;
    args.painter.ctx.save();
    args.painter.ctx.translate(c.x, c.y);
    args.painter.ctx.scale(-xScale, -yScale);
    args.painter.ctx.rotate(zeroAngle);
    args.painter.ctx.strokeStyle = 'black';
    args.painter.ctx.fillStyle = 'yellow';
    args.painter.ctx.globalAlpha *= 0.4;
    args.painter.ctx.beginPath();
    args.painter.ctx.moveTo(0, 0);
    args.painter.ctx.lineTo(0, r);
    args.painter.ctx.arc(0, 0, r, Math.PI / 2, Math.PI / 2 + t, true);
    args.painter.ctx.lineTo(0, 0);
    args.painter.ctx.closePath();
    args.painter.ctx.stroke();
    args.painter.ctx.fill();
    args.painter.ctx.restore();
  };
  GatePainting.MATRIX_SYMBOL_DRAWER_EXCEPT_IN_TOOLBOX = function(args) {
    if (args.isInToolbox) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    GatePainting.MATRIX_DRAWER(args);
  };
  function _wireY(args, offset) {
    return args.rect.center().y + (offset - args.gate.height / 2 + 0.5) * Config.WIRE_SPACING;
  }
  GatePainting.gateButtonRect = function(wholeRect) {
    if (wholeRect.h > 50) {
      return wholeRect.bottomHalf().skipTop(6).paddedBy(-7);
    }
    return wholeRect.bottomHalf().paddedBy(+2);
  };
  GatePainting.paintGateButton = function(args) {
    if (!args.isHighlighted || args.isInToolbox || args.hand.isHoldingSomething()) {
      return;
    }
    var buttonRect = GatePainting.gateButtonRect(args.rect);
    var buttonFocus = !args.focusPoints.every(function(pt) {
      return !buttonRect.containsPoint(pt);
    });
    args.painter.fillRect(buttonRect, buttonFocus ? 'red' : 'orange');
    args.painter.print('change', buttonRect.center().x, buttonRect.center().y, 'center', 'middle', 'black', '12px sans-serif', buttonRect.w, buttonRect.h);
    args.painter.strokeRect(buttonRect, 'black');
  };
  function _eraseWiresForPermutation(args) {
    for (var i = 0; i < args.gate.height; i++) {
      var y = _wireY(args, i);
      var p = new Point(args.rect.x, y);
      var c = new Point(args.rect.x + Config.GATE_RADIUS, y);
      var q = new Point(args.rect.right(), y);
      var loc = new Point(args.positionInCircuit.col, args.positionInCircuit.row + i);
      var isMeasured1 = args.stats.circuitDefinition.locIsMeasured(loc);
      var isMeasured2 = args.stats.circuitDefinition.locIsMeasured(loc.offsetBy(1, 0));
      var $__5 = true;
      var $__6 = false;
      var $__7 = undefined;
      try {
        for (var $__3 = void 0,
            $__2 = (isMeasured1 ? [-1, +1] : [0])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
          var dy = $__3.value;
          {
            args.painter.strokeLine(p.offsetBy(0, dy), c.offsetBy(1, dy), 'white');
          }
        }
      } catch ($__8) {
        $__6 = true;
        $__7 = $__8;
      } finally {
        try {
          if (!$__5 && $__2.return != null) {
            $__2.return();
          }
        } finally {
          if ($__6) {
            throw $__7;
          }
        }
      }
      var $__12 = true;
      var $__13 = false;
      var $__14 = undefined;
      try {
        for (var $__10 = void 0,
            $__9 = (isMeasured2 ? [-1, +1] : [0])[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
          var dy$__20 = $__10.value;
          {
            args.painter.strokeLine(c.offsetBy(-1, dy$__20), q.offsetBy(0, dy$__20), 'white');
          }
        }
      } catch ($__15) {
        $__13 = true;
        $__14 = $__15;
      } finally {
        try {
          if (!$__12 && $__9.return != null) {
            $__9.return();
          }
        } finally {
          if ($__13) {
            throw $__14;
          }
        }
      }
    }
  }
  GatePainting.PERMUTATION_DRAWER = function(args) {
    var $__17,
        $__18;
    if (args.positionInCircuit === undefined) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    if (args.isHighlighted || args.isResizeHighlighted || args.stats.circuitDefinition.colHasControls(args.positionInCircuit.col)) {
      GatePainting.paintBackground(args, '#F3F3F3', '#F3F3F3');
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
    } else {
      _eraseWiresForPermutation(args);
    }
    var x1 = args.rect.x;
    var x2 = args.rect.right();
    args.painter.ctx.strokeStyle = 'black';
    for (var i = 0; i < args.gate.height; i++) {
      var j = args.gate.knownBitPermutationFunc(i);
      var pt = new Point(args.positionInCircuit.col, args.positionInCircuit.row + i);
      var isMeasured = args.stats.circuitDefinition.locIsMeasured(pt);
      var y1 = _wireY(args, i);
      var y2 = _wireY(args, j);
      args.painter.ctx.beginPath();
      var $__5 = true;
      var $__6 = false;
      var $__7 = undefined;
      try {
        for (var $__3 = void 0,
            $__2 = (isMeasured ? [[j > i ? +1 : -1, -1], [0, +1]] : [[0, 0]])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
          var $__16 = $__3.value,
              dx = ($__17 = $__16[Symbol.iterator](), ($__18 = $__17.next()).done ? void 0 : $__18.value),
              dy = ($__18 = $__17.next()).done ? void 0 : $__18.value;
          {
            args.painter.ctx.moveTo(Math.min(x1, x1 + dx), y1 + dy);
            args.painter.ctx.lineTo(x1 + dx, y1 + dy);
            args.painter.ctx.lineTo(x2 + dx, y2 + dy);
            args.painter.ctx.lineTo(Math.max(x2, x2 + dx), y2 + dy);
          }
        }
      } catch ($__8) {
        $__6 = true;
        $__7 = $__8;
      } finally {
        try {
          if (!$__5 && $__2.return != null) {
            $__2.return();
          }
        } finally {
          if ($__6) {
            throw $__7;
          }
        }
      }
      args.painter.ctx.stroke();
    }
  };
  return {get GatePainting() {
      return GatePainting;
    }};
});
//# sourceURL=src/draw/GatePainting.js
;$traceurRuntime.registerModule("src/draw/MathPainter.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/MathPainter.js";
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Painter.js", "src/draw/MathPainter.js")).Painter;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/draw/MathPainter.js")).Format;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/draw/MathPainter.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/draw/MathPainter.js")).Rect;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/draw/MathPainter.js")),
      seq = $__17.seq,
      Seq = $__17.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/draw/MathPainter.js")).Util;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/draw/MathPainter.js")).Config;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/draw/MathPainter.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/draw/MathPainter.js")).Matrix;
  var MathPainter = function() {
    function MathPainter() {}
    return ($traceurRuntime.createClass)(MathPainter, {}, {
      describeProbability: function(p, fractionalDigits) {
        var v = p * 100;
        var e = Math.pow(10, -fractionalDigits);
        if (v > 100 - e / 2) {
          return "On";
        }
        if (v < e / 2) {
          return "Off";
        }
        return Math.min(Math.max(v, e), 100 - e).toFixed(fractionalDigits) + "%";
      },
      paintProbabilityBox: function(painter, probability, drawArea) {
        var focusPoints = arguments[3] !== (void 0) ? arguments[3] : [];
        var backgroundColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_BACK_COLOR;
        var fillColor = arguments[5] !== (void 0) ? arguments[5] : Config.DISPLAY_GATE_FORE_COLOR;
        painter.fillRect(drawArea, backgroundColor);
        var cen = drawArea.center();
        if (isNaN(probability)) {
          painter.fillPolygon([drawArea.bottomLeft(), drawArea.topLeft(), drawArea.topRight()], fillColor);
          painter.print("NaN", cen.x, cen.y, 'center', 'middle', 'red', '9pt sans-serif', drawArea.w, drawArea.h);
        } else {
          painter.fillRect(drawArea.takeBottomProportion(probability), fillColor);
          painter.print(MathPainter.describeProbability(probability, 1), cen.x, cen.y, 'center', 'middle', 'black', '9pt sans-serif', drawArea.w, drawArea.h);
        }
        painter.strokeRect(drawArea, 'lightgray');
        if (seq(focusPoints).any(function(pt) {
          return drawArea.containsPoint(pt);
        })) {
          painter.strokeRect(drawArea, 'orange', 2);
          MathPainter.paintDeferredValueTooltip(painter, drawArea.right(), drawArea.y, 'Chance of being ON if measured', (100 * probability).toFixed(5) + "%");
        }
      },
      paintMatrixTooltip: function(painter, matrix, drawArea, focusPoints, titleFunc, valueTextFunc1) {
        var valueTextFunc2 = arguments[6] !== (void 0) ? arguments[6] : function() {
          return undefined;
        };
        var numCols = matrix.width();
        var numRows = matrix.height();
        var $__9 = drawArea,
            x = $__9.x,
            y = $__9.y;
        var diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (focusPoints)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var pt = $__3.value;
            {
              var c = Math.floor((pt.x - x) / diam);
              var r = Math.floor((pt.y - y) / diam);
              if (c >= 0 && c < matrix.width() && r >= 0 && r < matrix.height()) {
                painter.strokeRect(new Rect(x + diam * c, y + diam * r, diam, diam), 'orange', 2);
                var v = matrix.cell(c, r);
                MathPainter.paintDeferredValueTooltip(painter, x + diam * c + diam, y + diam * r, titleFunc(c, r), valueTextFunc1(c, r, v), valueTextFunc2(c, r, v));
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      },
      _traceAmplitudeProbabilitySquare: function(trace, real, imag, x, y, d) {
        var p = real * real + imag * imag;
        if (p > 0.001) {
          trace.polygon([x, y + d * (1 - p), x + d, y + d * (1 - p), x + d, y + d, x, y + d]);
        }
      },
      _traceProbabilitySquare: function(trace, real, imag, x, y, d) {
        var p = real;
        if (d * p > 0.1) {
          trace.polygon([x, y + d * (1 - p), x + d, y + d * (1 - p), x + d, y + d, x, y + d]);
        }
      },
      _traceAmplitudeProbabilityCircle: function(trace, real, imag, x, y, d) {
        var mag = Math.sqrt(real * real + imag * imag);
        if (d * mag > 0.5) {
          trace.circle(x + d / 2, y + d / 2, mag * d / 2);
        }
      },
      _traceAmplitudeLogarithmCircle: function(trace, real, imag, x, y, d) {
        var g = 1 + Math.log(real * real + imag * imag) / 15;
        if (g > 0) {
          trace.circle(x + d / 2, y + d / 2, g * d / 2);
        }
      },
      _traceAmplitudePhaseDirection: function(trace, real, imag, x, y, d) {
        var mag = Math.sqrt(real * real + imag * imag);
        var g = 1 + Math.log(mag) / 10;
        var r = Math.max(1, g / mag) * Math.max(d / 2, 5);
        if (r < 0.1) {
          return;
        }
        var cx = x + d / 2;
        var cy = y + d / 2;
        trace.line(cx, cy, cx + real * r, cy - imag * r);
      },
      paintMatrix: function(painter, matrix, drawArea, amplitudeCircleFillColor, amplitudeCircleStrokeColor, amplitudeProbabilityFillColor) {
        var backColor = arguments[6] !== (void 0) ? arguments[6] : Config.DISPLAY_GATE_BACK_COLOR;
        var amplitudePhaseStrokeColor = arguments[7];
        var logCircleStrokeColor = arguments[8] !== (void 0) ? arguments[8] : '#AAA';
        var numCols = matrix.width();
        var numRows = matrix.height();
        var buf = matrix.rawBuffer();
        var diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        drawArea = drawArea.withW(diam * numCols).withH(diam * numRows);
        var $__9 = drawArea,
            x = $__9.x,
            y = $__9.y;
        var hasNaN = matrix.hasNaN();
        amplitudePhaseStrokeColor = amplitudePhaseStrokeColor || amplitudeCircleStrokeColor;
        painter.fillRect(drawArea, backColor);
        var traceCellsWith = function(cellTraceFunc) {
          return painter.trace(function(trace) {
            for (var row = 0; row < numRows; row++) {
              for (var col = 0; col < numCols; col++) {
                var k = (row * numCols + col) * 2;
                cellTraceFunc(trace, buf[k], buf[k + 1], x + diam * col, y + diam * row, diam);
              }
            }
          });
        };
        if (!hasNaN) {
          if (amplitudeProbabilityFillColor !== undefined) {
            traceCellsWith(MathPainter._traceAmplitudeProbabilitySquare).thenFill(amplitudeProbabilityFillColor).thenStroke('lightgray', 0.5);
          }
          if (amplitudeCircleFillColor !== undefined) {
            traceCellsWith(MathPainter._traceAmplitudeProbabilityCircle).thenFill(amplitudeCircleFillColor).thenStroke(amplitudeCircleStrokeColor, 0.5);
            traceCellsWith(MathPainter._traceAmplitudeLogarithmCircle).thenStroke(logCircleStrokeColor, 0.5);
          }
        }
        painter.trace(function(trace) {
          return trace.grid(x, y, drawArea.w, drawArea.h, numCols, numRows);
        }).thenStroke('lightgray');
        if (!hasNaN) {
          if (logCircleStrokeColor !== undefined) {
            traceCellsWith(MathPainter._traceAmplitudePhaseDirection).thenStroke(amplitudePhaseStrokeColor);
          }
        }
        if (hasNaN) {
          painter.print('NaN', drawArea.x + drawArea.w / 2, drawArea.y + drawArea.h / 2, 'center', 'middle', 'red', '16px sans-serif', drawArea.w, drawArea.h);
        }
      },
      paintDeferredValueTooltip: function(painter, x, y, labelText, valueText) {
        var valueText2 = arguments[5];
        var backColor = arguments[6] !== (void 0) ? arguments[6] : Config.DISPLAY_GATE_BACK_COLOR;
        var labelFont = '12px sans-serif';
        var valueFont = 'bold 12px monospace';
        painter.defer(function() {
          painter.ctx.font = labelFont;
          var width1 = painter.ctx.measureText(labelText).width;
          painter.ctx.font = valueFont;
          var width2 = painter.ctx.measureText(valueText).width;
          var width3 = valueText2 === undefined ? 0 : painter.ctx.measureText(valueText2).width;
          var lineHeight = 20;
          var height = 40 + (valueText2 === undefined ? 0 : 20);
          var width = Math.max(Math.max(width1, width2), width3);
          var boundingRect = new Rect(x, y - height, width, height).snapInside(new Rect(0, 0, painter.ctx.canvas.clientWidth, painter.ctx.canvas.clientHeight));
          var borderPainter = function(w, h) {
            var r = new Rect(boundingRect.x, boundingRect.bottom() - h, w, h).paddedBy(4);
            painter.trace(function(tracer) {
              return tracer.rect(r.x, r.y, r.w, r.h);
            }).thenFill(backColor).thenStroke('black');
          };
          var labelPainter = function(w, h) {
            painter.print(labelText, boundingRect.x, boundingRect.bottom() - h, 'left', 'bottom', 'black', labelFont, boundingRect.w, lineHeight, function(w2, h2) {
              return borderPainter(Math.max(w, w2), h + h2);
            });
          };
          var value1Painter = function(w, h) {
            painter.print(valueText, boundingRect.x, boundingRect.bottom() - h, 'left', 'bottom', 'black', valueFont, boundingRect.w, lineHeight, function(w2, h2) {
              return labelPainter(Math.max(w, w2), h + h2);
            });
          };
          if (valueText2 === undefined) {
            value1Painter(0, 0);
          } else {
            painter.print(valueText2, boundingRect.x, boundingRect.bottom(), 'left', 'bottom', 'black', valueFont, boundingRect.w, lineHeight, value1Painter);
          }
        });
      },
      coordinateSystem: function(unit) {
        return {
          dx: new Point(unit / 3, -unit / 3),
          dy: new Point(unit, 0),
          dz: new Point(0, unit)
        };
      },
      paintBlochSphereRotation: function(painter, operation, drawArea) {
        var $__11;
        var backgroundColor = arguments[3] !== (void 0) ? arguments[3] : Config.DISPLAY_GATE_BACK_COLOR;
        var fillColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_FORE_COLOR;
        var c = drawArea.center();
        var u = Math.min(drawArea.w, drawArea.h) / 2;
        var $__9 = MathPainter.coordinateSystem(u),
            dx = $__9.dx,
            dy = $__9.dy,
            dz = $__9.dz;
        var projMatrix = Matrix.fromRows([[-dx.x, -dx.y], [dy.x, dy.y], [-dz.x, -dz.y]]).adjoint();
        var projToPt = function(col) {
          var p = projMatrix.times(col);
          return new Point(p.cell(0, 0).real, p.cell(0, 1).real);
        };
        var axes = Seq.range(3).map(function(i) {
          return Matrix.generate(1, 3, function(r, _) {
            return r === i ? 1 : 0;
          });
        }).toArray();
        painter.fillCircle(c, u, backgroundColor);
        painter.trace(function(trace) {
          trace.circle(c.x, c.y, u);
          trace.ellipse(c.x, c.y, u, u / 3);
          trace.ellipse(c.x, c.y, u / 3, u);
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (axes)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var a = $__3.value;
              {
                var d = projToPt(a);
                trace.line(c.x - d.x, c.y - d.y, c.x + d.x, c.y + d.y);
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }).thenStroke('#BBB');
        var $__10 = operation.qubitOperationToAngleAxisRotation(),
            angle = $__10.angle,
            axis = $__10.axis;
        var axisVec = ($__11 = Matrix).col.apply($__11, $traceurRuntime.spread(axis));
        var dAxis = projToPt(axisVec);
        var guideDeltas = [Matrix.col(axis[0], axis[1], 0), axisVec, Matrix.col(0, 0, axis[2])].map(projToPt);
        painter.strokePolygon(seq(guideDeltas).reverse().concat(guideDeltas.map(function(d) {
          return d.times(-1);
        })).map(function(d) {
          return c.plus(d);
        }).toArray(), '#666');
        painter.strokeLine(c.plus(dAxis), c.plus(dAxis.times(-1)), 'black', 2);
        var norm = function(e) {
          return Math.sqrt(e.adjoint().times(e).cell(0, 0).real);
        };
        var perpVec1 = seq(axes).mapWithIndex(function(a, i) {
          return a.times([-3, -2, 1][i]);
        }).map(function(a) {
          return axisVec.cross3(a);
        }).maxBy(norm);
        var perpVec2 = axisVec.cross3(perpVec1);
        perpVec1 = perpVec1.times(0.15 / norm(perpVec1));
        perpVec2 = perpVec2.times(0.15 / norm(perpVec2));
        var dPerp1 = projToPt(perpVec1);
        var dPerp2 = projToPt(perpVec2);
        MathPainter._paintBlochSphereRotation_rotationGuideArrows(painter, c, angle, dAxis, dPerp1, dPerp2, fillColor);
      },
      _paintBlochSphereRotation_rotationGuideArrows: function(painter, center, angle, dAlong, dPerp1, dPerp2, fillColor) {
        var rotationGuideDeltas = Seq.range(Math.floor(Math.abs(angle) * 32)).map(function(i) {
          var θ = (angle < 0 ? Math.PI - i / 32 : i / 32);
          return dPerp1.times(Math.cos(θ)).plus(dPerp2.times(Math.sin(θ)));
        }).toArray();
        if (rotationGuideDeltas.length <= 1) {
          return;
        }
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          var $__12 = function() {
            var offsetFactor = $__3.value;
            {
              var offsetCenter = center.plus(dAlong.times(offsetFactor));
              var arcPts = rotationGuideDeltas.map(function(d) {
                return offsetCenter.plus(d);
              });
              var arrowHeadRoot = arcPts[arcPts.length - 1];
              var arrowHeadDirection = arrowHeadRoot.plus(arcPts[arcPts.length - 2].times(-1));
              var arrowHeadPts = [dAlong.times(0.15), arrowHeadDirection.times(30), dAlong.times(-0.15)].map(function(d) {
                return arrowHeadRoot.plus(d);
              });
              var interleaved = [].concat.apply([], arrowHeadPts.map(function(e) {
                return [e.x, e.y];
              }));
              painter.strokePath(arcPts, '#444');
              painter.trace(function(tracer) {
                return tracer.polygon(interleaved);
              }).thenFill(fillColor).thenStroke('#444');
            }
          };
          for (var $__3 = void 0,
              $__2 = ([-0.55, 0, 0.55])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            $__12();
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      },
      paintDensityMatrix: function(painter, matrix, drawArea) {
        var focusPoints = arguments[3] !== (void 0) ? arguments[3] : [];
        var backgroundColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_BACK_COLOR;
        var fillColor = arguments[5] !== (void 0) ? arguments[5] : Config.DISPLAY_GATE_FORE_COLOR;
        var numCols = matrix.width();
        var numRows = matrix.height();
        var buf = matrix.rawBuffer();
        var diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        var x = drawArea.x;
        var y = drawArea.y;
        var hasNaN = matrix.hasNaN();
        var traceCouplingsWith = function(cellTraceFunc) {
          return painter.trace(function(trace) {
            for (var row = 0; row < numRows; row++) {
              for (var col = 0; col < numCols; col++) {
                var k = (row * numCols + col) * 2;
                cellTraceFunc(trace, buf[k], buf[k + 1], x + diam * col, y + diam * row, diam);
              }
            }
          });
        };
        var traceDiagonalWith = function(cellTraceFunc) {
          return painter.trace(function(trace) {
            for (var col = 0; col < numRows; col++) {
              var k = col * (numCols + 1) * 2;
              cellTraceFunc(trace, buf[k], buf[k + 1], x + diam * col, y + diam * col, diam);
            }
          });
        };
        painter.fillRect(drawArea, backgroundColor);
        if (!hasNaN) {
          traceDiagonalWith(MathPainter._traceProbabilitySquare).thenFill(fillColor).thenStroke('#040', 0.5);
          traceCouplingsWith(MathPainter._traceAmplitudeProbabilityCircle).thenFill(fillColor).thenStroke('#040', 0.5);
          traceCouplingsWith(MathPainter._traceAmplitudeLogarithmCircle).thenStroke('#BBB', 0.5);
          traceCouplingsWith(MathPainter._traceAmplitudePhaseDirection).thenStroke('black');
        }
        var d = drawArea.w / numCols;
        if (d > 2) {
          painter.trace(function(trace) {
            return trace.grid(x, y, drawArea.w, drawArea.h, numCols, numRows);
          }).thenStroke('lightgray', Math.min(1, 2 / Math.log(numCols)));
        } else {
          painter.ctx.save();
          painter.ctx.globalAlpha *= 0.2;
          painter.fillRect(drawArea, 'lightgray');
          painter.ctx.restore();
        }
        if (hasNaN) {
          painter.print('NaN', drawArea.x + drawArea.w / 2, drawArea.y + drawArea.h / 2, 'center', 'middle', 'red', '16px sans-serif', drawArea.w, drawArea.h);
        }
        var n = Math.round(Math.log2(numRows));
        MathPainter.paintMatrixTooltip(painter, matrix, drawArea, focusPoints, function(c, r) {
          return c === r ? ("Probability of |" + Util.bin(c, n) + "⟩ (decimal " + c + ")") : ("Coupling of |" + Util.bin(r, n) + "⟩ to ⟨" + Util.bin(c, n) + "| (decimal " + r + " to " + c + ")");
        }, function(c, r, v) {
          return c === r ? (matrix.cell(c, r).real * 100).toFixed(4) + "%" : matrix.cell(c, r).toString(new Format(false, 0, 6, ", "));
        });
      }
    });
  }();
  return {get MathPainter() {
      return MathPainter;
    }};
});
//# sourceURL=src/draw/MathPainter.js
;$traceurRuntime.registerModule("src/draw/Painter.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/Painter.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/draw/Painter.js")).Config;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/draw/Painter.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/draw/Painter.js")).Rect;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/RestartableRng.js", "src/draw/Painter.js")).RestartableRng;
  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/draw/Painter.js")),
      seq = $__15.seq,
      Seq = $__15.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/draw/Painter.js")).Util;
  var Painter = function() {
    function Painter(canvas) {
      var rng = arguments[1] !== (void 0) ? arguments[1] : new RestartableRng();
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d");
      this._deferredPaintActions = [];
      this._traceAction = new TraceAction(this.ctx);
      this._tracer = new Tracer(this.ctx);
      this.desiredCursorStyle = undefined;
      this.touchBlockers = [];
      this.rng = rng;
      this._ignoringTouchBlockers = 0;
    }
    return ($traceurRuntime.createClass)(Painter, {
      startIgnoringIncomingTouchBlockers: function() {
        this._ignoringTouchBlockers += 1;
      },
      stopIgnoringIncomingTouchBlockers: function() {
        this._ignoringTouchBlockers -= 1;
      },
      noteTouchBlocker: function(blocker) {
        if (this._ignoringTouchBlockers === 0) {
          this.touchBlockers.push(blocker);
        }
      },
      setDesiredCursor: function(cursorStyle) {
        this.desiredCursorStyle = cursorStyle;
      },
      defer: function(tooltipPainter) {
        this._deferredPaintActions.push(tooltipPainter);
      },
      paintDeferred: function() {
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._deferredPaintActions)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              e();
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this._deferredPaintActions = [];
      },
      paintableArea: function() {
        return new Rect(0, 0, this.canvas.width, this.canvas.height);
      },
      clear: function() {
        var color = arguments[0] !== (void 0) ? arguments[0] : Config.DEFAULT_FILL_COLOR;
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      },
      strokeLine: function(p1, p2) {
        var color = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_COLOR;
        var thickness = arguments[3] !== (void 0) ? arguments[3] : 1;
        this.ctx.beginPath();
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.stroke();
      },
      strokeRect: function(rect) {
        var color = arguments[1] !== (void 0) ? arguments[1] : "black";
        var thickness = arguments[2] !== (void 0) ? arguments[2] : 1;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      },
      fillRect: function(rect) {
        var color = arguments[1] !== (void 0) ? arguments[1] : Config.DEFAULT_FILL_COLOR;
        this.ctx.fillStyle = color;
        this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      },
      strokeCircle: function(center, radius) {
        var color = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_COLOR;
        var thickness = arguments[3] !== (void 0) ? arguments[3] : Config.DEFAULT_STROKE_THICKNESS;
        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.arc(center.x, center.y, Math.max(radius - 0.5, 0), 0, 2 * Math.PI);
        this.ctx.stroke();
      },
      trace: function(tracerFunc) {
        this.ctx.beginPath();
        tracerFunc(this._tracer);
        return this._traceAction;
      },
      fillCircle: function(center, radius) {
        var color = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_FILL_COLOR;
        this.ctx.beginPath();
        this.ctx.arc(center.x, center.y, Math.max(radius - 0.5, 0), 0, 2 * Math.PI);
        this.ctx.fillStyle = color;
        this.ctx.fill();
      },
      print: function(text, x, y, textAlign, textBaseline, fillStyle, font, boundingWidth, boundingHeight) {
        var afterMeasureBeforeDraw = arguments[9];
        var alsoStroke = arguments[10] !== (void 0) ? arguments[10] : false;
        this.ctx.font = font;
        var naiveWidth = this.ctx.measureText(text).width;
        var naiveHeight = this.ctx.measureText("0").width * 2.5;
        var scale = Math.min(Math.min(boundingWidth / naiveWidth, boundingHeight / naiveHeight), 1);
        if (afterMeasureBeforeDraw !== undefined) {
          afterMeasureBeforeDraw(naiveWidth * scale, naiveHeight * scale);
        }
        this.ctx.save();
        this.ctx.textAlign = textAlign;
        this.ctx.textBaseline = textBaseline;
        this.ctx.font = font;
        this.ctx.fillStyle = fillStyle;
        this.ctx.translate(x, y);
        this.ctx.scale(scale, scale);
        if (alsoStroke) {
          this.ctx.strokeText(text, 0, 0);
        }
        this.ctx.fillText(text, 0, 0);
        this.ctx.restore();
      },
      printParagraph: function(text, area) {
        var proportionalCenterOfAlignment = arguments[2] !== (void 0) ? arguments[2] : new Point(0, 0);
        var fontColor = arguments[3] !== (void 0) ? arguments[3] : Config.DEFAULT_TEXT_COLOR;
        var maxFontSize = arguments[4] !== (void 0) ? arguments[4] : Config.DEFAULT_FONT_SIZE;
        var fontFamily = arguments[5] !== (void 0) ? arguments[5] : Config.DEFAULT_FONT_FAMILY;
        var $__3 = this;
        var fontSize;
        var ascendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxAscent;
          return d === undefined ? fontSize * 0.75 : d;
        };
        var descendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxDescent;
          return d === undefined ? fontSize * 0.25 : d;
        };
        var heightOf = function(metric) {
          return ascendingHeightOf(metric) + descendingHeightOf(metric);
        };
        var lines;
        var measures;
        var height;
        var forcedLines = seq(text.split("\n"));
        for (var df = 0; ; df++) {
          fontSize = maxFontSize - df;
          this.ctx.font = fontSize + "px " + fontFamily;
          lines = forcedLines.flatMap(function(line) {
            return Util.breakLine(line, area.w, function(s) {
              return $__3.ctx.measureText(s).width;
            });
          }).toArray();
          measures = lines.map(function(e) {
            return $__3.ctx.measureText(e);
          });
          height = seq(measures.map(heightOf)).sum();
          if (height <= area.h || fontSize <= 4) {
            break;
          }
        }
        var f = function(offset, full, used, proportion) {
          return offset + (full - used) * proportion;
        };
        var fx = function(w) {
          return f(area.x, area.w, w, proportionalCenterOfAlignment.x);
        };
        var fy = function(h) {
          return f(area.y, area.h, h, proportionalCenterOfAlignment.y);
        };
        var y = fy(height);
        this.ctx.fillStyle = fontColor;
        var dy = 0;
        for (var i = 0; i < lines.length; i++) {
          dy += ascendingHeightOf(measures[i]);
          this.ctx.fillText(lines[i], fx(measures[i].width), y + dy);
          dy += descendingHeightOf(measures[i]);
        }
        var maxWidth = new Seq(measures).map(function(e) {
          return e.width;
        }).max(0);
        return new Rect(fx(maxWidth), y, maxWidth, height);
      },
      printLine: function(text, area) {
        var proportionalCenterOfHorizontalAlignment = arguments[2] !== (void 0) ? arguments[2] : 0;
        var fontColor = arguments[3] !== (void 0) ? arguments[3] : Config.DEFAULT_TEXT_COLOR;
        var maxFontSize = arguments[4] !== (void 0) ? arguments[4] : Config.DEFAULT_FONT_SIZE;
        var fontFamily = arguments[5] !== (void 0) ? arguments[5] : Config.DEFAULT_FONT_FAMILY;
        var proportionalCenterOfVerticalAlignment = arguments[6];
        var fontSize;
        var ascendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxAscent;
          return d === undefined ? fontSize * 0.75 : d;
        };
        var descendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxDescent;
          return d === undefined ? fontSize * 0.25 : d;
        };
        var heightOf = function(metric) {
          return ascendingHeightOf(metric) + descendingHeightOf(metric);
        };
        var measure;
        for (var df = 0; ; df++) {
          fontSize = maxFontSize - df;
          this.ctx.font = fontSize + "px " + fontFamily;
          measure = this.ctx.measureText(text);
          if ((measure.width <= area.w && heightOf(measure) <= area.h) || fontSize <= 4) {
            break;
          }
        }
        var h = heightOf(measure);
        var py = proportionalCenterOfVerticalAlignment === undefined ? ascendingHeightOf(measure) / h : proportionalCenterOfVerticalAlignment;
        var f = function(offset, full, used, proportion) {
          return offset + (full - used) * proportion;
        };
        var x = f(area.x, area.w, measure.width, proportionalCenterOfHorizontalAlignment);
        var y = f(area.y, area.h, h, py);
        this.ctx.fillStyle = fontColor;
        this.ctx.fillText(text, x, y + ascendingHeightOf(measure));
        return new Rect(x, y, measure.width, h);
      },
      strokePolygon: function(vertices) {
        var strokeColor = arguments[1] !== (void 0) ? arguments[1] : Config.DEFAULT_STROKE_COLOR;
        var strokeThickness = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_THICKNESS;
        if (vertices.length === 0) {
          return;
        }
        var last = vertices[vertices.length - 1];
        this.ctx.beginPath();
        this.ctx.moveTo(last.x, last.y);
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (vertices)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var p = $__5.value;
            {
              this.ctx.lineTo(p.x, p.y);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeThickness;
        this.ctx.stroke();
      },
      strokePath: function(vertices) {
        var strokeColor = arguments[1] !== (void 0) ? arguments[1] : Config.DEFAULT_STROKE_COLOR;
        var strokeThickness = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_THICKNESS;
        if (vertices.length === 0) {
          return;
        }
        this.ctx.beginPath();
        this.ctx.moveTo(vertices[0].x, vertices[0].y);
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (vertices.slice(1))[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var p = $__5.value;
            {
              this.ctx.lineTo(p.x, p.y);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeThickness;
        this.ctx.stroke();
      },
      fillPolygon: function(vertices, fillColor) {
        var last = vertices[vertices.length - 1];
        this.ctx.beginPath();
        this.ctx.moveTo(last.x, last.y);
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (vertices)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var p = $__5.value;
            {
              this.ctx.lineTo(p.x, p.y);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this.ctx.fillStyle = fillColor;
        this.ctx.fill();
      }
    }, {});
  }();
  var Tracer = function() {
    function Tracer(ctx) {
      this.ctx = ctx;
    }
    return ($traceurRuntime.createClass)(Tracer, {
      line: function(x1, y1, x2, y2) {
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
      },
      rect: function(x, y, w, h) {
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + w, y);
        this.ctx.lineTo(x + w, y + h);
        this.ctx.lineTo(x, y + h);
        this.ctx.lineTo(x, y);
      },
      circle: function(x, y, radius) {
        this.ctx.moveTo(x + radius, y);
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
      },
      ellipse: function(x, y, horizontal_radius, vertical_radius) {
        this.ctx.save();
        this.ctx.translate(x - horizontal_radius, y - vertical_radius);
        this.ctx.scale(horizontal_radius, vertical_radius);
        this.ctx.moveTo(2, 1);
        this.ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);
        this.ctx.restore();
      },
      grid: function(x, y, w, h, numCols, numRows) {
        var dw = w / numCols;
        var dh = h / numRows;
        var x2 = x + numCols * dw;
        var y2 = y + numRows * dh;
        for (var c = 0; c <= numCols; c++) {
          this.ctx.moveTo(x + c * dw, y);
          this.ctx.lineTo(x + c * dw, y2);
        }
        for (var r = 0; r <= numRows; r++) {
          this.ctx.moveTo(x, y + r * dh);
          this.ctx.lineTo(x2, y + r * dh);
        }
      },
      polygon: function(interleavedCoordinates) {
        if (interleavedCoordinates.length === 0) {
          return;
        }
        var n = interleavedCoordinates.length;
        this.ctx.moveTo(interleavedCoordinates[n - 2], interleavedCoordinates[n - 1]);
        for (var i = 0; i < n; i += 2) {
          this.ctx.lineTo(interleavedCoordinates[i], interleavedCoordinates[i + 1]);
        }
      },
      arrowHead: function(x, y, radius, facingAngle, sweptAngle) {
        var a1 = facingAngle + sweptAngle / 2 + Math.PI;
        var a2 = facingAngle - sweptAngle / 2 + Math.PI;
        this.polygon([x + Math.cos(facingAngle) * radius, y + Math.sin(facingAngle) * radius, x + Math.cos(a1) * radius, y + Math.sin(a1) * radius, x + Math.cos(a2) * radius, y + Math.sin(a2) * radius]);
      }
    }, {});
  }();
  var TraceAction = function() {
    function TraceAction(ctx) {
      this.ctx = ctx;
    }
    return ($traceurRuntime.createClass)(TraceAction, {
      thenFill: function(fillStyle) {
        this.ctx.fillStyle = fillStyle;
        this.ctx.fill();
        return this;
      },
      thenStroke: function(strokeStyle) {
        var lineWidth = arguments[1] !== (void 0) ? arguments[1] : 1;
        this.ctx.strokeStyle = strokeStyle;
        this.ctx.lineWidth = lineWidth;
        this.ctx.stroke();
        return this;
      }
    }, {});
  }();
  return {get Painter() {
      return Painter;
    }};
});
//# sourceURL=src/draw/Painter.js
;$traceurRuntime.registerModule("src/draw/WidgetPainter.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/WidgetPainter.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/draw/WidgetPainter.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/draw/WidgetPainter.js")).Config;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/draw/WidgetPainter.js")).Format;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/draw/WidgetPainter.js")).Gate;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MathPainter.js", "src/draw/WidgetPainter.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/draw/WidgetPainter.js")).Matrix;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Painter.js", "src/draw/WidgetPainter.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/draw/WidgetPainter.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/draw/WidgetPainter.js")).Rect;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/draw/WidgetPainter.js")).Seq;
  var drawCircuitTooltip = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/DisplayedCircuit.js", "src/draw/WidgetPainter.js")).drawCircuitTooltip;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/draw/WidgetPainter.js")).Util;
  var WidgetPainter = function() {
    function WidgetPainter() {}
    return ($traceurRuntime.createClass)(WidgetPainter, {}, {
      describeGateTransformations: function(matrix, format) {
        var n = matrix.height();
        var b = Math.round(Math.log2(n));
        return Seq.range(n).map(function(c) {
          var inputDescription = WidgetPainter.describeKet(b, c, 1, Format.SIMPLIFIED);
          var col = matrix.getColumn(c);
          if (col.every(function(e) {
            return e.isEqualTo(0);
          })) {
            return "discards " + inputDescription;
          } else if (Seq.range(n).every(function(r) {
            return col[r].isEqualTo(r === c ? 1 : 0);
          })) {
            if (format !== Format.CONSISTENT) {
              return "doesn't affect " + inputDescription;
            }
          } else if (Seq.range(n).every(function(r) {
            return r === c || col[r].isEqualTo(0);
          })) {
            var degs = col[c].ln().imag * 180 / Math.PI;
            return "phases " + inputDescription + " by " + format.formatFloat(degs) + "°";
          }
          var outputDescription = new Seq(col).mapWithIndex(function(e, c) {
            return WidgetPainter.describeKet(b, c, e, format);
          }).filter(function(e) {
            return e !== "";
          }).join(" + ").split(" + -").join(" - ").split(" + +").join(" + ");
          return 'transforms ' + inputDescription + ' into ' + outputDescription;
        }).toArray();
      },
      _paintGateTooltip_matrix: function(painter, gate, matrix, pad, dispSize, w, pushRect, nextY) {
        if (matrix === undefined) {
          return;
        }
        pushRect(new Rect(0, nextY(), 1, 0), pad * 2);
        pushRect(painter.printParagraph('As matrix:', new Rect(pad, nextY(), w, 18), new Point(0, 0), 'black', 12), 0);
        var matrixRect = new Rect(pad, nextY(), dispSize, dispSize);
        var matrixDescRect = new Rect(0, matrixRect.y, w - pad, dispSize).skipLeft(matrixRect.right() + pad);
        MathPainter.paintMatrix(painter, matrix, matrixRect, Config.OPERATION_FORE_COLOR, 'black', undefined, Config.OPERATION_BACK_COLOR, undefined, 'transparent');
        pushRect(matrixRect);
        var n = matrix.height();
        if (n <= 4) {
          var format = gate.stableDuration() < 0.2 ? Format.CONSISTENT : Format.SIMPLIFIED;
          var matDescs = WidgetPainter.describeGateTransformations(matrix, format);
          var rowHeight = matrixDescRect.h / n;
          for (var r = 0; r < n; r++) {
            pushRect(painter.printParagraph(matDescs[r], matrixDescRect.skipTop(r * rowHeight).takeTop(rowHeight), new Point(0, 0.5), 'black', 12));
          }
        }
      },
      _paintGateTooltip_rotation: function(painter, gate, matrix, pad, dispSize, w, pushRect, nextY) {
        if (matrix === undefined || matrix.width() !== 2 || !matrix.isUnitary(0.001)) {
          return;
        }
        pushRect(new Rect(0, nextY(), 1, 0), pad * 2);
        pushRect(painter.printParagraph('As rotation:', new Rect(pad, nextY(), w, 18), new Point(0, 0), 'black', 12), 0);
        var $__2 = matrix.qubitOperationToAngleAxisRotation(),
            angle = $__2.angle,
            axis = $__2.axis,
            phase = $__2.phase;
        var blochRect = new Rect(pad, nextY(), dispSize, dispSize);
        MathPainter.paintBlochSphereRotation(painter, matrix, blochRect, Config.OPERATION_BACK_COLOR, Config.OPERATION_FORE_COLOR);
        pushRect(blochRect);
        var format = gate.stableDuration() < 0.2 ? Format.CONSISTENT : Format.SIMPLIFIED;
        var rotDesc = new Seq([("rotates: " + format.formatFloat(angle * 180 / Math.PI) + "°"), ("around: " + WidgetPainter.describeAxis(axis, format)), '', ("global phase: exp(" + format.formatFloat(phase * 180 / Math.PI) + "°i)"), '']).join('\n');
        pushRect(painter.printParagraph(rotDesc, new Rect(0, blochRect.y, w - pad, dispSize).skipLeft(blochRect.right() + pad), new Point(0, 0.5), 'black', 12));
      },
      _paintGateTooltip_circuit: function(painter, nestedCircuit, pad, dispSize, w, pushRect, nextY, time) {
        if (nestedCircuit === undefined) {
          return;
        }
        var weight = nestedCircuit.gateWeight();
        pushRect(new Rect(0, nextY(), 1, 0), pad * 2);
        pushRect(painter.printParagraph(("As circuit (gate weight = " + weight + "):"), new Rect(pad, nextY(), w, 18), new Point(0, 0), 'black', 12), 0);
        var circuitRect = new Rect(pad, nextY(), w, dispSize);
        var $__2 = drawCircuitTooltip(painter, nestedCircuit, circuitRect, true, time),
            maxW = $__2.maxW,
            maxH = $__2.maxH;
        pushRect(circuitRect.withW(maxW).withH(maxH));
      },
      paintGateTooltipHelper: function(painter, w, gate, time) {
        var $__3,
            $__4,
            $__6,
            $__7;
        var $__2 = [4, 65],
            pad = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
            dispSize = ($__4 = $__3.next()).done ? void 0 : $__4.value;
        var $__5 = [0, pad],
            maxX = ($__6 = $__5[Symbol.iterator](), ($__7 = $__6.next()).done ? void 0 : $__7.value),
            maxY = ($__7 = $__6.next()).done ? void 0 : $__7.value;
        var pushRect = function(rect) {
          var actualPad = arguments[1] !== (void 0) ? arguments[1] : pad;
          maxY = Math.max(maxY, rect.bottom() + actualPad);
          maxX = Math.max(maxX, rect.right() + actualPad);
        };
        pushRect(painter.printLine(gate.name, new Rect(pad, maxY, w, 18), 0, "blue", 24));
        if (gate.blurb !== '') {
          pushRect(painter.printParagraph(gate.blurb, new Rect(pad, maxY, w, 50), new Point(0, 0), 'black', 14));
        }
        var matrix = gate.knownMatrixAt(time);
        if (gate.definitelyHasNoEffect()) {
          return {
            maxX: maxX,
            maxY: maxY
          };
        }
        WidgetPainter._paintGateTooltip_matrix(painter, gate, matrix, pad, dispSize, w, pushRect, function() {
          return maxY;
        });
        WidgetPainter._paintGateTooltip_rotation(painter, gate, matrix, pad, dispSize, w, pushRect, function() {
          return maxY;
        });
        WidgetPainter._paintGateTooltip_circuit(painter, gate.knownCircuitNested, pad, dispSize, w, pushRect, function() {
          return maxY;
        }, time);
        return {
          maxX: maxX,
          maxY: maxY
        };
      },
      paintGateTooltip: function(painter, area, gate, time) {
        var mayNeedToScale = arguments[4] !== (void 0) ? arguments[4] : true;
        painter.ctx.save();
        painter.ctx.translate(area.x, area.y);
        area = area.withX(0).withY(0);
        var scale = Math.min(area.w / 500, area.h / 300);
        if (mayNeedToScale && scale < 1) {
          painter.ctx.scale(scale, scale);
          area = area.withH(area.h / scale).withW(area.w / scale);
        }
        var w = area.w;
        var $__2 = WidgetPainter.paintGateTooltipHelper(painter, w, gate, time),
            maxX = $__2.maxX,
            maxY = $__2.maxY;
        var r = new Rect(0, 0, maxX, maxY);
        painter.fillRect(r, '#F9FFF9');
        painter.strokeRect(r, 'black');
        WidgetPainter.paintGateTooltipHelper(painter, w, gate, time);
        painter.ctx.restore();
        return {
          maxW: maxX,
          maxH: maxY
        };
      },
      describeKet: function(bitCount, bitMask, factor, format) {
        factor = Complex.from(factor);
        if (factor.isEqualTo(0)) {
          return "";
        }
        var scaleFactorDesc = factor.isEqualTo(1) ? "" : factor.isEqualTo(-1) ? "-" : factor.isEqualTo(Complex.I) ? "i" : factor.isEqualTo(Complex.I.times(-1)) ? "-i" : (factor.real === 0 || factor.imag === 0) && format !== Format.CONSISTENT ? factor.toString(format) : '(' + factor.toString(format) + ')·';
        var bitDesc = Util.bin(bitMask, bitCount);
        return scaleFactorDesc + '|' + bitDesc + '⟩';
      },
      describeAxis: function(unitAxis, format) {
        var max = new Seq(unitAxis).map(Math.abs).max();
        return new Seq(unitAxis).map(function(e) {
          return e / max;
        }).zip(["X", "Y", "Z"], function(val, name) {
          if (val === 0) {
            return "";
          }
          if (val === 1) {
            return name;
          }
          if (val === -1) {
            return "-" + name;
          }
          return format.formatFloat(val) + "·" + name;
        }).filter(function(e) {
          return e !== "";
        }).join(" + ").replace(" + -", " - ").replace(" + +", " + ");
      }
    });
  }();
  return {get WidgetPainter() {
      return WidgetPainter;
    }};
});
//# sourceURL=src/draw/WidgetPainter.js
;$traceurRuntime.registerModule("src/fallback.js", [], function() {
  "use strict";
  var __moduleName = "src/fallback.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./base/Describe.js", "src/fallback.js")).describe;
  var knownIssueRegexes = [];
  var isHooked = false;
  function hookErrorHandler() {
    isHooked = true;
    window.onerror = onErrorHandler;
  }
  function checkForKnownIssueHandler(subject, isKnownIssueUrl) {
    if (isKnownIssueUrl !== undefined) {
      return undefined;
    }
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (knownIssueRegexes)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var $__8 = $__2.value,
            regex = $__8.regex,
            handler = $__8.handler;
        {
          if (regex.test(subject)) {
            return handler;
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return undefined;
  }
  var showErrorDiv_forced = function(callout, subject, body, isKnownIssueUrl) {
    document.getElementById('error-happened-div').innerText = callout;
    document.getElementById('error-message-div').innerText = subject;
    document.getElementById('error-description-div').innerText = body;
    document.getElementById('error-mailto-anchor').innerText = 'Email the issue to craig.gidney@gmail.com';
    document.getElementById('error-mailto-anchor').href = ['mailto:craig.gidney@gmail.com?subject=', encodeURIComponent('Quirk had an error: ' + subject), '&body=', encodeURIComponent('\n\n\n' + body)].join('');
    document.getElementById('error-github-anchor').href = ['https://github.com/Strilanc/Quirk/issues/new?title=', encodeURIComponent('Encountered error: ' + subject), '&body=', encodeURIComponent('\n\n\n' + body)].join('');
    document.getElementById('error-image-pre').src = takeScreenshotOfCanvas();
    setTimeout(function() {
      document.getElementById('error-image-post').src = takeScreenshotOfCanvas();
    }, 0);
    if (isKnownIssueUrl === undefined) {
      document.getElementById('error-report-div').style.display = 'block';
      document.getElementById('error-known-div').style.display = 'none';
    } else {
      document.getElementById('error-report-div').style.display = 'none';
      document.getElementById('error-known-div').style.display = 'block';
      document.getElementById('error-known-issue-anchor').href = isKnownIssueUrl;
    }
  };
  var _alreadySeenBodies = [];
  var _alreadySeenIdentifiers = [];
  var showErrorDiv = function(callout, subject, body, identifier) {
    var isKnownIssueUrl = arguments[4];
    var errDivStyle = document.getElementById('error-div').style;
    if (errDivStyle.opacity < 0.7) {
      _alreadySeenBodies = [];
      _alreadySeenIdentifiers = [];
    }
    errDivStyle.backgroundColor = '#FFA';
    errDivStyle.opacity = 1.0;
    errDivStyle.display = 'block';
    if (_alreadySeenBodies.indexOf(body) !== -1) {
      return;
    }
    _alreadySeenBodies.push(body);
    if (_alreadySeenIdentifiers.length > 0) {
      body += "\n\nCOVERED\n" + _alreadySeenIdentifiers.join("\n-------------\n");
    }
    if (_alreadySeenIdentifiers.indexOf(identifier) === -1) {
      _alreadySeenIdentifiers.push(identifier);
    }
    var handler = checkForKnownIssueHandler(subject, isKnownIssueUrl);
    if (handler !== undefined) {
      handler();
      return;
    }
    showErrorDiv_forced(callout, subject, body, isKnownIssueUrl);
  };
  var takeScreenshotOfCanvas = function() {
    var canvas = document.getElementById("drawCanvas");
    if (canvas === undefined) {
      return '#';
    }
    return canvas.toDataURL("image/png");
  };
  var notifyAboutRecoveryFromUnexpectedError = function(recovery, context, error) {
    if (!isHooked) {
      throw error;
    }
    console.error('Recovered from unexpected error', {
      recovery: recovery,
      context: context,
      error: error
    });
    var location = error.stack || "unknown";
    var msg = [recovery, '', 'URL', document.location, '', 'BROWSER', window.navigator.userAgent, window.navigator.appName, window.navigator.appVersion, '', 'RECOVERY DETAILS', describe(context), '', 'ERROR OBJECT', describe(error), '', 'ERROR LOCATION', simplifySrcUrls(location)].join('\n');
    showErrorDiv('Recovered from an error. :(', recovery + ' (' + (error.message || '') + ')', msg, "(Recovered) " + recovery + " @ " + location.substr(0, 200) + "[...]");
  };
  var simplifySrcUrls = function(textContainingUrls) {
    return textContainingUrls.replace(/http.+?\/src\.min\.js/g, 'src.min.js');
  };
  var notifyAboutKnownIssue = function(summary, url, regexes) {
    var handler = function() {
      return showErrorDiv('A known problem is happening. :(', summary, '', summary, url);
    };
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (regexes)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var regex = $__2.value;
        {
          knownIssueRegexes.push({
            regex: regex,
            handler: handler
          });
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    handler();
  };
  var drawErrorBox = function(msg) {
    var canvas = document.getElementById("drawCanvas");
    if (canvas === undefined) {
      return;
    }
    var ctx = canvas.getContext("2d");
    ctx.font = '12px monospace';
    var lines = msg.split("\n");
    var w = 0;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (lines)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var line = $__2.value;
        {
          w = Math.max(w, ctx.measureText(line).width);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var h = 12 * lines.length;
    var x = (canvas.clientWidth - w) / 2;
    var y = (canvas.clientHeight - h) / 2;
    ctx.fillStyle = 'white';
    ctx.globalAlpha = 0.9;
    ctx.fillRect(x - 10, y - 10, w + 20, h + 20);
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = 'red';
    ctx.strokeRect(x - 10, y - 10, w + 20, h + 20);
    ctx.fillStyle = 'red';
    var dy = 0;
    for (var i = 0; i < lines.length; i++) {
      dy += 3;
      ctx.fillText(lines[i], x, y + dy);
      dy += 9;
    }
  };
  function onErrorHandler(errorMsg, url, lineNumber, columnNumber, errorObj) {
    try {
      var location = simplifySrcUrls(((errorObj instanceof Object) ? errorObj.stack : undefined) || (url + ":" + lineNumber + ":" + columnNumber));
      var body = ['URL', document.location, '', 'BROWSER', window.navigator.userAgent, window.navigator.appName, window.navigator.appVersion, '', 'ERROR OBJECT', errorObj instanceof Object && errorObj.toString !== undefined ? errorObj.toString() : String(errorObj), '', 'ERROR LOCATION', simplifySrcUrls(location)].join('\n');
      showErrorDiv('An error happened. :(', errorMsg, body, "(Unexpected) " + errorMsg + " @ " + location.substr(0, 200) + "[...]");
      drawErrorBox(['An error is happening. :(', '', errorMsg, '', 'Scroll down for more information'].join('\n'));
    } catch (ex) {
      console.error("Caused an exception when handling unexpected error.", ex);
    }
    return false;
  }
  return {
    get hookErrorHandler() {
      return hookErrorHandler;
    },
    get notifyAboutRecoveryFromUnexpectedError() {
      return notifyAboutRecoveryFromUnexpectedError;
    },
    get onErrorHandler() {
      return onErrorHandler;
    },
    get notifyAboutKnownIssue() {
      return notifyAboutKnownIssue;
    }
  };
});
//# sourceURL=src/fallback.js
;$traceurRuntime.registerModule("src/gates/AllGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/AllGates.js";
  var ArithmeticGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArithmeticGates.js", "src/gates/AllGates.js")).ArithmeticGates;
  var AmplitudeDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AmplitudeDisplay.js", "src/gates/AllGates.js")).AmplitudeDisplayFamily;
  var BitCountGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./BitCountGates.js", "src/gates/AllGates.js")).BitCountGates;
  var BlochSphereDisplay = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./BlochSphereDisplay.js", "src/gates/AllGates.js")).BlochSphereDisplay;
  var ComparisonGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ComparisonGates.js", "src/gates/AllGates.js")).ComparisonGates;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Controls.js", "src/gates/AllGates.js")).Controls;
  var CountingGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CountingGates.js", "src/gates/AllGates.js")).CountingGates;
  var CycleBitsGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CycleBitsGates.js", "src/gates/AllGates.js")).CycleBitsGates;
  var DensityMatrixDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DensityMatrixDisplay.js", "src/gates/AllGates.js")).DensityMatrixDisplayFamily;
  var ErrorInjectionGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Debug_ErrorInjectionGate.js", "src/gates/AllGates.js")).ErrorInjectionGate;
  var ExponentiatingGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExponentiatingGates.js", "src/gates/AllGates.js")).ExponentiatingGates;
  var FourierTransformGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FourierTransformGates.js", "src/gates/AllGates.js")).FourierTransformGates;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./HalfTurnGates.js", "src/gates/AllGates.js")).HalfTurnGates;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Joke_ImaginaryGate.js", "src/gates/AllGates.js")),
      ImaginaryGate = $__14.ImaginaryGate,
      AntiImaginaryGate = $__14.AntiImaginaryGate,
      SqrtImaginaryGate = $__14.SqrtImaginaryGate,
      AntiSqrtImaginaryGate = $__14.AntiSqrtImaginaryGate;
  var IncrementGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./IncrementGates.js", "src/gates/AllGates.js")).IncrementGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InputGates.js", "src/gates/AllGates.js")).InputGates;
  var InterleaveBitsGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InterleaveBitsGates.js", "src/gates/AllGates.js")).InterleaveBitsGates;
  var MeasurementGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MeasurementGate.js", "src/gates/AllGates.js")).MeasurementGate;
  var ModularIncrementGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularIncrementGates.js", "src/gates/AllGates.js")).ModularIncrementGates;
  var ModularAdditionGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularAdditionGates.js", "src/gates/AllGates.js")).ModularAdditionGates;
  var ModularMultiplicationGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularMultiplicationGates.js", "src/gates/AllGates.js")).ModularMultiplicationGates;
  var ModularMultiplyAccumulateGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularMultiplyAccumulateGates.js", "src/gates/AllGates.js")).ModularMultiplyAccumulateGates;
  var MultiplicationGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiplicationGates.js", "src/gates/AllGates.js")).MultiplicationGates;
  var MultiplyAccumulateGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiplyAccumulateGates.js", "src/gates/AllGates.js")).MultiplyAccumulateGates;
  var NeGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Joke_NeGate.js", "src/gates/AllGates.js")).NeGate;
  var ParametrizedRotationGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParametrizedRotationGates.js", "src/gates/AllGates.js")).ParametrizedRotationGates;
  var PhaseGradientGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PhaseGradientGates.js", "src/gates/AllGates.js")).PhaseGradientGates;
  var PivotFlipGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PivotFlipGates.js", "src/gates/AllGates.js")).PivotFlipGates;
  var PostSelectionGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PostSelectionGates.js", "src/gates/AllGates.js")).PostSelectionGates;
  var PoweringGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PoweringGates.js", "src/gates/AllGates.js")).PoweringGates;
  var ProbabilityDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ProbabilityDisplay.js", "src/gates/AllGates.js")).ProbabilityDisplayFamily;
  var QuarterTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./QuarterTurnGates.js", "src/gates/AllGates.js")).QuarterTurnGates;
  var ReverseBitsGateFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ReverseBitsGate.js", "src/gates/AllGates.js")).ReverseBitsGateFamily;
  var SampleDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SampleDisplay.js", "src/gates/AllGates.js")).SampleDisplayFamily;
  var Detectors = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Detector.js", "src/gates/AllGates.js")).Detectors;
  var SpacerGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SpacerGate.js", "src/gates/AllGates.js")).SpacerGate;
  var SwapGateHalf = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SwapGateHalf.js", "src/gates/AllGates.js")).SwapGateHalf;
  var UniversalNotGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Impossible_UniversalNotGate.js", "src/gates/AllGates.js")).UniversalNotGate;
  var VariousXGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./VariousXGates.js", "src/gates/AllGates.js")).VariousXGates;
  var VariousYGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./VariousYGates.js", "src/gates/AllGates.js")).VariousYGates;
  var VariousZGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./VariousZGates.js", "src/gates/AllGates.js")).VariousZGates;
  var XorGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./XorGates.js", "src/gates/AllGates.js")).XorGates;
  var ZeroGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Joke_ZeroGate.js", "src/gates/AllGates.js")).ZeroGate;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/gates/AllGates.js")).seq;
  var Gates = {};
  Gates.Special = {
    Measurement: MeasurementGate,
    SwapHalf: SwapGateHalf
  };
  Gates.Displays = {
    AmplitudeDisplayFamily: AmplitudeDisplayFamily,
    ProbabilityDisplayFamily: ProbabilityDisplayFamily,
    SampleDisplayFamily: SampleDisplayFamily,
    DensityMatrixDisplayFamily: DensityMatrixDisplayFamily,
    BlochSphereDisplay: BlochSphereDisplay
  };
  Gates.Arithmetic = ArithmeticGates;
  Gates.BitCountGates = BitCountGates;
  Gates.ComparisonGates = ComparisonGates;
  Gates.Controls = Controls;
  Gates.CountingGates = CountingGates;
  Gates.CycleBitsGates = CycleBitsGates;
  Gates.Displays.DensityMatrixDisplay = DensityMatrixDisplayFamily.ofSize(1);
  Gates.Displays.DensityMatrixDisplay2 = DensityMatrixDisplayFamily.ofSize(2);
  Gates.Displays.ChanceDisplay = Gates.Displays.ProbabilityDisplayFamily.ofSize(1);
  Gates.ErrorInjection = ErrorInjectionGate;
  Gates.Exponentiating = ExponentiatingGates;
  Gates.FourierTransformGates = FourierTransformGates;
  Gates.HalfTurns = HalfTurnGates;
  Gates.ImaginaryGate = ImaginaryGate;
  Gates.AntiImaginaryGate = AntiImaginaryGate;
  Gates.SqrtImaginaryGate = SqrtImaginaryGate;
  Gates.AntiSqrtImaginaryGate = AntiSqrtImaginaryGate;
  Gates.IncrementGates = IncrementGates;
  Gates.InputGates = InputGates;
  Gates.InterleaveBitsGates = InterleaveBitsGates;
  Gates.ModularIncrementGates = ModularIncrementGates;
  Gates.ModularAdditionGates = ModularAdditionGates;
  Gates.ModularMultiplicationGates = ModularMultiplicationGates;
  Gates.ModularMultiplyAccumulateGates = ModularMultiplyAccumulateGates;
  Gates.MultiplicationGates = MultiplicationGates;
  Gates.MultiplyAccumulateGates = MultiplyAccumulateGates;
  Gates.NeGate = NeGate;
  Gates.OtherX = VariousXGates;
  Gates.OtherY = VariousYGates;
  Gates.OtherZ = VariousZGates;
  Gates.ParametrizedRotationGates = ParametrizedRotationGates;
  Gates.PhaseGradientGates = PhaseGradientGates;
  Gates.PivotFlipGates = PivotFlipGates;
  Gates.PostSelectionGates = PostSelectionGates;
  Gates.Powering = PoweringGates;
  Gates.QuarterTurns = QuarterTurnGates;
  Gates.ReverseBitsGateFamily = ReverseBitsGateFamily;
  Gates.Detectors = Detectors;
  Gates.SpacerGate = SpacerGate;
  Gates.UniversalNot = UniversalNotGate;
  Gates.XorGates = XorGates;
  Gates.ZeroGate = ZeroGate;
  Gates.KnownToSerializer = $traceurRuntime.spread(Controls.all, InputGates.all, [MeasurementGate, SwapGateHalf, SpacerGate, UniversalNotGate, ErrorInjectionGate, ZeroGate, NeGate, ImaginaryGate, AntiImaginaryGate, SqrtImaginaryGate, AntiSqrtImaginaryGate], AmplitudeDisplayFamily.all, ProbabilityDisplayFamily.all, SampleDisplayFamily.all, DensityMatrixDisplayFamily.all, [BlochSphereDisplay], ArithmeticGates.all, BitCountGates.all, ComparisonGates.all, CountingGates.all, CycleBitsGates.all, Detectors.all, ExponentiatingGates.all, FourierTransformGates.all, HalfTurnGates.all, IncrementGates.all, InterleaveBitsGates.all, ModularAdditionGates.all, ModularIncrementGates.all, ModularMultiplicationGates.all, ModularMultiplyAccumulateGates.all, MultiplicationGates.all, MultiplyAccumulateGates.all, QuarterTurnGates.all, ParametrizedRotationGates.all, PhaseGradientGates.all, PivotFlipGates.all, PostSelectionGates.all, PoweringGates.all, ReverseBitsGateFamily.all, VariousXGates.all, VariousYGates.all, VariousZGates.all, XorGates.all);
  var gatesById = seq(Gates.KnownToSerializer).keyedBy(function(g) {
    return g.serializedId;
  });
  Gates.findKnownGateById = function(id, customGateSet) {
    return gatesById.has(id) ? gatesById.get(id) : customGateSet.findGateWithSerializedId(id);
  };
  Gates.TopToolboxGroups = [{
    hint: "Probes",
    gates: [MeasurementGate, undefined, PostSelectionGates.PostSelectOff, PostSelectionGates.PostSelectOn, Controls.AntiControl, Controls.Control]
  }, {
    hint: "Displays",
    gates: [undefined, undefined, DensityMatrixDisplayFamily.ofSize(1), BlochSphereDisplay, ProbabilityDisplayFamily.ofSize(1), AmplitudeDisplayFamily.ofSize(2)]
  }, {
    hint: "Half Turns",
    gates: [HalfTurnGates.Z, SwapGateHalf, HalfTurnGates.Y, undefined, HalfTurnGates.X, HalfTurnGates.H]
  }, {
    hint: "Quarter Turns",
    gates: [QuarterTurnGates.SqrtZForward, QuarterTurnGates.SqrtZBackward, QuarterTurnGates.SqrtYForward, QuarterTurnGates.SqrtYBackward, QuarterTurnGates.SqrtXForward, QuarterTurnGates.SqrtXBackward]
  }, {
    hint: "Eighth Turns",
    gates: [VariousZGates.Z4, VariousZGates.Z4i, VariousYGates.Y4, VariousYGates.Y4i, VariousXGates.X4, VariousXGates.X4i]
  }, {
    hint: "Spinning",
    gates: [PoweringGates.ZForward, PoweringGates.ZBackward, PoweringGates.YForward, PoweringGates.YBackward, PoweringGates.XForward, PoweringGates.XBackward]
  }, {
    hint: "Formulaic",
    gates: [ParametrizedRotationGates.FormulaicRotationZ, ParametrizedRotationGates.FormulaicRotationRz, ParametrizedRotationGates.FormulaicRotationY, ParametrizedRotationGates.FormulaicRotationRy, ParametrizedRotationGates.FormulaicRotationX, ParametrizedRotationGates.FormulaicRotationRx]
  }, {
    hint: "Parametrized",
    gates: [ParametrizedRotationGates.ZToA, ParametrizedRotationGates.ZToMinusA, ParametrizedRotationGates.YToA, ParametrizedRotationGates.YToMinusA, ParametrizedRotationGates.XToA, ParametrizedRotationGates.XToMinusA]
  }, {
    hint: 'Sampling',
    gates: [Detectors.ZDetector, Detectors.ZDetectControlClear, Detectors.YDetector, Detectors.YDetectControlClear, Detectors.XDetector, Detectors.XDetectControlClear]
  }, {
    hint: "Parity",
    gates: [Controls.ZParityControl, undefined, Controls.YParityControl, undefined, Controls.XParityControl, undefined]
  }];
  Gates.BottomToolboxGroups = [{
    hint: "X/Y Probes",
    gates: [Controls.XAntiControl, Controls.XControl, Controls.YAntiControl, Controls.YControl, PostSelectionGates.PostSelectAntiX, PostSelectionGates.PostSelectX, PostSelectionGates.PostSelectAntiY, PostSelectionGates.PostSelectY]
  }, {
    hint: "Order",
    gates: [CountingGates.CountingFamily.ofSize(3), CountingGates.UncountingFamily.ofSize(3), ReverseBitsGateFamily.ofSize(2), undefined, CycleBitsGates.CycleBitsFamily.ofSize(3), CycleBitsGates.ReverseCycleBitsFamily.ofSize(3), InterleaveBitsGates.InterleaveBitsGateFamily.ofSize(6), InterleaveBitsGates.DeinterleaveBitsGateFamily.ofSize(6)]
  }, {
    hint: 'Frequency',
    gates: [FourierTransformGates.FourierTransformFamily.ofSize(2), FourierTransformGates.InverseFourierTransformFamily.ofSize(2), undefined, undefined, PhaseGradientGates.PhaseGradientFamily.ofSize(2), PhaseGradientGates.PhaseDegradientFamily.ofSize(2), PhaseGradientGates.DynamicPhaseGradientFamily.ofSize(2), PhaseGradientGates.DynamicPhaseDegradientFamily.ofSize(2)]
  }, {
    hint: "Inputs",
    gates: [InputGates.InputAFamily.ofSize(2), InputGates.SetA, InputGates.InputBFamily.ofSize(2), InputGates.SetB, InputGates.InputRFamily.ofSize(2), InputGates.SetR, undefined, undefined]
  }, {
    hint: 'Arithmetic',
    gates: [IncrementGates.IncrementFamily.ofSize(2), IncrementGates.DecrementFamily.ofSize(2), ArithmeticGates.PlusAFamily.ofSize(2), ArithmeticGates.MinusAFamily.ofSize(2), MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(2), MultiplyAccumulateGates.MultiplySubtractInputsFamily.ofSize(2), MultiplicationGates.TimesAFamily.ofSize(2), MultiplicationGates.TimesAInverseFamily.ofSize(2)]
  }, {
    hint: "Compare",
    gates: [ComparisonGates.ALessThanB, ComparisonGates.AGreaterThanB, ComparisonGates.ALessThanOrEqualToB, ComparisonGates.AGreaterThanOrEqualToB, ComparisonGates.AEqualToB, ComparisonGates.ANotEqualToB, undefined, undefined]
  }, {
    hint: "Modular",
    gates: [ModularIncrementGates.IncrementModRFamily.ofSize(2), ModularIncrementGates.DecrementModRFamily.ofSize(2), ModularAdditionGates.PlusAModRFamily.ofSize(2), ModularAdditionGates.MinusAModRFamily.ofSize(2), ModularMultiplicationGates.TimesAModRFamily.ofSize(2), ModularMultiplicationGates.TimesAModRInverseFamily.ofSize(2), ModularMultiplicationGates.TimesBToTheAModRFamily.ofSize(2), ModularMultiplicationGates.TimesInverseBToTheAModRFamily.ofSize(2)]
  }, {
    hint: 'Scalar',
    gates: [SpacerGate, ZeroGate, NeGate, undefined, ImaginaryGate, AntiImaginaryGate, SqrtImaginaryGate, AntiSqrtImaginaryGate]
  }];
  var INITIAL_STATES_TO_GATES = new Map([[undefined, []], ['1', [Gates.HalfTurns.X]], ['+', [Gates.HalfTurns.H]], ['-', [Gates.HalfTurns.H, Gates.HalfTurns.Z]], ['i', [Gates.HalfTurns.H, Gates.QuarterTurns.SqrtZForward]], ['-i', [Gates.HalfTurns.H, Gates.QuarterTurns.SqrtZBackward]]]);
  return {
    get Gates() {
      return Gates;
    },
    get INITIAL_STATES_TO_GATES() {
      return INITIAL_STATES_TO_GATES;
    }
  };
});
//# sourceURL=src/gates/AllGates.js
;$traceurRuntime.registerModule("src/gates/AmplitudeDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/AmplitudeDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/AmplitudeDisplay.js")).Config;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitShaders.js", "src/gates/AmplitudeDisplay.js")).CircuitShaders;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/AmplitudeDisplay.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/AmplitudeDisplay.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateShaders.js", "src/gates/AmplitudeDisplay.js")).GateShaders;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/gates/AmplitudeDisplay.js")).Format;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/gates/AmplitudeDisplay.js")).MathPainter;
  var $__23 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/AmplitudeDisplay.js")),
      Matrix = $__23.Matrix,
      complexVectorToReadableJson = $__23.complexVectorToReadableJson,
      realVectorToReadableJson = $__23.realVectorToReadableJson;
  var probabilityStatTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ProbabilityDisplay.js", "src/gates/AmplitudeDisplay.js")).probabilityStatTexture;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/AmplitudeDisplay.js")).Point;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/AmplitudeDisplay.js")).Util;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/gates/AmplitudeDisplay.js")).Shaders;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/gates/AmplitudeDisplay.js")).WglConfiguredShader;
  var $__29 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/gates/AmplitudeDisplay.js")),
      Inputs = $__29.Inputs,
      Outputs = $__29.Outputs,
      currentShaderCoder = $__29.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__29.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTexturePool.js", "src/gates/AmplitudeDisplay.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTextureTrader.js", "src/gates/AmplitudeDisplay.js")).WglTextureTrader;
  function amplitudeDisplayStatTextures(stateKet, controls, controlsTexture, rangeOffset, rangeLength) {
    var incoherentKet = probabilityStatTexture(stateKet, controlsTexture, rangeOffset, rangeLength);
    var trader = new WglTextureTrader(stateKet);
    trader.dontDeallocCurrentTexture();
    var startingQubits = currentShaderCoder().vec2.arrayPowerSizeOfTexture(stateKet);
    var lostQubits = Util.numberOfSetBits(controls.inclusionMask);
    var lostHeadQubits = Util.numberOfSetBits(controls.inclusionMask & ((1 << rangeOffset) - 1));
    var involvedQubits = startingQubits - lostQubits;
    var broadcastQubits = involvedQubits - rangeLength;
    trader.shadeAndTrade(function(tex) {
      return CircuitShaders.controlSelect(controls, tex);
    }, WglTexturePool.takeVec2Tex(involvedQubits));
    trader.shadeAndTrade(function(tex) {
      return GateShaders.cycleAllBits(tex, lostHeadQubits - rangeOffset);
    });
    var ketJustAfterCycle = trader.dontDeallocCurrentTexture();
    trader.shadeAndTrade(AMPS_TO_SQUARED_MAGS_SHADER, WglTexturePool.takeVecFloatTex(involvedQubits));
    for (var k = 0; k < rangeLength; k++) {
      trader.shadeHalveAndTrade(Shaders.sumFoldFloatAdjacents);
    }
    trader.shadeAndTrade(MAGS_TO_INDEXED_MAGS_SHADER, WglTexturePool.takeVec2Tex(broadcastQubits));
    for (var k$__11 = 0; k$__11 < broadcastQubits; k$__11++) {
      trader.shadeHalveAndTrade(FOLD_MAX_INDEXED_MAG_SHADER);
    }
    trader.shadeAndTrade(function(indexed_mag) {
      return LOOKUP_KET_AT_INDEXED_MAG_SHADER(ketJustAfterCycle, indexed_mag);
    }, WglTexturePool.takeVec2Tex(rangeLength));
    var rawKet = trader.dontDeallocCurrentTexture();
    trader.shadeAndTrade(function(small_input) {
      return POINTWISE_CMUL_CONJ_SHADER(small_input, ketJustAfterCycle);
    }, WglTexturePool.takeVec2Tex(involvedQubits));
    ketJustAfterCycle.deallocByDepositingInPool("ketJustAfterCycle in makeAmplitudeSpanPipeline");
    for (var k$__12 = 0; k$__12 < rangeLength; k$__12++) {
      trader.shadeHalveAndTrade(Shaders.sumFoldVec2Adjacents);
    }
    trader.shadeAndTrade(AMPS_TO_SQUARED_MAGS_SHADER, WglTexturePool.takeVecFloatTex(broadcastQubits));
    for (var k$__13 = 0; k$__13 < broadcastQubits; k$__13++) {
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    if (currentShaderCoder().float.needRearrangingToBeInVec4Format) {
      trader.shadeHalveAndTrade(Shaders.packFloatIntoVec4);
    }
    var denormalizedQuality = trader.currentTexture;
    trader.currentTexture = rawKet;
    if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
      trader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
    }
    var ket = trader.currentTexture;
    return [ket, denormalizedQuality, incoherentKet];
  }
  function processOutputs(span, pixelGroups, circuitDefinition) {
    var $__9,
        $__10;
    var $__8 = pixelGroups,
        ketPixels = ($__9 = $__8[Symbol.iterator](), ($__10 = $__9.next()).done ? void 0 : $__10.value),
        qualityPixels = ($__10 = $__9.next()).done ? void 0 : $__10.value,
        rawIncoherentKetPixels = ($__10 = $__9.next()).done ? void 0 : $__10.value;
    var denormalizedQuality = qualityPixels[0];
    var n = 1 << span;
    var w = n === 2 ? 2 : 1 << Math.floor(Math.round(Math.log2(n)) / 2);
    var h = n / w;
    var unity = 0;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (ketPixels)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var e = $__2.value;
        {
          unity += e * e;
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var incoherentKetPixels = new Float32Array(w * h * 2);
    var incoherentUnity = 0;
    for (var i = 0; i < n; i++) {
      incoherentUnity += rawIncoherentKetPixels[i];
    }
    for (var i$__14 = 0; i$__14 < n; i$__14++) {
      incoherentKetPixels[i$__14 << 1] = Math.sqrt(rawIncoherentKetPixels[i$__14] / incoherentUnity);
    }
    if (isNaN(incoherentUnity) || incoherentUnity < 0.000001) {
      return {
        quality: 0.0,
        ket: Matrix.zero(w, h).times(NaN),
        phaseLockIndex: 0,
        incoherentKet: Matrix.zero(w, h).times(NaN)
      };
    }
    var quality = denormalizedQuality / unity / incoherentUnity;
    var phaseIndex = span === circuitDefinition.numWires ? undefined : _processOutputs_pickPhaseLockIndex(ketPixels);
    var phase = phaseIndex === undefined ? 0 : Math.atan2(ketPixels[phaseIndex * 2 + 1], ketPixels[phaseIndex * 2]);
    var c = Math.cos(phase);
    var s = -Math.sin(phase);
    var buf = new Float32Array(n * 2);
    var sqrtUnity = Math.sqrt(unity);
    for (var i$__15 = 0; i$__15 < n; i$__15++) {
      var real = ketPixels[i$__15 * 2] / sqrtUnity;
      var imag = ketPixels[i$__15 * 2 + 1] / sqrtUnity;
      buf[i$__15 * 2] = real * c + imag * -s;
      buf[i$__15 * 2 + 1] = real * s + imag * c;
    }
    return {
      quality: quality,
      ket: new Matrix(w, h, buf),
      phaseLockIndex: phaseIndex,
      incoherentKet: new Matrix(w, h, incoherentKetPixels)
    };
  }
  function _processOutputs_pickPhaseLockIndex(ketPixels) {
    var result = 0;
    var best = 0;
    for (var k = 0; k < ketPixels.length; k += 2) {
      var r = ketPixels[k];
      var i = ketPixels[k + 1];
      var m = r * r + i * i;
      if (m > best * 10000) {
        best = m;
        result = k >> 1;
      }
    }
    return result;
  }
  var AMPS_TO_SQUARED_MAGS_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.float(), "float outputFor(float k) {\n        vec2 ri = read_input(k);\n        return dot(ri, ri);\n    }");
  var MAGS_TO_INDEXED_MAGS_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.vec2(), "vec2 outputFor(float k) {\n        return vec2(float(k), read_input(k));\n    }");
  var FOLD_MAX_INDEXED_MAG_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "vec2 outputFor(float k) {\n        vec2 a = read_input(k);\n        vec2 b = read_input(k + len_output());\n        return a.y >= b.y ? a : b;\n    }");
  var LOOKUP_KET_AT_INDEXED_MAG_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input'), Inputs.vec2('indexed_mag')], Outputs.vec2(), "vec2 outputFor(float k) {\n        return read_input(k + read_indexed_mag(0.0).x * len_output());\n    }");
  var POINTWISE_CMUL_CONJ_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('small_input'), Inputs.vec2('large_input')], Outputs.vec2(), "\n    vec2 cmul_conj(vec2 c1, vec2 c2) {\n        return mat2(c1.x, -c1.y, c1.y, c1.x) * c2;\n    }\n    vec2 outputFor(float k) {\n        vec2 in1 = read_small_input(floor(mod(k + 0.5, len_small_input())));\n        vec2 in2 = read_large_input(k);\n        return cmul_conj(in1, in2);\n    }\n    ");
  var AMPLITUDE_DRAWER_FROM_CUSTOM_STATS = GatePainting.makeDisplayDrawer(function(args) {
    var n = args.gate.height;
    var $__8 = args.customStats || {
      ket: (n === 1 ? Matrix.zero(2, 1) : Matrix.zero(1 << Math.floor(n / 2), 1 << Math.ceil(n / 2))).times(NaN),
      quality: 1,
      phaseLockIndex: 0,
      incoherentKet: undefined
    },
        quality = $__8.quality,
        ket = $__8.ket,
        phaseLockIndex = $__8.phaseLockIndex,
        incoherentKet = $__8.incoherentKet;
    var isIncoherent = quality < 0.99;
    var matrix = isIncoherent ? incoherentKet : ket;
    var dw = args.rect.w - args.rect.h * ket.width() / ket.height();
    var drawRect = args.rect.skipLeft(dw / 2).skipRight(dw / 2);
    var indicatorAlpha = Math.min(1, Math.max(0, (quality - 0.9999) / 0.0001));
    MathPainter.paintMatrix(args.painter, matrix, drawRect, Config.SUPERPOSITION_MID_COLOR, 'black', Config.SUPERPOSITION_FORE_COLOR, Config.SUPERPOSITION_BACK_COLOR, ("rgba(0, 0, 0, " + indicatorAlpha + ")"));
    var forceSign = function(v) {
      return (v >= 0 ? '+' : '') + v.toFixed(2);
    };
    if (isIncoherent) {
      MathPainter.paintMatrixTooltip(args.painter, matrix, drawRect, args.focusPoints, function(c, r) {
        return ("Chance of |" + Util.bin(r * matrix.width() + c, args.gate.height) + "⟩ (decimal " + (r * matrix.width() + c) + ") [amplitude not defined]");
      }, function(c, r, v) {
        return ("raw: " + (v.norm2() * 100).toFixed(4) + "%, log: " + (Math.log10(v.norm2()) * 10).toFixed(1) + " dB");
      }, function(c, r, v) {
        return '[entangled with other qubits]';
      });
    } else {
      MathPainter.paintMatrixTooltip(args.painter, matrix, drawRect, args.focusPoints, function(c, r) {
        return ("Amplitude of |" + Util.bin(r * matrix.width() + c, args.gate.height) + "⟩ (decimal " + (r * matrix.width() + c) + ")");
      }, function(c, r, v) {
        return 'val:' + v.toString(new Format(false, 0, 5, ", "));
      }, function(c, r, v) {
        return ("mag²:" + (v.norm2() * 100).toFixed(4) + "%, phase:" + forceSign(v.phase() * 180 / Math.PI) + "°");
      });
      if (phaseLockIndex !== undefined) {
        var cw = drawRect.w / matrix.width();
        var rh = drawRect.h / matrix.height();
        var c = phaseLockIndex % matrix.width();
        var r = Math.floor(phaseLockIndex / matrix.width());
        var cx = drawRect.x + cw * (c + 0.5);
        var cy = drawRect.y + rh * (r + 0.5);
        args.painter.strokeLine(new Point(cx, cy), new Point(cx + cw / 2, cy), ("rgba(255,0,0," + indicatorAlpha + ")"), 2);
        args.painter.print('fixed', cx + 0.5 * cw, cy, 'right', 'bottom', ("rgba(255,0,0," + indicatorAlpha + ")"), '12px monospace', cw * 0.5, rh * 0.5);
      }
    }
    paintErrorIfPresent(args, indicatorAlpha);
  });
  function paintErrorIfPresent(args, indicatorAlpha) {
    var err = undefined;
    var $__8 = args.positionInCircuit,
        col = $__8.col,
        row = $__8.row;
    var measured = ((args.stats.circuitDefinition.colIsMeasuredMask(col) >> row) & ((1 << args.gate.height) - 1)) !== 0;
    if (measured) {
      indicatorAlpha = 0;
      err = args.gate.width <= 2 ? '(w/ measure defer)' : '(assuming measurement deferred)';
    } else if (indicatorAlpha < 0.999) {
      err = 'incoherent';
    }
    if (err !== undefined) {
      args.painter.print(err, args.rect.x + args.rect.w / 2, args.rect.y + args.rect.h, 'center', 'hanging', ("rgba(255,0,0," + (1 - indicatorAlpha) + ")"), '12px sans-serif', args.rect.w, args.rect.h, undefined);
    }
  }
  function customStatsToJsonData(customStats) {
    var $__8 = customStats,
        quality = $__8.quality,
        ket = $__8.ket,
        phaseLockIndex = $__8.phaseLockIndex,
        incoherentKet = $__8.incoherentKet;
    var n = ket.width() * ket.height();
    return {
      coherence_measure: quality,
      superposition_phase_locked_state_index: phaseLockIndex === undefined ? null : phaseLockIndex,
      ket: complexVectorToReadableJson(new Matrix(1, n, ket.rawBuffer()).getColumn(0)),
      incoherentKet: realVectorToReadableJson(new Matrix(1, n, incoherentKet.rawBuffer()).getColumn(0))
    };
  }
  var AmplitudeDisplayFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Amps" + span).setSymbol("Amps").setTitle("Amplitude Display").setBlurb("Shows the amplitudes of some wires, if separable.\nUse controls to see conditional amplitudes.").setWidth(span === 1 ? 2 : span % 2 === 0 ? span : Math.ceil(span / 2)).promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    }).setStatTexturesMaker(function(ctx) {
      return amplitudeDisplayStatTextures(ctx.stateTrader.currentTexture, ctx.controls, ctx.controlsTexture, ctx.row, span);
    }).setStatPixelDataPostProcessor(function(val, def) {
      return processOutputs(span, val, def);
    }).setProcessedStatsToJsonFunc(customStatsToJsonData).setDrawer(AMPLITUDE_DRAWER_FROM_CUSTOM_STATS);
  });
  return {
    get AmplitudeDisplayFamily() {
      return AmplitudeDisplayFamily;
    },
    get AMPS_TO_SQUARED_MAGS_SHADER() {
      return AMPS_TO_SQUARED_MAGS_SHADER;
    },
    get MAGS_TO_INDEXED_MAGS_SHADER() {
      return MAGS_TO_INDEXED_MAGS_SHADER;
    },
    get FOLD_MAX_INDEXED_MAG_SHADER() {
      return FOLD_MAX_INDEXED_MAG_SHADER;
    },
    get LOOKUP_KET_AT_INDEXED_MAG_SHADER() {
      return LOOKUP_KET_AT_INDEXED_MAG_SHADER;
    },
    get POINTWISE_CMUL_CONJ_SHADER() {
      return POINTWISE_CMUL_CONJ_SHADER;
    },
    get amplitudeDisplayStatTextures() {
      return amplitudeDisplayStatTextures;
    }
  };
});
//# sourceURL=src/gates/AmplitudeDisplay.js
;$traceurRuntime.registerModule("src/gates/ArithmeticGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ArithmeticGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ArithmeticGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/ArithmeticGates.js")).GatePainting;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ArithmeticGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/ArithmeticGates.js")).WglArg;
  var ArithmeticGates = {};
  var chunkedScaledAdditionPermutationMaker = function(span, factor) {
    return function(e) {
      var sa = Math.floor(span / 2);
      var sb = Math.ceil(span / 2);
      var a = e & ((1 << sa) - 1);
      var b = e >> sa;
      b += a * factor;
      b &= ((1 << sb) - 1);
      return a + (b << sa);
    };
  };
  var ADDITION_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float d = read_input_A();\n        d *= factor;\n        d = mod(d, span);\n        return mod(out_id + span - d, span);");
  ArithmeticGates.Legacy_AdditionFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("add" + span).setSymbol("b+=a").setTitle("Addition Gate").setBlurb("Adds a little-endian number into another.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b+=a"], [Math.floor(span / 2) / span])).setActualEffectToUpdateFunc(function(ctx) {
      return ArithmeticGates.PlusAFamily.ofSize(Math.ceil(span / 2)).customOperation(ctx.withRow(ctx.row + Math.floor(span / 2)).withInputSetToRange('A', ctx.row, Math.floor(span / 2)));
    }).setKnownEffectToPermutation(chunkedScaledAdditionPermutationMaker(span, 1));
  });
  ArithmeticGates.Legacy_SubtractionFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ArithmeticGates.Legacy_AdditionFamily).setSerializedId("sub" + span).setSymbol("b-=a").setTitle("Subtraction Gate").setBlurb("Subtracts a little-endian number from another.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b-=a"], [Math.floor(span / 2) / span])).setActualEffectToUpdateFunc(function(ctx) {
      return ArithmeticGates.MinusAFamily.ofSize(Math.ceil(span / 2)).customOperation(ctx.withRow(ctx.row + Math.floor(span / 2)).withInputSetToRange('A', ctx.row, Math.floor(span / 2)));
    }).setKnownEffectToPermutation(chunkedScaledAdditionPermutationMaker(span, -1));
  });
  ArithmeticGates.PlusAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+=A" + span).setSymbol("+A").setTitle("Addition Gate [input A]").setBlurb("Adds input A into the qubits covered by this gate.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(v, a) {
      return (v + a) & ((1 << span) - 1);
    });
  });
  ArithmeticGates.MinusAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ArithmeticGates.PlusAFamily).setSerializedId("-=A" + span).setSymbol("−A").setTitle("Subtraction Gate [input A]").setBlurb("Subtracts input A out of the qubits covered by this gate.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(v, a) {
      return (v - a) & ((1 << span) - 1);
    });
  });
  ArithmeticGates.all = $traceurRuntime.spread(ArithmeticGates.Legacy_AdditionFamily.all, ArithmeticGates.Legacy_SubtractionFamily.all, ArithmeticGates.PlusAFamily.all, ArithmeticGates.MinusAFamily.all);
  return {get ArithmeticGates() {
      return ArithmeticGates;
    }};
});
//# sourceURL=src/gates/ArithmeticGates.js
;$traceurRuntime.registerModule("src/gates/BitCountGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/BitCountGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/BitCountGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/BitCountGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/BitCountGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/BitCountGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/BitCountGates.js")).WglArg;
  var BitCountGates = {};
  var POP_COUNT_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), ("\n        float d = read_input_A();\n        float popcnt = 0.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            popcnt += mod(d, 2.0);\n            d = floor(d / 2.0);\n        }\n        float offset = mod(popcnt * factor, span);\n        return mod(out_id + span - offset, span);"));
  BitCountGates.PlusBitCountAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedIdAndSymbol("+cntA" + span).setSymbol("+1s(A)").setTitle("Bit Count Gate").setBlurb("Counts the number of ON bits in input A and adds that into this output.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = POP_COUNT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t + Util.numberOfSetBits(a)) & ((1 << span) - 1);
    });
  });
  BitCountGates.MinusBitCountAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(BitCountGates.PlusBitCountAFamily).setSerializedIdAndSymbol("-cntA" + span).setSymbol("-1s(A)").setTitle("Bit Un-Count Gate").setBlurb("Counts the number of ON bits in input A and subtracts that into this output.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = POP_COUNT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t - Util.numberOfSetBits(a)) & ((1 << span) - 1);
    });
  });
  BitCountGates.all = $traceurRuntime.spread(BitCountGates.PlusBitCountAFamily.all, BitCountGates.MinusBitCountAFamily.all);
  return {get BitCountGates() {
      return BitCountGates;
    }};
});
//# sourceURL=src/gates/BitCountGates.js
;$traceurRuntime.registerModule("src/gates/BlochSphereDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/BlochSphereDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/BlochSphereDisplay.js")).Config;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/BlochSphereDisplay.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/BlochSphereDisplay.js")).GatePainting;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/gates/BlochSphereDisplay.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/BlochSphereDisplay.js")).Point;
  function _paintBlochSphereDisplay_tooltips(painter, drawArea, x, y, z, focusPoints) {
    var c = drawArea.center();
    var u = Math.min(drawArea.w, drawArea.h) / 2;
    if (focusPoints.every(function(pt) {
      return pt.distanceTo(c) >= u;
    })) {
      return;
    }
    var τ = Math.PI * 2;
    var deg = function(v) {
      return (v >= 0 ? '+' : '') + (v * 360 / τ).toFixed(2) + '°';
    };
    var forceSign = function(v) {
      return (v >= 0 ? '+' : '') + v.toFixed(4);
    };
    var d = Math.sqrt(x * x + y * y + z * z);
    var ϕ = Math.atan2(y, -x);
    var θ = Math.max(0, Math.PI / 2 - Math.atan2(-z, Math.sqrt(y * y + x * x)));
    painter.strokeCircle(c, u, 'orange', 2);
    MathPainter.paintDeferredValueTooltip(painter, c.x + u * Math.sqrt(0.5), c.y - u * Math.sqrt(0.5), 'Bloch sphere representation of local state', ("r:" + forceSign(d) + ", ϕ:" + deg(ϕ) + ", θ:" + deg(θ)), ("x:" + forceSign(-x) + ", y:" + forceSign(y) + ", z:" + forceSign(-z)));
  }
  function _paintBlochSphereDisplay_indicator(painter, x, y, z, drawArea, fillColor) {
    var c = drawArea.center();
    var u = Math.min(drawArea.w, drawArea.h) / 2;
    var $__7 = MathPainter.coordinateSystem(u),
        dx = $__7.dx,
        dy = $__7.dy,
        dz = $__7.dz;
    var p = c.plus(dx.times(x)).plus(dy.times(y)).plus(dz.times(z));
    var r = 3.8 / (1 + x / 6);
    painter.strokeLine(c, p, 'black', 1.5);
    painter.fillCircle(p, r, fillColor);
    painter.ctx.save();
    painter.ctx.globalAlpha *= Math.min(1, Math.max(0, 1 - x * x - y * y - z * z));
    painter.fillCircle(p, r, 'yellow');
    painter.ctx.restore();
    painter.strokeCircle(p, r, 'black');
    painter.ctx.save();
    painter.ctx.globalAlpha *= Math.min(1, Math.max(0, 0.5 + x * 5));
    painter.strokeLine(c, p, 'black', 2);
    painter.ctx.restore();
  }
  function paintBlochSphereDisplay(painter, qubitDensityMatrix, drawArea) {
    var $__9,
        $__10,
        $__11,
        $__12,
        $__13;
    var focusPoints = arguments[3] !== (void 0) ? arguments[3] : [];
    var backgroundColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_BACK_COLOR;
    var fillColor = arguments[5] !== (void 0) ? arguments[5] : Config.DISPLAY_GATE_FORE_COLOR;
    var c = drawArea.center();
    var u = Math.min(drawArea.w, drawArea.h) / 2;
    var $__7 = MathPainter.coordinateSystem(u),
        dx = $__7.dx,
        dy = $__7.dy,
        dz = $__7.dz;
    painter.fillCircle(c, u, backgroundColor);
    painter.trace(function(trace) {
      trace.circle(c.x, c.y, u);
      trace.ellipse(c.x, c.y, dy.x, dx.y);
      trace.ellipse(c.x, c.y, dx.x, dz.y);
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = ([dx, dy, dz])[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var d = $__1.value;
          {
            trace.line(c.x - d.x, c.y - d.y, c.x + d.x, c.y + d.y);
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
    }).thenStroke('#BBB');
    var $__8 = [NaN, NaN, NaN],
        x = ($__9 = $__8[Symbol.iterator](), ($__10 = $__9.next()).done ? void 0 : $__10.value),
        y = ($__10 = $__9.next()).done ? void 0 : $__10.value,
        z = ($__10 = $__9.next()).done ? void 0 : $__10.value;
    if (qubitDensityMatrix.hasNaN()) {
      painter.printParagraph("NaN", drawArea, new Point(0.5, 0.5), 'red');
    } else {
      ($__11 = qubitDensityMatrix.qubitDensityMatrixToBlochVector(), x = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value), y = ($__13 = $__12.next()).done ? void 0 : $__13.value, z = ($__13 = $__12.next()).done ? void 0 : $__13.value, $__11);
      _paintBlochSphereDisplay_indicator(painter, x, y, z, drawArea, fillColor);
    }
    _paintBlochSphereDisplay_tooltips(painter, drawArea, x, y, z, focusPoints);
  }
  var BlochSphereDisplay = new GateBuilder().setSerializedIdAndSymbol("Bloch").setTitle("Bloch Sphere Display").setBlurb("Shows a wire's local state as a point on the Bloch Sphere.\nUse controls to see conditional states.").markAsDrawerNeedsSingleQubitDensityStats().setDrawer(GatePainting.makeDisplayDrawer(function(args) {
    var $__7 = args.positionInCircuit,
        row = $__7.row,
        col = $__7.col;
    var ρ = args.stats.qubitDensityMatrix(col, row);
    paintBlochSphereDisplay(args.painter, ρ, args.rect, args.focusPoints);
  })).promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
    return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
  }).gate;
  return {
    get paintBlochSphereDisplay() {
      return paintBlochSphereDisplay;
    },
    get BlochSphereDisplay() {
      return BlochSphereDisplay;
    }
  };
});
//# sourceURL=src/gates/BlochSphereDisplay.js
;$traceurRuntime.registerModule("src/gates/ComparisonGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ComparisonGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ComparisonGates.js")).GateBuilder;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ComparisonGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/gates/ComparisonGates.js")).WglConfiguredShader;
  var ComparisonGates = {};
  function customComparisonShader(compareCode) {
    var shader = ketShaderPermute(("\n            " + ketInputGateShaderCode('A') + "\n            " + ketInputGateShaderCode('B') + "\n        "), ("\n            float lhs = read_input_A();\n            float rhs = read_input_B();\n            return mod(out_id + ((" + compareCode + ") ? 1.0 : 0.0), 2.0);"));
    return function(ctx) {
      var $__1;
      return ($__1 = shader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A', 'B'])));
    };
  }
  ComparisonGates.ALessThanB = new GateBuilder().setSerializedId("^A<B").setSymbol("⊕A<B").setTitle("Less-Than Gate").setBlurb("Toggles a qubit if input A is less than input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs < rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a < b ? 1 : 0);
  }).gate;
  ComparisonGates.ALessThanOrEqualToB = new GateBuilder().setSerializedId("^A<=B").setSymbol("⊕A≤B").setTitle("At-Most Gate").setBlurb("Toggles a qubit if input A is at most input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs <= rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a <= b ? 1 : 0);
  }).gate;
  ComparisonGates.AGreaterThanB = new GateBuilder().setAlternate(ComparisonGates.ALessThanOrEqualToB).setSerializedId("^A>B").setSymbol("⊕A>B").setTitle("Greater-Than Gate").setBlurb("Toggles a qubit if input A is greater than input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs > rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a > b ? 1 : 0);
  }).gate;
  ComparisonGates.AGreaterThanOrEqualToB = new GateBuilder().setAlternate(ComparisonGates.ALessThanB).setSerializedId("^A>=B").setSymbol("⊕A≥B").setTitle("At-Least Gate").setBlurb("Toggles a qubit if input A is at least input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs >= rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a >= b ? 1 : 0);
  }).gate;
  ComparisonGates.AEqualToB = new GateBuilder().setSerializedId("^A=B").setSymbol("⊕A=B").setTitle("Equality Gate").setBlurb("Toggles a qubit if input A is equal to input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs == rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a === b ? 1 : 0);
  }).gate;
  ComparisonGates.ANotEqualToB = new GateBuilder().setAlternate(ComparisonGates.AEqualToB).setSerializedId("^A!=B").setSymbol("⊕A≠B").setTitle("Inequality Gate").setBlurb("Toggles a qubit if input A isn't equal to input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs != rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a !== b ? 1 : 0);
  }).gate;
  ComparisonGates.all = [ComparisonGates.ALessThanB, ComparisonGates.AGreaterThanB, ComparisonGates.AEqualToB, ComparisonGates.ANotEqualToB, ComparisonGates.ALessThanOrEqualToB, ComparisonGates.AGreaterThanOrEqualToB];
  return {get ComparisonGates() {
      return ComparisonGates;
    }};
});
//# sourceURL=src/gates/ComparisonGates.js
;$traceurRuntime.registerModule("src/gates/Controls.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Controls.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Controls.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Controls.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateShaders.js", "src/gates/Controls.js")).GateShaders;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./HalfTurnGates.js", "src/gates/Controls.js")).HalfTurnGates;
  var QuarterTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./QuarterTurnGates.js", "src/gates/Controls.js")).QuarterTurnGates;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/Controls.js")).Config;
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/Controls.js")),
      ketArgs = $__8.ketArgs,
      ketShaderPermute = $__8.ketShaderPermute;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/Controls.js")).WglArg;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/Controls.js")).Util;
  var Controls = {};
  Controls.Control = new GateBuilder().setSerializedIdAndSymbol("•").setTitle("Control").setBlurb("Conditions on a qubit being ON.\nGates in the same column only apply to states meeting the condition.").promiseHasNoNetEffectOnStateVector().markAsControlExpecting(true).promiseEffectIsUnitary().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    args.painter.fillCircle(args.rect.center(), 5, "black");
  }).gate;
  Controls.AntiControl = new GateBuilder().setAlternate(Controls.Control).setSerializedIdAndSymbol("◦").setTitle("Anti-Control").setBlurb("Conditions on a qubit being OFF.\nGates in the same column only apply to states meeting the condition.").promiseHasNoNetEffectOnStateVector().markAsControlExpecting(false).promiseEffectIsUnitary().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
  }).gate;
  Controls.XAntiControl = new GateBuilder().setSerializedId("⊕").setSymbol("⊖").setTitle("X-Axis Anti-Control").setBlurb("Conditions on a qubit being ON+OFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(false).setSetupCleanupEffectToUpdateFunc(HalfTurnGates.H.customOperation, HalfTurnGates.H.customOperation).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().promiseEffectIsUnitary().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
    args.painter.strokeLine(p.offsetBy(-5, 0), p.offsetBy(+5, 0));
  }).gate;
  Controls.XControl = new GateBuilder().setAlternate(Controls.XAntiControl).setSerializedId("⊖").setSymbol("⊕").setTitle("X-Axis Control").setBlurb("Conditions on a qubit being ON-OFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(true).setSetupCleanupEffectToUpdateFunc(HalfTurnGates.H.customOperation, HalfTurnGates.H.customOperation).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().promiseEffectIsUnitary().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
    args.painter.strokeLine(p.offsetBy(0, -5), p.offsetBy(0, +5));
    args.painter.strokeLine(p.offsetBy(-5, 0), p.offsetBy(+5, 0));
  }).gate;
  Controls.YAntiControl = new GateBuilder().setSerializedId("⊗").setSymbol("(/)").setTitle("Y-Axis Anti-Control").setBlurb("Conditions on a qubit being ON+iOFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(false).setSetupCleanupEffectToUpdateFunc(function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXForward._knownMatrix);
  }, function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXBackward._knownMatrix);
  }).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().promiseEffectIsUnitary().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
    var r = 5 * Math.sqrt(0.5) * 1.1;
    args.painter.strokeLine(p.offsetBy(+r, -r), p.offsetBy(-r, +r));
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintOutline(args);
    }
  }).gate;
  Controls.YControl = new GateBuilder().setAlternate(Controls.YAntiControl).setSerializedId("(/)").setSymbol("⊗").setTitle("Y-Axis Control").setBlurb("Conditions on a qubit being ON-iOFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(true).setSetupCleanupEffectToUpdateFunc(function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXForward._knownMatrix);
  }, function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXBackward._knownMatrix);
  }).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().promiseEffectIsUnitary().setDrawer(function(ctx) {
    if (ctx.isInToolbox || ctx.isHighlighted) {
      GatePainting.paintBackground(ctx);
      GatePainting.paintOutline(ctx);
    }
    var p = ctx.rect.center();
    ctx.painter.fillCircle(p, 5);
    ctx.painter.strokeCircle(p, 5);
    var r = 5 * Math.sqrt(0.5);
    ctx.painter.strokeLine(p.offsetBy(+r, +r), p.offsetBy(-r, -r));
    ctx.painter.strokeLine(p.offsetBy(+r, -r), p.offsetBy(-r, +r));
    if (ctx.isInToolbox || ctx.isHighlighted) {
      GatePainting.paintOutline(ctx);
    }
  }).gate;
  var PARITY_SHADER = ketShaderPermute("\n        uniform float parityMask;\n    ", ("\n        float bitPos = 1.0;\n        float result = 0.5;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float maskBit = mod(floor(parityMask/bitPos), 2.0);\n            float posBit = mod(floor(full_out_id/bitPos), 2.0);\n            float flip = maskBit * posBit;\n            result += flip;\n            bitPos *= 2.0;\n        }\n        return mod(result, 2.0) - 0.5;"), 1);
  function parityGatherScatter(ctx, order) {
    var $__1;
    var c = ctx.rawControls;
    var isLast = 2 << ctx.row > c.parityMask;
    var isFirst = 1 << ctx.row === (c.parityMask & ~(c.parityMask - 1));
    if (order ? isLast : isFirst) {
      ctx.applyOperation(($__1 = PARITY_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx.withRow(Util.ceilLg2(c.parityMask & c.inclusionMask))), [WglArg.float('parityMask', c.parityMask)])));
    }
  }
  function parityDrawer(name) {
    return function(args) {
      if (args.isInToolbox || args.isHighlighted) {
        GatePainting.paintBackground(args);
        GatePainting.paintOutline(args);
      }
      var center = args.rect.paddedBy(-10);
      args.painter.fillRect(center);
      args.painter.strokeRect(center);
      args.painter.fillRect(center.paddedBy(-4).skipBottom(-6).skipTop(-6));
      args.painter.printLine(name, center, 0.5, undefined, undefined, undefined, 0);
      args.painter.printLine('par', center, 0.5, 'red', 10, undefined, 1);
    };
  }
  Controls.XParityControl = new GateBuilder().setSerializedIdAndSymbol("xpar").setTitle("Parity Control (X)").setBlurb("Includes a qubit's X observable in the column parity control.\n" + "Gates in the same column only apply if an odd number of parity controls are satisfied.").setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().promiseEffectIsUnitary().markAsControlExpecting('parity').setSetupCleanupEffectToUpdateFunc(function(ctx) {
    HalfTurnGates.H.customOperation(ctx);
    parityGatherScatter(ctx, true);
  }, function(ctx) {
    parityGatherScatter(ctx, false);
    HalfTurnGates.H.customOperation(ctx);
  }).setDrawer(parityDrawer('X')).gate;
  Controls.YParityControl = new GateBuilder().setSerializedIdAndSymbol("ypar").setTitle("Parity Control (Y)").setBlurb("Includes a qubit's Y observable in the column parity control.\n" + "Gates in the same column only apply if an odd number of parity controls are satisfied.").setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().promiseEffectIsUnitary().markAsControlExpecting('parity').setSetupCleanupEffectToUpdateFunc(function(ctx) {
    GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXForward._knownMatrix);
    parityGatherScatter(ctx, true);
  }, function(ctx) {
    parityGatherScatter(ctx, false);
    GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXBackward._knownMatrix);
  }).setDrawer(parityDrawer('Y')).gate;
  Controls.ZParityControl = new GateBuilder().setSerializedIdAndSymbol("zpar").setTitle("Parity Control (Z)").setBlurb("Includes a qubit's Z observable in the column parity control.\n" + "Gates in the same column only apply if an odd number of parity controls are satisfied.").promiseHasNoNetEffectOnStateVector().markAsControlExpecting('parity').setSetupCleanupEffectToUpdateFunc(function(ctx) {
    return parityGatherScatter(ctx, true);
  }, function(ctx) {
    return parityGatherScatter(ctx, false);
  }).setActualEffectToUpdateFunc(function() {}).promiseEffectIsUnitary().setDrawer(parityDrawer('Z')).gate;
  Controls.all = [Controls.Control, Controls.AntiControl, Controls.XAntiControl, Controls.XControl, Controls.YAntiControl, Controls.YControl, Controls.XParityControl, Controls.YParityControl, Controls.ZParityControl];
  return {get Controls() {
      return Controls;
    }};
});
//# sourceURL=src/gates/Controls.js
;$traceurRuntime.registerModule("src/gates/CountingGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/CountingGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/CountingGates.js")).Config;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/CountingGates.js")),
      Gate = $__7.Gate,
      GateBuilder = $__7.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/CountingGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/CountingGates.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/CountingGates.js")).Point;
  var ketArgs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/CountingGates.js")).ketArgs;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/CountingGates.js")).WglArg;
  var offsetShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./IncrementGates.js", "src/gates/CountingGates.js")).offsetShader;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CycleBitsGates.js", "src/gates/CountingGates.js")),
      makeCycleBitsPermutation = $__14.makeCycleBitsPermutation,
      cycleBitsShader = $__14.cycleBitsShader;
  var CountingGates = {};
  var staircaseCurve = function(steps) {
    steps = Math.min(128, steps);
    var curve = [];
    for (var i = 0; i < steps; i++) {
      var x = i / steps;
      var y = i / (steps - 1);
      if (steps < 128) {
        curve.push(new Point(x, y));
      }
      curve.push(new Point(x + 1 / steps, y));
    }
    return curve;
  };
  var STAIRCASE_DRAWER = function(timeOffset, steps) {
    var flip = arguments[2] !== (void 0) ? arguments[2] : false;
    return function(args) {
      var $__4,
          $__5;
      var $__1,
          $__2,
          $__3;
      GatePainting.MAKE_HIGHLIGHTED_DRAWER(Config.TIME_DEPENDENT_HIGHLIGHT_COLOR)(args);
      if (args.isInToolbox && !args.isHighlighted) {
        return;
      }
      var t = (args.stats.time + timeOffset) % 1;
      var yOn = args.rect.y + 3;
      var yNeutral = args.rect.bottom();
      var yOff = args.rect.bottom() - 3;
      if (!flip) {
        ($__1 = [yOff, yOn], yOn = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value), yOff = ($__3 = $__2.next()).done ? void 0 : $__3.value, $__1);
        yNeutral = args.rect.y;
      }
      var xi = args.rect.x;
      var xf = args.rect.right();
      var xt = function(p) {
        return Math.min(Math.max(xi + (xf - xi) * p, xi), xf);
      };
      var yt = function(p) {
        return yOff + (yOn - yOff) * p;
      };
      var curve = [];
      curve.push(new Point(xi, yNeutral));
      ($__4 = curve).push.apply($__4, $traceurRuntime.spread(staircaseCurve(steps).map(function(p) {
        return new Point(xt(p.x - t), yt(p.y));
      })));
      ($__5 = curve).push.apply($__5, $traceurRuntime.spread(staircaseCurve(steps).map(function(p) {
        return new Point(xt(p.x + 1 - t), yt(p.y));
      })));
      curve.push(new Point(xf, yNeutral));
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.3;
      args.painter.fillPolygon(curve, 'yellow');
      for (var i = 1; i < curve.length - 2; i++) {
        args.painter.strokeLine(curve[i], curve[i + 1], 'black');
      }
      if (steps === 2 && t < 0.5) {
        args.painter.fillRect(args.rect, 'white');
        args.painter.fillRect(args.rect, 'white');
        args.painter.fillRect(args.rect, 'white');
      }
      args.painter.ctx.restore();
    };
  };
  function offsetPermutation(time, factor, span, state) {
    var offset = Math.floor(time * (1 << span)) * factor;
    return (state + offset) & ((1 << span) - 1);
  }
  function bitOffsetPermutation(time, factor, span, state) {
    var offset = Math.floor(time * span) * factor;
    return makeCycleBitsPermutation(offset, span)(state);
  }
  CountingGates.ClockPulseGate = new GateBuilder().setSerializedIdAndSymbol("X^⌈t⌉").setTitle("Clock Pulse Gate").setBlurb("Xors a square wave into the target wire.").setDrawer(STAIRCASE_DRAWER(0, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return (t % 1) < 0.5 ? Matrix.identity(2) : Matrix.PAULI_X;
  }).promiseEffectOnlyPermutesAndPhases().gate;
  CountingGates.QuarterPhaseClockPulseGate = new GateBuilder().setSerializedIdAndSymbol("X^⌈t-¼⌉").setTitle("Clock Pulse Gate (Quarter Phase)").setBlurb("Xors a quarter-phased square wave into the target wire.").setDrawer(STAIRCASE_DRAWER(0.75, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return ((t + 0.75) % 1) < 0.5 ? Matrix.identity(2) : Matrix.PAULI_X;
  }).promiseEffectOnlyPermutesAndPhases().gate;
  CountingGates.CountingFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Counting" + span).setSymbol("+⌈t⌉").setTitle("Counting Gate").setBlurb("Adds an increasing little-endian count into a block of qubits.").setDrawer(STAIRCASE_DRAWER(0, 1 << span)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = offsetShader).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", Math.floor(ctx.time * (1 << span)))]));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return offsetPermutation(t, +1, span, i);
    });
  });
  CountingGates.UncountingFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(CountingGates.CountingFamily).setSerializedId("Uncounting" + span).setSymbol("-⌈t⌉").setTitle("Down Counting Gate").setBlurb("Subtracts an increasing little-endian count from a block of qubits.").setDrawer(STAIRCASE_DRAWER(0, 1 << span, true)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = offsetShader).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", -Math.floor(ctx.time * (1 << span)))]));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return offsetPermutation(t, -1, span, i);
    });
  });
  CountingGates.RightShiftRotatingFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId(">>t" + span).setSymbol("↟⌈t⌉").setTitle("Right-Shift Cycling Gate").setBlurb("Right-rotates a block of bits by more and more.").setDrawer(STAIRCASE_DRAWER(0, span, true)).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, -Math.floor(ctx.time * span));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return bitOffsetPermutation(t, -1, span, i);
    });
  });
  CountingGates.LeftShiftRotatingFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("<<t" + span).setSymbol("↡⌈t⌉").setTitle("Left-Shift Cycling Gate").setBlurb("Left-rotates a block of bits by more and more.").setDrawer(STAIRCASE_DRAWER(0, span)).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, Math.floor(ctx.time * span));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return bitOffsetPermutation(t, +1, span, i);
    });
  });
  CountingGates.all = $traceurRuntime.spread([CountingGates.ClockPulseGate, CountingGates.QuarterPhaseClockPulseGate], CountingGates.CountingFamily.all, CountingGates.UncountingFamily.all, CountingGates.RightShiftRotatingFamily.all, CountingGates.LeftShiftRotatingFamily.all);
  return {get CountingGates() {
      return CountingGates;
    }};
});
//# sourceURL=src/gates/CountingGates.js
;$traceurRuntime.registerModule("src/gates/CycleBitsGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/CycleBitsGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/CycleBitsGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/CycleBitsGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/CycleBitsGates.js")).GatePainting;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/CycleBitsGates.js")),
      ketArgs = $__5.ketArgs,
      ketShaderPermute = $__5.ketShaderPermute;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/CycleBitsGates.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/CycleBitsGates.js")).Point;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/CycleBitsGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/CycleBitsGates.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/gates/CycleBitsGates.js")).WglConfiguredShader;
  var CycleBitsGates = {};
  var cycleBitsShader = function(ctx, qubitSpan, shiftAmount) {
    var $__1;
    return ($__1 = CYCLE_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, qubitSpan), [WglArg.float("amount", 1 << Util.properMod(-shiftAmount, qubitSpan))]));
  };
  var CYCLE_SHADER = ketShaderPermute('uniform float amount;', 'out_id *= amount; return mod(out_id, span) + floor(out_id / span);');
  var makeCycleBitsPermutation = function(shift, span) {
    return function(e) {
      shift = Util.properMod(shift, span);
      return ((e << shift) & ((1 << span) - 1)) | (e >> (span - shift));
    };
  };
  var makeCycleBitsMatrix = function(shift, span) {
    return Matrix.generateTransition(1 << span, makeCycleBitsPermutation(shift, span));
  };
  var cyclePainter = function(reverse) {
    return function(args) {
      if (args.positionInCircuit !== undefined) {
        GatePainting.PERMUTATION_DRAWER(args);
        return;
      }
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
      var x1 = args.rect.x + 6;
      var x2 = args.rect.right() - 6;
      var y = args.rect.center().y - Config.GATE_RADIUS + 6;
      var dh = (Config.GATE_RADIUS - 6) * 2 / 2;
      for (var i = 0; i < 3; i++) {
        var j = (i + (reverse ? 2 : 1)) % 3;
        var y1 = y + i * dh;
        var y2 = y + j * dh;
        args.painter.strokePath([new Point(x1, y1), new Point(x1 + 8, y1), new Point(x2 - 8, y2), new Point(x2, y2)]);
      }
    };
  };
  CycleBitsGates.CycleBitsFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("<<" + span).setSymbol("<<<").setTitle("Left Rotate").setBlurb("Rotates bits downward.").setDrawer(cyclePainter(false)).setTooltipMatrixFunc(function() {
      return makeCycleBitsMatrix(1, span);
    }).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, +1);
    }).setKnownEffectToBitPermutation(function(i) {
      return (i + 1) % span;
    });
  });
  CycleBitsGates.ReverseCycleBitsFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setAlternateFromFamily(CycleBitsGates.CycleBitsFamily).setSerializedId(">>" + span).setSymbol(">>>").setTitle("Right Rotate").setBlurb("Rotates bits upward.").setDrawer(cyclePainter(true)).setTooltipMatrixFunc(function() {
      return makeCycleBitsMatrix(-1, span);
    }).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, -1);
    }).setKnownEffectToBitPermutation(function(i) {
      return (i + span - 1) % span;
    });
  });
  CycleBitsGates.all = $traceurRuntime.spread(CycleBitsGates.CycleBitsFamily.all, CycleBitsGates.ReverseCycleBitsFamily.all);
  return {
    get CycleBitsGates() {
      return CycleBitsGates;
    },
    get cycleBitsShader() {
      return cycleBitsShader;
    },
    get makeCycleBitsPermutation() {
      return makeCycleBitsPermutation;
    }
  };
});
//# sourceURL=src/gates/CycleBitsGates.js
;$traceurRuntime.registerModule("src/gates/Debug_ErrorInjectionGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Debug_ErrorInjectionGate.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/gates/Debug_ErrorInjectionGate.js")).DetailedError;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Debug_ErrorInjectionGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Debug_ErrorInjectionGate.js")).GatePainting;
  var ErrorInjectionGate = new GateBuilder().setSerializedId("__error__").setSymbol("ERR!").setTitle("Error Injection Gate").setBlurb("Throws an exception during circuit stat computations, for testing error paths.").setDrawer(GatePainting.MAKE_HIGHLIGHTED_DRAWER('red', 'red')).setActualEffectToUpdateFunc(function(ctx) {
    throw new DetailedError("Applied an Error Injection Gate", {qubit: ctx.row});
  }).promiseEffectIsStable().gate;
  return {get ErrorInjectionGate() {
      return ErrorInjectionGate;
    }};
});
//# sourceURL=src/gates/Debug_ErrorInjectionGate.js
;$traceurRuntime.registerModule("src/gates/DensityMatrixDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/DensityMatrixDisplay.js";
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitShaders.js", "src/gates/DensityMatrixDisplay.js")).CircuitShaders;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/DensityMatrixDisplay.js")),
      Gate = $__4.Gate,
      GateBuilder = $__4.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/DensityMatrixDisplay.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateShaders.js", "src/gates/DensityMatrixDisplay.js")).GateShaders;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/gates/DensityMatrixDisplay.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/DensityMatrixDisplay.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/gates/DensityMatrixDisplay.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/DensityMatrixDisplay.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/DensityMatrixDisplay.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/gates/DensityMatrixDisplay.js")).WglConfiguredShader;
  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/gates/DensityMatrixDisplay.js")),
      Inputs = $__13.Inputs,
      Outputs = $__13.Outputs,
      currentShaderCoder = $__13.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__13.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTexturePool.js", "src/gates/DensityMatrixDisplay.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTextureTrader.js", "src/gates/DensityMatrixDisplay.js")).WglTextureTrader;
  function densityDisplayStatTexture(inp, qubitCount, controls, rangeOffset, rangeLength) {
    var trader = new WglTextureTrader(inp);
    trader.dontDeallocCurrentTexture();
    var startingQubits = currentShaderCoder().vec2.arrayPowerSizeOfTexture(inp);
    var lostQubits = Util.numberOfSetBits(controls.inclusionMask);
    var lostHeadQubits = Util.numberOfSetBits(controls.inclusionMask & ((1 << rangeOffset) - 1));
    trader.shadeAndTrade(function(ket) {
      return CircuitShaders.controlSelect(controls, ket);
    }, WglTexturePool.takeVec2Tex(startingQubits - lostQubits));
    trader.shadeAndTrade(function(ket) {
      return GateShaders.cycleAllBits(ket, lostHeadQubits - rangeOffset);
    });
    var n = qubitCount - lostQubits + rangeLength;
    trader.shadeAndTrade(function(e) {
      return amplitudesToCouplings(e, rangeLength);
    }, WglTexturePool.takeVec2Tex(n));
    while (n > 2 * rangeLength) {
      n--;
      trader.shadeHalveAndTrade(Shaders.sumFoldVec2);
    }
    if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
      trader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
    }
    return trader.currentTexture;
  }
  var amplitudesToCouplings = function(inputTexture, qubitSpan) {
    return AMPLITUDES_TO_DENSITIES_SHADER(inputTexture, WglArg.float('qubitSpan', 1 << qubitSpan));
  };
  var AMPLITUDES_TO_DENSITIES_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "\n    uniform float qubitSpan;\n\n    vec2 outputFor(float k) {\n        float k_ket = mod(k, qubitSpan);\n        float k_bra = mod(floor(k / qubitSpan), qubitSpan);\n        float k_rest = floor(k / qubitSpan / qubitSpan);\n        float offset = k_rest*qubitSpan;\n\n        vec2 ampKet = read_input(k_ket + offset);\n        vec2 ampBra = read_input(k_bra + offset);\n        float r = dot(ampKet, ampBra);\n        float i = dot(ampKet, vec2(-ampBra.y, ampBra.x));\n\n        return vec2(r, i);\n    }");
  function decohereMeasuredBitsInDensityMatrix(densityMatrix, isMeasuredMask) {
    if (isMeasuredMask === 0) {
      return densityMatrix;
    }
    var buf = new Float32Array(densityMatrix.rawBuffer());
    var n = densityMatrix.width();
    for (var row = 0; row < n; row++) {
      for (var col = 0; col < n; col++) {
        if (((row ^ col) & isMeasuredMask) !== 0) {
          var k = (row * n + col) * 2;
          buf[k] = 0;
          buf[k + 1] = 0;
        }
      }
    }
    return new Matrix(n, n, buf);
  }
  function densityPixelsToMatrix(pixels, circuitDefinition, col, row) {
    var n = pixels.length >> 1;
    var d = Math.round(Math.sqrt(n));
    var unity = 0;
    for (var i = 0; i < d; i++) {
      unity += pixels[2 * i * (d + 1)];
    }
    if (isNaN(unity) || unity < 0.000001) {
      return Matrix.zero(d, d).times(NaN);
    }
    for (var i$__2 = 0; i$__2 < pixels.length; i$__2++) {
      pixels[i$__2] /= unity;
    }
    var isMeasuredMask = circuitDefinition.colIsMeasuredMask(col) >> row;
    return decohereMeasuredBitsInDensityMatrix(new Matrix(d, d, pixels), isMeasuredMask).transpose();
  }
  function densityMatrixDisplayMaker_shared(builder) {
    return builder.setSymbol("Density").setTitle("Density Matrix Display").setBlurb("Shows the density matrix of the local mixed state of some wires.\n" + "Use controls to see conditional states.").promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    });
  }
  function singleDensityMatrixDisplayMaker(builder) {
    return densityMatrixDisplayMaker_shared(builder).setSerializedId("Density").markAsDrawerNeedsSingleQubitDensityStats().setDrawer(GatePainting.makeDisplayDrawer(function(args) {
      var $__1 = args.positionInCircuit,
          col = $__1.col,
          row = $__1.row;
      var ρ = args.stats.qubitDensityMatrix(col, row).transpose();
      MathPainter.paintDensityMatrix(args.painter, ρ, args.rect, args.focusPoints);
    }));
  }
  function largeDensityMatrixDisplayMaker(span, builder) {
    return densityMatrixDisplayMaker_shared(builder).setSerializedId("Density" + span).setWidth(span).setDrawer(DENSITY_MATRIX_DRAWER_FROM_CUSTOM_STATS).setProcessedStatsToJsonFunc(function(data) {
      return {density_matrix: data.toReadableJson()};
    }).setStatTexturesMaker(function(ctx) {
      return densityDisplayStatTexture(ctx.stateTrader.currentTexture, ctx.wireCount, ctx.controls, ctx.row, span);
    }).setStatPixelDataPostProcessor(densityPixelsToMatrix);
  }
  var DENSITY_MATRIX_DRAWER_FROM_CUSTOM_STATS = GatePainting.makeDisplayDrawer(function(args) {
    var n = args.gate.height;
    var ρ = args.customStats || Matrix.zero(1 << n, 1 << n).times(NaN);
    MathPainter.paintDensityMatrix(args.painter, ρ, args.rect, args.focusPoints);
  });
  var DensityMatrixDisplayFamily = Gate.buildFamily(1, 8, function(span, builder) {
    return span === 1 ? singleDensityMatrixDisplayMaker(builder) : largeDensityMatrixDisplayMaker(span, builder);
  });
  return {
    get DensityMatrixDisplayFamily() {
      return DensityMatrixDisplayFamily;
    },
    get amplitudesToCouplings() {
      return amplitudesToCouplings;
    }
  };
});
//# sourceURL=src/gates/DensityMatrixDisplay.js
;$traceurRuntime.registerModule("src/gates/Detector.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Detector.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Detector.js")).GateBuilder;
  var amplitudesToProbabilities = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/ProbabilityDisplay.js", "src/gates/Detector.js")).amplitudesToProbabilities;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTexturePool.js", "src/gates/Detector.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTextureTrader.js", "src/gates/Detector.js")).WglTextureTrader;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/gates/Detector.js")).Shaders;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/gates/Detector.js")),
      currentShaderCoder = $__14.currentShaderCoder,
      Inputs = $__14.Inputs;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitShaders.js", "src/gates/Detector.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Controls.js", "src/gates/Detector.js")).Controls;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/Detector.js")).WglArg;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/Detector.js")).Config;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Detector.js")).GatePainting;
  var $__20 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/gates/Detector.js")),
      makePseudoShaderWithInputsAndOutputAndCode = $__20.makePseudoShaderWithInputsAndOutputAndCode,
      Outputs = $__20.Outputs;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/Detector.js")).Matrix;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateShaders.js", "src/gates/Detector.js")).GateShaders;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/Detector.js")).Point;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/gates/Detector.js")).DetailedError;
  var QuarterTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./QuarterTurnGates.js", "src/gates/Detector.js")).QuarterTurnGates;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./HalfTurnGates.js", "src/gates/Detector.js")).HalfTurnGates;
  function controlMaskTex(ctx, controls) {
    var powerSize = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ctx.stateTrader.currentTexture);
    return CircuitShaders.controlMask(controls).toBoolTexture(powerSize);
  }
  function textureWithTotalWeightMatchingGivenControls(ketTexture, controlMaskTex) {
    var forStats = arguments[2] !== (void 0) ? arguments[2] : false;
    var powerSize = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ketTexture);
    var trader = new WglTextureTrader(ketTexture);
    trader.dontDeallocCurrentTexture();
    trader.shadeAndTrade(function(tex) {
      return amplitudesToProbabilities(tex, controlMaskTex);
    }, WglTexturePool.takeVecFloatTex(powerSize));
    var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ketTexture);
    while (n > 0) {
      n -= 1;
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    trader.shadeAndTrade(Shaders.packFloatIntoVec4, WglTexturePool.takeVec4Tex(0));
    return trader.currentTexture;
  }
  function detectorStatTexture(ctx) {
    var mask = controlMaskTex(ctx, ctx.controls.and(Controls.bit(ctx.row, true)));
    try {
      return textureWithTotalWeightMatchingGivenControls(ctx.stateTrader.currentTexture, mask, true);
    } finally {
      mask.deallocByDepositingInPool('textureWithTotalWeightMatchingPositiveMeasurement:mask');
    }
  }
  var detectorShader = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('total_weight'), Inputs.float('detection_weight'), Inputs.bool('classification'), Inputs.vec2('ket')], Outputs.vec2(), "\n        uniform float rnd;\n    \n        vec2 outputFor(float k) {\n            float detectChance = read_detection_weight(0.0) / read_total_weight(0.0);\n            float detection_type = float(rnd < detectChance);\n            float own_type = read_classification(k);\n            if (detection_type == own_type) {\n                float matchChance = detectChance * own_type + (1.0 - own_type) * (1.0 - detectChance);\n                return read_ket(k) / sqrt(matchChance);\n            } else {\n                return vec2(0.0, 0.0);\n            }\n        }\n    ");
  function switchToBasis(ctx, axis, inverse) {
    switch (axis) {
      case 'X':
        GateShaders.applyMatrixOperation(ctx, HalfTurnGates.H.knownMatrixAt(0));
        break;
      case 'Y':
        if (inverse) {
          GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXBackward.knownMatrixAt(0));
        } else {
          GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXForward.knownMatrixAt(0));
        }
        break;
      case 'Z':
        break;
      default:
        throw new DetailedError('Unrecognized axis.', {axis: axis});
    }
  }
  function sampleMeasure(ctx) {
    var maskAll = controlMaskTex(ctx, Controls.NONE);
    var maskMatch = controlMaskTex(ctx, ctx.controls.and(Controls.bit(ctx.row, true)));
    var weightAll = textureWithTotalWeightMatchingGivenControls(ctx.stateTrader.currentTexture, maskAll);
    var weightMatch = textureWithTotalWeightMatchingGivenControls(ctx.stateTrader.currentTexture, maskMatch);
    ctx.applyOperation(detectorShader(weightAll, weightMatch, maskMatch, ctx.stateTrader.currentTexture, WglArg.float('rnd', Math.random())));
    weightMatch.deallocByDepositingInPool();
    weightAll.deallocByDepositingInPool();
    maskMatch.deallocByDepositingInPool();
    maskAll.deallocByDepositingInPool();
  }
  function drawDetector(args, axis) {
    drawHighlight(args);
    drawWedge(args, axis);
    drawClick(args, axis);
  }
  function drawHighlight(args) {
    if (args.isHighlighted || args.isInToolbox) {
      args.painter.fillRect(args.rect, args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR);
      GatePainting.paintOutline(args);
    }
  }
  function drawWedge(args, axis) {
    var τ = Math.PI * 2;
    var r = Math.min(args.rect.h / 2, args.rect.w) - 1;
    var $__8 = args.rect.center(),
        x = $__8.x,
        y = $__8.y;
    x -= r * 0.5;
    x += 0.5;
    y += 0.5;
    args.painter.trace(function(trace) {
      trace.ctx.arc(x, y, r, τ * 3 / 4, τ / 4);
      trace.ctx.lineTo(x, y - r - 1);
    }).thenStroke('black', 2).thenFill(Config.TIME_DEPENDENT_HIGHLIGHT_COLOR);
    args.painter.printLine(axis, args.rect, 0.5, undefined, undefined, undefined, 0.5);
  }
  function drawClick(args, axis) {
    var clicked = args.customStats;
    if (!clicked) {
      return;
    }
    var r = Math.min(args.rect.h / 2, args.rect.w);
    args.painter.ctx.save();
    args.painter.ctx.translate(args.rect.center().x, args.rect.center().y);
    args.painter.ctx.rotate(axis === undefined ? Math.PI / 3 : Math.PI / 4);
    args.painter.ctx.strokeStyle = 'white';
    args.painter.ctx.lineWidth = 3;
    args.painter.print('*click*', 0, axis === undefined ? 0 : -5, 'center', 'middle', 'black', 'bold 16px sans-serif', r * 2.8, r * 2.8, undefined, true);
    if (axis !== undefined) {
      args.painter.print(axis, 0, 10, 'center', 'middle', 'black', 'bold 16px sans-serif', r * 2.8, r * 2.8, undefined, true);
    }
    args.painter.ctx.restore();
  }
  function drawControlBulb(args, axis) {
    redrawControlWires(args);
    var p = args.rect.center();
    switch (axis) {
      case 'X':
        args.painter.fillCircle(p, 5);
        args.painter.strokeCircle(p, 5);
        args.painter.strokeLine(p.offsetBy(0, -5), p.offsetBy(0, +5));
        args.painter.strokeLine(p.offsetBy(-5, 0), p.offsetBy(+5, 0));
        break;
      case 'Y':
        args.painter.fillCircle(p, 5);
        args.painter.strokeCircle(p, 5);
        var r = 5 * Math.sqrt(0.5) * 1.1;
        args.painter.strokeLine(p.offsetBy(+r, -r), p.offsetBy(-r, +r));
        args.painter.strokeLine(p.offsetBy(-r, -r), p.offsetBy(+r, +r));
        break;
      case 'Z':
        args.painter.fillCircle(p, 5, "black");
        break;
      default:
        throw new DetailedError('Unrecognized axis.', {axis: axis});
    }
  }
  function drawDetectClearReset(args, axis) {
    var fullRect = args.rect;
    var detectorRect = fullRect.leftHalf();
    var resetRect = fullRect.rightHalf();
    var clearWireRect = fullRect.rightHalf();
    clearWireRect.y += clearWireRect.h / 2 - 2;
    clearWireRect.h = 5;
    args.painter.fillRect(clearWireRect, 'white');
    drawHighlight(args);
    args.painter.printLine('|0⟩', resetRect, 1, undefined, undefined, undefined, 0.5);
    args.rect = detectorRect;
    drawWedge(args, axis);
    args.rect = fullRect;
    drawControlBulb(args, axis);
    args.rect = detectorRect;
    drawClick(args, undefined);
    args.rect = fullRect;
  }
  function redrawControlWires(args) {
    if (args.positionInCircuit === undefined || args.isHighlighted) {
      return;
    }
    var painter = args.painter;
    var columnIndex = args.positionInCircuit.col;
    var x = Math.round(args.rect.center().x - 0.5) + 0.5;
    var circuit = args.stats.circuitDefinition;
    if (circuit.columns[columnIndex].hasGatesWithGlobalEffects()) {
      painter.ctx.save();
      painter.ctx.setLineDash([1, 4]);
      painter.strokeLine(new Point(x, args.rect.y), new Point(x, args.rect.bottom()));
      painter.ctx.restore();
    }
    var row = args.positionInCircuit.row;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (circuit.controlLinesRanges(columnIndex))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var $__8 = $__2.value,
            first = $__8.first,
            last = $__8.last,
            measured = $__8.measured;
        {
          if (first <= row && row <= last) {
            var y1 = first === row ? args.rect.center().y : args.rect.y;
            var y2 = last === row ? args.rect.center().y : args.rect.bottom();
            if (measured) {
              painter.strokeLine(new Point(x + 1, y1), new Point(x + 1, y2));
              painter.strokeLine(new Point(x - 1, y1), new Point(x - 1, y2));
            } else {
              painter.strokeLine(new Point(x, y1), new Point(x, y2));
            }
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  }
  function withClearedControls(func) {
    return function(ctx) {
      var controls = ctx.controls;
      var texture = ctx.controlsTexture;
      try {
        ctx.controls = Controls.NONE;
        ctx.controlsTexture = controlMaskTex(ctx, ctx.controls);
        return func(ctx);
      } finally {
        ctx.controlsTexture.deallocByDepositingInPool('withClearedControls');
        ctx.controlsTexture = texture;
        ctx.controls = controls;
      }
    };
  }
  function makeDetectControlClearGate(axis) {
    var builder = new GateBuilder().setSerializedIdAndSymbol((axis + "DetectControlReset")).setTitle((axis + " Detect-Control-Reset")).setBlurb(("Does a sampled " + axis + "-axis measurement.\nControls operations with the result.\nResets the target to |0⟩.")).setDrawer(function(args) {
      return drawDetectClearReset(args, axis);
    }).markAsControlExpecting(true, true).markAsReachingOtherWires().setActualEffectToUpdateFunc(function() {}).setStatTexturesMaker(withClearedControls(detectorStatTexture)).setSetupCleanupEffectToUpdateFunc(withClearedControls(function(ctx) {
      switchToBasis(ctx, axis, false);
      sampleMeasure(ctx);
    }), withClearedControls(function(ctx) {
      GateShaders.applyMatrixOperation(ctx, Matrix.square(1, 1, 0, 0));
    })).setStatPixelDataPostProcessor(function(pixels, circuit, row, col) {
      return pixels[0] > 0;
    });
    if (axis === 'Z') {
      builder.promiseEffectIsDiagonal();
    }
    return builder.gate;
  }
  function makeDetector(axis) {
    var state = new Map([['X', '|0⟩-|1⟩'], ['Y', '|0⟩-i|1⟩'], ['Z', '|1⟩']]).get(axis);
    var builder = new GateBuilder().setSerializedIdAndSymbol((axis + "Detector")).setTitle((axis + " Axis Detector")).setBlurb(("Sampled " + axis + "-axis measurement.\n") + ("Shows *click* when the target qubit is " + state + " and controls are satisfied.")).setDrawer(function(args) {
      return drawDetector(args, axis);
    }).markAsReachingOtherWires().setSetupCleanupEffectToUpdateFunc(function(ctx) {
      return switchToBasis(ctx, axis, false);
    }, function(ctx) {
      return switchToBasis(ctx, axis, true);
    }).setActualEffectToUpdateFunc(sampleMeasure).setStatTexturesMaker(detectorStatTexture).setStatPixelDataPostProcessor(function(pixels, circuit, row, col) {
      return pixels[0] > 0;
    });
    if (axis === 'Z') {
      builder.promiseEffectIsDiagonal();
    }
    return builder.gate;
  }
  var Detectors = {};
  Detectors.XDetector = makeDetector('X');
  Detectors.YDetector = makeDetector('Y');
  Detectors.ZDetector = makeDetector('Z');
  Detectors.XDetectControlClear = makeDetectControlClearGate('X');
  Detectors.YDetectControlClear = makeDetectControlClearGate('Y');
  Detectors.ZDetectControlClear = makeDetectControlClearGate('Z');
  Detectors.all = [Detectors.XDetector, Detectors.YDetector, Detectors.ZDetector, Detectors.XDetectControlClear, Detectors.YDetectControlClear, Detectors.ZDetectControlClear];
  return {get Detectors() {
      return Detectors;
    }};
});
//# sourceURL=src/gates/Detector.js
;$traceurRuntime.registerModule("src/gates/ExponentiatingGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ExponentiatingGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ExponentiatingGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/ExponentiatingGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/ExponentiatingGates.js")).Matrix;
  var ExponentiatingGates = {};
  var τ = Math.PI * 2;
  var XExp = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([c, 0, 0, -s, 0, -s, c, 0]));
  };
  var YExp = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([c, 0, -s, 0, s, 0, c, 0]));
  };
  var ZExp = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([c, -s, 0, 0, 0, 0, c, s]));
  };
  ExponentiatingGates.XForward = new GateBuilder().setSerializedIdAndSymbol("e^-iXt").setTitle("X-Exponentiating Gate (forward)").setBlurb("Right-hand rotation around the X axis.\nPasses through ±iX instead of X.").setDrawer(GatePainting.makeCycleDrawer(1, 1, 2)).setEffectToTimeVaryingMatrix(XExp).promiseEffectIsUnitary().gate;
  ExponentiatingGates.XBackward = new GateBuilder().setAlternate(ExponentiatingGates.XForward).setSerializedIdAndSymbol("e^iXt").setTitle("X-Exponentiating Gate (backward)").setBlurb("Left-hand rotation around the X axis.\nPasses through ±iX instead of X.").setDrawer(GatePainting.makeCycleDrawer(-1, 1, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return XExp(-t);
  }).promiseEffectIsUnitary().gate;
  ExponentiatingGates.YForward = new GateBuilder().setSerializedIdAndSymbol("e^-iYt").setTitle("Y-Exponentiating Gate (forward)").setBlurb("Right-hand rotation around the Y axis.\nPasses through ±iY instead of Y.").setDrawer(GatePainting.makeCycleDrawer(0.5, 1, 2)).setEffectToTimeVaryingMatrix(YExp).promiseEffectIsUnitary().gate;
  ExponentiatingGates.YBackward = new GateBuilder().setAlternate(ExponentiatingGates.YForward).setSerializedIdAndSymbol("e^iYt").setTitle("Y-Exponentiating Gate (backward)").setBlurb("Left-hand rotation around the Y axis.\nPasses through ±iY instead of Y.").setDrawer(GatePainting.makeCycleDrawer(-0.5, 1, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return YExp(-t);
  }).promiseEffectIsUnitary().gate;
  ExponentiatingGates.ZForward = new GateBuilder().setSerializedIdAndSymbol("e^-iZt").setTitle("Z-Exponentiating Gate (forward)").setBlurb("Right-hand rotation around the Z axis.\nPasses through ±iZ instead of Z.").setDrawer(GatePainting.makeCycleDrawer(-1, -0.5, 2)).setEffectToTimeVaryingMatrix(ZExp).promiseEffectOnlyPhases().gate;
  ExponentiatingGates.ZBackward = new GateBuilder().setAlternate(ExponentiatingGates.ZForward).setSerializedIdAndSymbol("e^iZt").setTitle("Z-Exponentiating Gate (backward)").setBlurb("Left-hand rotation around the Z axis.\nPasses through ±iZ instead of Z.").setDrawer(GatePainting.makeCycleDrawer(1, -0.5, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return ZExp(-t);
  }).promiseEffectOnlyPhases().gate;
  ExponentiatingGates.all = [ExponentiatingGates.XBackward, ExponentiatingGates.YBackward, ExponentiatingGates.ZBackward, ExponentiatingGates.XForward, ExponentiatingGates.YForward, ExponentiatingGates.ZForward];
  return {
    get ExponentiatingGates() {
      return ExponentiatingGates;
    },
    get XExp() {
      return XExp;
    },
    get YExp() {
      return YExp;
    },
    get ZExp() {
      return ZExp;
    }
  };
});
//# sourceURL=src/gates/ExponentiatingGates.js
;$traceurRuntime.registerModule("src/gates/FourierTransformGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/FourierTransformGates.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/FourierTransformGates.js")).Complex;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/FourierTransformGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/FourierTransformGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPhase = $__4.ketShaderPhase;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/FourierTransformGates.js")).Matrix;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./HalfTurnGates.js", "src/gates/FourierTransformGates.js")).HalfTurnGates;
  var reverseShaderForSize = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ReverseBitsGate.js", "src/gates/FourierTransformGates.js")).reverseShaderForSize;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/FourierTransformGates.js")).WglArg;
  function applyControlledPhaseGradient(ctx, qubitSpan) {
    var $__1;
    var factor = arguments[2] !== (void 0) ? arguments[2] : 1;
    ctx.applyOperation(($__1 = CONTROLLED_PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, qubitSpan), [WglArg.float("factor", factor)])));
  }
  var CONTROLLED_PHASE_GRADIENT_SHADER = ketShaderPhase('uniform float factor;', "\n        float hold = floor(out_id * 2.0 / span);\n        float step = mod(out_id, span / 2.0);\n        return hold * step * factor * 6.2831853071795864769 / span;\n    ");
  var FOURIER_TRANSFORM_MATRIX_MAKER = function(span) {
    return Matrix.generate(1 << span, 1 << span, function(r, c) {
      return Complex.polar(Math.pow(0.5, span / 2), Math.PI * 2 * r * c / (1 << span));
    });
  };
  var INVERSE_FOURIER_TRANSFORM_MATRIX_MAKER = function(span) {
    return FOURIER_TRANSFORM_MATRIX_MAKER(span).adjoint();
  };
  var FourierTransformGates = {};
  function applyForwardGradientShaders(ctx, span) {
    if (span > 1) {
      ctx.applyOperation(reverseShaderForSize(span));
    }
    for (var i = 0; i < span; i++) {
      if (i > 0) {
        applyControlledPhaseGradient(ctx, i + 1, +1);
      }
      HalfTurnGates.H.customOperation(ctx.withRow(ctx.row + i));
    }
  }
  function applyBackwardGradientShaders(ctx, span) {
    for (var i = span - 1; i >= 0; i--) {
      HalfTurnGates.H.customOperation(ctx.withRow(ctx.row + i));
      if (i > 0) {
        applyControlledPhaseGradient(ctx, i + 1, -1);
      }
    }
    if (span > 1) {
      ctx.applyOperation(reverseShaderForSize(span));
    }
  }
  FourierTransformGates.FourierTransformFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("QFT" + span).setSymbol("QFT").setTitle("Fourier Transform Gate").setBlurb("Transforms to/from phase frequency space.").setActualEffectToUpdateFunc(function(ctx) {
      return applyForwardGradientShaders(ctx, span);
    }).promiseEffectIsUnitary().setTooltipMatrixFunc(function() {
      return FOURIER_TRANSFORM_MATRIX_MAKER(span);
    });
  });
  FourierTransformGates.InverseFourierTransformFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("QFT†" + span).setSymbol("QFT^†").setAlternateFromFamily(FourierTransformGates.FourierTransformFamily).setTitle("Inverse Fourier Transform Gate").setBlurb("Transforms from/to phase frequency space.").setActualEffectToUpdateFunc(function(ctx) {
      return applyBackwardGradientShaders(ctx, span);
    }).promiseEffectIsUnitary().setTooltipMatrixFunc(function() {
      return INVERSE_FOURIER_TRANSFORM_MATRIX_MAKER(span);
    });
  });
  FourierTransformGates.all = $traceurRuntime.spread(FourierTransformGates.FourierTransformFamily.all, FourierTransformGates.InverseFourierTransformFamily.all);
  return {
    get applyControlledPhaseGradient() {
      return applyControlledPhaseGradient;
    },
    get FourierTransformGates() {
      return FourierTransformGates;
    }
  };
});
//# sourceURL=src/gates/FourierTransformGates.js
;$traceurRuntime.registerModule("src/gates/HalfTurnGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/HalfTurnGates.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/HalfTurnGates.js")),
      Gate = $__2.Gate,
      GateBuilder = $__2.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/HalfTurnGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/HalfTurnGates.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/HalfTurnGates.js")).Point;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/HalfTurnGates.js")),
      ketArgs = $__6.ketArgs,
      ketShader = $__6.ketShader,
      ketShaderPermute = $__6.ketShaderPermute;
  var HalfTurnGates = {};
  function NOT_DRAWER(args) {
    if (args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    if (args.positionInCircuit === undefined) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var drawArea = args.rect.scaledOutwardBy(0.6);
    args.painter.fillCircle(drawArea.center(), drawArea.w / 2);
    args.painter.strokeCircle(drawArea.center(), drawArea.w / 2);
    var hasSingleWireControl = args.positionInCircuit !== undefined && args.stats.circuitDefinition.colHasSingleWireControl(args.positionInCircuit.col);
    var hasDoubleWireControl = args.positionInCircuit !== undefined && args.stats.circuitDefinition.colHasDoubleWireControl(args.positionInCircuit.col);
    if (hasSingleWireControl || !hasDoubleWireControl) {
      args.painter.strokeLine(drawArea.topCenter(), drawArea.bottomCenter());
    }
    if (hasDoubleWireControl) {
      args.painter.strokeLine(drawArea.topCenter().offsetBy(-1, 0), drawArea.bottomCenter().offsetBy(-1, 0));
      args.painter.strokeLine(drawArea.topCenter().offsetBy(+1, 0), drawArea.bottomCenter().offsetBy(+1, 0));
    }
    var isMeasured = args.positionInCircuit !== undefined && args.stats.circuitDefinition.locIsMeasured(new Point(args.positionInCircuit.col, args.positionInCircuit.row));
    if (isMeasured) {
      args.painter.strokeLine(drawArea.centerLeft().offsetBy(0, -1), drawArea.centerRight().offsetBy(0, -1));
      args.painter.strokeLine(drawArea.centerLeft().offsetBy(0, +1), drawArea.centerRight().offsetBy(0, +1));
    } else {
      args.painter.strokeLine(drawArea.centerLeft(), drawArea.centerRight());
    }
  }
  var xShader = ketShaderPermute('', 'return 1.0-out_id;', 1);
  HalfTurnGates.X = new GateBuilder().setSerializedIdAndSymbol("X").setTitle("Pauli X Gate").setBlurb("The NOT gate.\nToggles between ON and OFF.").setDrawer(NOT_DRAWER).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = xShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.PAULI_X).gate;
  var yShader = ketShader('', 'vec2 v = inp(1.0-out_id); return (out_id*2.0 - 1.0)*vec2(-v.y, v.x);', 1);
  HalfTurnGates.Y = new GateBuilder().setSerializedIdAndSymbol("Y").setTitle("Pauli Y Gate").setBlurb("A combination of the X and Z gates.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = yShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.PAULI_Y).gate;
  var zShader = ketShader('', 'return amp*(1.0 - out_id*2.0);', 1);
  HalfTurnGates.Z = new GateBuilder().setSerializedIdAndSymbol("Z").setTitle("Pauli Z Gate").setBlurb("The phase flip gate.\nNegates phases when the qubit is ON.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = zShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.PAULI_Z).gate;
  var hShader = ketShader('', 'return 0.7071067811865476*(amp*(1.0-2.0*out_id) + inp(1.0-out_id));', 1);
  HalfTurnGates.H = new GateBuilder().setSerializedIdAndSymbol("H").setTitle("Hadamard Gate").setBlurb("Creates simple superpositions.\n" + "Maps ON to ON + OFF.\n" + "Maps OFF to ON - OFF.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = hShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.HADAMARD).gate;
  HalfTurnGates.all = [HalfTurnGates.X, HalfTurnGates.Y, HalfTurnGates.Z, HalfTurnGates.H];
  return {get HalfTurnGates() {
      return HalfTurnGates;
    }};
});
//# sourceURL=src/gates/HalfTurnGates.js
;$traceurRuntime.registerModule("src/gates/Impossible_UniversalNotGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Impossible_UniversalNotGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Impossible_UniversalNotGate.js")).GateBuilder;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/Impossible_UniversalNotGate.js")),
      ketArgs = $__2.ketArgs,
      ketShader = $__2.ketShader;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/gates/Impossible_UniversalNotGate.js")).WglConfiguredShader;
  var universalNot = function(ctx) {
    var $__0;
    return ($__0 = UNIVERSAL_NOT_SHADER).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx)));
  };
  var UNIVERSAL_NOT_SHADER = ketShader('', 'vec2 other = inp(1.0 - out_id); return vec2(other.x, -other.y) * (1.0 - 2.0 * out_id);', 1);
  var UniversalNotGate = new GateBuilder().setSerializedId("__unstable__UniversalNot").setSymbol("UniNot").setTitle("Universal Not Gate").setBlurb("Mirrors through the origin of the Bloch sphere.\nImpossible in practice.").setActualEffectToShaderProvider(universalNot).promiseEffectIsStable().gate;
  return {
    get universalNot() {
      return universalNot;
    },
    get UniversalNotGate() {
      return UniversalNotGate;
    }
  };
});
//# sourceURL=src/gates/Impossible_UniversalNotGate.js
;$traceurRuntime.registerModule("src/gates/IncrementGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/IncrementGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/IncrementGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit//KetShaderUtil.js", "src/gates/IncrementGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/IncrementGates.js")).WglArg;
  var IncrementGates = {};
  var offsetShader = ketShaderPermute('uniform float amount;', 'return mod(out_id - amount + span, span);');
  IncrementGates.IncrementFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("inc" + span).setSymbol("+1").setTitle("Increment Gate").setBlurb("Adds 1 to the little-endian number represented by a block of qubits.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = offsetShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", +1)]));
    }).setKnownEffectToPermutation(function(t) {
      return (t + 1) & ((1 << span) - 1);
    });
  });
  IncrementGates.DecrementFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(IncrementGates.IncrementFamily).setSerializedId("dec" + span).setSymbol("−1").setTitle("Decrement Gate").setBlurb("Subtracts 1 from the little-endian number represented by a block of qubits.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = offsetShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", -1)]));
    }).setKnownEffectToPermutation(function(t) {
      return (t - 1) & ((1 << span) - 1);
    });
  });
  IncrementGates.all = $traceurRuntime.spread(IncrementGates.IncrementFamily.all, IncrementGates.DecrementFamily.all);
  return {
    get IncrementGates() {
      return IncrementGates;
    },
    get offsetShader() {
      return offsetShader;
    }
  };
});
//# sourceURL=src/gates/IncrementGates.js
;$traceurRuntime.registerModule("src/gates/InputGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/InputGates.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/InputGates.js")),
      Gate = $__3.Gate,
      GateBuilder = $__3.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/InputGates.js")).GatePainting;
  var reverseShaderForSize = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ReverseBitsGate.js", "src/gates/InputGates.js")).reverseShaderForSize;
  var InputGates = {};
  function drawInputGate(args, key, reverse) {
    GatePainting.paintBackground(args, '#DDD', '#DDD');
    if (args.isInToolbox) {
      GatePainting.paintOutline(args);
    } else {
      args.painter.strokeRect(args.rect, '#888');
    }
    GatePainting.paintResizeTab(args);
    var $__2 = args.rect.center(),
        x = $__2.x,
        y = $__2.y;
    args.painter.print('input', x, y - 2, 'center', 'bottom', 'black', '16px sans-serif', args.rect.w - 2, args.rect.h / 2);
    args.painter.print(key + (reverse ? '[::-1]' : ''), x, y + 2, 'center', 'top', 'black', '16px sans-serif', args.rect.w - 2, args.rect.h / 2);
  }
  var makeInputGate = function(key, reverse) {
    return Gate.buildFamily(1, 16, function(span, builder) {
      return builder.setSerializedId((reverse ? 'rev' : '') + ("input" + key + span)).setSymbol((reverse ? 'rev ' : '') + ("input " + key)).setTitle(("Input Gate [" + key + "]") + (reverse ? ' [reversed]' : '')).setBlurb(("Temporarily uses some qubits as input " + key + (reverse ? ', in big-endian order' : '') + ".")).setDrawer(function(args) {
        return drawInputGate(args, key, reverse);
      }).promiseHasNoNetEffectOnStateVector().markAsNotInterestedInControls().setSetupCleanupEffectsToShaderProviders(reverse && span > 1 ? reverseShaderForSize(span) : undefined, reverse && span > 1 ? reverseShaderForSize(span) : undefined).setContextProvider(function(qubitIndex) {
        return [{
          key: ("Input Range " + key),
          val: {
            offset: qubitIndex,
            length: span
          }
        }];
      });
    });
  };
  var makeSetInputGate = function(key) {
    return new GateBuilder().setSerializedIdAndSymbol(("set" + key)).setTitle(("Set Default " + key)).setBlurb(("Sets a default value for input " + key + ", for when an inline input isn't given.")).setWidth(2).setHeight(2).promiseHasNoNetEffectOnStateVector().markAsNotInterestedInControls().markAsReachingOtherWires().setStickyContextProvider(function(qubitIndex, gate) {
      return [{
        key: ("Input Default " + key),
        val: gate.param,
        sticky: true
      }];
    }).setDrawer(function(args) {
      GatePainting.paintLocationIndependentFrame(args, '#EEE', '#EEE');
      if (args.isInToolbox) {
        GatePainting.paintGateSymbol(args, (key + "=#\ndefault"));
      } else {
        GatePainting.paintGateSymbol(args, (key + "=" + args.gate.param));
      }
      GatePainting.paintGateButton(args);
    }).setOnClickGateFunc(function(oldGate) {
      var txt = prompt(("Enter new fallback value for input " + key + " (between 0 and 65535)."), '' + oldGate.param);
      if (txt === null || txt.trim() === '') {
        return oldGate;
      }
      var val = parseInt(txt);
      if (!Number.isInteger(val) || val < 0 || val >= 1 << 16) {
        alert(("'" + txt + "' isn't an integer between 0 and 65535. Keeping " + oldGate.param + "."));
        return oldGate;
      }
      return oldGate.withParam(val);
    }).setExtraDisableReasonFinder(function(args) {
      var p = args.gate.param;
      if (!Number.isInteger(p) || p < 0 || p > 1 << 16) {
        return 'bad\nvalue';
      }
      return undefined;
    }).gate.withParam(2);
  };
  InputGates.InputAFamily = makeInputGate('A', false);
  InputGates.InputBFamily = makeInputGate('B', false);
  InputGates.InputRFamily = makeInputGate('R', false);
  InputGates.InputRevAFamily = makeInputGate('A', true);
  InputGates.InputRevBFamily = makeInputGate('B', true);
  InputGates.SetA = makeSetInputGate('A');
  InputGates.SetB = makeSetInputGate('B');
  InputGates.SetR = makeSetInputGate('R');
  InputGates.Letters = ["A", "B", "R"];
  InputGates.all = $traceurRuntime.spread(InputGates.InputAFamily.all, InputGates.InputBFamily.all, InputGates.InputRFamily.all, InputGates.InputRevAFamily.all, InputGates.InputRevBFamily.all, [InputGates.SetA, InputGates.SetB, InputGates.SetR]);
  return {get InputGates() {
      return InputGates;
    }};
});
//# sourceURL=src/gates/InputGates.js
;$traceurRuntime.registerModule("src/gates/InterleaveBitsGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/InterleaveBitsGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/InterleaveBitsGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/InterleaveBitsGates.js")).Gate;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/InterleaveBitsGates.js")),
      ketArgs = $__7.ketArgs,
      ketShaderPermute = $__7.ketShaderPermute;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/InterleaveBitsGates.js")).GatePainting;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/InterleaveBitsGates.js")).Point;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/gates/InterleaveBitsGates.js")).Seq;
  var InterleaveBitsGates = {};
  function interleaveBit(bit, len) {
    var h = Math.ceil(len / 2);
    var group = Math.floor(bit / h);
    var stride = bit % h;
    return stride * 2 + group;
  }
  function deinterleaveBit(bit, len) {
    var h = Math.ceil(len / 2);
    var stride = Math.floor(bit / 2);
    var group = bit % 2;
    return stride + group * h;
  }
  function shaderFromBitPermutation(span, bitPermutation) {
    var bitMoveLines = [];
    for (var i = 0; i < span; i++) {
      bitMoveLines.push(("r += mod(floor(out_id / " + (1 << bitPermutation(i, span)) + ".0), 2.0) * " + (1 << i) + ".0;"));
    }
    return ketShaderPermute('', ("\n            float r = 0.0;\n            " + bitMoveLines.join("\n            ") + "\n            return r;\n        "), span);
  }
  var _interleaveShadersForSize = Seq.range(Config.MAX_WIRE_COUNT + 1).skip(2).toMap(function(k) {
    return k;
  }, function(k) {
    return shaderFromBitPermutation(k, interleaveBit);
  });
  var _deinterleaveShadersForSize = Seq.range(Config.MAX_WIRE_COUNT + 1).skip(2).toMap(function(k) {
    return k;
  }, function(k) {
    return shaderFromBitPermutation(k, deinterleaveBit);
  });
  var interleavePainter = function(reverse) {
    return function(args) {
      var $__2,
          $__3;
      if (args.positionInCircuit !== undefined) {
        GatePainting.PERMUTATION_DRAWER(args);
        return;
      }
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
      var x1 = args.rect.x + 6;
      var x2 = args.rect.right() - 6;
      var y = args.rect.center().y - Config.GATE_RADIUS + 6;
      var dh = ((Config.GATE_RADIUS - 6) * 2 - 14) / 5;
      for (var i = 0; i < 6; i++) {
        var j = interleaveBit(i, 6);
        var yi = y + i * dh + Math.floor(i / 3) * 14;
        var yj = y + j * dh + Math.floor(j / 2) * 7;
        var $__1 = reverse ? [yj, yi] : [yi, yj],
            y1 = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
            y2 = ($__3 = $__2.next()).done ? void 0 : $__3.value;
        args.painter.strokePath([new Point(x1, y1), new Point(x1 + 8, y1), new Point(x2 - 8, y2), new Point(x2, y2)]);
      }
    };
  };
  InterleaveBitsGates.InterleaveBitsGateFamily = Gate.buildFamily(4, 16, function(span, builder) {
    return builder.setSerializedId("weave" + span).setSymbol("Interleave").setTitle("Interleave").setBlurb("Re-orders blocks of bits into stripes of bits.").setWidth(span <= 8 ? 1 : 2).setDrawer(interleavePainter(false)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = _interleaveShadersForSize.get(span)).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span)));
    }).setKnownEffectToBitPermutation(function(b) {
      return interleaveBit(b, span);
    });
  });
  InterleaveBitsGates.DeinterleaveBitsGateFamily = Gate.buildFamily(4, 16, function(span, builder) {
    return builder.setAlternateFromFamily(InterleaveBitsGates.InterleaveBitsGateFamily).setSerializedId("split" + span).setSymbol("Deinterleave").setTitle("Deinterleave").setBlurb("Re-orders stripes of bits into blocks of bits.").setWidth(span <= 8 ? 1 : 2).setDrawer(interleavePainter(true)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = _deinterleaveShadersForSize.get(span)).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span)));
    }).setKnownEffectToBitPermutation(function(b) {
      return deinterleaveBit(b, span);
    });
  });
  InterleaveBitsGates.all = $traceurRuntime.spread(InterleaveBitsGates.InterleaveBitsGateFamily.all, InterleaveBitsGates.DeinterleaveBitsGateFamily.all);
  return {
    get InterleaveBitsGates() {
      return InterleaveBitsGates;
    },
    get interleaveBit() {
      return interleaveBit;
    },
    get deinterleaveBit() {
      return deinterleaveBit;
    },
    get shaderFromBitPermutation() {
      return shaderFromBitPermutation;
    }
  };
});
//# sourceURL=src/gates/InterleaveBitsGates.js
;$traceurRuntime.registerModule("src/gates/Joke_ImaginaryGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_ImaginaryGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Joke_ImaginaryGate.js")).GateBuilder;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/Joke_ImaginaryGate.js")).Matrix;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/Joke_ImaginaryGate.js")).Complex;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Joke_ImaginaryGate.js")).GatePainting;
  var ImaginaryGate = new GateBuilder().setSerializedIdAndSymbol("i").setTitle("Imaginary Gate").setBlurb("Phases everything by i.").setDrawer(function(args) {
    GatePainting.paintLocationIndependentFrame(args);
    GatePainting.paintGateSymbol(args);
  }).setKnownEffectToMatrix(Matrix.square(Complex.I, 0, 0, Complex.I)).gate;
  var AntiImaginaryGate = new GateBuilder().setAlternate(ImaginaryGate).setSerializedIdAndSymbol("-i").setTitle("Anti-Imaginary Gate").setBlurb("Phases everything by -i.").setDrawer(function(args) {
    GatePainting.paintLocationIndependentFrame(args);
    GatePainting.paintGateSymbol(args);
  }).setKnownEffectToMatrix(Matrix.square(Complex.I.neg(), 0, 0, Complex.I.neg())).gate;
  var SqrtImaginaryGate = new GateBuilder().setSerializedIdAndSymbol("√i").setTitle("Half Imaginary Gate").setBlurb("Phases everything by √i.").setDrawer(function(args) {
    GatePainting.paintLocationIndependentFrame(args);
    GatePainting.paintGateSymbol(args);
  }).setKnownEffectToMatrix(Matrix.square(1, 0, 0, 1).times(new Complex(Math.sqrt(0.5), Math.sqrt(0.5)))).gate;
  var AntiSqrtImaginaryGate = new GateBuilder().setAlternate(SqrtImaginaryGate).setSerializedIdAndSymbol("√-i").setTitle("Half Anti-Imaginary Gate").setBlurb("Phases everything by √-i.").setDrawer(function(args) {
    GatePainting.paintLocationIndependentFrame(args);
    GatePainting.paintGateSymbol(args);
  }).setKnownEffectToMatrix(Matrix.square(1, 0, 0, 1).times(new Complex(Math.sqrt(0.5), -Math.sqrt(0.5)))).gate;
  return {
    get AntiImaginaryGate() {
      return AntiImaginaryGate;
    },
    get ImaginaryGate() {
      return ImaginaryGate;
    },
    get SqrtImaginaryGate() {
      return SqrtImaginaryGate;
    },
    get AntiSqrtImaginaryGate() {
      return AntiSqrtImaginaryGate;
    }
  };
});
//# sourceURL=src/gates/Joke_ImaginaryGate.js
;$traceurRuntime.registerModule("src/gates/Joke_MysteryGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_MysteryGate.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/Joke_MysteryGate.js")).Complex;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Joke_MysteryGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Joke_MysteryGate.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/Joke_MysteryGate.js")).Matrix;
  var MysteryGateSymbol = "?";
  var MysteryGateMakerWithMatrix = function(matrix) {
    return new GateBuilder().setSerializedIdAndSymbol(MysteryGateSymbol).setTitle("Mystery Gate").setBlurb("Different every time.\n(Use shift+drag to copy circuit gates.)").setDrawer(GatePainting.MATRIX_SYMBOL_DRAWER_EXCEPT_IN_TOOLBOX).setKnownEffectToMatrix(matrix).gate;
  };
  var MysteryGateMaker = function() {
    return MysteryGateMakerWithMatrix(Matrix.square(new Complex(Math.random() - 0.5, Math.random() - 0.5), new Complex(Math.random() - 0.5, Math.random() - 0.5), new Complex(Math.random() - 0.5, Math.random() - 0.5), new Complex(Math.random() - 0.5, Math.random() - 0.5)).closestUnitary(0.00001));
  };
  return {
    get MysteryGateSymbol() {
      return MysteryGateSymbol;
    },
    get MysteryGateMaker() {
      return MysteryGateMaker;
    },
    get MysteryGateMakerWithMatrix() {
      return MysteryGateMakerWithMatrix;
    }
  };
});
//# sourceURL=src/gates/Joke_MysteryGate.js
;$traceurRuntime.registerModule("src/gates/Joke_NeGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_NeGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Joke_NeGate.js")).GateBuilder;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/Joke_NeGate.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/Joke_NeGate.js")).Point;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Joke_NeGate.js")).GatePainting;
  var NeGate = new GateBuilder().setSerializedId("NeGate").setTitle("Ne-Gate").setBlurb("Negates all amplitudes.").setDrawer(function(args) {
    GatePainting.paintLocationIndependentFrame(args);
    var $__0 = args.rect.center(),
        x = $__0.x,
        y = $__0.y;
    args.painter.strokeLine(new Point(x - 6, y), new Point(x + 6, y), 'black', 2);
  }).setKnownEffectToMatrix(Matrix.square(-1, 0, 0, -1)).gate;
  return {get NeGate() {
      return NeGate;
    }};
});
//# sourceURL=src/gates/Joke_NeGate.js
;$traceurRuntime.registerModule("src/gates/Joke_ZeroGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_ZeroGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/Joke_ZeroGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/Joke_ZeroGate.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/Joke_ZeroGate.js")).Matrix;
  var ZeroGate = new GateBuilder().setSerializedIdAndSymbol("0").setTitle("Nothing Gate").setBlurb("Destroys the universe.").setDrawer(GatePainting.makeLocationIndependentGateDrawer('#666')).setKnownEffectToMatrix(Matrix.square(0, 0, 0, 0)).gate;
  return {get ZeroGate() {
      return ZeroGate;
    }};
});
//# sourceURL=src/gates/Joke_ZeroGate.js
;$traceurRuntime.registerModule("src/gates/MeasurementGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/MeasurementGate.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/MeasurementGate.js")).Config;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/MeasurementGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/MeasurementGate.js")).GatePainting;
  function drawMeasurementGate(args) {
    var $__2,
        $__3,
        $__5,
        $__6;
    var backColor = Config.GATE_FILL_COLOR;
    if (args.isHighlighted) {
      backColor = Config.HIGHLIGHTED_GATE_FILL_COLOR;
    }
    args.painter.fillRect(args.rect, backColor);
    GatePainting.paintOutline(args);
    var τ = Math.PI * 2;
    var r = args.rect.w * 0.4;
    var $__0 = args.rect.center(),
        x = $__0.x,
        y = $__0.y;
    y += r * 0.6;
    var a = -τ / 6;
    var $__1 = [Math.cos(a) * r * 1.5, Math.sin(a) * r * 1.5],
        c = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
        s = ($__3 = $__2.next()).done ? void 0 : $__3.value;
    var $__4 = [x + c, y + s],
        p = ($__5 = $__4[Symbol.iterator](), ($__6 = $__5.next()).done ? void 0 : $__6.value),
        q = ($__6 = $__5.next()).done ? void 0 : $__6.value;
    args.painter.trace(function(trace) {
      trace.ctx.arc(x, y, r, τ / 2, τ);
      trace.line(x, y, p, q);
    }).thenStroke('black');
    args.painter.trace(function(trace) {
      return trace.arrowHead(p, q, r * 0.3, a, τ / 4);
    }).thenFill('black');
  }
  var MeasurementGate = new GateBuilder().setSerializedIdAndSymbol("Measure").setTitle("Measurement Gate").setBlurb("Measures whether a qubit is ON or OFF, without conditioning on the result.").promiseHasNoNetEffectOnStateVector().setDrawer(drawMeasurementGate).setExtraDisableReasonFinder(function(args) {
    if (args.isNested) {
      return "can't\nnest\nmeasure\n(sorry)";
    }
    var isMeasured = (args.measuredMask & (1 << args.outerRow)) !== 0;
    if (args.innerColumn.hasControl() && !isMeasured) {
      return "can't\ncontrol\n(sorry)";
    }
    return undefined;
  }).gate;
  return {get MeasurementGate() {
      return MeasurementGate;
    }};
});
//# sourceURL=src/gates/MeasurementGate.js
;$traceurRuntime.registerModule("src/gates/ModularAdditionGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularAdditionGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ModularAdditionGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ModularAdditionGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/ModularAdditionGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/ModularAdditionGates.js")).WglArg;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularIncrementGates.js", "src/gates/ModularAdditionGates.js")).modulusTooBigChecker;
  var ModularAdditionGates = {};
  var MODULAR_ADDITION_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float r = read_input_R();\n        if (out_id >= r) {\n            return out_id;\n        }\n        float d = read_input_A();\n        d *= factor;\n        d = floor(mod(d + 0.5, r));\n        return floor(mod(out_id + r - d + 0.5, r));\n    ");
  ModularAdditionGates.PlusAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+AmodR" + span).setSymbol("+A\nmod R").setTitle("Modular Addition Gate").setBlurb("Adds input A into the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, r) {
      return t < r ? (t + a) % r : t;
    });
  });
  ModularAdditionGates.MinusAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ModularAdditionGates.PlusAModRFamily).setSerializedId("-AmodR" + span).setSymbol("−A\nmod R").setTitle("Modular Subtraction Gate").setBlurb("Subtracts input A out of the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, r) {
      return t < r ? Util.properMod(t - a, r) : t;
    });
  });
  ModularAdditionGates.all = $traceurRuntime.spread(ModularAdditionGates.PlusAModRFamily.all, ModularAdditionGates.MinusAModRFamily.all);
  return {get ModularAdditionGates() {
      return ModularAdditionGates;
    }};
});
//# sourceURL=src/gates/ModularAdditionGates.js
;$traceurRuntime.registerModule("src/gates/ModularIncrementGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularIncrementGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ModularIncrementGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ModularIncrementGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/ModularIncrementGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/ModularIncrementGates.js")).WglArg;
  var ModularIncrementGates = {};
  var modulusTooBigChecker = function(inputKey, span) {
    var modName = arguments[2] !== (void 0) ? arguments[2] : 'mod';
    return function(args) {
      var r = args.context.get('Input Range ' + inputKey);
      var d = args.context.get('Input Default ' + inputKey);
      if (r !== undefined && r.length > span) {
        return (modName + "\ntoo\nbig");
      }
      if (r === undefined && d !== undefined && d > 1 << span) {
        return (modName + "\ntoo\nbig");
      }
      return undefined;
    };
  };
  var MODULAR_INCREMENT_SHADER = ketShaderPermute(("\n        uniform float amount;\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float r = read_input_R();\n        return out_id >= r\n            ? out_id\n            // HACK: sometimes mod(value-equal-to-r, r) returns r instead of 0. The perturbation works around it.\n            : floor(mod(out_id + r - amount, r - 0.000001));");
  ModularIncrementGates.IncrementModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("incmodR" + span).setSymbol("+1\nmod R").setTitle("Modular Increment Gate").setBlurb("Adds 1 into the target, but wraps R-1 to 0.\n" + "Only affects values less than R.").setRequiredContextKeys("Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_INCREMENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['R']), [WglArg.float("amount", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return t < a ? (t + 1) % a : t;
    });
  });
  ModularIncrementGates.DecrementModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ModularIncrementGates.IncrementModRFamily).setSerializedId("decmodR" + span).setSymbol("−1\nmod R").setTitle("Modular Decrement Gate").setBlurb("Subtracts 1 out of the target, but wraps 0 to R-1.\n" + "Only affects values less than R.").setRequiredContextKeys("Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_INCREMENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['R']), [WglArg.float("amount", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return t < a ? Util.properMod(t - 1, a) : t;
    });
  });
  ModularIncrementGates.all = $traceurRuntime.spread(ModularIncrementGates.IncrementModRFamily.all, ModularIncrementGates.DecrementModRFamily.all);
  return {
    get ModularIncrementGates() {
      return ModularIncrementGates;
    },
    get modulusTooBigChecker() {
      return modulusTooBigChecker;
    }
  };
});
//# sourceURL=src/gates/ModularIncrementGates.js
;$traceurRuntime.registerModule("src/gates/ModularMultiplicationGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularMultiplicationGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/ModularMultiplicationGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ModularMultiplicationGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ModularMultiplicationGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularIncrementGates.js", "src/gates/ModularMultiplicationGates.js")).modulusTooBigChecker;
  var BIG_MUL_MOD_SHADER_CODE = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiplyAccumulateGates.js", "src/gates/ModularMultiplicationGates.js")).BIG_MUL_MOD_SHADER_CODE;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/ModularMultiplicationGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/ModularMultiplicationGates.js")).WglArg;
  var ModularMultiplicationGates = {};
  var MODULAR_INVERSE_SHADER_CODE = ("\n    vec2 _mod_mul_step(vec2 v, float q) {\n        return vec2(v.y - q * v.x, v.x);\n    }\n    \n    " + BIG_MUL_MOD_SHADER_CODE + "\n\n    float modular_multiplicative_inverse(float value, float modulus) {\n        vec2 s = vec2(0.0, 1.0);\n        vec2 t = vec2(1.0, 0.0);\n        vec2 r = vec2(modulus, value);\n        float q;\n        // For values up to x, a number of iterations n satisfying phi^n > x should be sufficient.\n        for (int repeat = 0; repeat < " + Math.ceil(Config.MAX_WIRE_COUNT / (Math.log2(1 + Math.sqrt(5)) - 1)) + "; repeat++) {\n            if (r.x != 0.0) {\n                q = floor(r.y / r.x);\n                r = _mod_mul_step(r, q);\n                s = _mod_mul_step(s, q);\n                t = _mod_mul_step(t, q);\n            }\n        }\n        if (r.y != 1.0) {\n            return -1.0;\n        }\n        return floor(mod(floor(mod(s.y + 0.5, modulus)) + modulus + 0.5, modulus));\n    }\n");
  var POW_MOD_SHADER_CODE = ("\n    " + MODULAR_INVERSE_SHADER_CODE + "\n\n    float pow_mod(float base, float exponent, float modulus) {\n        float base_inverse = modular_multiplicative_inverse(base, modulus);\n        if (base_inverse == -1.0) {\n            return -1.0;\n        }\n\n        if (exponent < 0.0) {\n            base = base_inverse;\n            exponent = -exponent;\n        }\n\n        float f = 1.0;\n        for (int k = 0; k < " + Config.MAX_WIRE_COUNT + "; k++) {\n            if (floor(mod(exponent + 0.5, 2.0)) == 1.0) {\n                exponent -= 1.0;\n                f = big_mul_mod(f, base, modulus);\n            }\n            base = big_mul_mod(base, base, modulus);\n            exponent /= 2.0;\n        }\n        return f;\n    }\n");
  function modularMultiply(val, factor, modulus) {
    if (val >= modulus) {
      return val;
    }
    factor = Util.properMod(factor, modulus);
    if (factor === 0 || Util.extended_gcd(factor, modulus).gcd !== 1) {
      return val;
    }
    return (val * factor) % modulus;
  }
  function modularUnmultiply(val, factor, modulus) {
    if (val >= modulus) {
      return val;
    }
    factor = Util.properMod(factor, modulus);
    if (factor === 0) {
      return val;
    }
    var inverse_factor = Util.modular_multiplicative_inverse(factor, modulus);
    if (inverse_factor === undefined) {
      return val;
    }
    return (val * inverse_factor) % modulus;
  }
  function modularPowerMultiply(val, base, exponent, modulus) {
    if (val >= modulus) {
      return val;
    }
    base = Util.properMod(base, modulus);
    var inverse = Util.modular_multiplicative_inverse(base, modulus);
    if (inverse === undefined) {
      return val;
    }
    if (exponent < 0) {
      exponent = -exponent;
      base = inverse;
    }
    while (exponent > 0) {
      if ((exponent & 1) !== 0) {
        val = (val * base) % modulus;
      }
      base = (base * base) % modulus;
      exponent >>= 1;
    }
    return val;
  }
  var MODULAR_MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float input_a = read_input_A();\n        float modulus = read_input_R();\n        input_a = floor(mod(input_a + 0.5, modulus));\n        float v = modular_multiplicative_inverse(input_a, modulus);\n        if (v == -1.0 || out_id >= modulus) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, v, modulus);\n    ");
  var MODULAR_INVERSE_MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float input_a = read_input_A();\n        float modulus = read_input_R();\n        input_a = floor(mod(input_a + 0.5, modulus));\n        if (modular_multiplicative_inverse(input_a, modulus) == -1.0 || out_id >= modulus) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, input_a, modulus);\n    ");
  var MODULAR_POWER_MULTIPLICATION_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('B') + "\n        " + ketInputGateShaderCode('R') + "\n        " + POW_MOD_SHADER_CODE + "\n    "), "\n        float exponent = -read_input_A() * factor;\n        float base = read_input_B();\n        float modulus = read_input_R();\n        float f = pow_mod(base, exponent, modulus);\n        if (f == -1.0 || out_id >= modulus) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, f, modulus);\n    ");
  ModularMultiplicationGates.TimesAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("*AmodR" + span).setSymbol("×A\nmod R").setTitle("Modular Multiplication Gate").setBlurb("Multiplies the target by input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R'])));
    }).setKnownEffectToParametrizedPermutation(modularMultiply);
  });
  ModularMultiplicationGates.TimesAModRInverseFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ModularMultiplicationGates.TimesAModRFamily).setSerializedId("/AmodR" + span).setSymbol("×A^-1\nmod R").setTitle("Modular Division Gate").setBlurb("Inverse-multiplies the target by input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_INVERSE_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R'])));
    }).setKnownEffectToParametrizedPermutation(modularUnmultiply);
  });
  ModularMultiplicationGates.TimesBToTheAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("*BToAmodR" + span).setSymbol("×B^A\nmod R").setTitle("Modular Power Multiplication Gate").setBlurb("Multiplies the target by input B raised to the input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_POWER_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float('factor', +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return modularPowerMultiply(t, b, a, r);
    });
  });
  ModularMultiplicationGates.TimesInverseBToTheAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ModularMultiplicationGates.TimesBToTheAModRFamily).setSerializedId("/BToAmodR" + span).setSymbol("×B^-A\nmod R").setTitle("Modular Power Division Gate").setBlurb("Inverse-multiplies the target by input B raised to the input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_POWER_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float('factor', -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return modularPowerMultiply(t, b, -a, r);
    });
  });
  ModularMultiplicationGates.all = $traceurRuntime.spread(ModularMultiplicationGates.TimesAModRFamily.all, ModularMultiplicationGates.TimesAModRInverseFamily.all, ModularMultiplicationGates.TimesBToTheAModRFamily.all, ModularMultiplicationGates.TimesInverseBToTheAModRFamily.all);
  return {
    get ModularMultiplicationGates() {
      return ModularMultiplicationGates;
    },
    get MODULAR_INVERSE_SHADER_CODE() {
      return MODULAR_INVERSE_SHADER_CODE;
    },
    get POW_MOD_SHADER_CODE() {
      return POW_MOD_SHADER_CODE;
    },
    get modularMultiply() {
      return modularMultiply;
    },
    get modularUnmultiply() {
      return modularUnmultiply;
    },
    get modularPowerMultiply() {
      return modularPowerMultiply;
    }
  };
});
//# sourceURL=src/gates/ModularMultiplicationGates.js
;$traceurRuntime.registerModule("src/gates/ModularMultiplyAccumulateGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularMultiplyAccumulateGates.js";
  var BIG_MUL_MOD_SHADER_CODE = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiplyAccumulateGates.js", "src/gates/ModularMultiplyAccumulateGates.js")).BIG_MUL_MOD_SHADER_CODE;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ModularMultiplyAccumulateGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ModularMultiplyAccumulateGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularIncrementGates.js", "src/gates/ModularMultiplyAccumulateGates.js")).modulusTooBigChecker;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/ModularMultiplyAccumulateGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/ModularMultiplyAccumulateGates.js")).WglArg;
  var ModularMultiplyAccumulateGates = {};
  var MODULAR_MULTIPLY_ACCUMULATE_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('B') + "\n        " + ketInputGateShaderCode('R') + "\n        " + BIG_MUL_MOD_SHADER_CODE + "\n    "), "\n        float r = read_input_R();\n        float a = read_input_A();\n        float b = read_input_B();\n\n        float d = big_mul_mod(factor * a, b, r);\n\n        float in_id = floor(mod(out_id - d + 0.5, r));\n        if (in_id < 0.0) {\n            in_id += r;\n        }\n        if (in_id >= r) {\n            in_id -= r;\n        }\n\n        return out_id >= r ? out_id : in_id;\n    ");
  ModularMultiplyAccumulateGates.PlusABModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+ABmodR" + span).setSymbol("+AB\nmod R").setTitle("Modular Multiply-Add Gate").setBlurb("Adds input A times input B into the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return t < r ? (t + a * b) % r : t;
    });
  });
  ModularMultiplyAccumulateGates.MinusABModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(ModularMultiplyAccumulateGates.PlusABModRFamily).setSerializedId("-ABmodR" + span).setSymbol("−AB\nmod R").setTitle("Modular Multiply-Subtract Gate").setBlurb("Subtracts input A times input B out of the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return t < r ? Util.properMod(t - a * b, r) : t;
    });
  });
  ModularMultiplyAccumulateGates.all = $traceurRuntime.spread(ModularMultiplyAccumulateGates.PlusABModRFamily.all, ModularMultiplyAccumulateGates.MinusABModRFamily.all);
  return {get ModularMultiplyAccumulateGates() {
      return ModularMultiplyAccumulateGates;
    }};
});
//# sourceURL=src/gates/ModularMultiplyAccumulateGates.js
;$traceurRuntime.registerModule("src/gates/MultiplicationGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/MultiplicationGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/MultiplicationGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/MultiplicationGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularMultiplicationGates.js", "src/gates/MultiplicationGates.js")),
      modularMultiply = $__4.modularMultiply,
      modularUnmultiply = $__4.modularUnmultiply,
      MODULAR_INVERSE_SHADER_CODE = $__4.MODULAR_INVERSE_SHADER_CODE;
  var MultiplicationGates = {};
  var MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float input_a = read_input_A();\n        input_a = mod(input_a, span);\n        float v = modular_multiplicative_inverse(input_a, span);\n        if (v == -1.0) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, v, span);\n    ");
  var INVERSE_MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float input_a = read_input_A();\n        input_a = mod(input_a, span);\n        if (modular_multiplicative_inverse(input_a, span) == -1.0) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, input_a, span);\n    ");
  MultiplicationGates.TimesAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("*A" + span).setSymbol("×A").setTitle("Multiplication Gate").setBlurb("Multiplies the target by input A.\n" + "No effect if the input is even (would be irreversible).").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    }).setKnownEffectToParametrizedPermutation(function(x, a) {
      return modularMultiply(x, a, 1 << span);
    });
  });
  MultiplicationGates.TimesAInverseFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(MultiplicationGates.TimesAFamily).setSerializedId("/A" + span).setSymbol("×A^-1").setTitle("Inverse Multiplication Gate").setBlurb("Inverse-multiplies the target by input A (modulo 2^n).\n" + "No effect if the input is even (would be irreversible).").setRequiredContextKeys("Input Range A").setKnownEffectToParametrizedPermutation(function(x, a) {
      return modularUnmultiply(x, a, 1 << span);
    }).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = INVERSE_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    });
  });
  MultiplicationGates.all = $traceurRuntime.spread(MultiplicationGates.TimesAFamily.all, MultiplicationGates.TimesAInverseFamily.all);
  return {
    get MultiplicationGates() {
      return MultiplicationGates;
    },
    get MODULAR_INVERSE_SHADER_CODE() {
      return MODULAR_INVERSE_SHADER_CODE;
    }
  };
});
//# sourceURL=src/gates/MultiplicationGates.js
;$traceurRuntime.registerModule("src/gates/MultiplyAccumulateGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/MultiplyAccumulateGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/MultiplyAccumulateGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/MultiplyAccumulateGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/MultiplyAccumulateGates.js")).GatePainting;
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/MultiplyAccumulateGates.js")),
      ketArgs = $__8.ketArgs,
      ketShaderPermute = $__8.ketShaderPermute,
      ketInputGateShaderCode = $__8.ketInputGateShaderCode;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/MultiplyAccumulateGates.js")).WglArg;
  var MultiplyAccumulateGates = {};
  var sectionSizes = function(totalSize) {
    var c = Math.ceil(totalSize / 2);
    var b = Math.ceil((totalSize - c) / 2);
    var a = Math.max(totalSize - c - b, 1);
    return [a, b, totalSize - a - b];
  };
  var makeScaledMultiplyAddPermutation = function(span, scaleFactor) {
    return function(e) {
      var $__2,
          $__3;
      var $__1 = sectionSizes(span),
          sa = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
          sb = ($__3 = $__2.next()).done ? void 0 : $__3.value,
          sc = ($__3 = $__2.next()).done ? void 0 : $__3.value;
      var a = e & ((1 << sa) - 1);
      var b = (e >> sa) & ((1 << sb) - 1);
      var c = e >> (sa + sb);
      c += a * b * scaleFactor;
      c &= ((1 << sc) - 1);
      return a | (b << sa) | (c << (sa + sb));
    };
  };
  var MUL_STEP = 6;
  var BIG_MUL_MOD_SHADER_CODE = ("\n    // Avoids large multiplications that lose precision.\n    float big_mul_mod(float b, float f, float modulus) {\n        float t = 0.0;\n        float r;\n        for (int k = 0; k < " + Math.ceil(Config.MAX_WIRE_COUNT / MUL_STEP) + "; k++) {\n            r = floor(mod(f + 0.5, " + (1 << MUL_STEP) + ".0));\n            f -= r;\n            t = floor(mod(t + b*r + 0.5, modulus));\n            b = floor(mod(b * " + (1 << MUL_STEP) + ".0 + 0.5, modulus));\n            f /= " + (1 << MUL_STEP) + ".0;\n        }\n        return t;\n    }\n");
  var MULTIPLY_ACCUMULATE_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('B') + "\n        " + BIG_MUL_MOD_SHADER_CODE + "\n    "), "\n        float d1 = read_input_A();\n        float d2 = read_input_B();\n        float d = floor(mod(big_mul_mod(d1, d2, span)*factor + 0.5, span));\n        return mod(out_id + span - d, span);");
  MultiplyAccumulateGates.Legacy_MultiplyAddFamily = Gate.buildFamily(3, 16, function(span, builder) {
    return builder.setSerializedId("c+=ab" + span).setSymbol("c+=ab").setTitle("Multiply-Add Gate").setBlurb("Adds the product of two numbers into a third.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b", "c+=ab"], sectionSizes(span).slice(0, 2).map(function(e) {
      return e / span;
    }))).setActualEffectToUpdateFunc(function(ctx) {
      var $__2,
          $__3;
      var $__1 = sectionSizes(span),
          a = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
          b = ($__3 = $__2.next()).done ? void 0 : $__3.value,
          c = ($__3 = $__2.next()).done ? void 0 : $__3.value;
      return MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(c).customOperation(ctx.withRow(ctx.row + a + b).withInputSetToRange('A', ctx.row, a).withInputSetToRange('B', ctx.row + a, b));
    }).setKnownEffectToPermutation(makeScaledMultiplyAddPermutation(span, +1));
  });
  MultiplyAccumulateGates.Legacy_MultiplySubtractFamily = Gate.buildFamily(3, 16, function(span, builder) {
    return builder.setAlternateFromFamily(MultiplyAccumulateGates.Legacy_MultiplyAddFamily).setSerializedId("c-=ab" + span).setSymbol("c-=ab").setTitle("Multiply-Subtract Gate").setBlurb("Subtracts the product of two numbers from a third.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b", "c-=ab"], sectionSizes(span).slice(0, 2).map(function(e) {
      return e / span;
    }))).setActualEffectToUpdateFunc(function(ctx) {
      var $__2,
          $__3;
      var $__1 = sectionSizes(span),
          a = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
          b = ($__3 = $__2.next()).done ? void 0 : $__3.value,
          c = ($__3 = $__2.next()).done ? void 0 : $__3.value;
      return MultiplyAccumulateGates.MultiplySubtractInputsFamily.ofSize(c).customOperation(ctx.withRow(ctx.row + a + b).withInputSetToRange('A', ctx.row, a).withInputSetToRange('B', ctx.row + a, b));
    }).setKnownEffectToPermutation(makeScaledMultiplyAddPermutation(span, -1));
  });
  MultiplyAccumulateGates.MultiplyAddInputsFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+=AB" + span).setSymbol("+AB").setTitle("Multiply-Add Gate [Inputs A, B]").setBlurb("Adds the product of inputs A and B into the qubits covered by this gate.").setRequiredContextKeys('Input Range A', 'Input Range B').setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b) {
      return (t + a * b) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.MultiplySubtractInputsFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(MultiplyAccumulateGates.MultiplyAddInputsFamily).setSerializedId("-=AB" + span).setSymbol("−AB").setTitle("Multiply-Subtract Gate [Inputs A, B]").setBlurb("Subtracts the product of inputs A and B out of the qubits covered by this gate.").setRequiredContextKeys('Input Range A', 'Input Range B').setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b) {
      return (t - a * b) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.SquareAddInputFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+=AA" + span).setSymbol("+A^2").setTitle("Square-Add Gate [Input A]").setBlurb("Adds the square of input A into the qubits covered by this gate.").setRequiredContextKeys('Input Range A').setActualEffectToUpdateFunc(function(ctx) {
      return MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(span).customOperation(ctx.withInputSetToOtherInput('B', 'A'));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t + a * a) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.SquareSubtractInputFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(MultiplyAccumulateGates.SquareAddInputFamily).setSerializedId("-=AA" + span).setSymbol("-A^2").setTitle("Square-Subtract Gate [Input A]").setBlurb("Subtracts the square of input A out of the qubits covered by this gate.").setRequiredContextKeys('Input Range A').setActualEffectToUpdateFunc(function(ctx) {
      return MultiplyAccumulateGates.MultiplySubtractInputsFamily.ofSize(span).customOperation(ctx.withInputSetToOtherInput('B', 'A'));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t - a * a) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.all = $traceurRuntime.spread(MultiplyAccumulateGates.Legacy_MultiplyAddFamily.all, MultiplyAccumulateGates.Legacy_MultiplySubtractFamily.all, MultiplyAccumulateGates.MultiplyAddInputsFamily.all, MultiplyAccumulateGates.MultiplySubtractInputsFamily.all, MultiplyAccumulateGates.SquareAddInputFamily.all, MultiplyAccumulateGates.SquareSubtractInputFamily.all);
  return {
    get MultiplyAccumulateGates() {
      return MultiplyAccumulateGates;
    },
    get BIG_MUL_MOD_SHADER_CODE() {
      return BIG_MUL_MOD_SHADER_CODE;
    },
    get MUL_STEP() {
      return MUL_STEP;
    }
  };
});
//# sourceURL=src/gates/MultiplyAccumulateGates.js
;$traceurRuntime.registerModule("src/gates/ParametrizedRotationGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ParametrizedRotationGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ParametrizedRotationGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/ParametrizedRotationGates.js")).GatePainting;
  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/ParametrizedRotationGates.js")),
      Complex = $__11.Complex,
      PARSE_COMPLEX_TOKEN_MAP_RAD = $__11.PARSE_COMPLEX_TOKEN_MAP_RAD;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/ParametrizedRotationGates.js")).Matrix;
  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ParametrizedRotationGates.js")),
      ketArgs = $__13.ketArgs,
      ketShader = $__13.ketShader,
      ketShaderPhase = $__13.ketShaderPhase,
      ketInputGateShaderCode = $__13.ketInputGateShaderCode;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/ParametrizedRotationGates.js")).WglArg;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/ParametrizedRotationGates.js")).Util;
  var parseFormula = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/FormulaParser.js", "src/gates/ParametrizedRotationGates.js")).parseFormula;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExponentiatingGates.js", "src/gates/ParametrizedRotationGates.js")),
      XExp = $__17.XExp,
      YExp = $__17.YExp,
      ZExp = $__17.ZExp;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/ParametrizedRotationGates.js")).Config;
  var ParametrizedRotationGates = {};
  function configurableRotationDrawer(pattern, xyz, tScale) {
    var xScale = [1, 0.5, -1][xyz];
    var yScale = [1, 1, -0.5][xyz];
    return function(args) {
      GatePainting.paintBackground(args, Config.TIME_DEPENDENT_HIGHLIGHT_COLOR);
      GatePainting.paintOutline(args);
      var text = pattern;
      if (!args.isInToolbox) {
        text = text.split('f(t)').join(args.gate.param);
      }
      GatePainting.paintGateSymbol(args, text, pattern.indexOf('^') !== -1);
      GatePainting.paintGateButton(args);
      var isStable = args.gate.stableDuration() === Infinity;
      if ((!args.isInToolbox || args.isHighlighted) && !isStable) {
        var rads = tScale * parseTimeFormula(args.gate.param, args.stats.time * 2 - 1, false) || 0;
        GatePainting.paintCycleState(args, rads, xScale, yScale);
      }
    };
  }
  function exponent_to_A_len_painter(args) {
    var v = args.getGateContext('Input Range A');
    var denom_exponent = v === undefined ? 'ⁿ' : Util.digits_to_superscript_digits('' + v.length);
    var symbol = args.gate.symbol.replace('ⁿ', denom_exponent);
    GatePainting.paintBackground(args);
    GatePainting.paintOutline(args);
    GatePainting.paintGateSymbol(args, symbol);
  }
  var X_TO_A_SHADER = ketShader(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float angle = read_input_A() * factor / _gen_input_span_A;\n        float c = cos(angle) * 0.5;\n        float s = sin(angle) * 0.5;\n        vec2 u = vec2(0.5 + c, s);\n        vec2 v = vec2(0.5 - c, -s);\n        // multiply state by the matrix [[u, v], [v, u]]\n        vec2 amp2 = inp(1.0-out_id);\n        return cmul(u, amp) + cmul(v, amp2);\n    ");
  var Y_TO_A_SHADER = ketShader(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float angle = read_input_A() * factor / _gen_input_span_A;\n        float c = cos(angle) * 0.5;\n        float s = sin(angle) * 0.5;\n        vec2 u = vec2(c + 0.5, s);\n        vec2 v = vec2(s, 0.5 - c);\n        // multiply state by the matrix [[u, v], [-v, u]]\n        vec2 amp2 = inp(1.0-out_id);\n        vec2 vs = v * (-1.0 + 2.0 * out_id);\n        return cmul(u, amp) + cmul(vs, amp2);\n    ");
  var Z_TO_A_SHADER = ketShaderPhase(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        return read_input_A() * out_id * factor / _gen_input_span_A;\n    ");
  ParametrizedRotationGates.XToA = new GateBuilder().setSerializedId("X^(A/2^n)").setSymbol("X^A/2ⁿ").setTitle("Parametrized X Gate").setBlurb("Rotates the target by input A / 2ⁿ'th of a half turn around the X axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__8;
    return ($__8 = X_TO_A_SHADER).withArgs.apply($__8, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.XToMinusA = new GateBuilder().setAlternate(ParametrizedRotationGates.XToA).setSerializedId("X^(-A/2^n)").setSymbol("X^-A/2ⁿ").setTitle("Parametrized -X Gate").setBlurb("Counter-rotates the target by input A / 2ⁿ'th of a half turn around the X axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__8;
    return ($__8 = X_TO_A_SHADER).withArgs.apply($__8, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', -Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.YToA = new GateBuilder().setSerializedId("Y^(A/2^n)").setSymbol("Y^A/2ⁿ").setTitle("Parametrized Y Gate").setBlurb("Rotates the target by input A / 2ⁿ'th of a half turn around the Y axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__8;
    return ($__8 = Y_TO_A_SHADER).withArgs.apply($__8, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.YToMinusA = new GateBuilder().setAlternate(ParametrizedRotationGates.YToA).setSerializedId("Y^(-A/2^n)").setSymbol("Y^-A/2ⁿ").setTitle("Parametrized -Y Gate").setBlurb("Counter-rotates the target by input A / 2ⁿ'th of a half turn around the Y axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__8;
    return ($__8 = Y_TO_A_SHADER).withArgs.apply($__8, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', -Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.ZToA = new GateBuilder().setSerializedId("Z^(A/2^n)").setSymbol("Z^A/2ⁿ").setTitle("Parametrized Z Gate").setBlurb("Rotates the target by input A / 2ⁿ'th of a half turn around the Z axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__8;
    return ($__8 = Z_TO_A_SHADER).withArgs.apply($__8, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', Math.PI)]));
  }).promiseEffectIsStable().promiseEffectOnlyPhases().gate;
  ParametrizedRotationGates.ZToMinusA = new GateBuilder().setAlternate(ParametrizedRotationGates.ZToA).setSerializedId("Z^(-A/2^n)").setSymbol("Z^-A/2ⁿ").setTitle("Parametrized -Z Gate").setBlurb("Counter-rotates the target by input A / 2ⁿ'th of a half turn around the Z axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__8;
    return ($__8 = Z_TO_A_SHADER).withArgs.apply($__8, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', -Math.PI)]));
  }).promiseEffectIsStable().promiseEffectOnlyPhases().gate;
  function parseTimeFormula(formula, time, warn) {
    var tokenMap = new Map($traceurRuntime.spread(PARSE_COMPLEX_TOKEN_MAP_RAD.entries()));
    if (time !== undefined) {
      tokenMap.set('t', time);
    }
    try {
      var angle = Complex.from(parseFormula(formula, tokenMap));
      if (Math.abs(angle.imag) > 0.0001) {
        throw new Error(("Non-real angle: " + formula + " = " + angle));
      }
      return angle.real;
    } catch (ex) {
      if (warn) {
        console.warn(ex);
      }
      return undefined;
    }
  }
  function badFormulaDetector(args) {
    if (typeof args.gate.param === 'number') {
      return args.gate.param;
    } else if (typeof args.gate.param === 'string') {
      var $__4 = true;
      var $__5 = false;
      var $__6 = undefined;
      try {
        for (var $__2 = void 0,
            $__1 = ([0.01, 0.63, 0.98])[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
          var t = $__2.value;
          {
            if (parseTimeFormula(args.gate.param, t, false) === undefined) {
              return 'bad\nformula';
            }
          }
        }
      } catch ($__7) {
        $__5 = true;
        $__6 = $__7;
      } finally {
        try {
          if (!$__4 && $__1.return != null) {
            $__1.return();
          }
        } finally {
          if ($__5) {
            throw $__6;
          }
        }
      }
      return undefined;
    } else {
      return 'bad\nvalue';
    }
  }
  function updateUsingFormula(gate) {
    var stable = parseTimeFormula(gate.param, undefined, false) !== undefined;
    gate._stableDuration = stable ? Infinity : 0;
    if (typeof gate.param === 'string') {
      gate.width = Math.ceil((gate.param.length + 1) / 5);
      gate.alternate = gate._copy();
      gate.alternate.alternate = gate;
      if (gate.param.startsWith('-(') && gate.param.endsWith(')')) {
        gate.alternate.param = gate.param.substring(2, gate.param.length - 1);
      } else {
        gate.alternate.param = '-(' + gate.param + ')';
      }
    } else {
      gate.width = 1;
      gate.alternate = gate;
    }
  }
  function angleClicker(quantityName) {
    return function(oldGate) {
      var txt = prompt(("Enter a formula to use for the " + quantityName + ".\n") + "\n" + "The formula can depend on the time variable t.\n" + "Time t starts at -1, grows to +1 over time, then jumps back to -1.\n" + "Invalid results will default to 0.\n" + "\n" + "Available constants: e, pi\n" + "Available functions: cos, sin, acos, asin, tan, atan, ln, sqrt, exp\n" + "Available operators: + * / - ^", '' + oldGate.param);
      if (txt === null || txt.trim() === '') {
        return oldGate;
      }
      return oldGate.withParam(txt);
    };
  }
  ParametrizedRotationGates.FormulaicRotationX = new GateBuilder().setSerializedIdAndSymbol("X^ft").setTitle("Formula X Rotation").setBlurb("Rotates around X by an amount determined by a formula.").setDrawer(configurableRotationDrawer('X^f(t)', 0, Math.PI)).setWidth(2).setExtraDisableReasonFinder(badFormulaDetector).setOnClickGateFunc(angleClicker("X gate's exponent")).setEffectToTimeVaryingMatrix(function(t, formula) {
    var exponent = parseTimeFormula(formula, t * 2 - 1, true) || 0;
    return Matrix.fromPauliRotation(exponent / 2, 0, 0);
  }).setWithParamPropertyRecomputeFunc(updateUsingFormula).promiseEffectIsUnitary().gate.withParam('sin(pi t)');
  ParametrizedRotationGates.FormulaicRotationY = new GateBuilder().setSerializedIdAndSymbol("Y^ft").setTitle("Formula Y Rotation").setBlurb("Rotates around Y by an amount determined by a formula.").setDrawer(configurableRotationDrawer('Y^f(t)', 1, Math.PI)).setWidth(2).setExtraDisableReasonFinder(badFormulaDetector).setOnClickGateFunc(angleClicker("Y gate's exponent")).setEffectToTimeVaryingMatrix(function(t, formula) {
    var exponent = parseTimeFormula(formula, t * 2 - 1, true) || 0;
    return Matrix.fromPauliRotation(0, exponent / 2, 0);
  }).setWithParamPropertyRecomputeFunc(updateUsingFormula).promiseEffectIsUnitary().gate.withParam('sin(pi t)');
  ParametrizedRotationGates.FormulaicRotationZ = new GateBuilder().setSerializedIdAndSymbol("Z^ft").setTitle("Formula Z Rotation").setBlurb("Rotates around Z by an amount determined by a formula.").setDrawer(configurableRotationDrawer('Z^f(t)', 2, Math.PI)).setWidth(2).setExtraDisableReasonFinder(badFormulaDetector).setOnClickGateFunc(angleClicker("Z gate's exponent")).setEffectToTimeVaryingMatrix(function(t, formula) {
    var exponent = parseTimeFormula(formula, t * 2 - 1, true) || 0;
    return Matrix.fromPauliRotation(0, 0, exponent / 2);
  }).setWithParamPropertyRecomputeFunc(updateUsingFormula).promiseEffectOnlyPhases().gate.withParam('sin(pi t)');
  ParametrizedRotationGates.FormulaicRotationRx = new GateBuilder().setSerializedIdAndSymbol("Rxft").setTitle("Formula Rx Gate").setBlurb("Rotates around X by an angle in radians determined by a formula.").setDrawer(configurableRotationDrawer('Rx(f(t))', 0, 1)).setWidth(2).setExtraDisableReasonFinder(badFormulaDetector).setOnClickGateFunc(angleClicker("Rx gate's angle in radians")).setEffectToTimeVaryingMatrix(function(t, formula) {
    return XExp((parseTimeFormula(formula, t * 2 - 1, true) || 0) / Math.PI / 4);
  }).setWithParamPropertyRecomputeFunc(updateUsingFormula).promiseEffectIsUnitary().gate.withParam('pi t^2');
  ParametrizedRotationGates.FormulaicRotationRy = new GateBuilder().setSerializedIdAndSymbol("Ryft").setTitle("Formula Ry Gate").setBlurb("Rotates around Y by an angle in radians determined by a formula.").setDrawer(configurableRotationDrawer('Ry(f(t))', 1, 1)).setWidth(2).setExtraDisableReasonFinder(badFormulaDetector).setOnClickGateFunc(angleClicker("Ry gate's angle in radians")).setEffectToTimeVaryingMatrix(function(t, formula) {
    return YExp((parseTimeFormula(formula, t * 2 - 1, true) || 0) / Math.PI / 4);
  }).setWithParamPropertyRecomputeFunc(updateUsingFormula).promiseEffectIsUnitary().gate.withParam('pi t^2');
  ParametrizedRotationGates.FormulaicRotationRz = new GateBuilder().setSerializedIdAndSymbol("Rzft").setTitle("Formula Rz Gate").setBlurb("Rotates around Z by an angle in radians determined by a formula.").setDrawer(configurableRotationDrawer('Rz(f(t))', 2, 1)).setWidth(2).setExtraDisableReasonFinder(badFormulaDetector).setOnClickGateFunc(angleClicker("Rz gate's angle in radians")).setEffectToTimeVaryingMatrix(function(t, formula) {
    return ZExp((parseTimeFormula(formula, t * 2 - 1, true) || 0) / Math.PI / 4);
  }).setWithParamPropertyRecomputeFunc(updateUsingFormula).promiseEffectOnlyPhases().gate.withParam('pi t^2');
  ParametrizedRotationGates.all = [ParametrizedRotationGates.XToA, ParametrizedRotationGates.XToMinusA, ParametrizedRotationGates.YToA, ParametrizedRotationGates.YToMinusA, ParametrizedRotationGates.ZToA, ParametrizedRotationGates.ZToMinusA, ParametrizedRotationGates.FormulaicRotationX, ParametrizedRotationGates.FormulaicRotationY, ParametrizedRotationGates.FormulaicRotationZ, ParametrizedRotationGates.FormulaicRotationRx, ParametrizedRotationGates.FormulaicRotationRy, ParametrizedRotationGates.FormulaicRotationRz];
  return {get ParametrizedRotationGates() {
      return ParametrizedRotationGates;
    }};
});
//# sourceURL=src/gates/ParametrizedRotationGates.js
;$traceurRuntime.registerModule("src/gates/PhaseGradientGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PhaseGradientGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/PhaseGradientGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/PhaseGradientGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/PhaseGradientGates.js")).GatePainting;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/PhaseGradientGates.js")),
      ketArgs = $__5.ketArgs,
      ketShaderPhase = $__5.ketShaderPhase;
  var MUL_STEP = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiplyAccumulateGates.js", "src/gates/PhaseGradientGates.js")).MUL_STEP;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglArg.js", "src/gates/PhaseGradientGates.js")).WglArg;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/PhaseGradientGates.js")).Matrix;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/PhaseGradientGates.js")).Complex;
  var PHASE_GRADIENT_SHADER = ketShaderPhase(("\n        uniform float factor;\n\n        /// Scales an angle by an integer factor.\n        /// Performs the multiplication gradually, to avoid losing precision.\n        float angle_mul(float base_angle, float whole_factor) {\n            float result = 0.0;\n            for (int k = 0; k < " + Math.ceil(Config.MAX_WIRE_COUNT / MUL_STEP) + "; k++) {\n                result += base_angle * mod(whole_factor, " + (1 << MUL_STEP) + ".0);\n                result = mod(result, 6.283185307179586476925286766559);\n                whole_factor = floor(whole_factor / " + (1 << MUL_STEP) + ".0);\n                base_angle = mod(base_angle * " + (1 << MUL_STEP) + ".0, 6.283185307179586476925286766559);\n            }\n            return result;\n        }\n    "), "\n        return angle_mul(factor, out_id);\n    ");
  var PhaseGradientGates = {};
  PhaseGradientGates.PhaseGradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("PhaseGradient" + span).setSymbol("Grad^½").setTitle("Half Gradient Gate").setBlurb("Phases the target by an amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", Math.PI / (1 << span))]));
    }).setKnownEffectToPhaser(function(k) {
      return k / (2 << span);
    });
  });
  PhaseGradientGates.PhaseDegradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(PhaseGradientGates.PhaseGradientFamily).setSerializedId("PhaseUngradient" + span).setSymbol("Grad^-½").setTitle("Inverse Half Gradient Gate").setBlurb("Counter-phases the target by an amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", -Math.PI / (1 << span))]));
    }).setKnownEffectToPhaser(function(k) {
      return -k / (2 << span);
    });
  });
  PhaseGradientGates.DynamicPhaseGradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("grad^t" + span).setSymbol("Grad^t").setTitle("Cycling Gradient Gate").setBlurb("Phases the target by a cycling amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", ctx.time * Math.PI * 2)]));
    }).setEffectToTimeVaryingMatrix(function(t) {
      return Matrix.generateDiagonal(1 << span, function(k) {
        return Complex.polar(1, t * 2 * Math.PI * k);
      });
    }).promiseEffectOnlyPhases().setDrawer(GatePainting.makeCycleDrawer(-1, -1, 1, -Math.PI / 2));
  });
  PhaseGradientGates.DynamicPhaseDegradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setAlternateFromFamily(PhaseGradientGates.DynamicPhaseGradientFamily).setSerializedId("grad^-t" + span).setSymbol("Grad^-t").setTitle("Inverse Cycling Gradient Gate").setBlurb("Counter-phases the target by a cycling amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", -ctx.time * Math.PI * 2)]));
    }).setEffectToTimeVaryingMatrix(function(t) {
      return Matrix.generateDiagonal(1 << span, function(k) {
        return Complex.polar(1, t * 2 * Math.PI * -k);
      });
    }).promiseEffectOnlyPhases().setDrawer(GatePainting.makeCycleDrawer(1, -1, 1, Math.PI / 2));
  });
  PhaseGradientGates.all = $traceurRuntime.spread(PhaseGradientGates.PhaseGradientFamily.all, PhaseGradientGates.PhaseDegradientFamily.all, PhaseGradientGates.DynamicPhaseGradientFamily.all, PhaseGradientGates.DynamicPhaseDegradientFamily.all);
  return {
    get PhaseGradientGates() {
      return PhaseGradientGates;
    },
    get PHASE_GRADIENT_SHADER() {
      return PHASE_GRADIENT_SHADER;
    }
  };
});
//# sourceURL=src/gates/PhaseGradientGates.js
;$traceurRuntime.registerModule("src/gates/PivotFlipGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PivotFlipGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/PivotFlipGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/PivotFlipGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModularIncrementGates.js", "src/gates/PivotFlipGates.js")).modulusTooBigChecker;
  var PivotFlipGates = {};
  var PIVOT_FLIP_SHADER = ketShaderPermute(("\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float a = read_input_A();\n        return out_id >= a ? out_id : a - out_id - 1.0;\n    ");
  PivotFlipGates.FlipUnderA = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId('Flip<A' + span).setSymbol('Flip\n< A').setTitle('Pivot-Flip Gate').setBlurb('Reverses the order of states below the pivot value.').setRequiredContextKeys('Input Range A').setExtraDisableReasonFinder(modulusTooBigChecker('A', span, 'pivot')).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PIVOT_FLIP_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return t >= a ? t : a - t - 1;
    });
  });
  PivotFlipGates.all = $traceurRuntime.spread(PivotFlipGates.FlipUnderA.all);
  return {get PivotFlipGates() {
      return PivotFlipGates;
    }};
});
//# sourceURL=src/gates/PivotFlipGates.js
;$traceurRuntime.registerModule("src/gates/PostSelectionGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PostSelectionGates.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/PostSelectionGates.js")).Complex;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/PostSelectionGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/PostSelectionGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/PostSelectionGates.js")).Matrix;
  var PostSelectionGates = {};
  var POST_SELECT_DRAWER = function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
    } else {
      args.painter.fillRect(args.rect, 'white');
      GatePainting.paintGateSymbol(args);
    }
    if (!args.isInToolbox) {
      var $__1 = args.rect,
          x = $__1.x,
          y = $__1.y,
          w = $__1.w,
          h = $__1.h;
      args.painter.print("post-", x + w / 2, y, 'center', 'hanging', 'red', '10px sans-serif', w, h / 2);
      args.painter.print("select", x + w / 2, y + h, 'center', 'bottom', 'red', '10px sans-serif', w, h / 2);
    }
  };
  PostSelectionGates.PostSelectOff = new GateBuilder().setSerializedIdAndSymbol("|0⟩⟨0|").setTitle("Postselect Off").setBlurb("Keeps OFF states, discards/retries ON states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, 0, 0, 0)).gate;
  PostSelectionGates.PostSelectOn = new GateBuilder().setAlternate(PostSelectionGates.PostSelectOff).setSerializedIdAndSymbol("|1⟩⟨1|").setTitle("Postselect On").setBlurb("Keeps On states, discards/retries Off states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(0, 0, 0, 1)).gate;
  PostSelectionGates.PostSelectAntiX = new GateBuilder().setSerializedId("|+⟩⟨+|").setSymbol("|+⟩⟨+|").setTitle("Postselect X-Off").setBlurb("Keeps ON+OFF states, discards/retries ON-OFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, 1, 1, 1).times(0.5)).gate;
  PostSelectionGates.PostSelectX = new GateBuilder().setAlternate(PostSelectionGates.PostSelectAntiX).setSerializedId("|-⟩⟨-|").setSymbol("|-⟩⟨-|").setTitle("Postselect X-On").setBlurb("Keeps ON-OFF states, discards/retries ON+OFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, -1, -1, 1).times(0.5)).gate;
  PostSelectionGates.PostSelectAntiY = new GateBuilder().setSerializedId("|X⟩⟨X|").setSymbol("|i⟩⟨i|").setTitle("Postselect Y-Off").setBlurb("Keeps ON+iOFF states, discards ON-iOFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, Complex.I.neg(), Complex.I, 1).times(0.5)).gate;
  PostSelectionGates.PostSelectY = new GateBuilder().setAlternate(PostSelectionGates.PostSelectAntiY).setSerializedId("|/⟩⟨/|").setSymbol("|-i⟩⟨-i|").setTitle("Postselect Y-On").setBlurb("Keeps ON-iOFF states, discards/retries ON+iOFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, Complex.I, Complex.I.neg(), 1).times(0.5)).gate;
  PostSelectionGates.all = [PostSelectionGates.PostSelectOff, PostSelectionGates.PostSelectOn, PostSelectionGates.PostSelectAntiX, PostSelectionGates.PostSelectX, PostSelectionGates.PostSelectAntiY, PostSelectionGates.PostSelectY];
  return {get PostSelectionGates() {
      return PostSelectionGates;
    }};
});
//# sourceURL=src/gates/PostSelectionGates.js
;$traceurRuntime.registerModule("src/gates/PoweringGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PoweringGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/PoweringGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/PoweringGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/PoweringGates.js")).Matrix;
  var PoweringGates = {};
  var τ = Math.PI * 2;
  var XPow = function(t) {
    var c = Math.cos(τ * t) / 2;
    var s = Math.sin(τ * t) / 2;
    return new Matrix(2, 2, new Float32Array([0.5 + c, s, 0.5 - c, -s, 0.5 - c, -s, 0.5 + c, s]));
  };
  var YPow = function(t) {
    var c = Math.cos(τ * t) / 2;
    var s = Math.sin(τ * t) / 2;
    return new Matrix(2, 2, new Float32Array([0.5 + c, s, -s, c - 0.5, s, 0.5 - c, 0.5 + c, s]));
  };
  var ZPow = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([1, 0, 0, 0, 0, 0, c, s]));
  };
  PoweringGates.XForward = new GateBuilder().setSerializedIdAndSymbol("X^t").setTitle("X-Raising Gate (forward)").setBlurb("Right-handed cycle from no-op to X.").setDrawer(GatePainting.makeCycleDrawer(1, 1)).setEffectToTimeVaryingMatrix(XPow).promiseEffectIsUnitary().gate;
  PoweringGates.XBackward = new GateBuilder().setAlternate(PoweringGates.XForward).setSerializedIdAndSymbol("X^-t").setTitle("X-Raising Gate (backward)").setBlurb("Left-handed cycle from no-op to X.").setDrawer(GatePainting.makeCycleDrawer(-1, 1)).setEffectToTimeVaryingMatrix(function(t) {
    return XPow(-t);
  }).promiseEffectIsUnitary().gate;
  PoweringGates.YForward = new GateBuilder().setSerializedIdAndSymbol("Y^t").setTitle("Y-Raising Gate (forward)").setBlurb("Right-handed cycle from no-op to Y.").setDrawer(GatePainting.makeCycleDrawer(0.5, 1)).setEffectToTimeVaryingMatrix(YPow).promiseEffectIsUnitary().gate;
  PoweringGates.YBackward = new GateBuilder().setAlternate(PoweringGates.YForward).setSerializedIdAndSymbol("Y^-t").setTitle("Y-Raising Gate (backward)").setBlurb("Left-handed cycle from no-op to Y.").setDrawer(GatePainting.makeCycleDrawer(-0.5, 1)).setEffectToTimeVaryingMatrix(function(t) {
    return YPow(-t);
  }).promiseEffectIsUnitary().gate;
  PoweringGates.ZForward = new GateBuilder().setSerializedIdAndSymbol("Z^t").setTitle("Z-Raising Gate (forward)").setBlurb("Right-handed cycle from no-op to Z.").setDrawer(GatePainting.makeCycleDrawer(-1, -0.5)).setEffectToTimeVaryingMatrix(ZPow).promiseEffectOnlyPhases().gate;
  PoweringGates.ZBackward = new GateBuilder().setAlternate(PoweringGates.ZForward).setSerializedIdAndSymbol("Z^-t").setTitle("Z-Raising Gate (backward)").setBlurb("Left-handed cycle from no-op to Z.").setDrawer(GatePainting.makeCycleDrawer(1, -0.5)).setEffectToTimeVaryingMatrix(function(t) {
    return ZPow(-t);
  }).promiseEffectOnlyPhases().gate;
  PoweringGates.all = [PoweringGates.XForward, PoweringGates.YForward, PoweringGates.ZForward, PoweringGates.XBackward, PoweringGates.YBackward, PoweringGates.ZBackward];
  return {get PoweringGates() {
      return PoweringGates;
    }};
});
//# sourceURL=src/gates/PoweringGates.js
;$traceurRuntime.registerModule("src/gates/ProbabilityDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ProbabilityDisplay.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/gates/ProbabilityDisplay.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/ProbabilityDisplay.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ProbabilityDisplay.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/ProbabilityDisplay.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateShaders.js", "src/gates/ProbabilityDisplay.js")).GateShaders;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/gates/ProbabilityDisplay.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/ProbabilityDisplay.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/ProbabilityDisplay.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/gates/ProbabilityDisplay.js")).Rect;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/gates/ProbabilityDisplay.js")).Seq;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/Shaders.js", "src/gates/ProbabilityDisplay.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/ProbabilityDisplay.js")).Util;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglConfiguredShader.js", "src/gates/ProbabilityDisplay.js")).WglConfiguredShader;
  var $__24 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/ShaderCoders.js", "src/gates/ProbabilityDisplay.js")),
      Inputs = $__24.Inputs,
      Outputs = $__24.Outputs,
      currentShaderCoder = $__24.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__24.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTexturePool.js", "src/gates/ProbabilityDisplay.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../webgl/WglTextureTrader.js", "src/gates/ProbabilityDisplay.js")).WglTextureTrader;
  function probabilityStatTexture(ketTexture, controlTexture, rangeOffset, rangeLength) {
    var trader = new WglTextureTrader(ketTexture);
    trader.dontDeallocCurrentTexture();
    var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ketTexture);
    trader.shadeAndTrade(function(tex) {
      return amplitudesToProbabilities(tex, controlTexture);
    }, WglTexturePool.takeVecFloatTex(n));
    trader.shadeAndTrade(function(tex) {
      return GateShaders.cycleAllBitsFloat(tex, -rangeOffset);
    });
    while (n > rangeLength) {
      n -= 1;
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    if (currentShaderCoder().float.needRearrangingToBeInVec4Format) {
      trader.shadeQuarterAndTrade(Shaders.packFloatIntoVec4);
    }
    return trader.currentTexture;
  }
  var amplitudesToProbabilities = function(inputTexture, controlTex) {
    return AMPLITUDES_TO_PROBABILITIES_SHADER(inputTexture, controlTex);
  };
  var AMPLITUDES_TO_PROBABILITIES_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input'), Inputs.bool('control')], Outputs.float(), "float outputFor(float k) {\n        vec2 amp = read_input(k);\n        return dot(amp, amp) * read_control(k);\n    }");
  function probabilityPixelsToColumnVector(pixels, span) {
    var n = 1 << span;
    var unity = 0;
    for (var i = 0; i < n; i++) {
      unity += pixels[i];
    }
    if (isNaN(unity) || unity < 0.000001) {
      return Matrix.zero(1, n).times(NaN);
    }
    var buf = new Float32Array(n * 2);
    for (var i$__10 = 0; i$__10 < n; i$__10++) {
      buf[i$__10 * 2] = pixels[i$__10] / unity;
    }
    return new Matrix(1, n, buf);
  }
  function probabilityDataToJson(data) {
    return {probabilities: Seq.range(data.height()).map(function(k) {
        return Complex.realPartOf(data.cell(0, k));
      }).toArray()};
  }
  function _paintMultiProbabilityDisplay_grid(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h;
    var n = 1 << args.gate.height;
    var d = h / n;
    painter.fillRect(args.rect, Config.DISPLAY_GATE_BACK_COLOR);
    if (d < 1) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.2;
      painter.fillRect(args.rect, 'lightgray');
      args.painter.ctx.restore();
      return;
    }
    var r = args.gate.height - 5;
    painter.trace(function(tracer) {
      for (var i = 1; i < n; i++) {
        tracer.line(x, y + d * i, x + w, y + d * i);
      }
    }).thenStroke('lightgray', r <= 0 ? 1 : 1 / r);
    painter.strokeRect(args.rect, 'lightgray');
  }
  function _paintMultiProbabilityDisplay_probabilityBars(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h,
        probabilities = $__8.customStats;
    var n = 1 << args.gate.height;
    var d = h / n;
    var e = Math.max(d, 1);
    painter.ctx.save();
    painter.ctx.beginPath();
    painter.ctx.moveTo(x, y);
    for (var i = 0; i < n; i++) {
      var p = probabilities.rawBuffer()[i * 2];
      var px = x + w * p;
      var py = y + d * i;
      painter.ctx.lineTo(px, py);
      painter.ctx.lineTo(px, py + e);
    }
    painter.ctx.lineTo(x, y + h);
    painter.ctx.lineTo(x, y);
    painter.ctx.strokeStyle = 'gray';
    painter.ctx.lineWidth = 1;
    painter.ctx.stroke();
    painter.ctx.fillStyle = Config.DISPLAY_GATE_FORE_COLOR;
    painter.ctx.fill();
    painter.ctx.restore();
  }
  function _paintMultiProbabilityDisplay_logarithmHints(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h,
        probabilities = $__8.customStats;
    var n = 1 << args.gate.height;
    var d = h / n;
    var e = Math.max(d, 1);
    painter.ctx.save();
    painter.ctx.beginPath();
    painter.ctx.moveTo(x, y);
    var s = 1 / (4 + Math.max(8, args.gate.height));
    for (var i = 0; i < n; i++) {
      var p = probabilities.rawBuffer()[i * 2];
      var px = x + w * Math.min(1, Math.max(0, 1 + Math.log(p) * s));
      var py = y + d * i;
      painter.ctx.lineTo(px, py);
      painter.ctx.lineTo(px, py + e);
    }
    painter.ctx.lineTo(x, y + h);
    painter.ctx.lineWidth = 1;
    painter.ctx.strokeStyle = '#CCC';
    painter.ctx.stroke();
    painter.ctx.restore();
  }
  function _paintMultiProbabilityDisplay_tooltips(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h,
        probabilities = $__8.customStats;
    var n = 1 << args.gate.height;
    var d = h / n;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (args.focusPoints)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var pt = $__2.value;
        {
          var k = Math.floor((pt.y - y) / d);
          if (args.rect.containsPoint(pt) && k >= 0 && k < n) {
            var p = probabilities === undefined ? NaN : probabilities.rawBuffer()[k * 2];
            painter.strokeRect(new Rect(x, y + k * d, w, d), 'orange', 2);
            MathPainter.paintDeferredValueTooltip(painter, x + w, y + k * d, ("Chance of |" + Util.bin(k, args.gate.height) + "⟩ (decimal " + k + ") if measured"), 'raw: ' + (p * 100).toFixed(4) + "%", 'log: ' + (Math.log10(p) * 10).toFixed(1) + " dB");
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  }
  function _paintMultiProbabilityDisplay_probabilityTexts(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h,
        probabilities = $__8.customStats;
    var d = h / probabilities.height();
    for (var i = 0; i < probabilities.height(); i++) {
      var p = probabilities.rawBuffer()[i * 2];
      painter.print((p * 100).toFixed(1) + "%", x + w - 2, y + d * (i + 0.5), 'right', 'middle', 'black', '8pt monospace', w - 4, d);
    }
  }
  function paintMultiProbabilityDisplay(args) {
    _paintMultiProbabilityDisplay_grid(args);
    var probabilities = args.customStats;
    var noData = probabilities === undefined || probabilities.hasNaN();
    if (noData) {
      args.painter.printParagraph("NaN", args.rect, new Point(0.5, 0.5), 'red');
    } else {
      var textFits = args.rect.h / probabilities.height() > 8;
      if (!textFits) {
        _paintMultiProbabilityDisplay_logarithmHints(args);
      }
      _paintMultiProbabilityDisplay_probabilityBars(args);
      if (textFits) {
        _paintMultiProbabilityDisplay_probabilityTexts(args);
      }
    }
    _paintMultiProbabilityDisplay_tooltips(args);
  }
  function shared_chanceGateMaker(builder) {
    return builder.setSymbol("Chance").setTitle("Probability Display").setBlurb("Shows chances of outcomes if a measurement was performed.\n" + "Use controls to see conditional probabilities.").promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    });
  }
  function multiChanceGateMaker(span, builder) {
    return shared_chanceGateMaker(builder).setSerializedId("Chance" + span).setStatTexturesMaker(function(ctx) {
      return probabilityStatTexture(ctx.stateTrader.currentTexture, ctx.controlsTexture, ctx.row, span);
    }).setStatPixelDataPostProcessor(function(pixels) {
      return probabilityPixelsToColumnVector(pixels, span);
    }).setProcessedStatsToJsonFunc(probabilityDataToJson).setDrawer(GatePainting.makeDisplayDrawer(paintMultiProbabilityDisplay));
  }
  function singleChangeGateMaker(builder) {
    return shared_chanceGateMaker(builder).setSerializedId("Chance").markAsDrawerNeedsSingleQubitDensityStats().setDrawer(GatePainting.makeDisplayDrawer(function(args) {
      var $__8 = args.positionInCircuit,
          row = $__8.row,
          col = $__8.col;
      MathPainter.paintProbabilityBox(args.painter, args.stats.controlledWireProbabilityJustAfter(row, col), args.rect, args.focusPoints);
    }));
  }
  var ProbabilityDisplayFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return span === 1 ? singleChangeGateMaker(builder) : multiChanceGateMaker(span, builder);
  });
  return {
    get ProbabilityDisplayFamily() {
      return ProbabilityDisplayFamily;
    },
    get probabilityStatTexture() {
      return probabilityStatTexture;
    },
    get probabilityPixelsToColumnVector() {
      return probabilityPixelsToColumnVector;
    },
    get amplitudesToProbabilities() {
      return amplitudesToProbabilities;
    },
    get probabilityDataToJson() {
      return probabilityDataToJson;
    }
  };
});
//# sourceURL=src/gates/ProbabilityDisplay.js
;$traceurRuntime.registerModule("src/gates/QuarterTurnGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/QuarterTurnGates.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/QuarterTurnGates.js")),
      Gate = $__1.Gate,
      GateBuilder = $__1.GateBuilder;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/QuarterTurnGates.js")).Matrix;
  var QuarterTurnGates = {};
  QuarterTurnGates.SqrtXForward = new GateBuilder().setSerializedIdAndSymbol('X^½').setTitle("√X Gate").setBlurb("Principle square root of Not.").setKnownEffectToMatrix(Matrix.fromPauliRotation(0.25, 0, 0)).gate;
  QuarterTurnGates.SqrtXBackward = new GateBuilder().setAlternate(QuarterTurnGates.SqrtXForward).setSerializedIdAndSymbol('X^-½').setTitle("X^-½ Gate").setBlurb("Adjoint square root of Not.").setKnownEffectToMatrix(Matrix.fromPauliRotation(0.75, 0, 0)).gate;
  QuarterTurnGates.SqrtYForward = new GateBuilder().setSerializedIdAndSymbol('Y^½').setTitle("√Y Gate").setBlurb("Principle square root of Y.").setKnownEffectToMatrix(Matrix.fromPauliRotation(0, 0.25, 0)).gate;
  QuarterTurnGates.SqrtYBackward = new GateBuilder().setAlternate(QuarterTurnGates.SqrtYForward).setSerializedIdAndSymbol('Y^-½').setTitle("Y^-½ Gate").setBlurb("Adjoint square root of Y.").setKnownEffectToMatrix(Matrix.fromPauliRotation(0, 0.75, 0)).gate;
  QuarterTurnGates.SqrtZForward = new GateBuilder().setSerializedId('Z^½').setSymbol('S').setTitle("√Z Gate").setBlurb("Principle square root of Z.\nAlso known as the 'S' gate.").setKnownEffectToMatrix(Matrix.fromPauliRotation(0, 0, 0.25)).gate;
  QuarterTurnGates.SqrtZBackward = new GateBuilder().setAlternate(QuarterTurnGates.SqrtZForward).setSerializedId('Z^-½').setSymbol('S^-1').setTitle("Z^-½ Gate").setBlurb("Adjoint square root of Z.").setKnownEffectToMatrix(Matrix.fromPauliRotation(0, 0, 0.75)).gate;
  QuarterTurnGates.all = [QuarterTurnGates.SqrtXForward, QuarterTurnGates.SqrtYForward, QuarterTurnGates.SqrtZForward, QuarterTurnGates.SqrtXBackward, QuarterTurnGates.SqrtYBackward, QuarterTurnGates.SqrtZBackward];
  return {get QuarterTurnGates() {
      return QuarterTurnGates;
    }};
});
//# sourceURL=src/gates/QuarterTurnGates.js
;$traceurRuntime.registerModule("src/gates/ReverseBitsGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ReverseBitsGate.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/ReverseBitsGate.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/ReverseBitsGate.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/ReverseBitsGate.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/gates/ReverseBitsGate.js")).Seq;
  var _generateReverseShaderForSize = function(span) {
    return span < 2 ? undefined : ketShaderPermute('', ("\n        float rev = 0.0;\n        for (int k = 0; k < " + span + "; k++) {\n            rev *= 2.0;\n            rev += mod(out_id, 2.0);\n            out_id = floor(out_id*0.5);\n        }\n        return rev;\n    "), span);
  };
  var reverseShaders = Seq.range(Config.MAX_WIRE_COUNT + 1).map(_generateReverseShaderForSize).toArray();
  var reverseShaderForSize = function(span) {
    return function(ctx) {
      var $__0;
      return ($__0 = reverseShaders[span]).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx, span)));
    };
  };
  var ReverseBitsGateFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("rev" + span).setSymbol("Reverse").setTitle("Reverse Order").setBlurb("Swaps bits into the opposite order.").setKnownEffectToBitPermutation(function(i) {
      return span - 1 - i;
    }).setActualEffectToShaderProvider(reverseShaderForSize(span));
  });
  return {
    get ReverseBitsGateFamily() {
      return ReverseBitsGateFamily;
    },
    get reverseShaderForSize() {
      return reverseShaderForSize;
    }
  };
});
//# sourceURL=src/gates/ReverseBitsGate.js
;$traceurRuntime.registerModule("src/gates/SampleDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/SampleDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/SampleDisplay.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/SampleDisplay.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/SampleDisplay.js")).GatePainting;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/gates/SampleDisplay.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/gates/SampleDisplay.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/gates/SampleDisplay.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/gates/SampleDisplay.js")).Util;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ProbabilityDisplay.js", "src/gates/SampleDisplay.js")),
      probabilityStatTexture = $__18.probabilityStatTexture,
      probabilityPixelsToColumnVector = $__18.probabilityPixelsToColumnVector,
      probabilityDataToJson = $__18.probabilityDataToJson;
  function sampleFromDistribution(args) {
    var probabilities = args.customStats;
    var buf = probabilities.rawBuffer();
    var r = args.painter.rng.random();
    var n = probabilities.height();
    for (var i = 0; ; i++) {
      var p = buf[i * 2];
      r -= p;
      if (i === n - 1 || r < 0.00001) {
        return {
          i: i,
          p: p
        };
      }
    }
  }
  function _paintSampleDisplay_result(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h;
    var d = Config.WIRE_SPACING;
    var startY = y + h / 2 - d * args.gate.height / 2;
    var $__10 = sampleFromDistribution(args),
        sample = $__10.i,
        p = $__10.p;
    for (var i = 0; i < args.gate.height; i++) {
      var bit = ((sample >> i) & 1) !== 0;
      if (bit) {
        painter.fillRect(new Rect(x, startY + d * i + 5, w, d - 10), Config.OPERATION_FORE_COLOR);
      }
      painter.print(bit ? 'on' : 'off', x + w / 2, startY + d * (i + 0.5), 'center', 'middle', 'black', '16px sans-serif', w, d);
    }
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (args.focusPoints)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var pt = $__2.value;
        {
          var k = Math.floor((pt.y - y) * 2 / d) / 2;
          if (args.rect.containsPoint(pt)) {
            MathPainter.paintDeferredValueTooltip(painter, x + w, y + k * d, ("Sampled |" + Util.bin(sample, args.gate.height) + "⟩"), ("decimal: |" + sample + "⟩"), "chance: " + (p * 100).toFixed(4) + "%", Config.OPERATION_BACK_COLOR);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  }
  function paintSampleDisplay(args) {
    args.painter.fillRect(args.rect, Config.OPERATION_BACK_COLOR);
    var probabilities = args.customStats;
    var noData = probabilities === undefined || probabilities.hasNaN();
    if (noData) {
      args.painter.printParagraph("NaN", args.rect, new Point(0.5, 0.5), 'red');
    } else {
      _paintSampleDisplay_result(args);
    }
    args.painter.strokeRect(args.rect, 'lightgray');
  }
  var SampleDisplayFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Sample" + span).setSymbol("Sample").setTitle("Sampled Results Display").setBlurb("Shows a random sample of possible measurement outcomes.\nUse controls to see conditional samples.").setStatTexturesMaker(function(ctx) {
      return probabilityStatTexture(ctx.stateTrader.currentTexture, ctx.controlsTexture, ctx.row, span);
    }).setStatPixelDataPostProcessor(function(e) {
      return probabilityPixelsToColumnVector(e, span);
    }).promiseHasNoNetEffectOnStateVectorButStillRequiresDynamicRedraw().setProcessedStatsToJsonFunc(probabilityDataToJson).setDrawer(GatePainting.makeDisplayDrawer(paintSampleDisplay)).setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    });
  });
  return {get SampleDisplayFamily() {
      return SampleDisplayFamily;
    }};
});
//# sourceURL=src/gates/SampleDisplay.js
;$traceurRuntime.registerModule("src/gates/SpacerGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/SpacerGate.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/SpacerGate.js")).Config;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/SpacerGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/SpacerGate.js")).GatePainting;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/gates/SpacerGate.js")).Rect;
  var SpacerGate = new GateBuilder().setSerializedIdAndSymbol("…").setTitle("Spacer").setBlurb("A gate with no effect.").markAsNotInterestedInControls().promiseHasNoNetEffectOnStateVector().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      var backColor = Config.GATE_FILL_COLOR;
      if (args.isHighlighted) {
        backColor = Config.HIGHLIGHTED_GATE_FILL_COLOR;
      }
      args.painter.fillRect(args.rect, backColor);
      GatePainting.paintOutline(args);
    } else {
      var $__0 = args.rect.center(),
          x = $__0.x,
          y = $__0.y;
      var r = new Rect(x - 14, y - 2, 28, 4);
      args.painter.fillRect(r, Config.BACKGROUND_COLOR_CIRCUIT);
    }
    args.painter.fillCircle(args.rect.center().offsetBy(7, 0), 2, "black");
    args.painter.fillCircle(args.rect.center(), 2, "black");
    args.painter.fillCircle(args.rect.center().offsetBy(-7, 0), 2, "black");
  }).gate;
  return {get SpacerGate() {
      return SpacerGate;
    }};
});
//# sourceURL=src/gates/SpacerGate.js
;$traceurRuntime.registerModule("src/gates/SwapGateHalf.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/SwapGateHalf.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/SwapGateHalf.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/gates/SwapGateHalf.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/SwapGateHalf.js")).Matrix;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/gates/SwapGateHalf.js")).Rect;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/gates/SwapGateHalf.js")).Seq;
  var SwapGateHalf = new GateBuilder().setSerializedIdAndSymbol("Swap").setTitle("Swap Gate [Half]").setBlurb("Swaps the values of two qubits.\n(Place two in the same column.)").setKnownEffectToMatrix(Matrix.square(1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)).setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    var swapRect = Rect.centeredSquareWithRadius(args.rect.center(), args.rect.w / 6);
    args.painter.strokeLine(swapRect.topLeft(), swapRect.bottomRight());
    args.painter.strokeLine(swapRect.topRight(), swapRect.bottomLeft());
  }).setExtraDisableReasonFinder(function(args) {
    var col = args.innerColumn;
    var swapRows = Seq.range(col.gates.length).filter(function(row) {
      return col.gates[row] === SwapGateHalf;
    });
    var n = swapRows.count();
    if (n === 1) {
      return "need\nother\nswap";
    }
    if (n > 2) {
      return "too\nmany\nswap";
    }
    var affectsMeasured = swapRows.any(function(r) {
      return (args.measuredMask & (1 << r)) !== 0;
    });
    var affectsUnmeasured = swapRows.any(function(r) {
      return (args.measuredMask & (1 << r)) === 0;
    });
    if (affectsMeasured && col.hasCoherentControl(args.measuredMask)) {
      return "no\nremix\n(sorry)";
    }
    if (affectsMeasured && affectsUnmeasured && col.hasControl()) {
      return "no\nremix\n(sorry)";
    }
    return undefined;
  }).gate;
  return {get SwapGateHalf() {
      return SwapGateHalf;
    }};
});
//# sourceURL=src/gates/SwapGateHalf.js
;$traceurRuntime.registerModule("src/gates/VariousXGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/VariousXGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/VariousXGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/VariousXGates.js")).Matrix;
  var VariousXGates = {};
  VariousXGates.X3 = Gate.fromKnownMatrix("X^⅓", Matrix.fromPauliRotation(1 / 6, 0, 0), "X^⅓ Gate", "Principle third root of X.");
  VariousXGates.X3i = Gate.fromKnownMatrix("X^-⅓", Matrix.fromPauliRotation(-1 / 6, 0, 0), "X^-⅓ Gate", "Adjoint third root of X.", undefined, VariousXGates.X3);
  VariousXGates.X4 = Gate.fromKnownMatrix("X^¼", Matrix.fromPauliRotation(1 / 8, 0, 0), "X^¼ Gate", "Principle fourth root of X.");
  VariousXGates.X4i = Gate.fromKnownMatrix("X^-¼", Matrix.fromPauliRotation(-1 / 8, 0, 0), "X^-¼ Gate", "Adjoint fourth root of X.", undefined, VariousXGates.X4);
  VariousXGates.X8 = Gate.fromKnownMatrix("X^⅛", Matrix.fromPauliRotation(1 / 16, 0, 0), "X^⅛ Gate", "Principle eighth root of X.");
  VariousXGates.X8i = Gate.fromKnownMatrix("X^-⅛", Matrix.fromPauliRotation(-1 / 16, 0, 0), "X^-⅛ Gate", "Adjoint eighth root of X.", undefined, VariousXGates.X8);
  VariousXGates.X16 = Gate.fromKnownMatrix("X^⅟₁₆", Matrix.fromPauliRotation(1 / 32, 0, 0), "X^⅟₁₆ Gate", "Principle sixteenth root of X.");
  VariousXGates.X16i = Gate.fromKnownMatrix("X^-⅟₁₆", Matrix.fromPauliRotation(-1 / 32, 0, 0), "X^-⅟₁₆ Gate", "Adjoint sixteenth root of X.", undefined, VariousXGates.X16);
  VariousXGates.X32 = Gate.fromKnownMatrix("X^⅟₃₂", Matrix.fromPauliRotation(1 / 64, 0, 0), "X^⅟₃₂ Gate", "Principle 32'nd root of X.");
  VariousXGates.X32i = Gate.fromKnownMatrix("X^-⅟₃₂", Matrix.fromPauliRotation(-1 / 64, 0, 0), "X^-⅟₃₂ Gate", "Adjoint 32'nd root of X.", undefined, VariousXGates.X32);
  VariousXGates.all = [VariousXGates.X3, VariousXGates.X4, VariousXGates.X8, VariousXGates.X16, VariousXGates.X32, VariousXGates.X3i, VariousXGates.X4i, VariousXGates.X8i, VariousXGates.X16i, VariousXGates.X32i];
  return {get VariousXGates() {
      return VariousXGates;
    }};
});
//# sourceURL=src/gates/VariousXGates.js
;$traceurRuntime.registerModule("src/gates/VariousYGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/VariousYGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/VariousYGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/VariousYGates.js")).Matrix;
  var VariousYGates = {};
  VariousYGates.Y3 = Gate.fromKnownMatrix("Y^⅓", Matrix.fromPauliRotation(0, 1 / 6, 0), "Y^⅓ Gate", "Principle third root of Y.");
  VariousYGates.Y3i = Gate.fromKnownMatrix("Y^-⅓", Matrix.fromPauliRotation(0, -1 / 6, 0), "Y^-⅓ Gate", "Adjoint third root of Y.", undefined, VariousYGates.Y3);
  VariousYGates.Y4 = Gate.fromKnownMatrix("Y^¼", Matrix.fromPauliRotation(0, 1 / 8, 0), "Y^¼ Gate", "Principle fourth root of Y.");
  VariousYGates.Y4i = Gate.fromKnownMatrix("Y^-¼", Matrix.fromPauliRotation(0, -1 / 8, 0), "Y^-¼ Gate", "Adjoint fourth root of Y.", undefined, VariousYGates.Y4);
  VariousYGates.Y8 = Gate.fromKnownMatrix("Y^⅛", Matrix.fromPauliRotation(0, 1 / 16, 0), "Y^⅛ Gate", "Principle eighth root of Y.");
  VariousYGates.Y8i = Gate.fromKnownMatrix("Y^-⅛", Matrix.fromPauliRotation(0, -1 / 16, 0), "Y^-⅛ Gate", "Adjoint eighth root of Y.", undefined, VariousYGates.Y8);
  VariousYGates.Y16 = Gate.fromKnownMatrix("Y^⅟₁₆", Matrix.fromPauliRotation(0, 1 / 32, 0), "Y^⅟₁₆ Gate", "Principle sixteenth root of Y.");
  VariousYGates.Y16i = Gate.fromKnownMatrix("Y^-⅟₁₆", Matrix.fromPauliRotation(0, -1 / 32, 0), "Y^-⅟₁₆ Gate", "Adjoint sixteenth root of Y.", undefined, VariousYGates.Y16);
  VariousYGates.Y32 = Gate.fromKnownMatrix("Y^⅟₃₂", Matrix.fromPauliRotation(0, 1 / 64, 0), "Y^⅟₃₂ Gate", "Principle 32'nd root of Y.");
  VariousYGates.Y32i = Gate.fromKnownMatrix("Y^-⅟₃₂", Matrix.fromPauliRotation(0, -1 / 64, 0), "Y^-⅟₃₂ Gate", "Adjoint 32'nd root of Y.", undefined, VariousYGates.Y32);
  VariousYGates.all = [VariousYGates.Y3, VariousYGates.Y4, VariousYGates.Y8, VariousYGates.Y16, VariousYGates.Y32, VariousYGates.Y3i, VariousYGates.Y4i, VariousYGates.Y8i, VariousYGates.Y16i, VariousYGates.Y32i];
  return {get VariousYGates() {
      return VariousYGates;
    }};
});
//# sourceURL=src/gates/VariousYGates.js
;$traceurRuntime.registerModule("src/gates/VariousZGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/VariousZGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/VariousZGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/gates/VariousZGates.js")).Matrix;
  var VariousZGates = {};
  VariousZGates.Z3 = Gate.fromKnownMatrix("Z^⅓", Matrix.fromPauliRotation(0, 0, 1 / 6), "Z^⅓ Gate", "Principle third root of Z.");
  VariousZGates.Z3i = Gate.fromKnownMatrix("Z^-⅓", Matrix.fromPauliRotation(0, 0, -1 / 6), "Z^-⅓ Gate", "Adjoint third root of Z.", undefined, VariousZGates.Z3);
  VariousZGates.Z4 = Gate.fromKnownMatrix("T", Matrix.fromPauliRotation(0, 0, 1 / 8), "Z^¼ Gate", "Principle fourth root of Z.", "Z^¼");
  VariousZGates.Z4i = Gate.fromKnownMatrix("T^-1", Matrix.fromPauliRotation(0, 0, -1 / 8), "Z^-¼ Gate", "Adjoint fourth root of Z.", "Z^-¼", VariousZGates.Z4);
  VariousZGates.Z8 = Gate.fromKnownMatrix("Z^⅛", Matrix.fromPauliRotation(0, 0, 1 / 16), "Z^⅛ Gate", "Principle eighth root of Z.");
  VariousZGates.Z8i = Gate.fromKnownMatrix("Z^-⅛", Matrix.fromPauliRotation(0, 0, -1 / 16), "Z^-⅛ Gate", "Adjoint eighth root of Z.", undefined, VariousZGates.Z8);
  VariousZGates.Z16 = Gate.fromKnownMatrix("Z^⅟₁₆", Matrix.fromPauliRotation(0, 0, 1 / 32), "Z^⅟₁₆ Gate", "Principle 16'th root of Z.");
  VariousZGates.Z16i = Gate.fromKnownMatrix("Z^-⅟₁₆", Matrix.fromPauliRotation(0, 0, -1 / 32), "Z^-⅟₁₆ Gate", "Adjoint 16'th root of Z.", undefined, VariousZGates.Z16);
  VariousZGates.Z32 = Gate.fromKnownMatrix("Z^⅟₃₂", Matrix.fromPauliRotation(0, 0, 1 / 64), "Z^⅟₃₂ Gate", "Principle 32'nd root of Z.");
  VariousZGates.Z64 = Gate.fromKnownMatrix("Z^⅟₆₄", Matrix.fromPauliRotation(0, 0, 1 / 128), "Z^⅟₆₄ Gate", "Principle 64'th root of Z.");
  VariousZGates.Z128 = Gate.fromKnownMatrix("Z^⅟₁₂₈", Matrix.fromPauliRotation(0, 0, 1 / 256), "Z^⅟₁₂₈ Gate", "Principle 128'th root of Z.");
  VariousZGates.all = [VariousZGates.Z3, VariousZGates.Z4, VariousZGates.Z8, VariousZGates.Z16, VariousZGates.Z32, VariousZGates.Z64, VariousZGates.Z128, VariousZGates.Z3i, VariousZGates.Z4i, VariousZGates.Z8i, VariousZGates.Z16i];
  return {get VariousZGates() {
      return VariousZGates;
    }};
});
//# sourceURL=src/gates/VariousZGates.js
;$traceurRuntime.registerModule("src/gates/XorGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/XorGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/gates/XorGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/gates/XorGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/KetShaderUtil.js", "src/gates/XorGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var XorGates = {};
  var XOR_SHADER = ketShaderPermute(ketInputGateShaderCode('A'), ("\n        float srcMask = mod(read_input_A(), span);\n        float bitPos = 1.0;\n        float result = 0.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float srcBit = mod(floor(srcMask/bitPos), 2.0);\n            float dstBit = mod(floor(out_id/bitPos), 2.0);\n            result += (dstBit + srcBit - dstBit * srcBit * 2.0) * bitPos;\n            bitPos *= 2.0;\n        }\n        return result;"));
  XorGates.XorAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("^=A" + span).setSymbol("⊕A").setTitle("Xor Gate [input A]").setBlurb("Xors input A into the qubits covered by this gate.").setRequiredContextKeys("Input Range A").setKnownEffectToParametrizedPermutation(function(t, a) {
      return t ^ (a & ((1 << span) - 1));
    }).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = XOR_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    });
  });
  XorGates.all = $traceurRuntime.spread(XorGates.XorAFamily.all);
  return {get XorGates() {
      return XorGates;
    }};
});
//# sourceURL=src/gates/XorGates.js
;$traceurRuntime.registerModule("src/issues.js", [], function() {
  "use strict";
  var __moduleName = "src/issues.js";
  var notifyAboutKnownIssue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./fallback.js", "src/issues.js")).notifyAboutKnownIssue;
  var canvasCreatedForTesting = document.createElement('canvas');
  var webglContextCreatedForTesting = canvasCreatedForTesting.getContext('webgl') || canvasCreatedForTesting.getContext('experimental-webgl');
  function detectWebGlNotSupported() {
    return webglContextCreatedForTesting === null || webglContextCreatedForTesting === undefined;
  }
  function doDetectIssues() {
    if (detectWebGlNotSupported()) {
      notifyAboutKnownIssue("Can't simulate circuits. Your browser doesn't support WebGL, or has it disabled.", "https://github.com/Strilanc/Quirk/issues/168", [/Computing circuit values failed/, /Error creating WebGL context./]);
    }
  }
  return {
    get doDetectIssues() {
      return doDetectIssues;
    },
    get canvasCreatedForTesting() {
      return canvasCreatedForTesting;
    },
    get webglContextCreatedForTesting() {
      return webglContextCreatedForTesting;
    }
  };
});
//# sourceURL=src/issues.js
;$traceurRuntime.registerModule("src/main.js", [], function() {
  "use strict";
  var __moduleName = "src/main.js";
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./browser/Polyfills.js", "src/main.js"));
  var hookErrorHandler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./fallback.js", "src/main.js")).hookErrorHandler;
  hookErrorHandler();
  var doDetectIssues = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./issues.js", "src/main.js")).doDetectIssues;
  doDetectIssues();
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./circuit/CircuitStats.js", "src/main.js")).CircuitStats;
  var CooldownThrottle = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./base/CooldownThrottle.js", "src/main.js")).CooldownThrottle;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Config.js", "src/main.js")).Config;
  var DisplayedInspector = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/DisplayedInspector.js", "src/main.js")).DisplayedInspector;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./draw/Painter.js", "src/main.js")).Painter;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./math/Rect.js", "src/main.js")).Rect;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./base/RestartableRng.js", "src/main.js")).RestartableRng;
  var Revision = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./base/Revision.js", "src/main.js")).Revision;
  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./circuit/Serializer.js", "src/main.js")),
      initSerializer = $__11.initSerializer,
      fromJsonText_CircuitDefinition = $__11.fromJsonText_CircuitDefinition;
  var TouchScrollBlocker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./browser/TouchScrollBlocker.js", "src/main.js")).TouchScrollBlocker;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./base/Util.js", "src/main.js")).Util;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./webgl/WglContext.js", "src/main.js")).initializedWglContext;
  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./browser/MouseWatcher.js", "src/main.js")),
      watchDrags = $__15.watchDrags,
      isMiddleClicking = $__15.isMiddleClicking,
      eventPosRelativeTo = $__15.eventPosRelativeTo;
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./base/Obs.js", "src/main.js")),
      ObservableValue = $__16.ObservableValue,
      ObservableSource = $__16.ObservableSource;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/exports.js", "src/main.js")),
      initExports = $__17.initExports,
      obsExportsIsShowing = $__17.obsExportsIsShowing;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/forge.js", "src/main.js")),
      initForge = $__18.initForge,
      obsForgeIsShowing = $__18.obsForgeIsShowing;
  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/menu.js", "src/main.js")),
      initMenu = $__19.initMenu,
      obsMenuIsShowing = $__19.obsMenuIsShowing,
      closeMenu = $__19.closeMenu;
  var initUndoRedo = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/undo.js", "src/main.js")).initUndoRedo;
  var initClear = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/clear.js", "src/main.js")).initClear;
  var initUrlCircuitSync = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/url.js", "src/main.js")).initUrlCircuitSync;
  var initTitleSync = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/title.js", "src/main.js")).initTitleSync;
  var simulate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/sim.js", "src/main.js")).simulate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./draw/GatePainting.js", "src/main.js")).GatePainting;
  var GATE_CIRCUIT_DRAWER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ui/DisplayedCircuit.js", "src/main.js")).GATE_CIRCUIT_DRAWER;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./circuit/GateColumn.js", "src/main.js")).GateColumn;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./math/Point.js", "src/main.js")).Point;
  initSerializer(GatePainting.LABEL_DRAWER, GatePainting.MATRIX_DRAWER, GATE_CIRCUIT_DRAWER, GatePainting.LOCATION_INDEPENDENT_GATE_DRAWER);
  var canvasDiv = document.getElementById("canvasDiv");
  var canvas = document.getElementById("drawCanvas");
  if (!canvas) {
    throw new Error("Couldn't find 'drawCanvas'");
  }
  canvas.width = canvasDiv.clientWidth;
  canvas.height = window.innerHeight * 0.9;
  var haveLoaded = false;
  var semiStableRng = (function() {
    var target = {cur: new RestartableRng()};
    var cycleRng;
    cycleRng = function() {
      target.cur = new RestartableRng();
      setTimeout(cycleRng, Config.SEMI_STABLE_RANDOM_VALUE_LIFETIME_MILLIS * 0.99);
    };
    cycleRng();
    return target;
  })();
  var inspectorDiv = document.getElementById("inspectorDiv");
  var displayed = new ObservableValue(DisplayedInspector.empty(new Rect(0, 0, canvas.clientWidth, canvas.clientHeight)));
  var mostRecentStats = new ObservableValue(CircuitStats.EMPTY);
  var revision = Revision.startingAt(displayed.get().snapshot());
  revision.latestActiveCommit().subscribe(function(jsonText) {
    var circuitDef = fromJsonText_CircuitDefinition(jsonText);
    var newInspector = displayed.get().withCircuitDefinition(circuitDef);
    displayed.set(newInspector);
  });
  var desiredCanvasSizeFor = function(curInspector) {
    return {
      w: Math.max(canvasDiv.clientWidth, curInspector.desiredWidth()),
      h: curInspector.desiredHeight()
    };
  };
  var syncArea = function(ins) {
    var size = desiredCanvasSizeFor(ins);
    ins.updateArea(new Rect(0, 0, size.w, size.h));
    return ins;
  };
  displayed.observable().map(function(e) {
    return e.displayedCircuit.circuitDefinition;
  }).whenDifferent(Util.CUSTOM_IS_EQUAL_TO_EQUALITY).subscribe(function() {
    var errDivStyle = document.getElementById('error-div').style;
    errDivStyle.opacity *= 0.9;
    if (errDivStyle.opacity < 0.06) {
      errDivStyle.display = 'None';
    }
  });
  var redrawThrottle;
  var scrollBlocker = new TouchScrollBlocker(canvasDiv);
  var redrawNow = function() {
    if (!haveLoaded) {
      return;
    }
    var shown = syncArea(displayed.get()).previewDrop();
    if (displayed.get().hand.isHoldingSomething() && !shown.hand.isHoldingSomething()) {
      shown = shown.withHand(shown.hand.withHeldGateColumn(new GateColumn([]), new Point(0, 0)));
    }
    var stats = simulate(shown.displayedCircuit.circuitDefinition);
    mostRecentStats.set(stats);
    var size = desiredCanvasSizeFor(shown);
    canvas.width = size.w;
    canvas.height = size.h;
    var painter = new Painter(canvas, semiStableRng.cur.restarted());
    shown.updateArea(painter.paintableArea());
    shown.paint(painter, stats);
    painter.paintDeferred();
    displayed.get().hand.paintCursor(painter);
    scrollBlocker.setBlockers(painter.touchBlockers, painter.desiredCursorStyle);
    canvas.style.cursor = painter.desiredCursorStyle || 'auto';
    var dt = displayed.get().stableDuration();
    if (dt < Infinity) {
      window.requestAnimationFrame(function() {
        return redrawThrottle.trigger();
      });
    }
  };
  redrawThrottle = new CooldownThrottle(redrawNow, Config.REDRAW_COOLDOWN_MILLIS, 0.1, true);
  window.addEventListener('resize', function() {
    return redrawThrottle.trigger();
  }, false);
  displayed.observable().subscribe(function() {
    return redrawThrottle.trigger();
  });
  var clickDownGateButtonKey = undefined;
  canvasDiv.addEventListener('click', function(ev) {
    var pt = eventPosRelativeTo(ev, canvasDiv);
    var curInspector = displayed.get();
    if (curInspector.tryGetHandOverButtonKey() !== clickDownGateButtonKey) {
      return;
    }
    var clicked = syncArea(curInspector.withHand(curInspector.hand.withPos(pt))).tryClick();
    if (clicked !== undefined) {
      revision.commit(clicked.afterTidyingUp().snapshot());
    }
  });
  watchDrags(canvasDiv, function(pt, ev) {
    var oldInspector = displayed.get();
    var newHand = oldInspector.hand.withPos(pt);
    var newInspector = syncArea(oldInspector.withHand(newHand));
    clickDownGateButtonKey = (ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey ? undefined : newInspector.tryGetHandOverButtonKey());
    if (clickDownGateButtonKey !== undefined) {
      displayed.set(newInspector);
      return;
    }
    newInspector = newInspector.afterGrabbing(ev.shiftKey, ev.ctrlKey || ev.metaKey);
    if (displayed.get().isEqualTo(newInspector) || !newInspector.hand.isBusy()) {
      return;
    }
    revision.startedWorkingOnCommit();
    displayed.set(syncArea(oldInspector.withHand(newHand).withJustEnoughWires(newInspector.hand, 1)).afterGrabbing(ev.shiftKey, ev.ctrlKey || ev.metaKey, false, ev.altKey));
    ev.preventDefault();
  }, function(ev) {
    revision.cancelCommitBeingWorkedOn();
    ev.preventDefault();
  }, function(pt, ev) {
    if (!displayed.get().hand.isBusy()) {
      return;
    }
    var newHand = displayed.get().hand.withPos(pt);
    var newInspector = displayed.get().withHand(newHand);
    displayed.set(newInspector);
    ev.preventDefault();
  }, function(pt, ev) {
    if (!displayed.get().hand.isBusy()) {
      return;
    }
    var newHand = displayed.get().hand.withPos(pt);
    var newInspector = syncArea(displayed.get()).withHand(newHand).afterDropping().afterTidyingUp();
    var clearHand = newInspector.hand.withPos(undefined);
    var clearInspector = newInspector.withJustEnoughWires(clearHand, 0);
    revision.commit(clearInspector.snapshot());
    ev.preventDefault();
  });
  canvasDiv.addEventListener('mousedown', function(ev) {
    if (!isMiddleClicking(ev)) {
      return;
    }
    var cur = syncArea(displayed.get());
    var initOver = cur.tryGetHandOverButtonKey();
    var newHand = cur.hand.withPos(eventPosRelativeTo(ev, canvas));
    var newInspector;
    if (initOver !== undefined && initOver.startsWith('wire-init-')) {
      var newCircuit = cur.displayedCircuit.circuitDefinition.withSwitchedInitialStateOn(parseInt(initOver.substr(10)), 0);
      newInspector = cur.withCircuitDefinition(newCircuit).withHand(newHand).afterTidyingUp();
    } else {
      newInspector = cur.withHand(newHand).afterGrabbing(false, false, true, false).withHand(newHand).afterTidyingUp().withJustEnoughWires(newHand, 0);
    }
    if (!displayed.get().isEqualTo(newInspector)) {
      revision.commit(newInspector.snapshot());
      ev.preventDefault();
    }
  });
  canvasDiv.addEventListener('mousemove', function(ev) {
    if (!displayed.get().hand.isBusy()) {
      var newHand = displayed.get().hand.withPos(eventPosRelativeTo(ev, canvas));
      var newInspector = displayed.get().withHand(newHand);
      displayed.set(newInspector);
    }
  });
  canvasDiv.addEventListener('mouseleave', function() {
    if (!displayed.get().hand.isBusy()) {
      var newHand = displayed.get().hand.withPos(undefined);
      var newInspector = displayed.get().withHand(newHand);
      displayed.set(newInspector);
    }
  });
  var obsIsAnyOverlayShowing = new ObservableSource();
  initUrlCircuitSync(revision);
  initExports(revision, mostRecentStats, obsIsAnyOverlayShowing.observable());
  initForge(revision, obsIsAnyOverlayShowing.observable());
  initUndoRedo(revision, obsIsAnyOverlayShowing.observable());
  initClear(revision, obsIsAnyOverlayShowing.observable());
  initMenu(revision, obsIsAnyOverlayShowing.observable());
  initTitleSync(revision);
  obsForgeIsShowing.zipLatest(obsExportsIsShowing, function(e1, e2) {
    return e1 || e2;
  }).zipLatest(obsMenuIsShowing, function(e1, e2) {
    return e1 || e2;
  }).whenDifferent().subscribe(function(e) {
    obsIsAnyOverlayShowing.send(e);
    canvasDiv.tabIndex = e ? -1 : 0;
  });
  haveLoaded = true;
  setTimeout(function() {
    inspectorDiv.style.display = 'block';
    redrawNow();
    document.getElementById("loading-div").style.display = 'none';
    document.getElementById("close-menu-button").style.display = 'block';
    if (!displayed.get().displayedCircuit.circuitDefinition.isEmpty()) {
      closeMenu();
    }
    try {
      initializedWglContext().onContextRestored = function() {
        return redrawThrottle.trigger();
      };
    } catch (ex) {
      console.error(ex);
    }
  }, 0);
  return {};
});
//# sourceURL=src/main.js
;$traceurRuntime.registerModule("src/math/Axis.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Axis.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/math/Axis.js")).DetailedError;
  var UNICODE_FRACTIONS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/math/Axis.js")).UNICODE_FRACTIONS;
  var parseFormula = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FormulaParser.js", "src/math/Axis.js")).parseFormula;
  var PARSE_AXIS_TOKEN_MAP = new Map();
  var Axis = function() {
    function Axis(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    return ($traceurRuntime.createClass)(Axis, {
      toString: function() {
        return (this.x + "X + " + this.y + "Y + " + this.z + "Z");
      },
      isEqualTo: function(other) {
        return other instanceof Axis && other.x === this.x && other.y === this.y && other.z === this.z;
      }
    }, {
      parse: function(text) {
        var result = parseFormula(text, PARSE_AXIS_TOKEN_MAP);
        if (!(result instanceof Axis)) {
          throw new DetailedError("Not an axis.", {
            text: text,
            result: result
          });
        }
        return result;
      },
      classify: function(v) {
        if (typeof v === "number") {
          return false;
        }
        if (v instanceof Axis) {
          return true;
        }
        throw new DetailedError("Not an axis or a number", {v: v});
      },
      op: function(a, b, numNum, axisNum, numAxis, axisAxis) {
        var ca = Axis.classify(a);
        var cb = Axis.classify(b);
        if (ca && cb) {
          return axisAxis(a, b);
        }
        if (!ca && !cb) {
          return numNum(a, b);
        }
        if (ca) {
          return axisNum(a, b);
        }
        return numAxis(a, b);
      },
      times: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a * b;
        }, function(a, b) {
          return new Axis(a.x * b, a.y * b, a.z * b);
        }, function(a, b) {
          return new Axis(b.x * a, b.y * a, b.z * a);
        }, function(a, b) {
          throw new DetailedError("Can't multiply axes.", {
            a: a,
            b: b
          });
        });
      },
      add: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a + b;
        }, function(a, b) {
          throw new DetailedError("Can't add axes to numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't add axes to numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          return new Axis(a.x + b.x, a.y + b.y, a.z + b.z);
        });
      },
      negate: function(u) {
        return Axis.classify(u) ? new Axis(-u.x, -u.y, -u.z) : -u;
      },
      subtract: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a - b;
        }, function(a, b) {
          throw new DetailedError("Can't subtract axes and numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't subtract axes and numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          return new Axis(a.x - b.x, a.y - b.y, a.z - b.z);
        });
      },
      divide: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a / b;
        }, function(a, b) {
          return new Axis(a.x / b, a.y / b, a.z / b);
        }, function(a, b) {
          throw new DetailedError("Can't divide by an axis.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't divide by an axis.", {
            a: a,
            b: b
          });
        });
      },
      raisedTo: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return Math.pow(a, b);
        }, function(a, b) {
          throw new DetailedError("Can't raise an axis to a power.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't raise to an axis power.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't raise to an axis power.", {
            a: a,
            b: b
          });
        });
      }
    });
  }();
  PARSE_AXIS_TOKEN_MAP.set("x", new Axis(1, 0, 0));
  PARSE_AXIS_TOKEN_MAP.set("y", new Axis(0, 1, 0));
  PARSE_AXIS_TOKEN_MAP.set("z", new Axis(0, 0, 1));
  PARSE_AXIS_TOKEN_MAP.set("(", "(");
  PARSE_AXIS_TOKEN_MAP.set(")", ")");
  var $__5 = true;
  var $__6 = false;
  var $__7 = undefined;
  try {
    for (var $__3 = void 0,
        $__2 = (UNICODE_FRACTIONS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
      var $__9 = $__3.value,
          character = $__9.character,
          value = $__9.value;
      {
        PARSE_AXIS_TOKEN_MAP.set(character, value);
      }
    }
  } catch ($__8) {
    $__6 = true;
    $__7 = $__8;
  } finally {
    try {
      if (!$__5 && $__2.return != null) {
        $__2.return();
      }
    } finally {
      if ($__6) {
        throw $__7;
      }
    }
  }
  PARSE_AXIS_TOKEN_MAP.set("sqrt", {
    unary_action: function(e) {
      return Axis.raisedTo(e, 0.5);
    },
    priority: 4
  });
  PARSE_AXIS_TOKEN_MAP.set("^", {
    binary_action: Axis.raisedTo,
    priority: 3
  });
  PARSE_AXIS_TOKEN_MAP.set("*", {
    binary_action: Axis.times,
    priority: 2
  });
  PARSE_AXIS_TOKEN_MAP.set("/", {
    binary_action: Axis.divide,
    priority: 2
  });
  PARSE_AXIS_TOKEN_MAP.set("-", {
    unary_action: Axis.negate,
    binary_action: Axis.subtract,
    priority: 1
  });
  PARSE_AXIS_TOKEN_MAP.set("+", {
    unary_action: function(e) {
      return e;
    },
    binary_action: Axis.add,
    priority: 1
  });
  PARSE_AXIS_TOKEN_MAP.set("√", PARSE_AXIS_TOKEN_MAP.get("sqrt"));
  return {get Axis() {
      return Axis;
    }};
});
//# sourceURL=src/math/Axis.js
;$traceurRuntime.registerModule("src/math/Complex.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Complex.js";
  var $__18,
      $__19;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/math/Complex.js")).DetailedError;
  var $__21 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/math/Complex.js")),
      Format = $__21.Format,
      UNICODE_FRACTIONS = $__21.UNICODE_FRACTIONS;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/math/Complex.js")).Util;
  var parseFormula = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FormulaParser.js", "src/math/Complex.js")).parseFormula;
  var PARSE_COMPLEX_TOKEN_MAP_ALL = new Map();
  var PARSE_COMPLEX_TOKEN_MAP_RAD = new Map();
  var PARSE_COMPLEX_TOKEN_MAP_DEG = new Map();
  var Complex = function() {
    function Complex(real, imag) {
      this.real = real;
      this.imag = imag;
    }
    return ($traceurRuntime.createClass)(Complex, {
      isEqualTo: function(other) {
        if (other instanceof Complex) {
          return this.real === other.real && this.imag === other.imag;
        }
        if (typeof other === "number") {
          return this.real === other && this.imag === 0;
        }
        return false;
      },
      isApproximatelyEqualTo: function(other, epsilon) {
        if (other instanceof Complex || typeof other === "number") {
          var d = this.minus(Complex.from(other));
          return Math.abs(d.real) <= epsilon && Math.abs(d.imag) <= epsilon && d.abs() <= epsilon;
        }
        return false;
      },
      toString: function(format) {
        format = format || Format.EXACT;
        return format.allowAbbreviation ? this._toString_allowSingleValue(format) : this._toString_bothValues(format);
      },
      _toString_allowSingleValue: function(format) {
        if (Math.abs(this.imag) <= format.maxAbbreviationError) {
          return format.formatFloat(this.real);
        }
        if (Math.abs(this.real) <= format.maxAbbreviationError) {
          if (Math.abs(this.imag - 1) <= format.maxAbbreviationError) {
            return "i";
          }
          if (Math.abs(this.imag + 1) <= format.maxAbbreviationError) {
            return "-i";
          }
          return format.formatFloat(this.imag) + "i";
        }
        return this._toString_bothValues(format);
      },
      _toString_bothValues: function(format) {
        var separator = this.imag >= 0 ? "+" : "-";
        var imagFactor = format.allowAbbreviation && Math.abs(Math.abs(this.imag) - 1) <= format.maxAbbreviationError ? "" : format.formatFloat(Math.abs(this.imag));
        var prefix = format.allowAbbreviation || format.fixedDigits === undefined || this.real < 0 ? "" : "+";
        return prefix + format.formatFloat(this.real) + separator + imagFactor + "i";
      },
      norm2: function() {
        return this.real * this.real + this.imag * this.imag;
      },
      abs: function() {
        return Math.sqrt(this.norm2());
      },
      conjugate: function() {
        return new Complex(this.real, -this.imag);
      },
      neg: function() {
        return new Complex(-this.real, -this.imag);
      },
      phase: function() {
        return Math.atan2(this.imag, this.real);
      },
      unit: function() {
        var m = this.norm2();
        if (m < 0.00001) {
          return Complex.polar(1, this.phase());
        }
        return this.dividedBy(Math.sqrt(m));
      },
      plus: function(v) {
        var c = Complex.from(v);
        return new Complex(this.real + c.real, this.imag + c.imag);
      },
      minus: function(v) {
        var c = Complex.from(v);
        return new Complex(this.real - c.real, this.imag - c.imag);
      },
      times: function(v) {
        var c = Complex.from(v);
        return new Complex(this.real * c.real - this.imag * c.imag, this.real * c.imag + this.imag * c.real);
      },
      dividedBy: function(v) {
        var c = Complex.from(v);
        var d = c.norm2();
        if (d === 0) {
          throw new Error("Division by Zero");
        }
        var n = this.times(c.conjugate());
        return new Complex(n.real / d, n.imag / d);
      },
      sqrts: function() {
        var $__17,
            $__18;
        var $__16 = [this.real, this.imag],
            r = ($__17 = $__16[Symbol.iterator](), ($__18 = $__17.next()).done ? void 0 : $__18.value),
            i = ($__18 = $__17.next()).done ? void 0 : $__18.value;
        var m = Math.sqrt(Math.sqrt(r * r + i * i));
        if (m === 0) {
          return [Complex.ZERO];
        }
        if (i === 0 && r < 0) {
          return [new Complex(0, m), new Complex(0, -m)];
        }
        var a = this.phase() / 2;
        var c = Complex.polar(m, a);
        return [c, c.times(-1)];
      },
      exp: function() {
        return Complex.polar(Math.exp(this.real), this.imag);
      },
      cos: function() {
        var z = this.times(Complex.I);
        return z.exp().plus(z.neg().exp()).times(0.5);
      },
      sin: function() {
        var z = this.times(Complex.I);
        return z.exp().minus(z.neg().exp()).dividedBy(new Complex(0, 2));
      },
      tan: function() {
        return this.sin().dividedBy(this.cos());
      },
      ln: function() {
        return new Complex(Math.log(this.abs()), this.phase());
      },
      raisedTo: function(exponent) {
        if (exponent === 0.5 && this.imag === 0 && this.real >= 0) {
          return new Complex(Math.sqrt(this.real), 0);
        }
        if (Complex.ZERO.isEqualTo(exponent)) {
          return Complex.ONE;
        }
        if (this.isEqualTo(Complex.ZERO)) {
          return Complex.ZERO;
        }
        return this.ln().times(Complex.from(exponent)).exp();
      }
    }, {
      from: function(v) {
        if (v instanceof Complex) {
          return v;
        }
        if (typeof v === "number") {
          return new Complex(v, 0);
        }
        throw new DetailedError("Unrecognized value type.", {v: v});
      },
      polar: function(magnitude, phase) {
        var $__17,
            $__18;
        var $__16 = Util.snappedCosSin(phase),
            cos = ($__17 = $__16[Symbol.iterator](), ($__18 = $__17.next()).done ? void 0 : $__18.value),
            sin = ($__18 = $__17.next()).done ? void 0 : $__18.value;
        return new Complex(magnitude * cos, magnitude * sin);
      },
      realPartOf: function(v) {
        if (v instanceof Complex) {
          return v.real;
        }
        if (typeof v === "number") {
          return v;
        }
        throw new DetailedError("Unrecognized value type.", {v: v});
      },
      imagPartOf: function(v) {
        if (v instanceof Complex) {
          return v.imag;
        }
        if (typeof v === "number") {
          return 0;
        }
        throw new DetailedError("Unrecognized value type.", {v: v});
      },
      parse: function(text) {
        return Complex.from(parseFormula(text, PARSE_COMPLEX_TOKEN_MAP_DEG));
      },
      rootsOfQuadratic: function(a, b, c) {
        a = Complex.from(a);
        b = Complex.from(b);
        c = Complex.from(c);
        if (a.isEqualTo(0)) {
          if (!b.isEqualTo(0)) {
            return [c.times(-1).dividedBy(b)];
          }
          if (!c.isEqualTo(0)) {
            return [];
          }
          throw Error("Degenerate");
        }
        var difs = b.times(b).minus(a.times(c).times(4)).sqrts();
        var mid = b.times(-1);
        var denom = a.times(2);
        return difs.map(function(d) {
          return mid.minus(d).dividedBy(denom);
        });
      }
    });
  }();
  Complex.ZERO = new Complex(0, 0);
  Complex.ONE = new Complex(1, 0);
  Complex.I = new Complex(0, 1);
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("i", Complex.I);
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("e", Complex.from(Math.E));
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("pi", Complex.from(Math.PI));
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("(", "(");
  PARSE_COMPLEX_TOKEN_MAP_ALL.set(")", ")");
  var $__5 = true;
  var $__6 = false;
  var $__7 = undefined;
  try {
    for (var $__3 = void 0,
        $__2 = (UNICODE_FRACTIONS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
      var $__16 = $__3.value,
          character = $__16.character,
          value = $__16.value;
      {
        PARSE_COMPLEX_TOKEN_MAP_ALL.set(character, value);
      }
    }
  } catch ($__8) {
    $__6 = true;
    $__7 = $__8;
  } finally {
    try {
      if (!$__5 && $__2.return != null) {
        $__2.return();
      }
    } finally {
      if ($__6) {
        throw $__7;
      }
    }
  }
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("sqrt", {
    unary_action: function(e) {
      return Complex.from(e).raisedTo(0.5);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("exp", {
    unary_action: function(e) {
      return Complex.from(e).exp();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("ln", {
    unary_action: function(e) {
      return Complex.from(e).ln();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("^", {
    binary_action: function(a, b) {
      return Complex.from(a).raisedTo(b);
    },
    priority: 3
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("*", {
    binary_action: function(a, b) {
      return Complex.from(a).times(b);
    },
    priority: 2
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("/", {
    binary_action: function(a, b) {
      return Complex.from(a).dividedBy(b);
    },
    priority: 2
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("-", {
    unary_action: function(e) {
      return Complex.from(e).neg();
    },
    binary_action: function(a, b) {
      return Complex.from(a).minus(b);
    },
    priority: 1
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("+", {
    unary_action: function(e) {
      return e;
    },
    binary_action: function(a, b) {
      return Complex.from(a).plus(b);
    },
    priority: 1
  });
  PARSE_COMPLEX_TOKEN_MAP_ALL.set("√", PARSE_COMPLEX_TOKEN_MAP_ALL.get("sqrt"));
  PARSE_COMPLEX_TOKEN_MAP_DEG.set("cos", {
    unary_action: function(e) {
      return new Complex(Math.PI / 180, 0).times(e).cos();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_DEG.set("sin", {
    unary_action: function(e) {
      return new Complex(Math.PI / 180, 0).times(e).sin();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_DEG.set("asin", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("asin input out of range", {e: e});
      }
      return Complex.from(Math.asin(Complex.realPartOf(e)) * 180 / Math.PI);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_DEG.set("acos", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("acos input out of range", {e: e});
      }
      return Complex.from(Math.acos(Complex.realPartOf(e)) * 180 / Math.PI);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_DEG.set("arccos", PARSE_COMPLEX_TOKEN_MAP_DEG.get("acos"));
  PARSE_COMPLEX_TOKEN_MAP_DEG.set("arcsin", PARSE_COMPLEX_TOKEN_MAP_DEG.get("asin"));
  PARSE_COMPLEX_TOKEN_MAP_RAD.set("cos", {
    unary_action: function(e) {
      return Complex.from(e).cos();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_RAD.set("sin", {
    unary_action: function(e) {
      return Complex.from(e).sin();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_RAD.set("tan", {
    unary_action: function(e) {
      return Complex.from(e).tan();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_RAD.set("asin", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("asin input out of range", {e: e});
      }
      return Complex.from(Math.asin(Complex.realPartOf(e)));
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_RAD.set("acos", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("acos input out of range", {e: e});
      }
      return Complex.from(Math.acos(Complex.realPartOf(e)));
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP_RAD.set("atan", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("atan input out of range", {e: e});
      }
      return Complex.from(Math.atan(Complex.realPartOf(e)));
    },
    priority: 4
  });
  var $__12 = true;
  var $__13 = false;
  var $__14 = undefined;
  try {
    for (var $__10 = void 0,
        $__9 = (PARSE_COMPLEX_TOKEN_MAP_ALL.entries())[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
      var $__17 = $__10.value,
          k = ($__18 = $__17[Symbol.iterator](), ($__19 = $__18.next()).done ? void 0 : $__19.value),
          v = ($__19 = $__18.next()).done ? void 0 : $__19.value;
      {
        PARSE_COMPLEX_TOKEN_MAP_DEG.set(k, v);
        PARSE_COMPLEX_TOKEN_MAP_RAD.set(k, v);
      }
    }
  } catch ($__15) {
    $__13 = true;
    $__14 = $__15;
  } finally {
    try {
      if (!$__12 && $__9.return != null) {
        $__9.return();
      }
    } finally {
      if ($__13) {
        throw $__14;
      }
    }
  }
  return {
    get Complex() {
      return Complex;
    },
    get PARSE_COMPLEX_TOKEN_MAP_DEG() {
      return PARSE_COMPLEX_TOKEN_MAP_DEG;
    },
    get PARSE_COMPLEX_TOKEN_MAP_RAD() {
      return PARSE_COMPLEX_TOKEN_MAP_RAD;
    }
  };
});
//# sourceURL=src/math/Complex.js
;$traceurRuntime.registerModule("src/math/FormulaParser.js", [], function() {
  "use strict";
  var __moduleName = "src/math/FormulaParser.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/math/FormulaParser.js")).DetailedError;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/math/FormulaParser.js")).seq;
  function _mergeScientificFloatTokens(tokens) {
    tokens = $traceurRuntime.spread(tokens);
    for (var i = tokens.indexOf('e', 1); i !== -1; i = tokens.indexOf('e', i + 1)) {
      var s = i - 1;
      var e = i + 1;
      if (!tokens[s].match(/[0-9]/)) {
        continue;
      }
      if ((tokens[e] + '').match(/[+-]/)) {
        e += 1;
      }
      if ((tokens[e] + '').match(/[0-9]/)) {
        e += 1;
        tokens.splice(s, e - s, tokens.slice(s, e).join(''));
        i -= 1;
      }
    }
    return tokens;
  }
  function _tokenize(text) {
    var tokens = seq(text.toLowerCase().split(/\s/)).flatMap(function(part) {
      return seq(part).segmentBy(function(e) {
        if (e.trim() === '') {
          return " ";
        }
        if (e.match(/[\.0-9]/)) {
          return "#";
        }
        if (e.match(/[_a-z]/)) {
          return "a";
        }
        return NaN;
      }).map(function(e) {
        return e.join('');
      });
    }).filter(function(e) {
      return e.trim() !== '';
    }).toArray();
    return _mergeScientificFloatTokens(tokens);
  }
  function _translate_token(token, tokenMap) {
    if (token.match(/[0-9]+(\.[0-9]+)?/)) {
      return parseFloat(token);
    }
    if (tokenMap.has(token)) {
      return tokenMap.get(token);
    }
    throw new DetailedError("Unrecognized token", {token: token});
  }
  function parseFormula(text, tokenMap) {
    var tokens = _tokenize(text).map(function(e) {
      return _translate_token(e, tokenMap);
    });
    if (tokens.length > 0 && tokens[tokens.length - 1].priority !== undefined) {
      tokens = tokens.slice(0, tokens.length - 1);
    }
    var ops = [];
    var vals = [];
    var isValidEndToken = function(token) {
      return token !== "(" && token.priority === undefined;
    };
    var isValidEndState = function() {
      return vals.length === 1 && ops.length === 0;
    };
    var apply = function(op) {
      if (op === "(") {
        throw new DetailedError("Bad expression: unmatched '('", {text: text});
      }
      if (vals.length < 2) {
        throw new DetailedError("Bad expression: operated on nothing", {text: text});
      }
      var b = vals.pop();
      var a = vals.pop();
      vals.push(op.f(a, b));
    };
    var closeParen = function() {
      while (true) {
        if (ops.length === 0) {
          throw new DetailedError("Bad expression: unmatched ')'", {text: text});
        }
        var op = ops.pop();
        if (op === "(") {
          break;
        }
        apply(op);
      }
    };
    var burnOps = function(w) {
      while (ops.length > 0 && vals.length >= 2 && vals[vals.length - 1] !== undefined) {
        var top = ops[ops.length - 1];
        if (top.w === undefined || top.w < w) {
          break;
        }
        apply(ops.pop());
      }
    };
    var feedOp = function(couldBeBinary, token) {
      var mul = tokenMap.get("*");
      if (couldBeBinary && token.binary_action === undefined && token !== ")") {
        burnOps(mul.priority);
        ops.push({
          f: mul.binary_action,
          w: mul.priority
        });
      }
      if (couldBeBinary && token.binary_action !== undefined) {
        burnOps(token.priority);
        ops.push({
          f: token.binary_action,
          w: token.priority
        });
      } else if (token.unary_action !== undefined) {
        burnOps(token.priority);
        vals.push(undefined);
        ops.push({
          f: function(a, b) {
            return token.unary_action(b);
          },
          w: Infinity
        });
      } else if (token.binary_action !== undefined) {
        throw new DetailedError("Bad expression: binary op in bad spot", {text: text});
      }
    };
    var wasValidEndToken = false;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (tokens)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var token = $__2.value;
        {
          feedOp(wasValidEndToken, token);
          wasValidEndToken = isValidEndToken(token);
          if (token === "(") {
            ops.push("(");
          } else if (token === ")") {
            closeParen();
          } else if (wasValidEndToken) {
            vals.push(token);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    burnOps(-Infinity);
    if (!isValidEndState()) {
      throw new DetailedError("Incomplete expression", {text: text});
    }
    return vals[0];
  }
  return {get parseFormula() {
      return parseFormula;
    }};
});
//# sourceURL=src/math/FormulaParser.js
;$traceurRuntime.registerModule("src/math/Matrix.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Matrix.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Complex.js", "src/math/Matrix.js")).Complex;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/math/Matrix.js")).DetailedError;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/math/Matrix.js")).Format;
  var $__35 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/math/Matrix.js")),
      seq = $__35.seq,
      Seq = $__35.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/math/Matrix.js")).Util;
  var Matrix = function() {
    function Matrix(width, height, buffer) {
      if (width * height * 2 !== buffer.length) {
        throw new DetailedError("width*height*2 !== buffer.length", {
          width: width,
          height: height,
          len: buffer.length
        });
      }
      this._width = width;
      this._height = height;
      this._buffer = buffer;
    }
    return ($traceurRuntime.createClass)(Matrix, {
      cell: function(col, row) {
        if (col < 0 || row < 0 || col >= this._width || row >= this._height) {
          throw new DetailedError("Cell out of range", {
            col: col,
            row: row,
            width: this._width,
            height: this._height
          });
        }
        var i = (this._width * row + col) * 2;
        return new Complex(this._buffer[i], this._buffer[i + 1]);
      },
      rawBuffer: function() {
        return this._buffer;
      },
      toReadableJson: function() {
        return seq(this.rows()).map(complexVectorToReadableJson).toArray();
      },
      rows: function() {
        var $__2 = this;
        return Seq.range(this._height).map(function(row) {
          return Seq.range($__2._width).map(function(col) {
            return $__2.cell(col, row);
          }).toArray();
        }).toArray();
      },
      isEqualTo: function(obj) {
        var $__2 = this;
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof Matrix)) {
          return false;
        }
        var other = obj;
        return this._width === other._width && this._height === other._height && Seq.range(this._buffer.length).every(function(i) {
          return $__2._buffer[i] === other._buffer[i];
        });
      },
      isApproximatelyEqualTo: function(other, epsilon) {
        return other instanceof Matrix && this._width === other._width && this._height === other._height && Math.sqrt(this.minus(other).norm2()) <= epsilon;
      },
      toString: function() {
        var format = arguments[0] !== (void 0) ? arguments[0] : Format.EXACT;
        var data = this.rows().map(function(row) {
          return row.map(function(e) {
            return e.toString(format);
          }).join(format.itemSeparator);
        }).join("}" + format.itemSeparator + "{");
        return "{{" + data + "}}";
      },
      width: function() {
        return this._width;
      },
      height: function() {
        return this._height;
      },
      isUnitary: function(epsilon) {
        var n = this.width();
        if (this.height() !== n) {
          return false;
        }
        return this.times(this.adjoint()).isApproximatelyEqualTo(Matrix.identity(n), epsilon);
      },
      isLowerTriangular: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var r = 0; r < this._height; r++) {
          for (var c = r + 1; c < this._width; c++) {
            var k = (r * this._width + c) * 2;
            var v1 = this._buffer[k];
            var v2 = this._buffer[k + 1];
            if (isNaN(v1) || isNaN(v2) || v1 * v1 + v2 * v2 > epsilon * epsilon) {
              return false;
            }
          }
        }
        return true;
      },
      isUpperTriangular: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var r = 0; r < this._height; r++) {
          for (var c = 0; c < r && c < this._width; c++) {
            var k = (r * this._width + c) * 2;
            var v1 = this._buffer[k];
            var v2 = this._buffer[k + 1];
            if (isNaN(v1) || isNaN(v2) || v1 * v1 + v2 * v2 > epsilon * epsilon) {
              return false;
            }
          }
        }
        return true;
      },
      isPhasedPermutation: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        if (this._width !== this._height) {
          return false;
        }
        var n = this._width;
        var colCounts = new Uint32Array(n);
        var rowCounts = new Uint32Array(n);
        for (var col = 0; col < n; col++) {
          for (var row = 0; row < n; row++) {
            var i = (row * n + col) * 2;
            var m = Math.max(Math.abs(this._buffer[i]), Math.abs(this._buffer[i + 1]));
            if (isNaN(m) || m > epsilon) {
              colCounts[col] += 1;
              rowCounts[row] += 1;
            }
          }
        }
        return seq(colCounts).concat(rowCounts).every(function(e) {
          return e <= 1;
        });
      },
      isApproximatelyHermitian: function(epsilon) {
        if (this._width !== this._height) {
          return false;
        }
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            var i = (this._width * r + c) * 2;
            var j = (this._width * c + r) * 2;
            if (Math.abs(this._buffer[i] - this._buffer[j]) > epsilon) {
              return false;
            }
            if (Math.abs(this._buffer[i + 1] + this._buffer[j + 1]) > epsilon) {
              return false;
            }
          }
        }
        return true;
      },
      isIdentity: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        if (this._width !== this._height) {
          return false;
        }
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            var i = (this._width * r + c) * 2;
            var dr = Math.abs(this._buffer[i] - (r === c ? 1 : 0));
            var di = Math.abs(this._buffer[i + 1]);
            if (Math.max(dr, di) > epsilon) {
              return false;
            }
          }
        }
        return !this.hasNaN();
      },
      isScaler: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        if (this._width !== this._height) {
          return false;
        }
        var sr = this._buffer[0];
        var si = this._buffer[1];
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            var i = (this._width * r + c) * 2;
            var dr = Math.abs(this._buffer[i] - (r === c ? sr : 0));
            var di = Math.abs(this._buffer[i + 1] - (r === c ? si : 0));
            if (Math.max(dr, di) > epsilon) {
              return false;
            }
          }
        }
        return !this.hasNaN();
      },
      hasNaN: function() {
        for (var i = 0; i < this._buffer.length; i++) {
          if (isNaN(this._buffer[i])) {
            return true;
          }
        }
        return false;
      },
      isDiagonal: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            if (r === c) {
              continue;
            }
            var k = (this._width * r + c) * 2;
            var dr = Math.abs(this._buffer[k]);
            var di = Math.abs(this._buffer[k + 1]);
            var d = Math.max(dr, di);
            if (isNaN(d) || d > epsilon) {
              return false;
            }
          }
        }
        return this._width === this._height;
      },
      adjoint: function() {
        var w = this._height;
        var h = this._width;
        var newBuf = new Float64Array(w * h * 2);
        for (var r = 0; r < h; r++) {
          for (var c = 0; c < w; c++) {
            var kIn = (c * this._width + r) * 2;
            var kOut = (r * w + c) * 2;
            newBuf[kOut] = this._buffer[kIn];
            newBuf[kOut + 1] = -this._buffer[kIn + 1];
          }
        }
        return new Matrix(w, h, newBuf);
      },
      transpose: function() {
        var w = this._height;
        var h = this._width;
        var newBuf = new Float64Array(w * h * 2);
        for (var r = 0; r < h; r++) {
          for (var c = 0; c < w; c++) {
            var kIn = (c * this._width + r) * 2;
            var kOut = (r * w + c) * 2;
            newBuf[kOut] = this._buffer[kIn];
            newBuf[kOut + 1] = this._buffer[kIn + 1];
          }
        }
        return new Matrix(w, h, newBuf);
      },
      trace: function() {
        var total_r = 0;
        var total_i = 0;
        var d = this._width * 2 + 2;
        for (var i = 0; i < this._buffer.length; i += d) {
          total_r += this._buffer[i];
          total_i += this._buffer[i + 1];
        }
        return new Complex(total_r, total_i);
      },
      _timesScalar: function(v) {
        var newBuffer = new Float64Array(this._buffer.length);
        var sr = Complex.realPartOf(v);
        var si = Complex.imagPartOf(v);
        for (var i = 0; i < newBuffer.length; i += 2) {
          var vr = this._buffer[i];
          var vi = this._buffer[i + 1];
          newBuffer[i] = vr * sr - vi * si;
          newBuffer[i + 1] = vr * si + vi * sr;
        }
        return new Matrix(this._width, this._height, newBuffer);
      },
      plus: function(other) {
        var $__20 = this,
            w = $__20._width,
            h = $__20._height,
            b1 = $__20._buffer;
        var b2 = other._buffer;
        Util.need(other._width === w && other._height === h, "Matrix.plus: compatible sizes");
        var newBuffer = new Float64Array(this._buffer.length);
        for (var i = 0; i < newBuffer.length; i++) {
          newBuffer[i] = b1[i] + b2[i];
        }
        return new Matrix(w, h, newBuffer);
      },
      minus: function(other) {
        var $__20 = this,
            w = $__20._width,
            h = $__20._height,
            b1 = $__20._buffer;
        var b2 = other._buffer;
        Util.need(other._width === w && other._height === h, "Matrix.minus: compatible sizes");
        var newBuffer = new Float64Array(this._buffer.length);
        for (var i = 0; i < newBuffer.length; i++) {
          newBuffer[i] = b1[i] - b2[i];
        }
        return new Matrix(w, h, newBuffer);
      },
      _timesMatrix: function(other) {
        if (this._width !== other._height) {
          throw new DetailedError("Incompatible sizes.", {
            'this': this,
            other: other
          });
        }
        var w = other._width;
        var h = this._height;
        var n = this._width;
        var newBuffer = new Float64Array(w * h * 2);
        for (var r = 0; r < h; r++) {
          for (var c = 0; c < w; c++) {
            var k3 = (r * w + c) * 2;
            for (var k = 0; k < n; k++) {
              var k1 = (r * n + k) * 2;
              var k2 = (k * w + c) * 2;
              var r1 = this._buffer[k1];
              var i1 = this._buffer[k1 + 1];
              var r2 = other._buffer[k2];
              var i2 = other._buffer[k2 + 1];
              var r3 = r1 * r2 - i1 * i2;
              var i3 = r1 * i2 + r2 * i1;
              newBuffer[k3] += r3;
              newBuffer[k3 + 1] += i3;
            }
          }
        }
        return new Matrix(w, h, newBuffer);
      },
      times: function(other) {
        return other instanceof Matrix ? this._timesMatrix(other) : this._timesScalar(other);
      },
      expandedForQubitInRegister: function(targetQubitOffset, registerSize, controls) {
        var used = Math.round(Math.log2(this._width));
        var result = Matrix.identity(1 << (registerSize - targetQubitOffset - used)).tensorProduct(this).tensorProduct(Matrix.identity(1 << targetQubitOffset))._clone();
        for (var c = 0; c < result._width; c++) {
          for (var r = 0; r < result._height; r++) {
            if (!controls.allowsState(c) || !controls.allowsState(r)) {
              var k = 2 * (c + r * result._width);
              result._buffer[k] = c === r ? 1 : 0;
              result._buffer[k + 1] = 0;
            }
          }
        }
        return result;
      },
      applyToStateVectorAtQubitWithControls: function(stateVector, qubitIndex, controls) {
        var chunkSize = this._width * 2;
        var chunkBuf = stateVector._buffer.slice(0, chunkSize);
        var strideLength = 2 << qubitIndex;
        var strideChunkSize = strideLength * chunkSize >> 1;
        var resultBuf = stateVector._buffer.slice();
        for (var strideChunkStart = 0; strideChunkStart < resultBuf.length; strideChunkStart += strideChunkSize) {
          for (var strideOffset = 0; strideOffset < strideLength; strideOffset += 2) {
            if (!controls.allowsState((strideChunkStart | strideOffset) >> 1)) {
              continue;
            }
            var k = strideChunkStart + strideOffset;
            for (var i = 0; i < chunkBuf.length; i += 2) {
              chunkBuf[i] = stateVector._buffer[k];
              chunkBuf[i + 1] = stateVector._buffer[k + 1];
              k += strideLength;
            }
            var transformedChunk = this.times(new Matrix(1, chunkBuf.length >> 1, chunkBuf));
            k = strideChunkStart + strideOffset;
            for (var i$__30 = 0; i$__30 < chunkBuf.length; i$__30 += 2) {
              resultBuf[k] = transformedChunk._buffer[i$__30];
              resultBuf[k + 1] = transformedChunk._buffer[i$__30 + 1];
              k += strideLength;
            }
          }
        }
        return new Matrix(1, stateVector.height(), resultBuf);
      },
      norm2: function() {
        var t = 0;
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this._buffer)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var e = $__4.value;
            {
              t += e * e;
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return t;
      },
      tensorProduct: function(other) {
        var w1 = this._width;
        var h1 = this._height;
        var w2 = other._width;
        var h2 = other._height;
        var w = w1 * w2;
        var h = h1 * h2;
        var newBuffer = new Float64Array(w * h * 2);
        for (var r1 = 0; r1 < h1; r1++) {
          for (var r2 = 0; r2 < h2; r2++) {
            for (var c1 = 0; c1 < w1; c1++) {
              for (var c2 = 0; c2 < w2; c2++) {
                var k1 = (r1 * w1 + c1) * 2;
                var k2 = (r2 * w2 + c2) * 2;
                var k3 = ((r1 * h2 + r2) * w + (c1 * w2 + c2)) * 2;
                var cr1 = this._buffer[k1];
                var ci1 = this._buffer[k1 + 1];
                var cr2 = other._buffer[k2];
                var ci2 = other._buffer[k2 + 1];
                var cr3 = cr1 * cr2 - ci1 * ci2;
                var ci3 = cr1 * ci2 + ci1 * cr2;
                newBuffer[k3] = cr3;
                newBuffer[k3 + 1] = ci3;
              }
            }
          }
        }
        return new Matrix(w, h, newBuffer);
      },
      timesQubitOperation: function(operation2x2, qubitIndex, controlMask, desiredValueMask) {
        var $__22,
            $__23;
        Util.need((controlMask & (1 << qubitIndex)) === 0, "Matrix.timesQubitOperation: self-controlled");
        Util.need(operation2x2._width === 2 && operation2x2._height === 2, "Matrix.timesQubitOperation: not 2x2");
        var $__20 = this,
            w = $__20._width,
            h = $__20._height,
            old = $__20._buffer;
        var $__21 = operation2x2._buffer,
            ar = ($__22 = $__21[Symbol.iterator](), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            ai = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            br = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            bi = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            cr = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            ci = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            dr = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            di = ($__23 = $__22.next()).done ? void 0 : $__23.value;
        Util.need(h >= (2 << qubitIndex), "Matrix.timesQubitOperation: qubit index out of range");
        var buf = new Float64Array(old);
        var i = 0;
        for (var r = 0; r < h; r++) {
          var isControlled = ((controlMask & r) ^ desiredValueMask) !== 0;
          var qubitVal = (r & (1 << qubitIndex)) !== 0;
          for (var c = 0; c < w; c++) {
            if (!isControlled && !qubitVal) {
              var j = i + (1 << qubitIndex) * 2 * w;
              var xr = buf[i];
              var xi = buf[i + 1];
              var yr = buf[j];
              var yi = buf[j + 1];
              buf[i] = xr * ar - xi * ai + yr * br - yi * bi;
              buf[i + 1] = xr * ai + xi * ar + yr * bi + yi * br;
              buf[j] = xr * cr - xi * ci + yr * dr - yi * di;
              buf[j + 1] = xr * ci + xi * cr + yr * di + yi * dr;
            }
            i += 2;
          }
        }
        return new Matrix(w, h, buf);
      },
      tensorPower: function(exponent) {
        if (!Number.isInteger(exponent) || exponent < 0) {
          throw new DetailedError("Bad exponent", {exponent: exponent});
        }
        var t = Matrix.identity(1);
        var p = this;
        for (var m = 1; m <= exponent; m *= 2) {
          if ((m & exponent) !== 0) {
            t = t.tensorProduct(p);
          }
          p = p.tensorProduct(p);
        }
        return t;
      },
      transformRealAndImagComponentsWith: function(func) {
        var buf = this._buffer.slice();
        for (var i = 0; i < buf.length; i++) {
          buf[i] = func(buf[i]);
        }
        return new Matrix(this._width, this._height, buf);
      },
      _inline_rowScale_preMultiply: function(row, scale) {
        for (var col = 0; col < this._width; col++) {
          var v1 = this.cell(col, row);
          var v2 = v1.times(scale);
          var k = (row * this._width + col) * 2;
          this._buffer[k] = v2.real;
          this._buffer[k + 1] = v2.imag;
        }
      },
      _inline_colScale_postMultiply: function(col, scale) {
        for (var row = 0; row < this._height; row++) {
          var v1 = this.cell(col, row);
          var v2 = v1.times(scale);
          var k = (row * this._width + col) * 2;
          this._buffer[k] = v2.real;
          this._buffer[k + 1] = v2.imag;
        }
      },
      _inline_rowMix_preMultiply: function(row1, row2, op) {
        var $__21,
            $__22;
        var $__20 = op._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        for (var col = 0; col < this._width; col++) {
          var x = this.cell(col, row1);
          var y = this.cell(col, row2);
          var v1 = x.times(a).plus(y.times(b));
          var v2 = x.times(c).plus(y.times(d));
          var k1 = (row1 * this._width + col) * 2;
          var k2 = (row2 * this._width + col) * 2;
          this._buffer[k1] = v1.real;
          this._buffer[k1 + 1] = v1.imag;
          this._buffer[k2] = v2.real;
          this._buffer[k2 + 1] = v2.imag;
        }
      },
      _inline_colMix_postMultiply: function(col1, col2, op) {
        var $__21,
            $__22;
        var $__20 = op._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        for (var row = 0; row < this._width; row++) {
          var x = this.cell(col1, row);
          var y = this.cell(col2, row);
          var v1 = x.times(a).plus(y.times(c));
          var v2 = x.times(b).plus(y.times(d));
          var k1 = (row * this._width + col1) * 2;
          var k2 = (row * this._width + col2) * 2;
          this._buffer[k1] = v1.real;
          this._buffer[k1 + 1] = v1.imag;
          this._buffer[k2] = v2.real;
          this._buffer[k2 + 1] = v2.imag;
        }
      },
      _clone: function() {
        return new Matrix(this._width, this._height, this._buffer.slice());
      },
      qrDecomposition: function() {
        if (this._width !== this._height) {
          throw new DetailedError("Expected a square matrix.", this);
        }
        var Q = Matrix.identity(this._width);
        var R = this._clone();
        for (var row = 0; row < this._height; row++) {
          for (var col = 0; col < row && col < this._width; col++) {
            var belowDiag = R.cell(col, row);
            var onDiag = R.cell(col, col);
            var mag1 = onDiag.abs();
            var mag2 = belowDiag.abs();
            if (mag2 === 0) {
              continue;
            }
            var theta = -Math.atan2(mag2, mag1);
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            var phase1 = onDiag.unit().conjugate();
            var phase2 = belowDiag.unit().conjugate();
            var op = Matrix.square(phase1.times(cos), phase2.times(-sin), phase1.times(sin), phase2.times(cos));
            R._inline_rowMix_preMultiply(col, row, op);
            Q._inline_colMix_postMultiply(col, row, op.adjoint());
          }
          var u = R.cell(row, row).unit();
          R._inline_rowScale_preMultiply(row, u.conjugate());
          Q._inline_colScale_postMultiply(row, u);
        }
        return {
          Q: Q,
          R: R
        };
      },
      lqDecomposition: function() {
        var $__20 = this.adjoint().qrDecomposition(),
            Q = $__20.Q,
            R = $__20.R;
        return {
          L: R.adjoint(),
          Q: Q.adjoint()
        };
      },
      eigenvalueMagnitudes: function(epsilon) {
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 1000;
        if (this._width !== this._height) {
          throw new DetailedError("Expected a square matrix.", this);
        }
        var iteration = 0;
        var m = this;
        while (!m.isUpperTriangular(epsilon) && iteration < maxIterations) {
          var $__20 = m.qrDecomposition(),
              Q = $__20.Q,
              R = $__20.R;
          if (R.isIdentity(epsilon)) {
            return Seq.repeat(1, this._width).toArray();
          }
          m = R.times(Q);
          iteration++;
        }
        return Seq.range(this._width).map(function(i) {
          return m.cell(i, i).abs();
        }).sortedBy(function(e) {
          return -e;
        }).toArray();
      },
      eigenDecomposition: function() {
        var $__21,
            $__22;
        if (this.width() !== 2 || this.height() !== 2) {
          throw new Error("Not implemented: non-2x2 eigen decomposition");
        }
        var $__20 = this._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var vals = Complex.rootsOfQuadratic(Complex.ONE, a.plus(d).times(-1), a.times(d).minus(b.times(c)));
        if (vals.length === 0) {
          throw new Error("Degenerate");
        }
        if (vals.length === 1) {
          return [{
            val: vals[0],
            vec: Matrix.col(1, 0)
          }, {
            val: vals[0],
            vec: Matrix.col(0, 1)
          }];
        }
        return vals.map(function(v) {
          var $__24,
              $__25,
              $__26,
              $__27,
              $__28;
          var $__23 = [b.times(-1), a.minus(v)],
              x = ($__24 = $__23[Symbol.iterator](), ($__25 = $__24.next()).done ? void 0 : $__25.value),
              y = ($__25 = $__24.next()).done ? void 0 : $__25.value;
          if (x.isEqualTo(0) && y.isEqualTo(0)) {
            ($__26 = [v.minus(d), c], x = ($__27 = $__26[Symbol.iterator](), ($__28 = $__27.next()).done ? void 0 : $__28.value), y = ($__28 = $__27.next()).done ? void 0 : $__28.value, $__26);
          }
          if (!x.isEqualTo(0)) {
            y = y.dividedBy(x);
            x = Complex.ONE;
          }
          var m = Math.sqrt(x.norm2() + y.norm2());
          if (m === 0) {
            throw new Error("Unexpected degenerate");
          }
          return {
            val: v,
            vec: Matrix.col(x, y).times(1 / m)
          };
        });
      },
      liftApply: function(complexFunction) {
        var t = this.times(0);
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.eigenDecomposition())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__20 = $__4.value,
                val = $__20.val,
                vec = $__20.vec;
            {
              var fVal = complexFunction(val);
              var part = vec.times(vec.adjoint());
              t = t.plus(part.times(fVal));
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return t;
      },
      qubitDensityMatrixToBlochVector: function() {
        var $__21,
            $__22;
        if (this._width !== 2 || this._height !== 2) {
          throw new DetailedError("Need a 2x2 density matrix.", this);
        }
        if (!this.isApproximatelyHermitian(0.01)) {
          throw new DetailedError("Density matrix should be Hermitian.", this);
        }
        if (!this.trace().isApproximatelyEqualTo(1, 0.01)) {
          throw new DetailedError("Density matrix should have unit trace.", this);
        }
        var $__20 = this._buffer,
            ar = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            ai = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            br = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            bi = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            cr = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            ci = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            dr = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            di = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var x = -cr - br;
        var y = bi - ci;
        var z = dr - ar;
        return [x, y, z];
      },
      determinant: function() {
        var $__2 = this;
        Util.need(this.width() === this.height(), "Must be square");
        var n = this.width();
        if (n === 1) {
          return this.cell(0, 0);
        }
        return Seq.range(n).map(function(k) {
          var cutColMatrix = Matrix.generate(n - 1, n - 1, function(r, c) {
            return $__2.cell(c + (c < k ? 0 : 1), r + 1);
          });
          return cutColMatrix.determinant().times($__2.cell(k, 0)).times(Math.pow(-1, k));
        }).aggregate(Complex.ZERO, function(a, e) {
          return a.plus(e);
        });
      },
      _2x2Breakdown: function() {
        return [new Complex(this._buffer[0], this._buffer[1]), new Complex(this._buffer[2], this._buffer[3]), new Complex(this._buffer[4], this._buffer[5]), new Complex(this._buffer[6], this._buffer[7])];
      },
      qubitOperationToAngleAxisRotation: function() {
        var $__21,
            $__22;
        Util.need(this.width() === 2 && this.height() === 2, "Need a 2x2 matrix.");
        Util.need(this.isUnitary(0.01), "Need a unitary matrix.");
        var $__20 = this._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var wφ = a.plus(d);
        var xφ = b.plus(c).dividedBy(Complex.I);
        var yφ = b.minus(c);
        var zφ = a.minus(d).dividedBy(Complex.I);
        var φ = seq([wφ, xφ, yφ, zφ]).maxBy(function(e) {
          return e.abs();
        }).unit().times(2);
        var w = Math.min(1, Math.max(-1, wφ.dividedBy(φ).real));
        var x = xφ.dividedBy(φ).real;
        var y = yφ.dividedBy(φ).real;
        var z = zφ.dividedBy(φ).real;
        var θ = -2 * Math.acos(w);
        var n = Math.sqrt(x * x + y * y + z * z);
        if (n < 0.0000001) {
          return {
            axis: [1, 0, 0],
            angle: 0,
            phase: φ.phase()
          };
        }
        x /= n;
        y /= n;
        z /= n;
        if (θ <= -Math.PI) {
          θ += 2 * Math.PI;
          φ = φ.times(-1);
        }
        if (x + y + z < 0) {
          x = -x;
          y = -y;
          z = -z;
          θ = -θ;
        }
        return {
          axis: [x, y, z],
          angle: θ,
          phase: φ.phase()
        };
      },
      cross3: function(other) {
        var $__2 = this;
        Util.need(this.width() === 1 && this.height() === 3, "This isn't a 3d column vector.");
        Util.need(other.width() === 1 && other.height() === 3, "Other's not a 3d column vector.");
        return Matrix.generate(1, 3, function(r) {
          var $__21,
              $__22;
          var $__20 = [(r + 1) % 3, (r + 2) % 3],
              i = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
              j = ($__22 = $__21.next()).done ? void 0 : $__22.value;
          var a = $__2.cell(0, i).times(other.cell(0, j));
          var b = $__2.cell(0, j).times(other.cell(0, i));
          return a.minus(b);
        });
      },
      _unordered_singularValueDecomposition_2x2: function() {
        var $__22,
            $__23;
        var U = Matrix.identity(2);
        var $__20 = this.lqDecomposition(),
            S = $__20.L,
            V = $__20.Q;
        var au = S.cell(0, 0).unit();
        var cu = S.cell(0, 1).unit();
        U._inline_colScale_postMultiply(0, au);
        U._inline_colScale_postMultiply(1, cu);
        S._inline_rowScale_preMultiply(0, au.conjugate());
        S._inline_rowScale_preMultiply(1, cu.conjugate());
        var du = S.cell(1, 1).unit();
        S._inline_colScale_postMultiply(1, du.conjugate());
        V._inline_rowScale_preMultiply(1, du);
        var $__21 = S._buffer,
            a = ($__22 = $__21[Symbol.iterator](), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            b = ($__22.next(), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            c = ($__22.next(), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            d = ($__22.next(), ($__23 = $__22.next()).done ? void 0 : $__23.value);
        var t = a + d;
        var x = b + c;
        var y = b - c;
        var z = a - d;
        var theta_0 = Math.atan2(x, t) / 2.0;
        var theta_d = Math.atan2(y, z) / 2.0;
        var s_0 = Math.sqrt(t * t + x * x) / 2.0;
        var s_d = Math.sqrt(z * z + y * y) / 2.0;
        U._inline_colMix_postMultiply(0, 1, Matrix.rotation(theta_0 - theta_d));
        V._inline_rowMix_preMultiply(0, 1, Matrix.rotation(theta_0 + theta_d));
        S = Matrix.square(s_0 + s_d, 0, 0, s_0 - s_d);
        return {
          U: U,
          S: S,
          V: V
        };
      },
      _unordered_singularValueDecomposition_iterative: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 100;
        var U = Matrix.identity(this._width);
        var S = this._clone();
        var V = Matrix.identity(this._width);
        var iter = 0;
        while (!S.isDiagonal(epsilon) && iter++ < maxIterations) {
          var $__20 = S.qrDecomposition(),
              Ql = $__20.Q,
              Sl = $__20.R;
          var $__21 = Sl.lqDecomposition(),
              Sr = $__21.L,
              Qr = $__21.Q;
          U = U.times(Ql);
          S = Sr;
          V = Qr.times(V);
        }
        return {
          U: U,
          S: S,
          V: V
        };
      },
      singularValueDecomposition: function() {
        var $__21,
            $__22,
            $__23,
            $__24,
            $__25,
            $__26,
            $__27,
            $__28,
            $__29;
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 100;
        if (this._width !== this._height) {
          throw new DetailedError("Expected a square matrix.", this);
        }
        var $__20 = this._width === 2 ? this._unordered_singularValueDecomposition_2x2() : this._unordered_singularValueDecomposition_iterative(epsilon, maxIterations),
            U = $__20.U,
            S = $__20.S,
            V = $__20.V;
        var permutation = Seq.range(this._width).sortedBy(function(i) {
          return -S.cell(i, i).norm2();
        }).toArray();
        for (var i = 0; i < S._width; i++) {
          var j = permutation.indexOf(i);
          if (i !== j) {
            U._inline_colMix_postMultiply(i, j, Matrix.PAULI_X);
            V._inline_rowMix_preMultiply(i, j, Matrix.PAULI_X);
            var si = i * (S._width + 1) * 2;
            var sj = j * (S._width + 1) * 2;
            ($__21 = [S._buffer[sj], S._buffer[si]], S._buffer[si] = ($__22 = $__21[Symbol.iterator](), ($__23 = $__22.next()).done ? void 0 : $__23.value), S._buffer[sj] = ($__23 = $__22.next()).done ? void 0 : $__23.value, $__21);
            ($__24 = [S._buffer[sj + 1], S._buffer[si + 1]], S._buffer[si + 1] = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value), S._buffer[sj + 1] = ($__26 = $__25.next()).done ? void 0 : $__26.value, $__24);
            ($__27 = [permutation[i], permutation[j]], permutation[j] = ($__28 = $__27[Symbol.iterator](), ($__29 = $__28.next()).done ? void 0 : $__29.value), permutation[i] = ($__29 = $__28.next()).done ? void 0 : $__29.value, $__27);
          }
        }
        for (var i$__31 = 0; i$__31 < S._width; i$__31++) {
          U._inline_colScale_postMultiply(i$__31, S.cell(i$__31, i$__31).unit());
        }
        S = Matrix.generateDiagonal(S._width, function(k) {
          return S.cell(k, k).abs();
        });
        return {
          U: U,
          S: S,
          V: V
        };
      },
      getColumn: function(colIndex) {
        Util.need(colIndex >= 0 && colIndex <= this.width(), "colIndex >= 0 && colIndex <= this.width()");
        var col = [];
        for (var r = 0; r < this._height; r++) {
          col.push(this.cell(colIndex, r));
        }
        return col;
      },
      getRow: function(rowIndex) {
        Util.need(rowIndex >= 0 && rowIndex <= this.height(), "rowIndex >= 0 && rowIndex <= this.height()");
        var row = [];
        for (var c = 0; c < this._width; c++) {
          row.push(this.cell(c, rowIndex));
        }
        return row;
      },
      closestUnitary: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 100;
        var svd = this.singularValueDecomposition(epsilon, maxIterations);
        return svd.U.times(svd.V);
      }
    }, {
      fromRows: function(rows) {
        Util.need(Array.isArray(rows) && rows.every(Array.isArray), "array rows", rows);
        Util.need(rows.length > 0, "non-zero height", arguments);
        var seqRows = seq(rows);
        var h = rows.length;
        var w = seqRows.map(function(e) {
          return e.length;
        }).distinct().single(null);
        if (w === null) {
          throw new DetailedError("Inconsistent row widths.", {rows: rows});
        }
        var buffer = new Float64Array(w * h * 2);
        var i = 0;
        var $__13 = true;
        var $__14 = false;
        var $__15 = undefined;
        try {
          for (var $__11 = void 0,
              $__10 = (rows)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
            var row = $__11.value;
            {
              var $__6 = true;
              var $__7 = false;
              var $__8 = undefined;
              try {
                for (var $__4 = void 0,
                    $__3 = (row)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                  var cell = $__4.value;
                  {
                    buffer[i] = Complex.realPartOf(cell);
                    buffer[i + 1] = Complex.imagPartOf(cell);
                    i += 2;
                  }
                }
              } catch ($__9) {
                $__7 = true;
                $__8 = $__9;
              } finally {
                try {
                  if (!$__6 && $__3.return != null) {
                    $__3.return();
                  }
                } finally {
                  if ($__7) {
                    throw $__8;
                  }
                }
              }
            }
          }
        } catch ($__16) {
          $__14 = true;
          $__15 = $__16;
        } finally {
          try {
            if (!$__13 && $__10.return != null) {
              $__10.return();
            }
          } finally {
            if ($__14) {
              throw $__15;
            }
          }
        }
        return new Matrix(w, h, buffer);
      },
      parse: function(text) {
        text = text.replace(/\s/g, "");
        if (text.length < 4 || text.substr(0, 2) !== "{{" || text.substr(text.length - 2, 2) !== "}}") {
          throw new Error("Not surrounded by {{}}.");
        }
        return Matrix.fromRows(text.substr(2, text.length - 4).split("},{").map(function(row) {
          return row.split(",").map(Complex.parse);
        }));
      },
      generate: function(width, height, coefficientRowColGenerator) {
        var buf = new Float64Array(width * height * 2);
        for (var r = 0; r < height; r++) {
          for (var c = 0; c < width; c++) {
            var k = (r * width + c) * 2;
            var v = coefficientRowColGenerator(r, c);
            buf[k] = Complex.realPartOf(v);
            buf[k + 1] = Complex.imagPartOf(v);
          }
        }
        return new Matrix(width, height, buf);
      },
      generateDiagonal: function(size, coefficientFunc) {
        var buf = new Float64Array(size * size * 2);
        for (var i = 0; i < size; i++) {
          var k = i * (size + 1) * 2;
          var v = coefficientFunc(i);
          buf[k] = Complex.realPartOf(v);
          buf[k + 1] = Complex.imagPartOf(v);
        }
        return new Matrix(size, size, buf);
      },
      generateTransition: function(size, transitionFunc) {
        var buf = new Float64Array(size * size * 2);
        for (var c = 0; c < size; c++) {
          var r = transitionFunc(c);
          var k = (r * size + c) * 2;
          buf[k] = 1;
        }
        return new Matrix(size, size, buf);
      },
      zero: function(width, height) {
        return new Matrix(width, height, new Float64Array(width * height * 2));
      },
      solo: function(coef) {
        return new Matrix(1, 1, new Float64Array([Complex.realPartOf(coef), Complex.imagPartOf(coef)]));
      },
      square: function() {
        for (var coefs = [],
            $__17 = 0; $__17 < arguments.length; $__17++)
          coefs[$__17] = arguments[$__17];
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        var n = Math.round(Math.sqrt(coefs.length));
        Util.need(n * n === coefs.length, "Matrix.square: non-square number of arguments");
        return Matrix.generate(n, n, function(r, c) {
          return coefs[r * n + c];
        });
      },
      col: function() {
        for (var coefs = [],
            $__18 = 0; $__18 < arguments.length; $__18++)
          coefs[$__18] = arguments[$__18];
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        return Matrix.generate(1, coefs.length, function(r) {
          return coefs[r];
        });
      },
      row: function() {
        for (var coefs = [],
            $__19 = 0; $__19 < arguments.length; $__19++)
          coefs[$__19] = arguments[$__19];
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        return Matrix.generate(coefs.length, 1, function(r, c) {
          return coefs[c];
        });
      },
      fromPauliRotation: function(x, y, z) {
        var $__21,
            $__22;
        var sinc = function(t) {
          if (Math.abs(t) < 0.0002) {
            return 1 - t * t / 6.0;
          }
          return Math.sin(t) / t;
        };
        x = -x * Math.PI * 2;
        y = -y * Math.PI * 2;
        z = -z * Math.PI * 2;
        var s = -11 * x + -13 * y + -17 * z >= 0 ? 1 : -1;
        var theta = Math.sqrt(x * x + y * y + z * z);
        var sigma_v = Matrix.PAULI_X.times(x).plus(Matrix.PAULI_Y.times(y)).plus(Matrix.PAULI_Z.times(z));
        var $__20 = Util.snappedCosSin(s * theta),
            cos = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            sin = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var ci = new Complex(1 + cos, sin).times(0.5);
        var cv = new Complex(Math.sin(theta / 2) * sinc(theta / 2), -s * sinc(theta)).times(s * 0.5);
        var m = Matrix.identity(2).times(ci).minus(sigma_v.times(cv));
        var expectNiceValuesCorrection = function(v) {
          return Format.simplifyByRounding(v, 0.0000000000001);
        };
        return m.transformRealAndImagComponentsWith(expectNiceValuesCorrection);
      },
      fromWireSwap: function(numWires, swapWire1, swapWire2) {
        var bitSwap = function(n) {
          var m1 = 1 << swapWire1;
          var m2 = 1 << swapWire2;
          var s = n & ~(m1 | m2);
          if ((n & m1) !== 0) {
            s |= m2;
          }
          if ((n & m2) !== 0) {
            s |= m1;
          }
          return s;
        };
        return Matrix.generateTransition(1 << numWires, bitSwap);
      },
      identity: function(size) {
        if (!Number.isInteger(size) || size <= 0) {
          throw new DetailedError("Bad size", {size: size});
        }
        var buf = new Float64Array(size * size * 2);
        for (var k = 0; k < size; k++) {
          buf[k * (size + 1) * 2] = 1;
        }
        return new Matrix(size, size, buf);
      },
      rotation: function(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return Matrix.square(c, -s, s, c);
      },
      fromAngleAxisPhaseRotation: function(angle, axis, phase) {
        var $__21,
            $__22,
            $__24,
            $__25;
        var $__20 = axis,
            x = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            y = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            z = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        Util.need(Math.abs(x * x + y * y + z * z - 1) < 0.000001, "Not a unit axis.");
        var vσ = Matrix.PAULI_X.times(x).plus(Matrix.PAULI_Y.times(y)).plus(Matrix.PAULI_Z.times(z));
        var $__23 = Util.snappedCosSin(-angle / 2),
            cos = ($__24 = $__23[Symbol.iterator](), ($__25 = $__24.next()).done ? void 0 : $__25.value),
            sin = ($__25 = $__24.next()).done ? void 0 : $__25.value;
        return Matrix.identity(2).times(cos).plus(vσ.times(new Complex(0, sin))).times(Complex.polar(1, phase));
      }
    });
  }();
  Matrix.PAULI_X = Matrix.square(0, 1, 1, 0);
  Matrix.PAULI_Y = Matrix.square(0, new Complex(0, -1), Complex.I, 0);
  Matrix.PAULI_Z = Matrix.square(1, 0, 0, -1);
  Matrix.HADAMARD = Matrix.square(1, 1, 1, -1).times(Math.sqrt(0.5));
  function complexVectorToReadableJson(vector) {
    return seq(vector).map(function(e) {
      return {
        r: Complex.realPartOf(e),
        i: Complex.imagPartOf(e)
      };
    }).toArray();
  }
  function realVectorToReadableJson(vector) {
    return seq(vector).map(Complex.realPartOf).toArray();
  }
  return {
    get Matrix() {
      return Matrix;
    },
    get complexVectorToReadableJson() {
      return complexVectorToReadableJson;
    },
    get realVectorToReadableJson() {
      return realVectorToReadableJson;
    }
  };
});
//# sourceURL=src/math/Matrix.js
;$traceurRuntime.registerModule("src/math/Point.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Point.js";
  var Point = function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }
    return ($traceurRuntime.createClass)(Point, {
      isEqualTo: function(obj) {
        if (!(obj instanceof Point)) {
          return false;
        }
        var other = obj;
        return other.x === this.x && other.y === this.y;
      },
      toString: function() {
        return ("(x: " + this.x + ", y: " + this.y + ")");
      },
      offsetBy: function(dx, dy) {
        return new Point(this.x + dx, this.y + dy);
      },
      plus: function(p) {
        return new Point(this.x + p.x, this.y + p.y);
      },
      minus: function(p) {
        return new Point(this.x - p.x, this.y - p.y);
      },
      times: function(c) {
        return new Point(this.x * c, this.y * c);
      },
      distanceTo: function(other) {
        var dx = this.x - other.x;
        var dy = this.y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    }, {});
  }();
  return {get Point() {
      return Point;
    }};
});
//# sourceURL=src/math/Point.js
;$traceurRuntime.registerModule("src/math/Rect.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Rect.js";
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Point.js", "src/math/Rect.js")).Point;
  var Rect = function() {
    function Rect(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }
    return ($traceurRuntime.createClass)(Rect, {
      isEqualTo: function(obj) {
        if (!(obj instanceof Rect)) {
          return false;
        }
        var other = obj;
        return other.x === this.x && other.y === this.y && other.w === this.w && other.h === this.h;
      },
      isApproximatelyEqualTo: function(obj, epsilon) {
        if (!(obj instanceof Rect)) {
          return false;
        }
        var other = obj;
        return Math.abs(other.x - this.x) <= epsilon && Math.abs(other.y - this.y) <= epsilon && Math.abs(other.right() - this.right()) <= epsilon && Math.abs(other.bottom() - this.bottom()) <= epsilon;
      },
      toString: function() {
        return ("[" + this.x + ":" + this.right() + "]x[" + this.y + ":" + this.bottom() + "]");
      },
      center: function() {
        return new Point(this.x + this.w / 2, this.y + this.h / 2);
      },
      topLeft: function() {
        return new Point(this.x, this.y);
      },
      topRight: function() {
        return new Point(this.x + this.w, this.y);
      },
      bottomLeft: function() {
        return new Point(this.x, this.y + this.h);
      },
      bottomRight: function() {
        return new Point(this.x + this.w, this.y + this.h);
      },
      centerLeft: function() {
        return new Point(this.x, this.y + this.h / 2);
      },
      centerRight: function() {
        return new Point(this.x + this.w, this.y + this.h / 2);
      },
      topCenter: function() {
        return new Point(this.x + this.w / 2, this.y);
      },
      bottomCenter: function() {
        return new Point(this.x + this.w / 2, this.y + this.h);
      },
      right: function() {
        return this.x + this.w;
      },
      bottom: function() {
        return this.y + this.h;
      },
      skipLeft: function(lostWidth) {
        var d = Math.min(lostWidth, this.w);
        return new Rect(this.x + d, this.y, this.w - d, this.h);
      },
      skipRight: function(lostWidth) {
        var d = Math.min(lostWidth, this.w);
        return new Rect(this.x, this.y, this.w - d, this.h);
      },
      skipTop: function(lostHeight) {
        var d = Math.min(lostHeight, this.h);
        return new Rect(this.x, this.y + d, this.w, this.h - d);
      },
      skipBottom: function(lostHeight) {
        var d = Math.min(lostHeight, this.h);
        return new Rect(this.x, this.y, this.w, this.h - d);
      },
      takeLeft: function(keptWidth) {
        var d = Math.max(keptWidth, 0);
        return new Rect(this.x, this.y, d, this.h);
      },
      takeRight: function(keptWidth) {
        var d = Math.max(keptWidth, 0);
        return new Rect(this.x + this.w - d, this.y, d, this.h);
      },
      takeTop: function(keptHeight) {
        var d = Math.max(keptHeight, 0);
        return new Rect(this.x, this.y, this.w, d);
      },
      takeBottom: function(keptHeight) {
        var d = Math.max(keptHeight, 0);
        return new Rect(this.x, this.y + this.h - d, this.w, d);
      },
      paddedBy: function(p) {
        return new Rect(this.x - p, this.y - p, this.w + p * 2, this.h + p * 2);
      },
      scaledOutwardBy: function(factor) {
        var c = this.center();
        var w2 = this.w * factor;
        var h2 = this.h * factor;
        return new Rect(c.x - w2 / 2, c.y - h2 / 2, w2, h2);
      },
      containsPoint: function(p) {
        return p.x >= this.x && p.x < this.x + this.w && p.y >= this.y && p.y < this.y + this.h;
      },
      takeLeftProportion: function(proportion) {
        return this.takeLeft(this.w * proportion);
      },
      takeRightProportion: function(proportion) {
        return this.takeRight(this.w * proportion);
      },
      takeTopProportion: function(proportion) {
        return this.takeTop(this.h * proportion);
      },
      takeBottomProportion: function(proportion) {
        return this.takeBottom(this.h * proportion);
      },
      leftHalf: function() {
        return this.skipRight(this.w / 2);
      },
      rightHalf: function() {
        return this.skipLeft(this.w / 2);
      },
      topHalf: function() {
        return this.skipBottom(this.h / 2);
      },
      bottomHalf: function() {
        return this.skipTop(this.h / 2);
      },
      shiftedBy: function(dx, dy) {
        return new Rect(this.x + dx, this.y + dy, this.w, this.h);
      },
      proportionalShiftedBy: function(dx, dy) {
        return this.shiftedBy(dx * this.w, dy * this.h);
      },
      withX: function(newX) {
        return new Rect(newX, this.y, this.w, this.h);
      },
      withY: function(newY) {
        return new Rect(this.x, newY, this.w, this.h);
      },
      withW: function(newW) {
        return new Rect(this.x, this.y, newW, this.h);
      },
      withH: function(newH) {
        return new Rect(this.x, this.y, this.w, newH);
      },
      snapInside: function(boundingRect) {
        var w = Math.min(boundingRect.w, this.w);
        var h = Math.min(boundingRect.h, this.h);
        var x = Math.max(Math.min(this.x, boundingRect.right() - w), boundingRect.x);
        var y = Math.max(Math.min(this.y, boundingRect.bottom() - h), boundingRect.y);
        return new Rect(x, y, w, h);
      }
    }, {centeredSquareWithRadius: function(center, radius) {
        return new Rect(center.x - radius, center.y - radius, radius * 2, radius * 2);
      }});
  }();
  return {get Rect() {
      return Rect;
    }};
});
//# sourceURL=src/math/Rect.js
;$traceurRuntime.registerModule("src/ui/clear.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/clear.js";
  function initClear(revision, obsIsAnyOverlayShowing) {
    var EMPTY_STATE = '{"cols":[]}';
    var clearAllButton = document.getElementById('clear-all-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, function(r, v) {
      return ({
        r: r,
        v: v
      });
    }).subscribe(function($__1) {
      var $__2 = $__1,
          r = $__2.r,
          v = $__2.v;
      clearAllButton.disabled = r === EMPTY_STATE || v;
    });
    clearAllButton.addEventListener('click', function() {
      return revision.commit(EMPTY_STATE);
    });
    var clearCircuitButton = document.getElementById('clear-circuit-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, function(r, v) {
      return ({
        r: r,
        v: v
      });
    }).subscribe(function($__1) {
      var $__2 = $__1,
          r = $__2.r,
          v = $__2.v;
      clearCircuitButton.disabled = r === _getEmptyCircuitState(revision) || v;
    });
    clearCircuitButton.addEventListener('click', function() {
      return revision.commit(_getEmptyCircuitState(revision));
    });
  }
  function _getEmptyCircuitState(revision) {
    var val = JSON.parse(revision.peekActiveCommit());
    val["cols"] = [];
    return JSON.stringify(val);
  }
  return {get initClear() {
      return initClear;
    }};
});
//# sourceURL=src/ui/clear.js
;$traceurRuntime.registerModule("src/ui/DisplayedCircuit.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedCircuit.js";
  var CachablePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/CachablePainting.js", "src/ui/DisplayedCircuit.js")).CachablePainting;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitDefinition.js", "src/ui/DisplayedCircuit.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitStats.js", "src/ui/DisplayedCircuit.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/DisplayedCircuit.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/ui/DisplayedCircuit.js")).DetailedError;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Equate.js", "src/ui/DisplayedCircuit.js")).equate;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/ui/DisplayedCircuit.js")).Format;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateColumn.js", "src/ui/DisplayedCircuit.js")).GateColumn;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GateDrawParams.js", "src/ui/DisplayedCircuit.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/ui/DisplayedCircuit.js")).GatePainting;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/Hand.js", "src/ui/DisplayedCircuit.js")).Hand;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/ui/DisplayedCircuit.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/ui/DisplayedCircuit.js")).Point;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/ui/DisplayedCircuit.js")).Matrix;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/ui/DisplayedCircuit.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/ui/DisplayedCircuit.js")).Util;
  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/ui/DisplayedCircuit.js")),
      seq = $__36.seq,
      Seq = $__36.Seq;
  var paintBlochSphereDisplay = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/BlochSphereDisplay.js", "src/ui/DisplayedCircuit.js")).paintBlochSphereDisplay;
  var CIRCUIT_OP_HORIZONTAL_SPACING = 10;
  var CIRCUIT_OP_LEFT_SPACING = 35;
  var SUPERPOSITION_GRID_LABEL_SPAN = 50;
  var EXTRA_COLS_FOR_SINGLE_QUBIT_DISPLAYS = 2;
  var DisplayedCircuit = function() {
    function DisplayedCircuit(top, circuitDefinition, compressedColumnIndex, highlightedSlot, extraWireStartIndex) {
      if (!Number.isFinite(top)) {
        throw new DetailedError("Bad top", {
          top: top,
          circuitDefinition: circuitDefinition
        });
      }
      if (!(circuitDefinition instanceof CircuitDefinition)) {
        throw new DetailedError("Bad circuitDefinition", {
          top: top,
          circuitDefinition: circuitDefinition
        });
      }
      this.top = top;
      this.circuitDefinition = circuitDefinition;
      this._compressedColumnIndex = compressedColumnIndex;
      this._highlightedSlot = highlightedSlot;
      this._extraWireStartIndex = extraWireStartIndex;
    }
    return ($traceurRuntime.createClass)(DisplayedCircuit, {
      isBeingEdited: function() {
        return this._extraWireStartIndex !== undefined;
      },
      _groundedWireCount: function() {
        var pseudoCount = this._extraWireStartIndex !== undefined && this._extraWireStartIndex !== Config.MAX_WIRE_COUNT ? 1 : 0;
        var n = Math.max(Config.MIN_WIRE_COUNT, this.circuitDefinition.numWires) - pseudoCount;
        return Math.max(n, this.circuitDefinition.minimumRequiredWireCount());
      },
      desiredHeight: function() {
        var forTooltip = arguments[0] !== (void 0) ? arguments[0] : false;
        if (forTooltip) {
          return this.circuitDefinition.numWires * Config.WIRE_SPACING;
        }
        return this._groundedWireCount() * Config.WIRE_SPACING + 55;
      },
      desiredWidth: function() {
        var forTooltip = arguments[0] !== (void 0) ? arguments[0] : false;
        if (forTooltip) {
          return this.opRect(this.circuitDefinition.columns.length - 1).right() + CIRCUIT_OP_LEFT_SPACING;
        }
        return this._rectForSuperpositionDisplay().right() + 101;
      },
      wireRect: function(wireIndex) {
        if (wireIndex < 0) {
          throw new DetailedError("Bad wireIndex", {wireIndex: wireIndex});
        }
        return new Rect(0, this.top + Config.WIRE_SPACING * wireIndex, Infinity, Config.WIRE_SPACING);
      },
      wireIndexAt: function(y) {
        return Math.floor((y - this.top) / Config.WIRE_SPACING);
      },
      toColumnSpaceCoordinate: function(x) {
        var spacing = (CIRCUIT_OP_HORIZONTAL_SPACING + Config.GATE_RADIUS * 2);
        var left = CIRCUIT_OP_LEFT_SPACING - CIRCUIT_OP_HORIZONTAL_SPACING / 2;
        return (x - left) / spacing - 0.5;
      },
      indexOfDisplayedRowAt: function(y) {
        var i = Math.floor((y - this.top) / Config.WIRE_SPACING);
        if (i < 0 || i >= this.circuitDefinition.numWires) {
          return undefined;
        }
        return i;
      },
      indexOfDisplayedColumnAt: function(x) {
        var col = this.toColumnSpaceCoordinate(x);
        var i;
        if (this._compressedColumnIndex === undefined || col < this._compressedColumnIndex - 0.75) {
          i = Math.round(col);
        } else if (col < this._compressedColumnIndex - 0.25) {
          i = this._compressedColumnIndex;
        } else {
          i = Math.round(col) - 1;
        }
        if (i < 0 || i >= this.circuitDefinition.columns.length) {
          return undefined;
        }
        return i;
      },
      findOpHalfColumnAt: function(p) {
        if (p.x < 0 || p.y < this.top || p.y > this.top + this.desiredHeight()) {
          return undefined;
        }
        return Math.max(-0.5, Math.round(this.toColumnSpaceCoordinate(p.x) * 2) / 2);
      },
      _findModificationIndex_helperColRow: function(hand) {
        if (hand.pos === undefined || hand.heldGate === undefined) {
          return undefined;
        }
        var pos = hand.pos.minus(hand.holdOffset).plus(new Point(Config.GATE_RADIUS, Config.GATE_RADIUS));
        var halfColIndex = this.findOpHalfColumnAt(pos);
        var row = this.indexOfDisplayedRowAt(pos.y);
        if (halfColIndex === undefined || row === undefined) {
          return undefined;
        }
        var col = Math.ceil(halfColIndex);
        return {
          col: col,
          row: row,
          halfColIndex: halfColIndex
        };
      },
      findModificationIndex: function(hand) {
        var loc = this._findModificationIndex_helperColRow(hand);
        if (loc === undefined) {
          return undefined;
        }
        var $__10 = loc,
            col = $__10.col,
            row = $__10.row,
            halfColIndex = $__10.halfColIndex;
        var isInsert = Math.abs(halfColIndex % 1) === 0.5;
        if (col >= this.circuitDefinition.columns.length) {
          return {
            col: col,
            row: row,
            isInsert: isInsert
          };
        }
        if (!isInsert) {
          var mustInsert = this.circuitDefinition.isSlotRectCoveredByGateInSameColumn(col, row, hand.heldGate.height);
          if (mustInsert) {
            var isAfter = hand.pos.x > this.opRect(col).center().x;
            isInsert = true;
            if (isAfter) {
              col += 1;
            }
          }
        }
        return {
          col: col,
          row: row,
          isInsert: isInsert
        };
      },
      opRect: function(operationIndex) {
        var opWidth = Config.GATE_RADIUS * 2;
        var opSeparation = opWidth + CIRCUIT_OP_HORIZONTAL_SPACING;
        var tweak = 0;
        if (this._compressedColumnIndex !== undefined && operationIndex === this._compressedColumnIndex) {
          tweak = opSeparation / 2;
        }
        if (this._compressedColumnIndex !== undefined && operationIndex > this._compressedColumnIndex) {
          tweak = opSeparation;
        }
        var dx = opSeparation * operationIndex - tweak + CIRCUIT_OP_LEFT_SPACING;
        return new Rect(dx, this.top, opWidth, this.desiredHeight());
      },
      gateRect: function(wireIndex, operationIndex) {
        var width = arguments[2] !== (void 0) ? arguments[2] : 1;
        var height = arguments[3] !== (void 0) ? arguments[3] : 1;
        var op = this.opRect(operationIndex);
        var wire = this.wireRect(wireIndex);
        var r = new Rect(op.center().x - Config.GATE_RADIUS, wire.center().y - Config.GATE_RADIUS, 2 * Config.GATE_RADIUS + (width - 1) * Config.WIRE_SPACING, 2 * Config.GATE_RADIUS + (height - 1) * Config.WIRE_SPACING);
        return new Rect(Math.round(r.x - 0.5) + 0.5, Math.round(r.y - 0.5) + 0.5, Math.round(r.w), Math.round(r.h));
      },
      afterTidyingUp: function() {
        return this.withCircuit(this.circuitDefinition.withUncoveredColumnsRemoved().withHeightOverlapsFixed().withWidthOverlapsFixed().withUncoveredColumnsRemoved().withTrailingSpacersIncluded())._withCompressedColumnIndex(undefined)._withExtraWireStartIndex(undefined)._withHighlightedSlot(undefined);
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof DisplayedCircuit && this.top === other.top && this.circuitDefinition.isEqualTo(other.circuitDefinition) && this._compressedColumnIndex === other._compressedColumnIndex && this._extraWireStartIndex === other._extraWireStartIndex && equate(this._highlightedSlot, other._highlightedSlot);
      },
      paint: function(painter, hand, stats) {
        var forTooltip = arguments[3] !== (void 0) ? arguments[3] : false;
        var showWires = arguments[4] !== (void 0) ? arguments[4] : true;
        if (showWires) {
          this._drawWires(painter, !forTooltip, hand);
        }
        for (var col = 0; col < this.circuitDefinition.columns.length; col++) {
          this._drawColumn(painter, this.circuitDefinition.columns[col], col, hand, stats);
        }
        if (!forTooltip) {
          this._drawOutputDisplays(painter, stats, hand);
          this._drawHintLabels(painter, stats);
        }
        this._drawRowDragHighlight(painter);
      },
      _drawWires: function(painter, showLabels, hand) {
        var $__2 = this;
        var drawnWireCount = Math.min(this.circuitDefinition.numWires, (this._extraWireStartIndex || Infinity) + 1);
        if (showLabels) {
          for (var row = 0; row < drawnWireCount; row++) {
            var wireRect = this.wireRect(row);
            var y = wireRect.center().y;
            var v = this.circuitDefinition.customInitialValues.get(row);
            if (v === undefined) {
              v = '0';
            }
            var rect = this._wireInitialStateClickableRect(row);
            painter.noteTouchBlocker({
              rect: rect,
              cursor: 'pointer'
            });
            if (this._highlightedSlot === undefined && hand.pos !== undefined && rect.containsPoint(hand.pos)) {
              painter.fillRect(rect, Config.HIGHLIGHTED_GATE_FILL_COLOR);
            }
            painter.print(("|" + v + "⟩"), 20, y, 'right', 'middle', 'black', '14px sans-serif', 20, Config.WIRE_SPACING);
          }
        }
        painter.ctx.save();
        var $__17 = this,
            $__18 = function(row) {
              if (row === $__17._extraWireStartIndex) {
                painter.ctx.globalAlpha *= 0.5;
              }
              painter.trace(function(trace) {
                var wireRect = $__2.wireRect(row);
                var y = Math.round(wireRect.center().y - 0.5) + 0.5;
                var lastX = showLabels ? 25 : 5;
                for (var col = 0; showLabels ? lastX < painter.canvas.width : col <= $__2.circuitDefinition.columns.length; col++) {
                  var x = $__2.opRect(col).center().x;
                  if ($__2.circuitDefinition.locIsMeasured(new Point(col, row))) {
                    trace.line(lastX, y - 1, x, y - 1);
                    trace.line(lastX, y + 1, x, y + 1);
                  } else {
                    trace.line(lastX, y, x, y);
                  }
                  lastX = x;
                }
              }).thenStroke('black');
            };
        for (var row$__16 = 0; row$__16 < drawnWireCount; row$__16++) {
          $__18(row$__16);
        }
        painter.ctx.restore();
        if (this._extraWireStartIndex !== undefined && this.circuitDefinition.numWires === Config.MAX_WIRE_COUNT) {
          painter.print(("(Max wires. Qubit limit is " + Config.MAX_WIRE_COUNT + ".)"), 5, this.wireRect(Config.MAX_WIRE_COUNT).y, 'left', 'top', 'red', '16px bold monospace', 400, Config.WIRE_SPACING);
        }
      },
      _highlightStatusAt: function(col, row, focusPosPts) {
        var $__2 = this;
        if (this._highlightedSlot !== undefined) {
          if (this._highlightedSlot.col === col && this._highlightedSlot.row === row) {
            return {
              isResizeShowing: true,
              isResizeHighlighted: this._highlightedSlot.resizeStyle,
              isHighlighted: !this._highlightedSlot.resizeStyle
            };
          }
        }
        var gate = this.circuitDefinition.gateInSlot(col, row);
        if (gate === undefined || this._highlightedSlot !== undefined) {
          return {
            isResizeShowing: false,
            isResizeHighlighted: false,
            isHighlighted: false
          };
        }
        var gateRect = this.gateRect(row, col, gate.width, gate.height);
        var resizeTabRect = GatePainting.rectForResizeTab(gateRect);
        var isOverGate = function(pos) {
          var overGate = $__2.findGateOverlappingPos(pos);
          return overGate !== undefined && overGate.col === col && overGate.row === row;
        };
        var isNotCoveredAt = function(pos) {
          var g = $__2.findGateOverlappingPos(pos);
          return g === undefined || (g.col === col && g.row === row);
        };
        var isOverGateResizeTab = function(pos) {
          return isNotCoveredAt(pos) && resizeTabRect.containsPoint(pos);
        };
        var isResizeHighlighted = gate.canChangeInSize() && seq(focusPosPts).any(isOverGateResizeTab);
        var isHighlighted = !isResizeHighlighted && seq(focusPosPts).any(isOverGate);
        var isResizeShowing = gate.canChangeInSize() && (isResizeHighlighted || isHighlighted);
        return {
          isHighlighted: isHighlighted,
          isResizeShowing: isResizeShowing,
          isResizeHighlighted: isResizeHighlighted
        };
      },
      _drawGate_disabledReason: function(painter, col, row, gateRect, isHighlighted) {
        var isDisabledReason = this.circuitDefinition.gateAtLocIsDisabledReason(col, row);
        if (isDisabledReason === undefined) {
          return;
        }
        painter.ctx.save();
        if (isHighlighted) {
          painter.ctx.globalAlpha *= 0.3;
        }
        painter.ctx.globalAlpha *= 0.5;
        painter.fillRect(gateRect.paddedBy(5), 'yellow');
        painter.ctx.globalAlpha *= 2;
        painter.strokeLine(gateRect.topLeft(), gateRect.bottomRight(), 'orange', 3);
        var r = painter.printParagraph(isDisabledReason, gateRect.paddedBy(5), new Point(0.5, 0.5), 'red');
        painter.ctx.globalAlpha *= 0.5;
        painter.fillRect(r.paddedBy(2), 'yellow');
        painter.ctx.globalAlpha *= 2;
        painter.printParagraph(isDisabledReason, gateRect.paddedBy(5), new Point(0.5, 0.5), 'red');
        painter.ctx.restore();
      },
      _drawColumn: function(painter, gateColumn, col, hand, stats) {
        this._drawColumnControlWires(painter, col);
        this._drawColumnDragHighlight(painter, col);
        for (var row = 0; row < this.circuitDefinition.numWires; row++) {
          if (gateColumn.gates[row] === undefined) {
            continue;
          }
          var gate = gateColumn.gates[row];
          var gateRect = this.gateRect(row, col, gate.width, gate.height);
          var $__10 = this._highlightStatusAt(col, row, hand.hoverPoints()),
              isHighlighted = $__10.isHighlighted,
              isResizeShowing = $__10.isResizeShowing,
              isResizeHighlighted = $__10.isResizeHighlighted;
          var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
          painter.noteTouchBlocker({
            rect: gateRect,
            cursor: 'pointer'
          });
          if (gate.canChangeInSize()) {
            painter.noteTouchBlocker({
              rect: GatePainting.rectForResizeTab(gateRect),
              cursor: 'ns-resize'
            });
          }
          drawer(new GateDrawParams(painter, hand, false, isHighlighted && !isResizeHighlighted, isResizeShowing, isResizeHighlighted, gateRect, gate, stats, {
            row: row,
            col: col
          }, this._highlightedSlot === undefined ? hand.hoverPoints() : [], stats.customStatsForSlot(col, row)));
          this._drawGate_disabledReason(painter, col, row, gateRect, isHighlighted);
        }
        this._drawColumnSurvivalRate(painter, gateColumn, col, stats);
      },
      _drawColumnSurvivalRate: function(painter, gateColumn, col, stats) {
        if (gateColumn.indexOfNonUnitaryGate() === undefined) {
          return;
        }
        var preRate = stats.survivalRate(col - 1);
        var postRate = stats.survivalRate(col);
        var marginalRate = (postRate - preRate) / preRate;
        if (isNaN(marginalRate) || Math.abs(marginalRate) <= 0.005) {
          return;
        }
        var descAmount;
        var descCategory;
        if (marginalRate < 0) {
          var rate = Math.round(-marginalRate * 100);
          var rateDesc = marginalRate === -1 ? "100" : rate < 100 ? rate : ">99";
          descAmount = (rateDesc + "%");
          descCategory = 'omits';
        } else {
          var factor = Math.round(marginalRate * 100 + 100);
          descAmount = (factor + "%");
          descCategory = 'gains';
        }
        var pt = this.opRect(col).bottomCenter();
        painter.print(descCategory, pt.x, pt.y - 28, 'center', 'bottom', 'red', '14px sans-serif', 800, 50);
        painter.print(descAmount, pt.x, pt.y - 13, 'center', 'bottom', 'red', '14px sans-serif', 800, 50);
      },
      _drawColumnDragHighlight: function(painter, col) {
        if (this._highlightedSlot !== undefined && this._highlightedSlot.col === col && this._highlightedSlot.row === undefined) {
          var rect = this.gateRect(0, col, 1, this._groundedWireCount()).paddedBy(3);
          painter.fillRect(rect, 'rgba(255, 196, 112, 0.7)');
          painter.strokeRect(rect, 'black');
        }
      },
      _drawRowDragHighlight: function(painter) {
        if (this._highlightedSlot !== undefined && this._highlightedSlot.col === undefined && this._highlightedSlot.row !== undefined) {
          var row = this._highlightedSlot.row;
          var w = this.gateRect(row, this.clampedCircuitColCount() + 1).x;
          var rect = this.wireRect(row).takeLeft(w);
          painter.fillRect(rect, 'rgba(255, 196, 112, 0.7)');
          painter.strokeRect(rect, 'black');
        }
      },
      _drawColumnControlWires: function(painter, columnIndex) {
        var x = Math.round(this.opRect(columnIndex).center().x - 0.5) + 0.5;
        if (this.circuitDefinition.columns[columnIndex].hasGatesWithGlobalEffects()) {
          painter.ctx.save();
          painter.ctx.setLineDash([1, 4]);
          painter.strokeLine(new Point(x, this.gateRect(0, 0).y), new Point(x, this.opRect(0).bottom() - 40));
          painter.ctx.restore();
        }
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.circuitDefinition.controlLinesRanges(columnIndex))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__10 = $__4.value,
                first = $__10.first,
                last = $__10.last,
                measured = $__10.measured;
            {
              var y1 = this.wireRect(first).center().y;
              var y2 = this.wireRect(last).center().y;
              if (measured) {
                painter.strokeLine(new Point(x + 1, y1), new Point(x + 1, y2));
                painter.strokeLine(new Point(x - 1, y1), new Point(x - 1, y2));
              } else {
                painter.strokeLine(new Point(x, y1), new Point(x, y2));
              }
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      },
      previewDrop: function(hand) {
        return hand.heldRow !== undefined ? this._previewDropMovedRow(hand) : hand.heldColumn !== undefined ? this._previewDropMovedGateColumn(hand) : hand.heldGate !== undefined ? this._previewDropMovedGate(hand) : this._previewResizedGate(hand);
      },
      _previewDropMovedRow: function(hand) {
        if (hand.pos === undefined) {
          return this;
        }
        var handWire = this.wireIndexAt(hand.pos.y);
        if (handWire < 0 || handWire >= this.circuitDefinition.numWires) {
          return this;
        }
        var heldRowHeight = seq(hand.heldRow.gates).map(function(g) {
          return g === undefined ? 1 : g.height;
        }).max(1);
        handWire = Math.min(handWire, this.circuitDefinition.numWires - heldRowHeight);
        var newCols = [];
        for (var c = 0; c < this.circuitDefinition.columns.length; c++) {
          var gates = $traceurRuntime.spread(this.circuitDefinition.columns[c].gates);
          gates.splice(handWire, 0, hand.heldRow.gates[c]);
          gates.pop();
          newCols.push(new GateColumn(gates));
        }
        var newInitialStates = seq(this.circuitDefinition.customInitialValues.entries()).map(function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              k = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              v = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return [k + (k >= handWire ? 1 : 0), v];
        }).toMap(function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              k = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              _ = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return k;
        }, function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              _ = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              v = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return v;
        });
        if (hand.heldRow.initialState !== undefined) {
          newInitialStates.set(handWire, hand.heldRow.initialState);
        }
        var newCircuitDef = this.circuitDefinition.withColumns(newCols).withInitialStates(newInitialStates);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: handWire,
          col: undefined,
          resizeStyle: false
        });
      },
      _previewDropMovedGateColumn: function(hand) {
        if (hand.pos === undefined) {
          return this;
        }
        var handWire = this.wireIndexAt(hand.pos.y);
        if (handWire < 0 || handWire >= Config.MAX_WIRE_COUNT || hand.pos.x <= 1) {
          return this;
        }
        var halfCol = this.findOpHalfColumnAt(new Point(hand.pos.x, this.top));
        var mustInsert = halfCol % 1 === 0 && this.circuitDefinition.columns[halfCol] !== undefined && !this.circuitDefinition.columns[halfCol].isEmpty();
        if (mustInsert) {
          var isAfter = hand.pos.x > this.opRect(halfCol).center().x;
          halfCol += isAfter ? 0.5 : -0.5;
        }
        var col = Math.ceil(halfCol);
        var isInsert = halfCol % 1 !== 0;
        var rowShift = Math.round((hand.pos.y - hand.holdOffset.y - this.top) / Config.WIRE_SPACING);
        var newCircuitDef = this._shiftAndSpliceColumn(rowShift, $traceurRuntime.spread(hand.heldColumn.gates), col, isInsert);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: undefined,
          col: col,
          resizeStyle: false
        })._withCompressedColumnIndex(isInsert ? col : undefined);
      },
      _shiftAndSpliceColumn: function(rowShift, gatesOfCol, insertCol, isInsert) {
        while (rowShift < 0 && gatesOfCol[0] === undefined) {
          gatesOfCol.shift();
          gatesOfCol.push(undefined);
          rowShift += 1;
        }
        while (rowShift > 0 && new GateColumn(gatesOfCol).minimumRequiredWireCount() < Config.MAX_WIRE_COUNT) {
          gatesOfCol.unshift(undefined);
          if (new GateColumn(gatesOfCol).minimumRequiredWireCount() < gatesOfCol.length) {
            gatesOfCol.pop();
          }
          rowShift -= 1;
        }
        var expandedCircuit = this.circuitDefinition.withWireCount(gatesOfCol.length);
        var newCols = $traceurRuntime.spread(expandedCircuit.columns);
        while (newCols.length < insertCol) {
          newCols.push(GateColumn.empty(expandedCircuit.numWires));
        }
        newCols.splice(insertCol, isInsert ? 0 : 1, new GateColumn(gatesOfCol));
        return expandedCircuit.withColumns(newCols).withTrailingSpacersIncluded();
      },
      _previewDropMovedGate: function(hand) {
        var modificationPoint = this.findModificationIndex(hand);
        if (modificationPoint === undefined) {
          return this;
        }
        var handRowOffset = Math.floor(hand.holdOffset.y / Config.WIRE_SPACING);
        if (modificationPoint.row + handRowOffset >= this.circuitDefinition.numWires) {
          return this;
        }
        var addedGate = hand.heldGate;
        var emptyCol = GateColumn.empty(this.circuitDefinition.numWires);
        var i = modificationPoint.col;
        var isInserting = modificationPoint.isInsert;
        var row = Math.min(modificationPoint.row, Math.max(0, Config.MAX_WIRE_COUNT - addedGate.height));
        var newCols = seq(this.circuitDefinition.columns).padded(i, emptyCol).ifThen(isInserting, function(s) {
          return s.withInsertedItem(i, emptyCol);
        }).padded(i + addedGate.width, emptyCol).withTransformedItem(i, function(c) {
          return c.withGatesAdded(row, new GateColumn([addedGate]));
        }).toArray();
        var newWireCount = Math.max(this._extraWireStartIndex || 0, Math.max(this.circuitDefinition.numWires, addedGate.height + row));
        if (newWireCount > Config.MAX_WIRE_COUNT) {
          return this;
        }
        var newCircuitDef = this.circuitDefinition.withColumns(newCols).withWireCount(newWireCount);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: row,
          col: modificationPoint.col,
          resizeStyle: false
        })._withCompressedColumnIndex(isInserting ? i : undefined)._withFallbackExtraWireStartIndex(this.circuitDefinition.numWires);
      },
      _previewResizedGate: function(hand) {
        if (hand.resizingGateSlot === undefined || hand.pos === undefined) {
          return this;
        }
        var gate = this.circuitDefinition.gateInSlot(hand.resizingGateSlot.x, hand.resizingGateSlot.y);
        if (gate === undefined) {
          return this;
        }
        var row = Math.min(this.wireIndexAt(hand.pos.y - hand.holdOffset.y), Config.MAX_WIRE_COUNT - 1);
        var newGate = seq(gate.gateFamily).minBy(function(g) {
          return Math.abs(g.height - (row - hand.resizingGateSlot.y + 1));
        });
        var newWireCount = Math.min(Config.MAX_WIRE_COUNT, Math.max(this.circuitDefinition.numWires, newGate.height + hand.resizingGateSlot.y));
        var newCols = seq(this.circuitDefinition.columns).withTransformedItem(hand.resizingGateSlot.x, function(colObj) {
          return new GateColumn(seq(colObj.gates).withOverlayedItem(hand.resizingGateSlot.y, newGate).toArray());
        }).toArray();
        var newCircuitWithoutOverlapFix = this.circuitDefinition.withColumns(newCols).withWireCount(newWireCount);
        var newCircuitWithOverlapFix = newCircuitWithoutOverlapFix.withHeightOverlapsFixed();
        var newCircuit = newCircuitWithOverlapFix.withTrailingSpacersIncluded();
        return this.withCircuit(newCircuit)._withHighlightedSlot(this._highlightedSlot)._withCompressedColumnIndex(newCircuitWithoutOverlapFix.isEqualTo(newCircuitWithOverlapFix) ? undefined : hand.resizingGateSlot.x + 1)._withFallbackExtraWireStartIndex(this.circuitDefinition.numWires);
      },
      afterDropping: function(hand) {
        return this.previewDrop(hand)._withCompressedColumnIndex(undefined);
      },
      withCircuit: function(circuitDefinition) {
        return new DisplayedCircuit(this.top, circuitDefinition, this._compressedColumnIndex, this._highlightedSlot, this._extraWireStartIndex);
      },
      _withCompressedColumnIndex: function(compressedColumnIndex) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, compressedColumnIndex, this._highlightedSlot, this._extraWireStartIndex);
      },
      _withHighlightedSlot: function(slot) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, this._compressedColumnIndex, slot, this._extraWireStartIndex);
      },
      _withExtraWireStartIndex: function(extraWireStartIndex) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, this._compressedColumnIndex, this._highlightedSlot, extraWireStartIndex);
      },
      _withFallbackExtraWireStartIndex: function(fallbackExtraWireStartIndex) {
        return this._withExtraWireStartIndex(this._extraWireStartIndex || fallbackExtraWireStartIndex);
      },
      withJustEnoughWires: function(hand, extraWireCount) {
        var neededWireCountForPlacement = hand.heldGate !== undefined ? hand.heldGate.height : 0;
        var desiredWireCount = this.circuitDefinition.minimumRequiredWireCount();
        var clampedWireCount = Math.min(Config.MAX_WIRE_COUNT, Math.max(Math.min(1, neededWireCountForPlacement), Math.max(Config.MIN_WIRE_COUNT, desiredWireCount) + extraWireCount));
        return this.withCircuit(this.circuitDefinition.withWireCount(clampedWireCount))._withExtraWireStartIndex(extraWireCount === 0 ? undefined : this.circuitDefinition.numWires);
      },
      findGateOverlappingPos: function(pos) {
        var col = this.indexOfDisplayedColumnAt(pos.x);
        var row = this.indexOfDisplayedRowAt(pos.y);
        if (col === undefined || row === undefined) {
          return undefined;
        }
        var target = this.circuitDefinition.findGateCoveringSlot(col, row);
        if (target === undefined) {
          return undefined;
        }
        var gateRect = this.gateRect(target.row, target.col, target.gate.width, target.gate.height);
        if (!gateRect.containsPoint(pos)) {
          return undefined;
        }
        return {
          col: target.col,
          row: target.row,
          offset: pos.minus(gateRect.topLeft())
        };
      },
      findGateWithButtonContaining: function(pos) {
        var foundPt = this.findGateOverlappingPos(pos);
        if (foundPt === undefined) {
          return undefined;
        }
        var gate = this.circuitDefinition.gateInSlot(foundPt.col, foundPt.row);
        if (gate.onClickGateFunc === undefined) {
          return undefined;
        }
        var buttonRect = GatePainting.gateButtonRect(this.gateRect(foundPt.row, foundPt.col, gate.width, gate.height));
        if (!buttonRect.containsPoint(pos)) {
          return undefined;
        }
        return {
          col: foundPt.col,
          row: foundPt.row,
          gate: gate
        };
      },
      _wireInitialStateClickableRect: function(wire) {
        var r = this.wireRect(wire);
        r.x = 0;
        r.y += 5;
        r.w = 30;
        r.h -= 10;
        return r;
      },
      findWireWithInitialStateAreaContaining: function(pt) {
        if (pt.x < 0 || pt.x > 30) {
          return undefined;
        }
        var wire = this.wireIndexAt(pt.y);
        if (wire < 0 || wire >= this.circuitDefinition.numWires) {
          return undefined;
        }
        var r = this._wireInitialStateClickableRect(wire);
        if (!r.containsPoint(pt)) {
          return undefined;
        }
        return wire;
      },
      tryClick: function(hand) {
        if (hand.pos === undefined || hand.heldGate !== undefined) {
          return undefined;
        }
        var clickedInitialStateWire = this.findWireWithInitialStateAreaContaining(hand.pos);
        if (clickedInitialStateWire !== undefined) {
          return this.withCircuit(this.circuitDefinition.withSwitchedInitialStateOn(clickedInitialStateWire));
        }
        var found = this.findGateWithButtonContaining(hand.pos);
        if (found === undefined) {
          return undefined;
        }
        var newGate = found.gate.onClickGateFunc(found.gate);
        var cols = $traceurRuntime.spread(this.circuitDefinition.columns);
        var col = cols[found.col];
        var gates = $traceurRuntime.spread(col.gates);
        gates.splice(found.row, 1, newGate);
        cols.splice(found.col, 1, new GateColumn(gates));
        return this.withCircuit(this.circuitDefinition.withColumns(cols));
      },
      tryGrab: function(hand) {
        var duplicate = arguments[1] !== (void 0) ? arguments[1] : false;
        var wholeColumn = arguments[2] !== (void 0) ? arguments[2] : false;
        var ignoreResizeTabs = arguments[3] !== (void 0) ? arguments[3] : false;
        var alt = arguments[4] !== (void 0) ? arguments[4] : false;
        if (wholeColumn) {
          var grabRowResult = this._tryGrabRow(hand, alt);
          if (grabRowResult !== undefined) {
            return grabRowResult;
          }
          return this._tryGrabWholeColumn(hand, duplicate, alt) || {
            newCircuit: this,
            newHand: hand
          };
        }
        var newHand = hand;
        var newCircuit = this;
        if (!ignoreResizeTabs) {
          var resizing = this._tryGrabResizeTab(hand);
          if (resizing !== undefined) {
            newHand = resizing.newHand;
            newCircuit = resizing.newCircuit;
          }
        }
        return newCircuit._tryGrabGate(newHand, duplicate, alt) || {
          newCircuit: newCircuit,
          newHand: newHand
        };
      },
      _tryGrabRow: function(hand, alt) {
        if (hand.pos === undefined) {
          return undefined;
        }
        var wire = this.wireIndexAt(hand.pos.y);
        if (wire < 0 || wire >= this.circuitDefinition.numWires) {
          return undefined;
        }
        var r = this._wireInitialStateClickableRect(wire);
        if (!r.containsPoint(hand.pos)) {
          return undefined;
        }
        var $__10 = this._cutRow(wire),
            newCircuit = $__10.newCircuit,
            initialState = $__10.initialState,
            rowGates = $__10.rowGates;
        var holdOffset = new Point(0, hand.pos.y - r.y);
        if (alt) {
          rowGates = rowGates.map(function(e) {
            return e === undefined ? e : e.alternate;
          });
        }
        return {
          newCircuit: this.withCircuit(newCircuit),
          newHand: hand.withHeldRow({
            initialState: initialState,
            gates: rowGates
          }, holdOffset)
        };
      },
      _cutRow: function(row) {
        var row_gates = [];
        var cols = [];
        for (var i = 0; i < this.circuitDefinition.columns.length; i++) {
          var col_gates = $traceurRuntime.spread(this.circuitDefinition.columns[i].gates);
          row_gates.push(col_gates[row]);
          col_gates.splice(row, 1);
          col_gates.push(undefined);
          cols.push(new GateColumn(col_gates));
        }
        var newInitialStates = seq(this.circuitDefinition.customInitialValues.entries()).filter(function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              k = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              _ = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return k !== row;
        }).map(function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              k = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              v = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return [k - (k > row ? 1 : 0), v];
        }).toMap(function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              k = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              _ = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return k;
        }, function($__10) {
          var $__12,
              $__13;
          var $__11 = $__10,
              _ = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
              v = ($__13 = $__12.next()).done ? void 0 : $__13.value;
          return v;
        });
        return {
          newCircuit: this.circuitDefinition.withColumns(cols).withInitialStates(newInitialStates),
          rowGates: row_gates,
          initialState: this.circuitDefinition.customInitialValues.get(row)
        };
      },
      _tryGrabGate: function(hand, duplicate, alt) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        var foundPt = this.findGateOverlappingPos(hand.pos);
        if (foundPt === undefined) {
          return undefined;
        }
        var $__10 = foundPt,
            col = $__10.col,
            row = $__10.row,
            offset = $__10.offset;
        var gate = this.circuitDefinition.columns[col].gates[row];
        if (alt) {
          gate = gate.alternate;
        }
        var remainingGates = seq(this.circuitDefinition.columns[col].gates).toArray();
        if (!duplicate) {
          remainingGates[row] = undefined;
        }
        var newCols = seq(this.circuitDefinition.columns).withOverlayedItem(col, new GateColumn(remainingGates)).toArray();
        return {
          newCircuit: new DisplayedCircuit(this.top, this.circuitDefinition.withColumns(newCols), undefined, undefined, this._extraWireStartIndex),
          newHand: hand.withHeldGate(gate, offset)
        };
      },
      _tryGrabResizeTab: function(hand) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        for (var col = 0; col < this.circuitDefinition.columns.length; col++) {
          for (var row = 0; row < this.circuitDefinition.numWires; row++) {
            var gate = this.circuitDefinition.columns[col].gates[row];
            if (gate === undefined) {
              continue;
            }
            var isResizeHighlighted = this._highlightStatusAt(col, row, hand.hoverPoints()).isResizeHighlighted;
            if (isResizeHighlighted) {
              var offset = hand.pos.minus(this.gateRect(row + gate.height - 1, col, 1, 1).center());
              return {
                newCircuit: this._withHighlightedSlot({
                  col: col,
                  row: row,
                  resizeStyle: true
                }),
                newHand: hand.withResizeSlot(new Point(col, row), offset)
              };
            }
          }
        }
        return undefined;
      },
      _tryGrabWholeColumn: function(hand, duplicate, alt) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        var col = Math.round(this.toColumnSpaceCoordinate(hand.pos.x));
        if (col < 0 || col >= this.circuitDefinition.columns.length || this.circuitDefinition.columns[col].isEmpty()) {
          return undefined;
        }
        var newCols = $traceurRuntime.spread(this.circuitDefinition.columns);
        if (!duplicate) {
          newCols.splice(col, 1, GateColumn.empty(this.circuitDefinition.numWires));
        }
        var holdOffset = new Point(0, this.wireIndexAt(hand.pos.y) * Config.WIRE_SPACING + Config.WIRE_SPACING / 2);
        var grabbedGates = this.circuitDefinition.columns[col];
        if (alt) {
          grabbedGates = new GateColumn(grabbedGates.gates.map(function(e) {
            return e === undefined ? e : e.alternate;
          }));
        }
        return {
          newCircuit: this.withCircuit(this.circuitDefinition.withColumns(newCols)),
          newHand: hand.withHeldGateColumn(grabbedGates, holdOffset)
        };
      },
      stableDuration: function() {
        return this.circuitDefinition.stableDuration();
      },
      importantWireCount: function() {
        return Math.max(this.circuitDefinition.numWires - (this._extraWireStartIndex === Config.MAX_WIRE_COUNT ? 0 : 1), Config.MIN_WIRE_COUNT, this.circuitDefinition.minimumRequiredWireCount());
      },
      _drawOutputDisplays: function(painter, stats, hand) {
        var chanceCol = this.clampedCircuitColCount() + 1;
        var blochCol = chanceCol + 1;
        var numWire = this.importantWireCount();
        for (var i = 0; i < numWire; i++) {
          var p = stats.controlledWireProbabilityJustAfter(i, Infinity);
          MathPainter.paintProbabilityBox(painter, p, this.gateRect(i, chanceCol), hand.hoverPoints());
          var m = stats.qubitDensityMatrix(Infinity, i);
          if (m !== undefined) {
            paintBlochSphereDisplay(painter, m, this.gateRect(i, blochCol), hand.hoverPoints());
          }
        }
        var bottom = this.wireRect(numWire - 1).bottom();
        var x = this.opRect(chanceCol - 1).x;
        painter.printParagraph("Local wire states\n(Chance/Bloch)", new Rect(x, bottom + 4, 190, 40), new Point(0.5, 0), 'gray');
        this._drawOutputSuperpositionDisplay(painter, stats, hand);
      },
      clampedCircuitColCount: function() {
        return Math.max(this.circuitDefinition.columns.length, Config.MIN_COL_COUNT + (this._compressedColumnIndex !== undefined ? 1 : 0));
      },
      _drawOutputSuperpositionDisplay: function(painter, stats, hand) {
        var amplitudeGrid = this._outputStateAsMatrix(stats);
        var gridRect = this._rectForSuperpositionDisplay();
        var numWire = this.importantWireCount();
        MathPainter.paintMatrix(painter, amplitudeGrid, gridRect, numWire < Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD ? Config.SUPERPOSITION_MID_COLOR : undefined, 'black', numWire < Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD ? Config.SUPERPOSITION_FORE_COLOR : undefined, Config.SUPERPOSITION_BACK_COLOR);
        var forceSign = function(v) {
          return (v >= 0 ? '+' : '') + v.toFixed(2);
        };
        MathPainter.paintMatrixTooltip(painter, amplitudeGrid, gridRect, hand.hoverPoints(), function(c, r) {
          return ("Amplitude of |" + Util.bin(r * amplitudeGrid.width() + c, numWire) + "⟩ (decimal " + (r * amplitudeGrid.width() + c) + ")");
        }, function(c, r, v) {
          return 'val:' + v.toString(new Format(false, 0, 5, ", "));
        }, function(c, r, v) {
          return ("mag²:" + (v.norm2() * 100).toFixed(4) + "%, phase:" + forceSign(v.phase() * 180 / Math.PI) + "°");
        });
        this._drawOutputSuperpositionDisplay_labels(painter);
      },
      _drawOutputSuperpositionDisplay_labels: function(painter) {
        var gridRect = this._rectForSuperpositionDisplay();
        var numWire = this.importantWireCount();
        _cachedRowLabelDrawer.paint(gridRect.right(), gridRect.y, painter, numWire);
        _cachedColLabelDrawer.paint(gridRect.x, gridRect.bottom(), painter, numWire);
      },
      _outputStateAsMatrix: function(stats) {
        var $__11,
            $__12,
            $__14,
            $__15;
        var numWire = this.importantWireCount();
        var buf = stats.finalState.rawBuffer();
        if (stats.circuitDefinition.numWires !== numWire) {
          var r = new Float32Array(2 << numWire);
          r.set(buf.slice(0, r.length));
          buf = r;
        }
        var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
            colWires = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
            rowWires = ($__12 = $__11.next()).done ? void 0 : $__12.value;
        var $__13 = [1 << colWires, 1 << rowWires],
            colCount = ($__14 = $__13[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
            rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
        return new Matrix(colCount, rowCount, buf);
      },
      _rectForSuperpositionDisplay: function() {
        var $__13,
            $__11,
            $__14,
            $__15;
        var col = this.clampedCircuitColCount() + EXTRA_COLS_FOR_SINGLE_QUBIT_DISPLAYS + 1;
        var numWire = this.importantWireCount();
        var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
            colWires = ($__13 = $__10[Symbol.iterator](), ($__11 = $__13.next()).done ? void 0 : $__11.value),
            rowWires = ($__11 = $__13.next()).done ? void 0 : $__11.value;
        var $__12 = [1 << colWires, 1 << rowWires],
            colCount = ($__14 = $__12[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
            rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
        var topRect = this.gateRect(0, col);
        var bottomRect = this.gateRect(numWire - 1, col);
        var gridRect = new Rect(topRect.x, topRect.y, 0, bottomRect.bottom() - topRect.y);
        return gridRect.withW(gridRect.h * (colCount / rowCount));
      },
      _drawHintLabels: function(painter, stats) {
        var gridRect = this._rectForSuperpositionDisplay();
        painter.print('Final amplitudes', gridRect.right() + 3, gridRect.bottom() + 3, 'left', 'top', 'gray', '12px sans-serif', 100, 20);
        if (this.circuitDefinition.colIsMeasuredMask(Infinity) !== 0) {
          painter.printParagraph("(assuming measurement deferred)", new Rect(gridRect.right() + 3, gridRect.bottom() + 20, 100, 75), new Point(0.5, 0), 'red');
        }
        var survivalRate = stats.survivalRate(Infinity);
        if (Math.abs(survivalRate - 1) > 0.01) {
          var desc;
          if (survivalRate < 1) {
            var rate = Math.round(survivalRate * 100);
            var rateDesc = survivalRate === 0 ? "0" : rate > 0 ? rate : "<1";
            desc = ("kept: " + rateDesc + "%");
          } else {
            var factor = Math.round(survivalRate * 100);
            desc = ("over-unity: " + factor + "%");
          }
          painter.print(desc, this._rectForSuperpositionDisplay().x - 5, gridRect.bottom() + SUPERPOSITION_GRID_LABEL_SPAN, 'right', 'bottom', 'red', '14px sans-serif', 800, 50);
        }
      }
    }, {
      empty: function(top) {
        return new DisplayedCircuit(top, new CircuitDefinition(Config.MIN_WIRE_COUNT, []), undefined, undefined, undefined);
      },
      fromTextDiagram: function(gateMap, diagramText) {
        var lines = diagramText.split('\n').map(function(e) {
          var p = e.split('|');
          if (p.length !== 2) {
            throw new DetailedError('Bad diagram', {
              diagramText: diagramText,
              gateMap: gateMap
            });
          }
          return p[1];
        });
        var circuitDiagramSubset = seq(lines).skip(1).stride(2).map(function(line) {
          return seq(line).skip(1).stride(2).join("");
        }).join('\n');
        var top = 10;
        var circuit = new DisplayedCircuit(top, CircuitDefinition.fromTextDiagram(gateMap, circuitDiagramSubset), undefined, undefined, undefined);
        var pts = Seq.naturals().takeWhile(function(k) {
          return diagramText.indexOf(k) !== -1;
        }).map(function(k) {
          var pos = seq(lines).mapWithIndex(function(line, row) {
            return ({
              row: row,
              col: line.indexOf(k)
            });
          }).filter(function(e) {
            return e.col !== -1;
          }).single();
          if (lines[pos.row][pos.col + 1] === '^') {
            pos.row -= 1;
            pos.col += 1;
          }
          return new Point(pos.col * Config.WIRE_SPACING / 2 + 35.5, pos.row * Config.WIRE_SPACING / 2 + 10.5);
        }).toArray();
        return {
          circuit: circuit,
          pts: pts
        };
      }
    });
  }();
  function drawCircuitTooltip(painter, circuitDefinition, rect, showWires, time) {
    var displayed = new DisplayedCircuit(0, circuitDefinition, undefined, undefined, undefined);
    var neededWidth = displayed.desiredWidth(true);
    var neededHeight = displayed.desiredHeight(true);
    var scaleX = rect.w / neededWidth;
    var scaleY = rect.h / neededHeight;
    if (showWires) {
      var s = Math.min(scaleX, scaleY);
      scaleX = s;
      scaleY = s;
    }
    var stats = CircuitStats.withNanDataFromCircuitAtTime(circuitDefinition, time);
    try {
      painter.ctx.save();
      painter.ctx.translate(rect.x, rect.y);
      painter.ctx.scale(Math.min(1, scaleX), Math.min(1, scaleY));
      painter.ctx.translate(0, 0);
      displayed.paint(painter, Hand.EMPTY, stats, true, showWires);
    } finally {
      painter.ctx.restore();
    }
    return {
      maxW: neededWidth * scaleX,
      maxH: neededHeight * scaleY
    };
  }
  var GATE_CIRCUIT_DRAWER = function(args) {
    var circuit = args.gate.knownCircuit;
    if (circuit === undefined || args.gate.symbol !== '') {
      if (args.gate.stableDuration() === Infinity) {
        GatePainting.DEFAULT_DRAWER(args);
      } else {
        GatePainting.makeCycleDrawer()(args);
      }
      return;
    }
    var toolboxColor = args.gate.stableDuration() === Infinity ? Config.GATE_FILL_COLOR : Config.TIME_DEPENDENT_HIGHLIGHT_COLOR;
    GatePainting.paintBackground(args, toolboxColor);
    drawCircuitTooltip(args.painter, args.gate.knownCircuitNested, args.rect, false, args.stats.time);
    GatePainting.paintOutline(args);
    if (args.isHighlighted) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.9;
      args.painter.fillRect(args.rect, Config.HIGHLIGHTED_GATE_FILL_COLOR);
      args.painter.ctx.restore();
    }
    GatePainting.paintOutline(args);
  };
  function _drawLabelsReasonablyFast(painter, dy, n, labeller, boundingWidth) {
    var ctx = painter.ctx;
    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    painter.ctx.font = '12px monospace';
    var w = Math.max(painter.ctx.measureText(labeller(0)).width, painter.ctx.measureText(labeller(n - 1)).width);
    var h = ctx.measureText("0").width * 2.5;
    var scale = Math.min(Math.min((boundingWidth - 2) / w, dy / h), 1);
    var step = dy / scale;
    var pad = 1 / scale;
    ctx.scale(scale, scale);
    ctx.translate(0, dy * 0.5 / scale - h * 0.5);
    ctx.fillStyle = 'lightgray';
    if (h < step * 0.95) {
      for (var i = 0; i < n; i++) {
        ctx.fillRect(0, step * i, w + 2 * pad, h);
      }
    } else {
      ctx.fillRect(0, 0, w + 2 * pad, step * n);
    }
    ctx.fillStyle = 'black';
    for (var i$__19 = 0; i$__19 < n; i$__19++) {
      ctx.fillText(labeller(i$__19), pad, h * 0.5 + step * i$__19);
    }
    ctx.restore();
  }
  var _cachedRowLabelDrawer = new CachablePainting(function(numWire) {
    return ({
      width: SUPERPOSITION_GRID_LABEL_SPAN,
      height: (numWire - 1) * Config.WIRE_SPACING + Config.GATE_RADIUS * 2
    });
  }, function(painter, numWire) {
    var $__12,
        $__13;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__12 = $__10[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
        rowWires = ($__13 = $__12.next()).done ? void 0 : $__13.value;
    var rowCount = 1 << rowWires;
    var suffix = colWires < 4 ? "_".repeat(colWires) : "_..";
    _drawLabelsReasonablyFast(painter, painter.canvas.height / rowCount, rowCount, function(i) {
      return Util.bin(i, rowWires) + suffix;
    }, SUPERPOSITION_GRID_LABEL_SPAN);
  });
  var _cachedColLabelDrawer = new CachablePainting(function(numWire) {
    var $__12,
        $__13,
        $__14,
        $__15;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__12 = $__10[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
        rowWires = ($__13 = $__12.next()).done ? void 0 : $__13.value;
    var $__11 = [1 << colWires, 1 << rowWires],
        colCount = ($__14 = $__11[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
        rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
    var total_height = (numWire - 1) * Config.WIRE_SPACING + Config.GATE_RADIUS * 2;
    var cellDiameter = total_height / rowCount;
    return {
      width: colCount * cellDiameter,
      height: SUPERPOSITION_GRID_LABEL_SPAN
    };
  }, function(painter, numWire) {
    var $__11,
        $__12;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
        rowWires = ($__12 = $__11.next()).done ? void 0 : $__12.value;
    var colCount = 1 << colWires;
    var dw = painter.canvas.width / colCount;
    painter.ctx.translate(colCount * dw, 0);
    painter.ctx.rotate(Math.PI / 2);
    var prefix = rowWires < 4 ? "_".repeat(rowWires) : ".._";
    _drawLabelsReasonablyFast(painter, dw, colCount, function(i) {
      return prefix + Util.bin(colCount - 1 - i, colWires);
    }, SUPERPOSITION_GRID_LABEL_SPAN);
  });
  return {
    get DisplayedCircuit() {
      return DisplayedCircuit;
    },
    get drawCircuitTooltip() {
      return drawCircuitTooltip;
    },
    get GATE_CIRCUIT_DRAWER() {
      return GATE_CIRCUIT_DRAWER;
    }
  };
});
//# sourceURL=src/ui/DisplayedCircuit.js
;$traceurRuntime.registerModule("src/ui/DisplayedInspector.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedInspector.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitDefinition.js", "src/ui/DisplayedInspector.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitStats.js", "src/ui/DisplayedInspector.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/DisplayedInspector.js")).Config;
  var DisplayedCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/DisplayedCircuit.js", "src/ui/DisplayedInspector.js")).DisplayedCircuit;
  var DisplayedToolbox = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/DisplayedToolbox.js", "src/ui/DisplayedInspector.js")).DisplayedToolbox;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GateDrawParams.js", "src/ui/DisplayedInspector.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/ui/DisplayedInspector.js")).GatePainting;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/AllGates.js", "src/ui/DisplayedInspector.js")).Gates;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/Hand.js", "src/ui/DisplayedInspector.js")).Hand;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/Painter.js", "src/ui/DisplayedInspector.js")).Painter;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/ui/DisplayedInspector.js")).Rect;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Serializer.js", "src/ui/DisplayedInspector.js")).Serializer;
  var DisplayedInspector = function() {
    function DisplayedInspector(drawArea, circuitWidget, displayedToolboxTop, displayedToolboxBottom, hand) {
      this.displayedCircuit = circuitWidget;
      this.displayedToolboxTop = displayedToolboxTop;
      this.displayedToolboxBottom = displayedToolboxBottom.withCustomGatesInserted(circuitWidget.circuitDefinition.customGateSet);
      this.hand = hand;
      this.drawArea = new Rect(0, 0, 0, 0);
      this.updateArea(drawArea);
    }
    return ($traceurRuntime.createClass)(DisplayedInspector, {
      desiredWidth: function() {
        return Math.max(this.displayedToolboxTop.desiredWidth(), Math.max(this.displayedCircuit.desiredWidth(), this.displayedToolboxBottom.desiredWidth()));
      },
      updateArea: function(drawArea) {
        this.drawArea = drawArea;
        this.displayedToolboxTop = this.displayedToolboxTop.withTop(0);
        this.displayedToolboxBottom = this.displayedToolboxBottom.withTop(this.drawArea.bottom() - this.displayedToolboxBottom.desiredHeight());
      },
      paint: function(painter, stats) {
        painter.fillRect(this.drawArea, Config.BACKGROUND_COLOR);
        this.displayedToolboxTop.paint(painter, stats, this.hand);
        this.displayedToolboxBottom.paint(painter, stats, this.hand);
        this.displayedCircuit.paint(painter, this.hand, stats);
        this._paintHand(painter, stats);
        this._drawHint(painter);
      },
      _paintHand: function(painter, stats) {
        if (this.hand.pos === undefined || this.hand.heldGate === undefined) {
          return;
        }
        var gate = this.hand.heldGate;
        var pos = this.hand.pos.minus(this.hand.holdOffset);
        var rect = new Rect(Math.round(pos.x - 0.5) + 0.5, Math.round(pos.y - 0.5) + 0.5, Config.GATE_RADIUS * 2 + Config.WIRE_SPACING * (gate.width - 1), Config.GATE_RADIUS * 2 + Config.WIRE_SPACING * (gate.height - 1));
        var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
        drawer(new GateDrawParams(painter, this.hand, false, true, true, false, rect, gate, stats, undefined, [], undefined));
      },
      tryGetHandOverButtonKey: function() {
        if (this.hand.pos === undefined) {
          return undefined;
        }
        var butBos = this.displayedCircuit.findGateWithButtonContaining(this.hand.pos);
        if (butBos !== undefined) {
          return ("gate-button-" + butBos.col + ":" + butBos.row);
        }
        var initPos = this.displayedCircuit.findWireWithInitialStateAreaContaining(this.hand.pos);
        if (initPos !== undefined) {
          return ("wire-init-" + initPos);
        }
        return undefined;
      },
      tryClick: function() {
        var newDisplayedCircuit = this.displayedCircuit.tryClick(this.hand);
        return newDisplayedCircuit === undefined ? undefined : this.withDisplayedCircuit(newDisplayedCircuit);
      },
      afterGrabbing: function() {
        var duplicate = arguments[0] !== (void 0) ? arguments[0] : false;
        var wholeCol = arguments[1] !== (void 0) ? arguments[1] : false;
        var ignoreResizeTabs = arguments[2] !== (void 0) ? arguments[2] : false;
        var alt = arguments[3] !== (void 0) ? arguments[3] : false;
        var hand = this.hand;
        var circuit = this.displayedCircuit;
        hand = this.displayedToolboxTop.tryGrab(hand);
        hand = this.displayedToolboxBottom.tryGrab(hand);
        var obj = circuit.tryGrab(hand, duplicate, wholeCol, ignoreResizeTabs, alt);
        hand = obj.newHand;
        circuit = obj.newCircuit;
        return new DisplayedInspector(this.drawArea, circuit, this.displayedToolboxTop, this.displayedToolboxBottom, hand);
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof DisplayedInspector && this.drawArea.isEqualTo(other.drawArea) && this.displayedCircuit.isEqualTo(other.displayedCircuit) && this.displayedToolboxTop.isEqualTo(other.displayedToolboxTop) && this.displayedToolboxBottom.isEqualTo(other.displayedToolboxBottom) && this.hand.isEqualTo(other.hand);
      },
      withDisplayedCircuit: function(displayedCircuit) {
        if (displayedCircuit === this.displayedCircuit) {
          return this;
        }
        return new DisplayedInspector(this.drawArea, displayedCircuit, this.displayedToolboxTop, this.displayedToolboxBottom, this.hand);
      },
      withJustEnoughWires: function(hand, extraWires) {
        return this.withDisplayedCircuit(this.displayedCircuit.withJustEnoughWires(hand, extraWires));
      },
      afterTidyingUp: function() {
        return this.withDisplayedCircuit(this.displayedCircuit.afterTidyingUp());
      },
      previewDrop: function() {
        if (!this.hand.isBusy()) {
          return this;
        }
        var hand = this.hand;
        var circuitWidget = this.displayedCircuit;
        var previewCircuit = circuitWidget.previewDrop(hand);
        var previewHand = previewCircuit === circuitWidget ? hand : hand.withDrop();
        return this.withHand(previewHand).withDisplayedCircuit(previewCircuit);
      },
      afterDropping: function() {
        return this.withDisplayedCircuit(this.displayedCircuit.afterDropping(this.hand)).withHand(this.hand.withDrop());
      },
      stableDuration: function() {
        return Math.min(this.displayedToolboxTop.stableDuration(this.hand), this.displayedToolboxBottom.stableDuration(this.hand), this.hand.stableDuration(), this.displayedCircuit.stableDuration());
      },
      withHand: function(hand) {
        return new DisplayedInspector(this.drawArea, this.displayedCircuit, this.displayedToolboxTop, this.displayedToolboxBottom, hand);
      },
      withCircuitDefinition: function(newCircuitDefinition) {
        return new DisplayedInspector(this.drawArea, DisplayedCircuit.empty(this.displayedToolboxTop.desiredHeight()).withCircuit(newCircuitDefinition), this.displayedToolboxTop, this.displayedToolboxBottom, this.hand.withDrop());
      },
      desiredHeight: function() {
        var minimumDesired = this.displayedToolboxBottom.desiredHeight() + this.displayedToolboxTop.desiredHeight() + this.displayedCircuit.desiredHeight();
        return Math.max(Config.MINIMUM_CANVAS_HEIGHT, minimumDesired);
      },
      snapshot: function() {
        return JSON.stringify(Serializer.toJson(this.displayedCircuit.circuitDefinition), null, 0);
      },
      _drawHint: function(painter) {
        this._drawHint_dragGatesOntoCircuit(painter);
        this._drawHint_watchOutputsChange(painter);
        this._drawHint_useControls(painter);
      },
      _drawHint_watchOutputsChange: function(painter) {
        var visibilityFactor = this._hintVisibility();
        if (visibilityFactor <= 0) {
          return;
        }
        painter.ctx.save();
        painter.ctx.globalAlpha *= Math.min(1, visibilityFactor);
        painter.ctx.translate(this.displayedCircuit.opRect(this.displayedCircuit.clampedCircuitColCount()).x - 280, 15);
        painter.ctx.save();
        painter.ctx.translate(268, 250);
        painter.ctx.rotate(Math.PI * 0.02);
        painter.ctx.fillStyle = 'red';
        painter.ctx.textAlign = 'right';
        painter.ctx.font = '16px sans-serif';
        painter.ctx.fillText("outputs change", 0, 0);
        painter.ctx.restore();
        painter.ctx.beginPath();
        painter.ctx.moveTo(270, 245);
        painter.ctx.bezierCurveTo(300, 245, 315, 235, 325, 225);
        painter.ctx.strokeStyle = 'red';
        painter.ctx.lineWidth = 3;
        painter.ctx.stroke();
        painter.trace(function(tracer) {
          tracer.arrowHead(330, 219, 10, Math.PI * -0.265, 1.3);
        }).thenFill('red');
        painter.ctx.restore();
      },
      _hintVisibility: function() {
        if (this.displayedCircuit.circuitDefinition.columns.length > 0) {
          return 0;
        }
        return this.hand.pos === undefined || !this.hand.isBusy() ? 1.0 : this.hand.heldGate !== undefined && this.hand.heldGate.isControl() ? 1.0 : (150 - this.hand.pos.y) / 50;
      },
      _drawHint_dragGatesOntoCircuit: function(painter) {
        var visibilityFactor = this._hintVisibility();
        if (visibilityFactor <= 0) {
          return;
        }
        painter.ctx.save();
        painter.ctx.globalAlpha *= Math.min(1, visibilityFactor);
        painter.ctx.save();
        painter.ctx.translate(130, 195);
        painter.ctx.rotate(Math.PI * 0.05);
        painter.ctx.fillStyle = 'red';
        painter.ctx.font = '16px sans-serif';
        painter.ctx.fillText("drag gates onto circuit", 0, 0);
        painter.ctx.restore();
        painter.ctx.beginPath();
        painter.ctx.moveTo(268, 132);
        painter.ctx.bezierCurveTo(260, 170, 235, 175, 217, 187);
        painter.ctx.strokeStyle = 'red';
        painter.ctx.lineWidth = 3;
        painter.ctx.stroke();
        painter.trace(function(tracer) {
          tracer.arrowHead(210, 190, 10, Math.PI * 0.84, 1.3);
        }).thenFill('red');
        painter.ctx.restore();
      },
      _drawHint_useControls: function(painter) {
        var visibilityFactor = this._hintVisibility();
        if (visibilityFactor <= 0) {
          return;
        }
        painter.ctx.save();
        painter.ctx.globalAlpha *= Math.min(1, visibilityFactor);
        var firstSlotAvailable = this.displayedCircuit.circuitDefinition.gateInSlot(0, 0) === undefined;
        var fy = firstSlotAvailable ? 173 : 223;
        painter.ctx.save();
        painter.ctx.translate(70, fy - 3);
        painter.ctx.rotate(Math.PI * -0.01);
        painter.ctx.fillStyle = 'red';
        painter.ctx.font = '16px sans-serif';
        painter.ctx.fillText("use controls", 0, 0);
        painter.ctx.restore();
        painter.ctx.beginPath();
        if (firstSlotAvailable) {
          painter.ctx.moveTo(90, 125);
          painter.ctx.bezierCurveTo(60, 140, 48, 160, 55, fy);
        } else {
          painter.ctx.moveTo(100, 125);
          painter.ctx.bezierCurveTo(115, 150, 105, 170, 55, fy);
        }
        painter.ctx.strokeStyle = 'red';
        painter.ctx.lineWidth = 3;
        painter.ctx.stroke();
        painter.ctx.beginPath();
        painter.ctx.arc(55, fy, 5, 0, 2 * Math.PI);
        painter.ctx.fillStyle = 'red';
        painter.ctx.fill();
        painter.ctx.restore();
      }
    }, {empty: function(drawArea) {
        var topToolbox = new DisplayedToolbox('Toolbox', 0, Gates.TopToolboxGroups, true);
        var displayedCircuit = DisplayedCircuit.empty(topToolbox.desiredHeight());
        var bottomToolbox = new DisplayedToolbox('Toolbox₂', displayedCircuit.top + displayedCircuit.desiredHeight(), Gates.BottomToolboxGroups, false);
        return new DisplayedInspector(drawArea, displayedCircuit, topToolbox, bottomToolbox, Hand.EMPTY);
      }});
  }();
  return {get DisplayedInspector() {
      return DisplayedInspector;
    }};
});
//# sourceURL=src/ui/DisplayedInspector.js
;$traceurRuntime.registerModule("src/ui/DisplayedToolbox.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedToolbox.js";
  var CachablePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/CachablePainting.js", "src/ui/DisplayedToolbox.js")).CachablePainting;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitStats.js", "src/ui/DisplayedToolbox.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/DisplayedToolbox.js")).Config;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GateDrawParams.js", "src/ui/DisplayedToolbox.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/GatePainting.js", "src/ui/DisplayedToolbox.js")).GatePainting;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/Hand.js", "src/ui/DisplayedToolbox.js")).Hand;
  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../gates/Joke_MysteryGate.js", "src/ui/DisplayedToolbox.js")),
      MysteryGateSymbol = $__19.MysteryGateSymbol,
      MysteryGateMaker = $__19.MysteryGateMaker;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/ui/DisplayedToolbox.js")).Rect;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/Painter.js", "src/ui/DisplayedToolbox.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/ui/DisplayedToolbox.js")).Point;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/ui/DisplayedToolbox.js")).seq;
  var WidgetPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/WidgetPainter.js", "src/ui/DisplayedToolbox.js")).WidgetPainter;
  var DisplayedToolbox = function() {
    function DisplayedToolbox(name, top, toolboxGroups, labelsOnTop) {
      var originalGroups = arguments[4];
      var standardAppearance = arguments[5];
      var $__2 = this;
      this.name = name;
      this.top = top;
      this.toolboxGroups = toolboxGroups;
      this.labelsOnTop = labelsOnTop;
      this._originalGroups = originalGroups || this.toolboxGroups;
      this._standardApperance = standardAppearance || new CachablePainting(function() {
        return ({
          width: $__2.desiredWidth(),
          height: $__2.desiredHeight()
        });
      }, function(painter) {
        painter.ctx.save();
        painter.ctx.translate(0, -$__2.top);
        $__2._paintStandardContents(painter);
        painter.ctx.restore();
      });
      this.groupHeight = 1;
      var $__6 = true;
      var $__7 = false;
      var $__8 = undefined;
      try {
        for (var $__4 = void 0,
            $__3 = (toolboxGroups)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
          var group = $__4.value;
          {
            var h = Math.ceil(group.gates.length / 2);
            this.groupHeight = Math.max(this.groupHeight, h);
          }
        }
      } catch ($__9) {
        $__7 = true;
        $__8 = $__9;
      } finally {
        try {
          if (!$__6 && $__3.return != null) {
            $__3.return();
          }
        } finally {
          if ($__7) {
            throw $__8;
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(DisplayedToolbox, {
      withCustomGatesInserted: function(customGateSet) {
        var groups = $traceurRuntime.spread(this._originalGroups);
        for (var i = 0; i < Math.max(1, customGateSet.gates.length); i += this.groupHeight * 2) {
          var group = {
            hint: 'Custom Gates',
            gates: [undefined, undefined, undefined, undefined, undefined, undefined]
          };
          for (var j = 0; j < this.groupHeight * 2 && i + j < customGateSet.gates.length; j++) {
            group.gates[j] = customGateSet.gates[i + j];
          }
          groups.push(group);
        }
        return new DisplayedToolbox(this.name, this.top, groups, this.labelsOnTop, this._originalGroups, this._standardApperance);
      },
      gateDrawRect: function(groupIndex, gateIndex) {
        var dx = gateIndex % 2;
        var dy = Math.floor(gateIndex / 2);
        var x = Config.TOOLBOX_MARGIN_X + dx * Config.TOOLBOX_GATE_SPAN + groupIndex * Config.TOOLBOX_GROUP_SPAN;
        var y = this.top + (this.labelsOnTop ? Config.TOOLBOX_MARGIN_Y : 3) + dy * Config.TOOLBOX_GATE_SPAN;
        return new Rect(Math.round(x - 0.5) + 0.5, Math.round(y - 0.5) + 0.5, Config.GATE_RADIUS * 2, Config.GATE_RADIUS * 2);
      },
      groupLabelRect: function(groupIndex) {
        if (this.labelsOnTop) {
          var r$__11 = this.gateDrawRect(groupIndex, 0);
          var c$__12 = new Point(r$__11.x + Config.TOOLBOX_GATE_SPAN - Config.TOOLBOX_GATE_SPACING / 2, r$__11.y - 18);
          return new Rect(c$__12.x - Config.TOOLBOX_GATE_SPAN, c$__12.y, Config.TOOLBOX_GATE_SPAN * 2, 20);
        }
        var r = this.gateDrawRect(groupIndex, this.groupHeight * 2 - 2);
        var c = new Point(r.x + Config.TOOLBOX_GATE_SPAN - Config.TOOLBOX_GATE_SPACING / 2, r.bottom());
        return new Rect(c.x - Config.TOOLBOX_GATE_SPAN, c.y + 2, Config.TOOLBOX_GATE_SPAN * 2, 20);
      },
      findGateAt: function(pt) {
        if (pt === undefined) {
          return undefined;
        }
        for (var groupIndex = 0; groupIndex < this.toolboxGroups.length; groupIndex++) {
          var group = this.toolboxGroups[groupIndex];
          for (var gateIndex = 0; gateIndex < group.gates.length; gateIndex++) {
            var gate = group.gates[gateIndex];
            var rect = this.gateDrawRect(groupIndex, gateIndex);
            if (gate !== undefined && rect.containsPoint(pt)) {
              return {
                groupIndex: groupIndex,
                gateIndex: gateIndex,
                gate: gate,
                rect: rect
              };
            }
          }
        }
        return undefined;
      },
      isEqualTo: function(other) {
        return other instanceof DisplayedToolbox && this.name === other.name && this.top === other.top && this.toolboxGroups === other.toolboxGroups && this.labelsOnTop === other.labelsOnTop;
      },
      withTop: function(newTop) {
        return new DisplayedToolbox(this.name, newTop, this.toolboxGroups, this.labelsOnTop, this._originalGroups, this._standardApperance);
      },
      curArea: function(maxWidth) {
        return new Rect(0, this.top, maxWidth, this.desiredHeight());
      },
      paint: function(painter, stats, hand) {
        painter.fillRect(this.curArea(painter.canvas.width), Config.BACKGROUND_COLOR_TOOLBOX);
        this._standardApperance.paint(0, this.top, painter);
        this._paintDeviations(painter, stats, hand);
      },
      _paintStandardContents: function(painter) {
        for (var groupIndex = 0; groupIndex < this.toolboxGroups.length; groupIndex++) {
          this._paintGatesInGroup(painter, Hand.EMPTY, groupIndex);
        }
        var r = this.curArea(Config.TOOLBOX_MARGIN_X);
        var $__10 = r.center(),
            x = $__10.x,
            y = $__10.y;
        painter.ctx.save();
        painter.ctx.translate(x, y);
        painter.ctx.rotate(-Math.PI / 2);
        painter.printLine(this.name, new Rect(-r.h / 2, -r.w / 2, r.h, r.w), 0.5, 'black', 24);
        painter.ctx.restore();
      },
      _paintDeviations: function(painter, stats, hand) {
        for (var groupIndex = 0; groupIndex < this.toolboxGroups.length; groupIndex++) {
          if (groupIndex >= this._originalGroups.length) {
            this._paintGatesInGroup(painter, hand, groupIndex);
          }
          var group = this.toolboxGroups[groupIndex];
          for (var gateIndex = 0; gateIndex < group.gates.length; gateIndex++) {
            if (group.gates[gateIndex] !== undefined) {
              painter.noteTouchBlocker({
                rect: this.gateDrawRect(groupIndex, gateIndex),
                cursor: 'pointer'
              });
            }
          }
        }
        this._paintFocus(painter, stats, hand);
      },
      _paintGatesInGroup: function(painter, hand, groupIndex) {
        var group = this.toolboxGroups[groupIndex];
        var r = this.groupLabelRect(groupIndex);
        painter.print(group.hint, r.x + r.w / 2, r.y + r.h / 2, 'center', 'middle', 'black', '16px sans-serif', r.w, r.h);
        for (var gateIndex = 0; gateIndex < group.gates.length; gateIndex++) {
          var gate = group.gates[gateIndex];
          if (gate === undefined) {
            continue;
          }
          var rect = this.gateDrawRect(groupIndex, gateIndex);
          DisplayedToolbox._paintGate(painter, hand, gate, rect, false, CircuitStats.EMPTY);
        }
      },
      _paintFocus: function(painter, stats, hand) {
        var f = this.findGateAt(hand.pos);
        if (f === undefined || (hand.heldGate !== undefined && f.gate.symbol !== hand.heldGate.symbol)) {
          return;
        }
        DisplayedToolbox._paintGate(painter, hand, f.gate, f.rect, true, stats);
        painter.ctx.save();
        painter.ctx.globalAlpha = 0;
        painter.ctx.translate(-10000, -10000);
        var $__10 = WidgetPainter.paintGateTooltip(painter, new Rect(0, 0, 500, 300), f.gate, stats.time, true),
            maxW = $__10.maxW,
            maxH = $__10.maxH;
        var mayNeedToScale = maxW >= 500 || maxH >= 300;
        painter.ctx.restore();
        var cx = f.rect.right() + 1;
        var hintRect = new Rect(cx, f.rect.center().y, maxW, maxH).snapInside(painter.paintableArea().skipRight(10).skipBottom(20));
        painter.defer(function() {
          return WidgetPainter.paintGateTooltip(painter, hintRect, f.gate, stats.time, mayNeedToScale);
        });
      },
      desiredWidth: function() {
        return this.gateDrawRect(this.toolboxGroups.length - 1, 5).right() + 5;
      },
      desiredHeight: function() {
        return (1 + this.groupHeight) * (Config.GATE_RADIUS * 2 + 2) - Config.GATE_RADIUS;
      },
      tryGrab: function(hand) {
        var $__2 = this;
        if (hand.pos === undefined || hand.isBusy()) {
          return hand;
        }
        var f = this.findGateAt(hand.pos);
        if (f === undefined) {
          return hand;
        }
        if (f.gate.symbol === MysteryGateSymbol) {
          setTimeout(function() {
            $__2.toolboxGroups[f.groupIndex].gates[f.gateIndex] = MysteryGateMaker();
          }, 0.1);
        }
        return hand.withHeldGate(f.gate, new Point(Config.GATE_RADIUS, Config.GATE_RADIUS));
      },
      stableDuration: function(hand) {
        var $__2 = this;
        return seq(hand.hoverPoints()).map(function(p) {
          return $__2.findGateAt(p);
        }).filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.gate.stableDuration();
        }).min(Infinity);
      }
    }, {_paintGate: function(painter, hand, gate, rect, isHighlighted, stats) {
        var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
        painter.startIgnoringIncomingTouchBlockers();
        drawer(new GateDrawParams(painter, hand, true, isHighlighted, false, false, rect, gate, stats, undefined, [], undefined));
        painter.stopIgnoringIncomingTouchBlockers();
      }});
  }();
  return {get DisplayedToolbox() {
      return DisplayedToolbox;
    }};
});
//# sourceURL=src/ui/DisplayedToolbox.js
;$traceurRuntime.registerModule("src/ui/exports.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/exports.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/exports.js")).Config;
  var ObservableValue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Obs.js", "src/ui/exports.js")).ObservableValue;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Serializer.js", "src/ui/exports.js")).Serializer;
  var selectAndCopyToClipboard = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../browser/Clipboard.js", "src/ui/exports.js")).selectAndCopyToClipboard;
  var fromJsonText_CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Serializer.js", "src/ui/exports.js")).fromJsonText_CircuitDefinition;
  var saveFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../browser/SaveFile.js", "src/ui/exports.js")).saveFile;
  var exportsIsVisible = new ObservableValue(false);
  var obsExportsIsShowing = exportsIsVisible.observable().whenDifferent();
  function initExports(revision, mostRecentStats, obsIsAnyOverlayShowing) {
    (function() {
      var exportButton = document.getElementById('export-button');
      var exportOverlay = document.getElementById('export-overlay');
      var exportDiv = document.getElementById('export-div');
      exportButton.addEventListener('click', function() {
        return exportsIsVisible.set(true);
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        exportButton.disabled = e;
      });
      exportOverlay.addEventListener('click', function() {
        return exportsIsVisible.set(false);
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          exportsIsVisible.set(false);
        }
      });
      obsExportsIsShowing.subscribe(function(showing) {
        exportDiv.style.display = showing ? 'block' : 'none';
        if (showing) {
          document.getElementById('export-link-copy-button').focus();
        }
      });
    })();
    var setupButtonElementCopyToClipboard = function(button, contentElement, resultElement) {
      var contentMaker = arguments[3];
      return button.addEventListener('click', function() {
        if (contentMaker !== undefined) {
          contentElement.innerText = contentMaker();
        }
        try {
          selectAndCopyToClipboard(contentElement);
          resultElement.innerText = "Done!";
        } catch (ex) {
          resultElement.innerText = "It didn't work...";
          console.warn('Clipboard copy failed.', ex);
        }
        button.disabled = true;
        setTimeout(function() {
          resultElement.innerText = "";
          button.disabled = false;
        }, 1000);
      });
    };
    (function() {
      var linkElement = document.getElementById('export-escaped-anchor');
      var copyButton = document.getElementById('export-link-copy-button');
      var copyResultElement = document.getElementById('export-link-copy-result');
      setupButtonElementCopyToClipboard(copyButton, linkElement, copyResultElement);
      revision.latestActiveCommit().subscribe(function(jsonText) {
        var escapedUrlHash = "#" + Config.URL_CIRCUIT_PARAM_KEY + "=" + encodeURIComponent(jsonText);
        linkElement.href = escapedUrlHash;
        linkElement.innerText = document.location.href.split("#")[0] + escapedUrlHash;
      });
    })();
    (function() {
      var jsonTextElement = document.getElementById('export-circuit-json-pre');
      var copyButton = document.getElementById('export-json-copy-button');
      var copyResultElement = document.getElementById('export-json-copy-result');
      setupButtonElementCopyToClipboard(copyButton, jsonTextElement, copyResultElement);
      revision.latestActiveCommit().subscribe(function(jsonText) {
        try {
          var val = JSON.parse(jsonText);
          jsonTextElement.innerText = JSON.stringify(val, null, '  ');
        } catch (_) {
          jsonTextElement.innerText = jsonText;
        }
      });
    })();
    (function() {
      var outputTextElement = document.getElementById('export-amplitudes-pre');
      var copyButton = document.getElementById('export-amplitudes-button');
      var copyResultElement = document.getElementById('export-amplitudes-result');
      var excludeAmps = document.getElementById('export-amplitudes-use-amps');
      obsIsAnyOverlayShowing.subscribe(function(_) {
        outputTextElement.innerText = '[not generated yet]';
      });
      setupButtonElementCopyToClipboard(copyButton, outputTextElement, copyResultElement, function() {
        var raw = JSON.stringify(mostRecentStats.get().toReadableJson(!excludeAmps.checked), null, ' ');
        return raw.replace(/{\s*"r": /g, '{"r":').replace(/,\s*"i":\s*([-e\d\.]+)\s*}/g, ',"i":$1}');
      });
    })();
    (function() {
      var downloadButton = document.getElementById('download-offline-copy-button');
      var fileNameForState = function(jsonText) {
        try {
          var circuitDef = fromJsonText_CircuitDefinition(jsonText);
          if (!circuitDef.isEmpty()) {
            return ("Quirk with Circuit - " + circuitDef.readableHash() + ".html");
          }
        } catch (_) {}
        return 'Quirk.html';
      };
      var latest;
      revision.latestActiveCommit().subscribe(function(jsonText) {
        downloadButton.innerText = ("Download \"" + fileNameForState(jsonText) + "\"");
        latest = jsonText;
      });
      downloadButton.addEventListener('click', function() {
        downloadButton.disabled = true;
        setTimeout(function() {
          downloadButton.disabled = false;
        }, 1000);
        var originalHtml = document.QUIRK_QUINE_ALL_HTML_ORIGINAL;
        var startDefaultTag = '//DEFAULT_CIRCUIT_START\n';
        var endDefaultTag = '//DEFAULT_CIRCUIT_END\n';
        var modStart = originalHtml.indexOf(startDefaultTag);
        var modStop = originalHtml.indexOf(endDefaultTag, modStart);
        var moddedHtml = originalHtml.substring(0, modStart) + startDefaultTag + 'document.DEFAULT_CIRCUIT = ' + JSON.stringify(latest) + ';\n' + originalHtml.substring(modStop);
        var anaStartTag = '<!-- Start Analytics -->\n';
        var anaStart = moddedHtml.indexOf(anaStartTag);
        if (anaStart !== -1) {
          var anaStopTag = '<!-- End Analytics -->\n';
          var anaStop = moddedHtml.indexOf(anaStopTag, anaStart);
          if (anaStop !== -1) {
            moddedHtml = moddedHtml.substring(0, anaStart) + anaStartTag + moddedHtml.substring(anaStop);
          }
        }
        saveFile(fileNameForState(latest), moddedHtml);
      });
    })();
  }
  return {
    get initExports() {
      return initExports;
    },
    get obsExportsIsShowing() {
      return obsExportsIsShowing;
    }
  };
});
//# sourceURL=src/ui/exports.js
;$traceurRuntime.registerModule("src/ui/forge.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/forge.js";
  var Axis = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Axis.js", "src/ui/forge.js")).Axis;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitDefinition.js", "src/ui/forge.js")).CircuitDefinition;
  var setGateBuilderEffectToCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitComputeUtil.js", "src/ui/forge.js")).setGateBuilderEffectToCircuit;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Complex.js", "src/ui/forge.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/forge.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/ui/forge.js")).DetailedError;
  var drawCircuitTooltip = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/DisplayedCircuit.js", "src/ui/forge.js")).drawCircuitTooltip;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Format.js", "src/ui/forge.js")).Format;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/ui/forge.js")),
      Gate = $__14.Gate,
      GateBuilder = $__14.GateBuilder;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateColumn.js", "src/ui/forge.js")).GateColumn;
  var getCircuitCycleTime = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ui/sim.js", "src/ui/forge.js")).getCircuitCycleTime;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/MathPainter.js", "src/ui/forge.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/ui/forge.js")).Matrix;
  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Obs.js", "src/ui/forge.js")),
      Observable = $__19.Observable,
      ObservableValue = $__19.ObservableValue;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../draw/Painter.js", "src/ui/forge.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/ui/forge.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Rect.js", "src/ui/forge.js")).Rect;
  var $__23 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Serializer.js", "src/ui/forge.js")),
      fromJsonText_CircuitDefinition = $__23.fromJsonText_CircuitDefinition,
      Serializer = $__23.Serializer;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/ui/forge.js")).seq;
  var textEditObservable = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../browser/EventUtil.js", "src/ui/forge.js")).textEditObservable;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/ui/forge.js")).Util;
  var forgeIsVisible = new ObservableValue(false);
  var obsForgeIsShowing = forgeIsVisible.observable().whenDifferent();
  function initForge(revision, obsIsAnyOverlayShowing) {
    var obsOnShown = obsForgeIsShowing.filter(function(e) {
      return e === true;
    });
    var latestInspectorText;
    revision.latestActiveCommit().subscribe(function(e) {
      latestInspectorText = e;
    });
    (function() {
      var forgeButton = document.getElementById('gate-forge-button');
      var forgeOverlay = document.getElementById('gate-forge-overlay');
      var forgeDiv = document.getElementById('gate-forge-div');
      forgeButton.addEventListener('click', function() {
        return forgeIsVisible.set(true);
      });
      forgeOverlay.addEventListener('click', function() {
        return forgeIsVisible.set(false);
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        forgeButton.disabled = e;
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          forgeIsVisible.set(false);
        }
      });
      obsForgeIsShowing.subscribe(function(showing) {
        forgeDiv.style.display = showing ? 'block' : 'none';
        if (showing) {
          document.getElementById('gate-forge-rotation-axis').focus();
        }
      });
    })();
    function computeAndPaintOp(canvas, opGetter, button) {
      button.disabled = true;
      var painter = new Painter(canvas);
      painter.clear();
      var d = Math.min((canvas.width - 5) / 2, canvas.height);
      var rect1 = new Rect(0, 0, d, d);
      var rect2 = new Rect(d + 5, 0, d, d);
      try {
        var op = opGetter();
        MathPainter.paintMatrix(painter, op, rect1, Config.OPERATION_FORE_COLOR, 'black', undefined, Config.OPERATION_BACK_COLOR, undefined, 'transparent');
        if (!op.isUnitary(0.009)) {
          painter.printParagraph('NOT UNITARY', rect2, new Point(0.5, 0.5), 'red', 24);
        } else if (op.width() !== 2) {
          painter.printParagraph('(Not a 1-qubit rotation)', rect2, new Point(0.5, 0.5), '#666', 20);
        } else {
          MathPainter.paintBlochSphereRotation(painter, op, rect2, Config.OPERATION_BACK_COLOR, Config.OPERATION_FORE_COLOR);
        }
        var cx = (rect1.right() + rect2.x) / 2;
        painter.strokeLine(new Point(cx, 0), new Point(cx, canvas.height), 'black', 2);
        if (!op.hasNaN()) {
          button.disabled = false;
        }
      } catch (ex) {
        painter.printParagraph(ex + "", new Rect(0, 0, canvas.width, canvas.height), new Point(0.5, 0.5), 'red', 24);
      }
    }
    function createCustomGateAndClose(gate) {
      var circuitDef = arguments[1];
      var c = circuitDef || fromJsonText_CircuitDefinition(latestInspectorText);
      revision.commit(JSON.stringify(Serializer.toJson(c.withCustomGate(gate)), null, 0));
      forgeIsVisible.set(false);
    }
    (function() {
      var $__5;
      var rotationCanvas = document.getElementById('gate-forge-rotation-canvas');
      var rotationButton = document.getElementById('gate-forge-rotation-button');
      var txtAxis = document.getElementById('gate-forge-rotation-axis');
      var txtAngle = document.getElementById('gate-forge-rotation-angle');
      var txtPhase = document.getElementById('gate-forge-rotation-phase');
      var txtName = document.getElementById('gate-forge-rotation-name');
      obsOnShown.subscribe(function() {
        txtName.value = "";
      });
      function parseRotationFromInputs() {
        return parseUserRotation(valueElsePlaceholder(txtAngle), valueElsePlaceholder(txtPhase), valueElsePlaceholder(txtAxis));
      }
      var redraw = function() {
        return computeAndPaintOp(rotationCanvas, parseRotationFromInputs, rotationButton);
      };
      ($__5 = Observable).of.apply($__5, $traceurRuntime.spread([obsOnShown], [txtPhase, txtAxis, txtAngle].map(textEditObservable))).flatten().throttleLatest(100).subscribe(redraw);
      rotationButton.addEventListener('click', function() {
        var mat;
        try {
          mat = parseRotationFromInputs();
        } catch (ex) {
          console.warn(ex);
          return;
        }
        var gate = new GateBuilder().setSerializedId('~' + Math.floor(Math.random() * (1 << 20)).toString(32)).setSymbol(txtName.value).setTitle('Custom Rotation Gate').setKnownEffectToMatrix(mat).gate;
        createCustomGateAndClose(gate);
      });
    })();
    (function() {
      var matrixCanvas = document.getElementById('gate-forge-matrix-canvas');
      var txtMatrix = document.getElementById('gate-forge-matrix');
      var chkFix = document.getElementById('gate-forge-matrix-fix');
      var matrixButton = document.getElementById('gate-forge-matrix-button');
      var txtName = document.getElementById('gate-forge-matrix-name');
      obsOnShown.subscribe(function() {
        txtName.value = "";
      });
      function parseMatrixFromInputs() {
        var text = valueElsePlaceholder(txtMatrix);
        var ensureUnitary = chkFix.checked;
        return parseUserMatrix(text, ensureUnitary);
      }
      var redraw = function() {
        return computeAndPaintOp(matrixCanvas, parseMatrixFromInputs, matrixButton);
      };
      Observable.of(obsOnShown, textEditObservable(txtMatrix), Observable.elementEvent(chkFix, 'change')).flatten().throttleLatest(100).subscribe(redraw);
      matrixButton.addEventListener('click', function() {
        var mat;
        try {
          mat = parseMatrixFromInputs();
        } catch (ex) {
          console.warn(ex);
          return;
        }
        var name = txtName.value.trim();
        var h = Math.round(Math.log2(mat.height()));
        var gate = new GateBuilder().setSerializedId('~' + Math.floor(Math.random() * (1 << 20)).toString(32)).setSymbol(name).setTitle('Custom Matrix Gate').setHeight(h).setWidth(name === '' ? h : 1).setKnownEffectToMatrix(mat).gate;
        createCustomGateAndClose(gate);
      });
    })();
    (function() {
      var circuitCanvas = document.getElementById('gate-forge-circuit-canvas');
      var txtCols = document.getElementById('gate-forge-circuit-cols');
      var txtRows = document.getElementById('gate-forge-circuit-rows');
      var spanInputs = document.getElementById('gate-forge-circuit-inputs');
      var spanWeight = document.getElementById('gate-forge-circuit-weight');
      var circuitButton = document.getElementById('gate-forge-circuit-button');
      var txtName = document.getElementById('gate-forge-circuit-name');
      obsOnShown.subscribe(function() {
        txtName.value = "";
      });
      function parseEnteredCircuitGate() {
        var circuit = fromJsonText_CircuitDefinition(latestInspectorText);
        var gate = parseUserGateFromCircuitRange(circuit, valueElsePlaceholder(txtCols), valueElsePlaceholder(txtRows), txtName.value.trim());
        return {
          gate: gate,
          circuit: circuit
        };
      }
      var latestGate = new ObservableValue(undefined);
      var drawGate = function(painter, gate) {
        return drawCircuitTooltip(painter, gate.knownCircuitNested, new Rect(0, 0, circuitCanvas.width, circuitCanvas.height), true, getCircuitCycleTime());
      };
      latestGate.observable().zipLatest(obsForgeIsShowing, function(g, s) {
        return s ? g : undefined;
      }).map(function(e) {
        return e === undefined || e.gate.stableDuration() === Infinity ? Observable.of() : Observable.requestAnimationTicker().map(function(_) {
          return e;
        });
      }).flattenLatest().subscribe(function(e) {
        var painter = new Painter(circuitCanvas);
        painter.clear();
        drawGate(painter, e.gate);
      });
      var redraw = function() {
        circuitButton.disabled = true;
        var painter = new Painter(circuitCanvas);
        painter.clear();
        try {
          var gate = parseEnteredCircuitGate().gate;
          var keys = gate.getUnmetContextKeys();
          spanInputs.innerText = keys.size === 0 ? "(none)" : $traceurRuntime.spread(keys).map(function(e) {
            return e.replace("Input Range ", "").replace("Input NO_DEFAULT Range ", "");
          }).join(", ");
          spanWeight.innerText = "" + gate.knownCircuit.gateWeight();
          drawGate(painter, gate);
          circuitButton.disabled = false;
          latestGate.set({gate: gate});
        } catch (ex) {
          latestGate.set(undefined);
          spanInputs.innerText = "(err)";
          spanWeight.innerText = "(err)";
          painter.printParagraph(ex + "", new Rect(0, 0, circuitCanvas.width, circuitCanvas.height), new Point(0.5, 0.5), 'red', 24);
        }
      };
      Observable.of(obsOnShown, textEditObservable(txtCols), textEditObservable(txtRows)).flatten().throttleLatest(100).subscribe(redraw);
      circuitButton.addEventListener('click', function() {
        try {
          var $__1 = parseEnteredCircuitGate(),
              gate = $__1.gate,
              circuit = $__1.circuit;
          createCustomGateAndClose(gate, circuit);
        } catch (ex) {
          console.warn(ex);
        }
      });
    })();
  }
  function valueElsePlaceholder(textBox) {
    return textBox.value === '' ? textBox.placeholder : textBox.value;
  }
  function parseUserAngle(text) {
    var c = Complex.parse(text);
    if (c.imag !== 0 || isNaN(c.imag)) {
      throw new Error("You just had to make it complicated, didn't you?");
    }
    return c.real * Math.PI / 180;
  }
  function decreasePrecisionAndSerializedSize(matrix) {
    return Matrix.parse(matrix.toString(new Format(true, 0.0000001, 7, ",")));
  }
  function parseUserRotation(angleText, phaseText, axisText) {
    var $__3,
        $__4;
    var w = parseUserAngle(angleText);
    var phase = parseUserAngle(phaseText);
    var $__1 = Axis.parse(axisText),
        x = $__1.x,
        y = $__1.y,
        z = $__1.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    x /= len;
    y /= len;
    z /= len;
    var $__2 = [Matrix.identity(2), Matrix.PAULI_X, Matrix.PAULI_Y, Matrix.PAULI_Z],
        I = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        X = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        Y = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        Z = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    var axisMatrix = X.times(x).plus(Y.times(y)).plus(Z.times(z));
    var result = I.times(Math.cos(w / 2)).plus(axisMatrix.times(Complex.I.neg()).times(Math.sin(w / 2))).times(Complex.polar(1, phase));
    if (result.hasNaN()) {
      throw new DetailedError("NaN", {
        x: x,
        y: y,
        z: z,
        result: result
      });
    }
    return decreasePrecisionAndSerializedSize(result);
  }
  function parseUserGateMatrix_noCorrection(text) {
    var $__5;
    if (text.match(/[\{}\[\]]/)) {
      return Matrix.parse(text.split(/[\{\[]/).join('{').split(/[}\]]/).join('}'));
    }
    text = text.split(/,?\s*\n\s*(?!$)/).join(',');
    text = text.trim();
    if (text.endsWith(',')) {
      text = text.substring(0, text.length - 1);
    }
    var parts = text.split(',').map(function(e) {
      return e === '' ? 0 : Complex.parse(e);
    });
    if (parts.length === 1) {
      parts.push(0, 0, parts[0]);
    }
    var n = Math.max(4, 1 << (2 * Math.max(1, Util.floorLg2(Math.sqrt(parts.length)))));
    if (n < parts.length) {
      n <<= 2;
    }
    if (n > (1 << 8)) {
      throw Error("Max custom matrix operation size is 4 qubits.");
    }
    return ($__5 = Matrix).square.apply($__5, $traceurRuntime.spread(parts, new Array(n - parts.length).fill(0)));
  }
  function parseUserMatrix(text, ensureUnitary) {
    var op = parseUserGateMatrix_noCorrection(text);
    if (op.width() !== op.height() || op.width() < 2 || op.width() > 16 || !Util.isPowerOf2(op.width())) {
      throw Error("Matrix must be 2x2, 4x4, 8x8, or 16x16.");
    }
    if (ensureUnitary && !op.hasNaN()) {
      op = op.closestUnitary(0.0001);
      op = decreasePrecisionAndSerializedSize(op);
    }
    return op;
  }
  function parseRange(text, maxLen) {
    var parts = text.split(":").map(function(e) {
      return e.trim();
    });
    if (parts.length > 2) {
      throw new Error("Too many colons.");
    }
    var infinities = [undefined, "", "∞"];
    var min = parseInt(parts[0] || "1");
    var max = infinities.indexOf(parts[1]) !== -1 ? Infinity : parseInt(parts[1]);
    if (isNaN(min)) {
      throw new Error("Not a number: " + parts[0]);
    }
    if (isNaN(max)) {
      throw new Error("Not a number: " + parts[1]);
    }
    var start = Math.min(maxLen, Math.max(0, min - 1));
    var end = Math.min(maxLen, Math.max(start, max));
    return {
      start: start,
      end: end
    };
  }
  function removeBrokenGates(circuit) {
    var w = circuit.columns.length;
    var h = circuit.numWires;
    return circuit.withColumns(seq(circuit.columns).mapWithIndex(function(col, c) {
      return new GateColumn(seq(col.gates).mapWithIndex(function(gate, r) {
        return gate === undefined || c + gate.width > w || r + gate.height > h ? undefined : gate;
      }).toArray());
    }).toArray());
  }
  function parseUserGateFromCircuitRange(circuit, colRangeText, wireRangeText, nameText) {
    var colRange = parseRange(colRangeText, circuit.columns.length);
    var rowRange = parseRange(wireRangeText, circuit.numWires);
    if (rowRange.end === rowRange.start) {
      throw new Error("Empty wire range.");
    }
    var cols = circuit.columns.slice(colRange.start, colRange.end).map(function(col) {
      return new GateColumn(col.gates.slice(rowRange.start, rowRange.end));
    });
    var gateCircuit = new CircuitDefinition(rowRange.end - rowRange.start, cols);
    gateCircuit = removeBrokenGates(gateCircuit);
    gateCircuit = gateCircuit.withUncoveredColumnsRemoved();
    if (gateCircuit.columns.length === 0) {
      throw new Error("No gates in included range.");
    }
    var symbol = nameText;
    var id = '~' + Math.floor(Math.random() * (1 << 20)).toString(32);
    return setGateBuilderEffectToCircuit(new GateBuilder(), gateCircuit).setSerializedId(id).setSymbol(symbol).setTitle(id).setBlurb('A custom gate.').gate;
  }
  return {
    get initForge() {
      return initForge;
    },
    get obsForgeIsShowing() {
      return obsForgeIsShowing;
    },
    get parseUserRotation() {
      return parseUserRotation;
    },
    get parseUserMatrix() {
      return parseUserMatrix;
    },
    get parseUserGateFromCircuitRange() {
      return parseUserGateFromCircuitRange;
    }
  };
});
//# sourceURL=src/ui/forge.js
;$traceurRuntime.registerModule("src/ui/Hand.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/Hand.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Describe.js", "src/ui/Hand.js")).describe;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/ui/Hand.js")).DetailedError;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Gate.js", "src/ui/Hand.js")).Gate;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/GateColumn.js", "src/ui/Hand.js")).GateColumn;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Point.js", "src/ui/Hand.js")).Point;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/ui/Hand.js")).Util;
  var Hand = function() {
    function Hand(pos, heldGate, holdOffset, heldColumn, heldRow, resizingGateSlot) {
      var args = {
        pos: pos,
        heldGate: heldGate,
        holdOffset: holdOffset,
        heldColumn: heldColumn,
        heldRow: heldRow,
        resizingGateSlot: resizingGateSlot
      };
      if (pos !== undefined && !(pos instanceof Point)) {
        throw new DetailedError("Bad pos", args);
      }
      if (heldGate !== undefined && !(heldGate instanceof Gate)) {
        throw new DetailedError("Bad heldGate", args);
      }
      if (holdOffset !== undefined && !(holdOffset instanceof Point)) {
        throw new DetailedError("Bad holdOffset", args);
      }
      if (resizingGateSlot !== undefined && !(resizingGateSlot instanceof Point)) {
        throw new DetailedError("Bad resizingGateSlot", args);
      }
      if (heldColumn !== undefined && !(heldColumn instanceof GateColumn)) {
        throw new DetailedError("Bad heldColumn", args);
      }
      if (heldRow !== undefined && !Array.isArray(heldRow.gates)) {
        throw new DetailedError("Bad heldRow", args);
      }
      if (heldGate !== undefined && this.resizingGateSlot !== undefined) {
        throw new DetailedError("Holding AND resizing", args);
      }
      this.pos = pos;
      this.heldGate = heldGate;
      this.holdOffset = holdOffset;
      this.heldColumn = heldColumn;
      this.heldRow = heldRow;
      this.resizingGateSlot = resizingGateSlot;
    }
    return ($traceurRuntime.createClass)(Hand, {
      isHoldingSomething: function() {
        return this.heldGate !== undefined || this.heldColumn !== undefined || this.heldRow !== undefined;
      },
      paintCursor: function(painter) {
        if (this.heldGate !== undefined || this.heldColumn !== undefined) {
          painter.setDesiredCursor('move');
        } else if (this.resizingGateSlot !== undefined) {
          painter.setDesiredCursor('ns-resize');
        }
      },
      isBusy: function() {
        return (this.heldGate !== undefined || this.heldColumn !== undefined || this.resizingGateSlot !== undefined || this.heldRow !== undefined);
      },
      hoverPoints: function() {
        return this.pos === undefined || this.isBusy() ? [] : [this.pos];
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof Hand && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.pos, other.pos) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.holdOffset, other.holdOffset) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.heldGate, other.heldGate) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.heldColumn, other.heldColumn) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.heldRow, other.heldRow) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.resizingGateSlot, other.resizingGateSlot);
      },
      toString: function() {
        return ("Hand(" + describe({
          pos: this.pos,
          heldGate: this.heldGate,
          holdOffset: this.holdOffset,
          heldColumn: this.heldColumn,
          heldRow: this.heldRow,
          resizingGateSlot: this.resizingGateSlot
        }));
      },
      withPos: function(newPos) {
        return new Hand(newPos, this.heldGate, this.holdOffset, this.heldColumn, this.heldRow, this.resizingGateSlot);
      },
      withDrop: function() {
        return new Hand(this.pos, undefined, undefined, undefined, undefined, undefined);
      },
      withHeldGate: function(heldGate, heldGateOffset) {
        return new Hand(this.pos, heldGate, heldGateOffset, undefined, undefined, undefined);
      },
      withHeldGateColumn: function(heldGateColumn, heldGateOffset) {
        return new Hand(this.pos, undefined, heldGateOffset, heldGateColumn, undefined, undefined);
      },
      withHeldRow: function(heldRow, heldGateOffset) {
        return new Hand(this.pos, undefined, heldGateOffset, undefined, heldRow, undefined);
      },
      withResizeSlot: function(resizeSlot, resizeTabOffset) {
        return new Hand(this.pos, undefined, resizeTabOffset, undefined, undefined, resizeSlot);
      },
      stableDuration: function() {
        return this.heldGate !== undefined ? this.heldGate.stableDuration() : this.heldColumn !== undefined ? this.heldColumn.stableDuration() : this.heldRow !== undefined ? new GateColumn(this.heldRow.gates).stableDuration() : Infinity;
      }
    }, {});
  }();
  Hand.EMPTY = new Hand(undefined, undefined, undefined, undefined, undefined, undefined);
  return {get Hand() {
      return Hand;
    }};
});
//# sourceURL=src/ui/Hand.js
;$traceurRuntime.registerModule("src/ui/menu.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/menu.js";
  var ObservableValue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Obs.js", "src/ui/menu.js")).ObservableValue;
  var menuIsVisible = new ObservableValue(true);
  var obsMenuIsShowing = menuIsVisible.observable().whenDifferent();
  var closeMenu = function() {
    return menuIsVisible.set(false);
  };
  var groverLink = {
    "cols": [["X", "X", "X", "X", "X"], ["H", "H", "H", "H", "H"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"]],
    "gates": [{
      "id": "~vn6c",
      "name": "Oracle",
      "circuit": {"cols": [["Z", "•", "◦", "•", "•"]]}
    }]
  };
  var teleportLink = {
    "cols": [[1, "H"], [1, "•", 1, 1, "X"], ["…", "…", 1, 1, "…"], ["…", "…", 1, 1, "…"], ["~87lj"], ["Bloch"], ["•", "X"], ["H"], ["Measure", "Measure"], [1, "•", 1, 1, "X"], ["•", 1, 1, 1, "Z"], [1, 1, 1, 1, "Bloch"], [1, 1, 1, 1, "~f7c0"]],
    "gates": [{
      "id": "~87lj",
      "name": "message",
      "circuit": {"cols": [["e^-iYt"], ["X^t"]]}
    }, {
      "id": "~f7c0",
      "name": "received",
      "matrix": "{{1,0},{0,1}}"
    }]
  };
  var eraserLink = {
    "cols": [[1, "H"], [1, "•", 1, 1, "X"], [1, "~slits", "QFT7"], [1, 1, "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure"], ["…", "…", "Chance7"], ["…", "…"], ["…", "…"], ["…", "…"], ["H"], ["Measure"], ["~choice"], ["•", "X^½"], [1, "Measure"], [1, "~result", 1, 1, 1, "~flat"], ["◦", "◦", "Chance7"], ["◦", "•", "Chance7"], [1, 1, 1, 1, 1, "~waves"], ["•", "◦", "Chance7"], ["•", "•", "Chance7"]],
    "gates": [{
      "id": "~choice",
      "name": "choice",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~result",
      "name": "result",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~flat",
      "name": "flat",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~waves",
      "name": "waves",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~slits",
      "name": "slits",
      "matrix": "{{1,0},{0,1}}"
    }]
  };
  var chshTestLink = {
    "cols": [["H"], ["◦", 1, 1, 1, "X"], ["X^-¼"], ["…", "…", "…", "…", "…"], ["~da85", "~5s2n", 1, "~5s2n", "~ahov"], [1, "H", 1, "H"], [1, "Measure", 1, "Measure"], ["X^½", "•"], [1, 1, 1, "•", "X^½"], ["Measure", 1, 1, 1, "Measure"], ["…", "…", "…", "…", "…"], [1, "•", "X", "•"], ["•", 1, "X"], [1, 1, "X", 1, "•"], [1, 1, "Chance"], [1, 1, "~q6e"]],
    "gates": [{
      "id": "~da85",
      "name": "Alice",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~ahov",
      "name": "Bob",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~5s2n",
      "name": "Referee",
      "matrix": "{{1,0},{0,1}}"
    }, {
      "id": "~q6e",
      "name": "Win?",
      "matrix": "{{1,0},{0,1}}"
    }]
  };
  var additionLink = {"cols": [["Counting5", 1, 1, 1, 1, 1, 1, 1, "X"], ["Chance5", 1, 1, 1, 1, "Chance5"], ["X", "X", "X", "X", "•", "X", "X", "X", "X", "X"], [1, 1, 1, 1, "•", "X"], ["Swap", 1, 1, 1, "Swap", "•"], [1, 1, 1, 1, "•", 1, "X"], [1, "Swap", 1, 1, "Swap", 1, "•"], [1, 1, 1, 1, "•", 1, 1, "X"], [1, 1, "Swap", 1, "Swap", 1, 1, "•"], [1, 1, 1, 1, "•", 1, 1, 1, "X"], [1, 1, 1, "Swap", "Swap", 1, 1, 1, "•"], [1, 1, 1, 1, "•", 1, 1, 1, 1, "X"], [1, 1, 1, "Swap", "Swap", 1, 1, 1, "•"], [1, 1, 1, "•", 1, 1, 1, 1, "X"], [1, 1, "Swap", 1, "Swap", 1, 1, "•"], [1, 1, "•", 1, 1, 1, 1, "X"], [1, "Swap", 1, 1, "Swap", 1, "•"], [1, "•", 1, 1, 1, 1, "X"], ["Swap", 1, 1, 1, "Swap", "•"], ["•", 1, 1, 1, 1, "X"], ["X", "X", "X", "X", "•", "X", "X", "X", "X", "X"], ["Chance5", 1, 1, 1, 1, "Chance5"]]};
  var qftLink = {"cols": [["Counting8"], ["Chance8"], ["…", "…", "…", "…", "…", "…", "…", "…"], ["Swap", 1, 1, 1, 1, 1, 1, "Swap"], [1, "Swap", 1, 1, 1, 1, "Swap"], [1, 1, "Swap", 1, 1, "Swap"], [1, 1, 1, "Swap", "Swap"], ["H"], ["Z^½", "•"], [1, "H"], ["Z^¼", "Z^½", "•"], [1, 1, "H"], ["Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, "H"], ["Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, "H"], ["Z^⅟₃₂", "Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, 1, "H"], ["Z^⅟₆₄", "Z^⅟₃₂", "Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, 1, 1, "H"], ["Z^⅟₁₂₈", "Z^⅟₆₄", "Z^⅟₃₂", "Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, 1, 1, 1, "H"]]};
  var superdenseCodingLink = {
    "cols": [[1, 1, "H"], [1, 1, "•", 1, 1, 1, "X"], ["…", "…", "…", "…", "…", "…", "…"], ["Counting2"], ["Measure", "Measure"], ["~msg"], ["Chance", "Chance"], ["~enc"], [1, "•", "X"], ["•", 1, "Z"], [1, 1, 1, "~send"], [1, 1, "Swap", 1, 1, "Swap"], [1, 1, 1, 1, 1, "~dec"], [1, 1, 1, 1, 1, "•", "X"], [1, 1, 1, 1, 1, "H"], [1, 1, 1, 1, 1, "Measure", "Measure"], [1, 1, 1, 1, 1, "~msg"], [1, 1, 1, 1, 1, "Chance", "Chance"]],
    "gates": [{
      "id": "~msg",
      "name": "message",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~enc",
      "name": "encode",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~send",
      "name": "send",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~dec",
      "name": "decode",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }]
  };
  var symmetryBreakingLink = {
    "cols": [["~tpqg", 1, "~r2ku"], ["…", "…", "…", "…"], ["H"], [1, 1, "H"], ["•", "X"], [1, 1, "•", "X"], [1, "Swap", 1, "Swap"], ["•", "X"], [1, 1, "•", "X"], ["X^½", "◦"], [1, 1, "X^½", "◦"], [1, "X^½"], [1, 1, 1, "X^½"], ["Measure", "Measure", "Measure", "Measure"], [1, "~57au"], ["•", 1, "Chance"], [1, "•", 1, "Chance"], ["◦", 1, "Chance"], [1, "◦", 1, "Chance"]],
    "gates": [{
      "id": "~tpqg",
      "name": "Alice^1",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~r2ku",
      "name": "Alice^2",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~57au",
      "name": "disagree",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }]
  };
  var shorLink = {
    "cols": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "~input", 1, 1, 1, "~guess"], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, {
      "id": "setR",
      "arg": 55
    }, 1, 1, 1, {
      "id": "setB",
      "arg": 26
    }], [], ["H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "X"], ["inputA10", 1, 1, 1, 1, 1, 1, 1, 1, 1, "*BToAmodR6"], ["QFT†10"], [1, 1, 1, 1, "~out"], ["Chance10"]],
    "gates": [{
      "id": "~guess",
      "name": "guess:",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~input",
      "name": "input:",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }, {
      "id": "~out",
      "name": "out:",
      "matrix": "{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}"
    }]
  };
  var distillLink = {"cols": [["H", "H", "H", "H", "H"], [1, "Z", "Z", "Z", 1, "⊖"], [1, "Z", "Z", 1, "Z", 1, "⊖"], [1, "Z", 1, "Z", "Z", 1, 1, "⊖"], [1, 1, "Z", "Z", "Z", 1, 1, 1, "⊖"], ["Z", "Z", "Z", "Z", "Z", 1, 1, 1, 1, "⊖"], ["Z", 1, 1, "Z", "Z", 1, 1, 1, 1, 1, "⊖"], ["Z", 1, "Z", 1, "Z", 1, 1, 1, 1, 1, 1, "⊖"], ["Z", "Z", 1, 1, "Z", 1, 1, 1, 1, 1, 1, 1, "⊖"], ["Z", 1, "Z", "Z", 1, 1, 1, 1, 1, 1, 1, 1, 1, "⊖"], ["Z", "Z", 1, "Z", 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "⊖"], ["Z", "Z", "Z", 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "⊖"], [1, "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼", "Z^¼"], [1, "H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "H"], [1, "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure"], [1, "X", "X", "X", 1, "•"], [1, "X", "X", 1, "X", 1, "•"], [1, "X", 1, "X", "X", 1, 1, "•"], [1, 1, "X", "X", "X", 1, 1, 1, "•"], ["Z", "X", "X", "X", "X", 1, 1, 1, 1, "•"], ["Z", 1, 1, "X", "X", 1, 1, 1, 1, 1, "•"], ["Z", 1, "X", 1, "X", 1, 1, 1, 1, 1, 1, "•"], ["Z", "X", 1, 1, "X", 1, 1, 1, 1, 1, 1, 1, "•"], ["Z", 1, "X", "X", 1, 1, 1, 1, 1, 1, 1, 1, 1, "•"], ["Z", "X", 1, "X", 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "•"], ["Z", "X", "X", 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "•"], ["X", "Chance4"], ["Amps1", "|0⟩⟨0|", "|0⟩⟨0|", "|0⟩⟨0|", "|0⟩⟨0|"]]};
  function initMenu(revision, obsIsAnyOverlayShowing) {
    var $__11,
        $__12;
    (function() {
      var menuButton = document.getElementById('menu-button');
      var closeMenuButton = document.getElementById('close-menu-button');
      var menuOverlay = document.getElementById('menu-overlay');
      var menutDiv = document.getElementById('menu-div');
      menuButton.addEventListener('click', function() {
        return menuIsVisible.set(true);
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        menuButton.disabled = e;
      });
      menuOverlay.addEventListener('click', function() {
        return menuIsVisible.set(false);
      });
      closeMenuButton.addEventListener('click', function() {
        return menuIsVisible.set(false);
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          menuIsVisible.set(false);
        }
      });
      obsMenuIsShowing.subscribe(function(showing) {
        menutDiv.style.display = showing ? 'block' : 'none';
        if (showing) {
          document.getElementById('export-link-copy-button').focus();
        }
      });
    })();
    var groverAnchor = document.getElementById('example-anchor-grover');
    var teleportAnchor = document.getElementById('example-anchor-teleport');
    var eraserAnchor = document.getElementById('example-anchor-delayed-eraser');
    var additionAnchor = document.getElementById('example-addition');
    var superdenseCodeAnchor = document.getElementById('example-superdense-coding');
    var symmetryBreakAnchor = document.getElementById('example-symmetry-break');
    var chshTestAnchor = document.getElementById('example-chsh-test');
    var qftAnchor = document.getElementById('example-qft');
    var shorAnchor = document.getElementById('example-anchor-shor');
    var distillAnchor = document.getElementById('example-anchor-distill');
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      var $__13 = function() {
        var $__10 = $__4.value,
            a = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
            t = ($__12 = $__11.next()).done ? void 0 : $__12.value;
        {
          var text = JSON.stringify(t);
          a.href = "#circuit=" + text;
          a.onclick = function(ev) {
            if (ev.shiftKey || ev.ctrlKey || ev.altKey || ev.which !== 1) {
              return undefined;
            }
            revision.commit(text);
            menuIsVisible.set(false);
            return false;
          };
        }
      };
      for (var $__4 = void 0,
          $__3 = ([[groverAnchor, groverLink], [shorAnchor, shorLink], [teleportAnchor, teleportLink], [eraserAnchor, eraserLink], [additionAnchor, additionLink], [superdenseCodeAnchor, superdenseCodingLink], [symmetryBreakAnchor, symmetryBreakingLink], [chshTestAnchor, chshTestLink], [qftAnchor, qftLink], [distillAnchor, distillLink]])[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        $__13();
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
  }
  return {
    get initMenu() {
      return initMenu;
    },
    get obsMenuIsShowing() {
      return obsMenuIsShowing;
    },
    get closeMenu() {
      return closeMenu;
    }
  };
});
//# sourceURL=src/ui/menu.js
;$traceurRuntime.registerModule("src/ui/sim.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/sim.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitDefinition.js", "src/ui/sim.js")).CircuitDefinition;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/sim.js")).Config;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitStats.js", "src/ui/sim.js")).CircuitStats;
  var getCircuitCycleTime = (function() {
    var _circuitCycleTime = 0;
    var _prevRealTime = performance.now();
    return function() {
      var nextRealTime = performance.now();
      var elapsed = (nextRealTime - _prevRealTime) / Config.CYCLE_DURATION_MS;
      _circuitCycleTime += elapsed;
      _circuitCycleTime %= 1;
      _prevRealTime = nextRealTime;
      return _circuitCycleTime;
    };
  })();
  var _cachedStats = undefined;
  function simulate(circuit) {
    if (_cachedStats !== undefined && _cachedStats.circuitDefinition.isEqualTo(circuit)) {
      return _cachedStats.withTime(getCircuitCycleTime());
    }
    _cachedStats = undefined;
    var result = CircuitStats.fromCircuitAtTime(circuit, getCircuitCycleTime());
    if (circuit.stableDuration() === Infinity) {
      _cachedStats = result;
    }
    return result;
  }
  return {
    get simulate() {
      return simulate;
    },
    get getCircuitCycleTime() {
      return getCircuitCycleTime;
    }
  };
});
//# sourceURL=src/ui/sim.js
;$traceurRuntime.registerModule("src/ui/title.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/title.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/title.js")).Config;
  var fromJsonText_CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Serializer.js", "src/ui/title.js")).fromJsonText_CircuitDefinition;
  function initTitleSync(revision) {
    var titleForState = function(jsonText) {
      try {
        var circuitDef = fromJsonText_CircuitDefinition(jsonText);
        if (!circuitDef.isEmpty()) {
          return ("Quirk: " + circuitDef.readableHash());
        }
      } catch (_) {}
      return Config.EMPTY_CIRCUIT_TITLE;
    };
    revision.latestActiveCommit().subscribe(function(jsonText) {
      setTimeout(function() {
        document.title = titleForState(jsonText);
      }, 0);
    });
  }
  return {get initTitleSync() {
      return initTitleSync;
    }};
});
//# sourceURL=src/ui/title.js
;$traceurRuntime.registerModule("src/ui/undo.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/undo.js";
  function initUndoRedo(revision, obsIsAnyOverlayShowing) {
    var overlay_divs = [document.getElementById('gate-forge-div'), document.getElementById('export-div')];
    var undoButton = document.getElementById('undo-button');
    var redoButton = document.getElementById('redo-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, function(_, b) {
      return b;
    }).subscribe(function(anyShowing) {
      undoButton.disabled = revision.isAtBeginningOfHistory() || anyShowing;
      redoButton.disabled = revision.isAtEndOfHistory() || anyShowing;
    });
    undoButton.addEventListener('click', function() {
      return revision.undo();
    });
    redoButton.addEventListener('click', function() {
      return revision.redo();
    });
    document.addEventListener("keydown", function(e) {
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = (overlay_divs)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var div = $__1.value;
          {
            if (div.style.display !== 'NONE' && div.style.display !== 'none') {
              return;
            }
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
      var Y_KEY = 89;
      var Z_KEY = 90;
      var isUndo = e.keyCode === Z_KEY && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
      var isRedo1 = e.keyCode === Z_KEY && e.ctrlKey && e.shiftKey && !e.altKey && !e.metaKey;
      var isRedo2 = e.keyCode === Y_KEY && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
      if (isUndo) {
        revision.undo();
        e.preventDefault();
      }
      if (isRedo1 || isRedo2) {
        revision.redo();
        e.preventDefault();
      }
    });
  }
  return {get initUndoRedo() {
      return initUndoRedo;
    }};
});
//# sourceURL=src/ui/undo.js
;$traceurRuntime.registerModule("src/ui/url.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/url.js";
  var notifyAboutRecoveryFromUnexpectedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../fallback.js", "src/ui/url.js")).notifyAboutRecoveryFromUnexpectedError;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/CircuitDefinition.js", "src/ui/url.js")).CircuitDefinition;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/ui/url.js")).Config;
  var HistoryPusher = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../browser/HistoryPusher.js", "src/ui/url.js")).HistoryPusher;
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../circuit/Serializer.js", "src/ui/url.js")),
      fromJsonText_CircuitDefinition = $__12.fromJsonText_CircuitDefinition,
      Serializer = $__12.Serializer;
  function urlWithCircuitHash(jsonText) {
    if (jsonText.indexOf('%') !== -1 || jsonText.indexOf('&') !== -1) {
      jsonText = encodeURIComponent(jsonText);
    }
    return "#" + Config.URL_CIRCUIT_PARAM_KEY + "=" + jsonText;
  }
  function initUrlCircuitSync(revision) {
    var getHashParameters = function() {
      var hashText = document.location.hash.substr(1);
      var paramsMap = new Map();
      if (hashText !== "") {
        var $__4 = true;
        var $__5 = false;
        var $__6 = undefined;
        try {
          for (var $__2 = void 0,
              $__1 = (hashText.split("&"))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
            var keyVal = $__2.value;
            {
              var eq = keyVal.indexOf("=");
              if (eq === -1) {
                continue;
              }
              var key = keyVal.substring(0, eq);
              var val = decodeURIComponent(keyVal.substring(eq + 1));
              paramsMap.set(key, val);
            }
          }
        } catch ($__7) {
          $__5 = true;
          $__6 = $__7;
        } finally {
          try {
            if (!$__4 && $__1.return != null) {
              $__1.return();
            }
          } finally {
            if ($__5) {
              throw $__6;
            }
          }
        }
      }
      return paramsMap;
    };
    var historyPusher = new HistoryPusher();
    var loadCircuitFromUrl = function() {
      try {
        historyPusher.currentStateIsMemorableButUnknown();
        var params = getHashParameters();
        if (!params.has(Config.URL_CIRCUIT_PARAM_KEY)) {
          var def = document.DEFAULT_CIRCUIT || JSON.stringify(Serializer.toJson(CircuitDefinition.EMPTY));
          params.set(Config.URL_CIRCUIT_PARAM_KEY, def);
        }
        var jsonText = params.get(Config.URL_CIRCUIT_PARAM_KEY);
        historyPusher.currentStateIsMemorableAndEqualTo(jsonText);
        var circuitDef = fromJsonText_CircuitDefinition(jsonText);
        var cleanedJson = JSON.stringify(Serializer.toJson(circuitDef));
        revision.clear(cleanedJson);
        if (circuitDef.isEmpty() && params.size === 1) {
          historyPusher.currentStateIsNotMemorable();
        } else {
          var urlHash = urlWithCircuitHash(jsonText);
          historyPusher.stateChange(jsonText, urlHash);
        }
      } catch (ex) {
        notifyAboutRecoveryFromUnexpectedError("Defaulted to an empty circuit. Failed to understand circuit from URL.", {document_location_hash: document.location.hash}, ex);
      }
    };
    window.addEventListener('popstate', loadCircuitFromUrl);
    loadCircuitFromUrl();
    revision.latestActiveCommit().whenDifferent().skip(1).subscribe(function(jsonText) {
      historyPusher.stateChange(jsonText, urlWithCircuitHash(jsonText));
    });
  }
  return {get initUrlCircuitSync() {
      return initUrlCircuitSync;
    }};
});
//# sourceURL=src/ui/url.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders_Base.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders_Base.js";
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglArg.js", "src/webgl/ShaderCoders_Base.js")).WglArg;
  var ShaderPart = function() {
    function ShaderPart(code, libs, argsFor) {
      this.code = code;
      this.libs = libs;
      this.argsFor = argsFor;
    }
    return ($traceurRuntime.createClass)(ShaderPart, {}, {});
  }();
  var SingleTypeCoder = function() {
    function SingleTypeCoder(inputPartGetter, outputPart, powerSizeOverhead, pixelType, dataToPixels, pixelsToData, needRearrangingToBeInVec4Format) {
      this.inputPartGetter = inputPartGetter;
      this.outputPart = outputPart;
      this.powerSizeOverhead = powerSizeOverhead;
      this.pixelType = pixelType;
      this.dataToPixels = dataToPixels;
      this.pixelsToData = pixelsToData;
      this.needRearrangingToBeInVec4Format = needRearrangingToBeInVec4Format;
    }
    return ($traceurRuntime.createClass)(SingleTypeCoder, {arrayPowerSizeOfTexture: function(tex) {
        return Math.max(0, tex.sizePower() - this.powerSizeOverhead);
      }}, {});
  }();
  var ShaderCoder = function() {
    function ShaderCoder(bool, float, vec2, vec4) {
      this.bool = bool;
      this.float = float;
      this.vec2 = vec2;
      this.vec4 = vec4;
    }
    return ($traceurRuntime.createClass)(ShaderCoder, {}, {});
  }();
  function boolInputPartGetter(name) {
    var pre = ("_gen_" + name);
    return new ShaderPart(("\n        ///////////// boolInput(" + name + ") ////////////\n        uniform sampler2D " + pre + "_tex;\n        uniform vec2 " + pre + "_size;\n\n        float read_" + name + "(float k) {\n            vec2 uv = vec2(mod(k, " + pre + "_size.x) + 0.5,\n                           floor(k / " + pre + "_size.x) + 0.5) / " + pre + "_size;\n            return float(texture2D(" + pre + "_tex, uv).x == 1.0);\n        }\n\n        float len_" + name + "() {\n            return " + pre + "_size.x * " + pre + "_size.y * 4.0;\n        }"), [], function(texture) {
      return [WglArg.texture((pre + "_tex"), texture), WglArg.vec2((pre + "_size"), texture.width, texture.height)];
    });
  }
  var BOOL_OUTPUT_PART = new ShaderPart("\n    ///////////// BOOL_OUTPUT_AS_FLOAT ////////////\n    bool outputFor(float k);\n\n    uniform vec2 _gen_output_size;\n    uniform float _gen_secret_half;\n\n    float len_output() {\n        return _gen_output_size.x * _gen_output_size.y;\n    }\n\n    void main() {\n        vec2 xy = gl_FragCoord.xy - vec2(_gen_secret_half, _gen_secret_half);\n        float k = xy.y * _gen_output_size.x + xy.x;\n        gl_FragColor = vec4(float(outputFor(k)), 0.0, 0.0, 0.0);\n    }", [], function(texture) {
    return [WglArg.vec2('_gen_output_size', texture.width, texture.height), WglArg.float('_gen_secret_half', 0.5)];
  });
  var BOOL_TYPE_CODER = new SingleTypeCoder(boolInputPartGetter, BOOL_OUTPUT_PART, 0, WebGLRenderingContext.UNSIGNED_BYTE, function(e) {
    return e;
  }, function(e) {
    return e;
  }, false);
  return {
    get SingleTypeCoder() {
      return SingleTypeCoder;
    },
    get ShaderCoder() {
      return ShaderCoder;
    },
    get ShaderPart() {
      return ShaderPart;
    },
    get BOOL_TYPE_CODER() {
      return BOOL_TYPE_CODER;
    }
  };
});
//# sourceURL=src/webgl/ShaderCoders_Base.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders_intoBytes.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders_intoBytes.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/webgl/ShaderCoders_intoBytes.js")).DetailedError;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglArg.js", "src/webgl/ShaderCoders_intoBytes.js")).WglArg;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/webgl/ShaderCoders_intoBytes.js")).Seq;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders_Base.js", "src/webgl/ShaderCoders_intoBytes.js")),
      ShaderPart = $__4.ShaderPart,
      SingleTypeCoder = $__4.SingleTypeCoder,
      ShaderCoder = $__4.ShaderCoder,
      BOOL_TYPE_CODER = $__4.BOOL_TYPE_CODER;
  function floatsAsBytes(floats) {
    if (floats instanceof Float64Array) {
      return new Uint8Array(new Float32Array(floats).buffer, 0, floats.length << 2);
    }
    if (floats instanceof Float32Array) {
      return new Uint8Array(floats.buffer, 0, floats.length << 2);
    }
    throw new DetailedError("Not a Float32Array or Float64Array", {
      type: (typeof floats === 'undefined' ? 'undefined' : $traceurRuntime.typeof(floats)),
      floats: floats
    });
  }
  function bytesAsFloats(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new DetailedError("Not a Uint8Array", {
        type: (typeof bytes === 'undefined' ? 'undefined' : $traceurRuntime.typeof(bytes)),
        bytes: bytes
      });
    }
    return new Float32Array(bytes.buffer, 0, bytes.length >> 2);
  }
  var PACK_FLOAT_INTO_BYTES_CODE = "\n    //////////// PACK_FLOAT_INTO_BYTES /////////////\n    vec4 _gen_packFloatIntoBytes(float val) {\n        if (val == 0.0) {\n            // If log2(0) returns -Infinity, then the logic below would work out just right and this IF block\n            // wouldn't be needed. Unfortunately, log2(0) isn't guaranteed to do that (it's undefined by the spec).\n            return vec4(0.0, 0.0, 0.0, 0.0);\n        }\n\n        float mag = abs(val);\n        float exponent = floor(log2(mag));\n        // Correct log2 approximation errors.\n        exponent += float(exp2(exponent) <= mag / 2.0);\n        exponent -= float(exp2(exponent) > mag);\n\n        float mantissa;\n        if (exponent > 100.0) {\n            // Not sure why this needs to be done in two steps for the largest float to work. Best guess is the\n            // optimizer is rewriting '/ exp2(e)' into '* exp2(-e)', but exp2(-128.0) is too small to represent.\n            mantissa = mag / 1024.0 / exp2(exponent - 10.0) - 1.0;\n        } else {\n            mantissa = mag / float(exp2(exponent)) - 1.0;\n        }\n\n        exponent += 127.0;\n        float a = float(val < 0.0) * 128.0 + floor(exponent / 2.0);\n        mantissa *= 128.0;\n        float b = mod(exponent, 2.0) * 128.0 + floor(mantissa);\n        mantissa -= floor(mantissa);\n        mantissa *= 256.0;\n        float c = floor(mantissa);\n        mantissa -= c;\n        mantissa *= 256.0;\n        float d = floor(mantissa);\n\n        return vec4(d, c, b, a) / 255.0;\n    }";
  var UNPACK_BYTES_INTO_FLOAT_CODE = "\n    //////////// UNPACK_BYTES_INTO_FLOAT_CODE /////////////\n    float _gen_unpackBytesIntoFloat(vec4 v) {\n        float d = floor(v.r * 255.0 + 0.5);\n        float c = floor(v.g * 255.0 + 0.5);\n        float b = floor(v.b * 255.0 + 0.5);\n        float a = floor(v.a * 255.0 + 0.5);\n\n        float sign = floor(a / 128.0);\n        sign = 1.0 - sign * 2.0;\n\n        float exponent = mod(a, 128.0) * 2.0 + floor(b / 128.0) - 127.0;\n        float mantissa = float(exponent > -127.0)\n                       + mod(b, 128.0) / 128.0\n                       + c / 32768.0\n                       + d / 8388608.0;\n        return sign * mantissa * exp2(exponent);\n    }";
  function makeByteCoderInput(vecSize, name) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    var pre = ("_gen_" + name);
    return new ShaderPart(("\n        ///////////// makeByteCoderInput(" + vecSize + ", " + name + ") ////////////\n        uniform sampler2D " + pre + "_tex;\n        uniform vec2 " + pre + "_size;\n\n        " + type + " read_" + name + "(float k) {\n            k *= " + vecSize + ".0;\n            vec2 uv = vec2(mod(k, " + pre + "_size.x) + 0.5,\n                           floor(k / " + pre + "_size.x) + 0.5) / " + pre + "_size;\n\n            " + Seq.range(vecSize).map(function(i) {
      return ("\n                vec2 uv" + i + " = uv + vec2(" + i + ".0 / " + pre + "_size.x, 0.0);\n                vec4 bytes" + i + " = texture2D(" + pre + "_tex, uv" + i + ");");
    }).join('') + "\n\n            return " + type + "(" + Seq.range(vecSize).map(function(i) {
      return ("\n                _gen_unpackBytesIntoFloat(bytes" + i + ")");
    }).join(',') + ");\n        }\n\n        float len_" + name + "() {\n            return " + pre + "_size.x * " + pre + "_size.y / " + vecSize + ".0;\n        }"), [UNPACK_BYTES_INTO_FLOAT_CODE], function(texture) {
      if (texture.pixelType !== WebGLRenderingContext.UNSIGNED_BYTE) {
        throw new DetailedError("vec2Input_Byte requires byte texture", {
          name: name,
          texture: texture
        });
      }
      return [WglArg.texture((pre + "_tex"), texture), WglArg.vec2((pre + "_size"), texture.width, texture.height)];
    });
  }
  function makeByteCoderOutput(vecSize) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    return new ShaderPart(("\n        ///////////// makeByteCoderOutput" + vecSize + " ////////////\n        " + type + " outputFor(float k);\n\n        uniform vec2 _gen_output_size;\n        uniform float _gen_secret_half;\n\n        float len_output() {\n            return _gen_output_size.x * _gen_output_size.y / " + vecSize + ".0;\n        }\n\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(_gen_secret_half, _gen_secret_half);\n            float k = xy.y * _gen_output_size.x + xy.x;\n            float r = mod(k, " + vecSize + ".0);\n            " + (vecSize === 1 ? 'float component = outputFor(k);' : (type + " result = outputFor(floor(k / " + vecSize + ".0));\n                 " + type + " picker = " + type + "(" + Seq.range(vecSize).map(function(r) {
      return ("float(r == " + r + ".0)");
    }).join(", ") + ");\n                 float component = dot(result, picker);")) + "\n            gl_FragColor = _gen_packFloatIntoBytes(component);\n        }"), [PACK_FLOAT_INTO_BYTES_CODE], function(texture) {
      return [WglArg.vec2('_gen_output_size', texture.width, texture.height), WglArg.float('_gen_secret_half', 0.5)];
    });
  }
  var FLOAT_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeByteCoderInput(1, name);
  }, makeByteCoderOutput(1), 0, WebGLRenderingContext.UNSIGNED_BYTE, floatsAsBytes, bytesAsFloats, false);
  var VEC2_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeByteCoderInput(2, name);
  }, makeByteCoderOutput(2), 1, WebGLRenderingContext.UNSIGNED_BYTE, floatsAsBytes, bytesAsFloats, false);
  var VEC4_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeByteCoderInput(4, name);
  }, makeByteCoderOutput(4), 2, WebGLRenderingContext.UNSIGNED_BYTE, floatsAsBytes, bytesAsFloats, false);
  var SHADER_CODER_BYTES = new ShaderCoder(BOOL_TYPE_CODER, FLOAT_TYPE_CODER, VEC2_TYPE_CODER, VEC4_TYPE_CODER);
  return {
    get SHADER_CODER_BYTES() {
      return SHADER_CODER_BYTES;
    },
    get floatsAsBytes() {
      return floatsAsBytes;
    },
    get bytesAsFloats() {
      return bytesAsFloats;
    },
    get UNPACK_BYTES_INTO_FLOAT_CODE() {
      return UNPACK_BYTES_INTO_FLOAT_CODE;
    },
    get PACK_FLOAT_INTO_BYTES_CODE() {
      return PACK_FLOAT_INTO_BYTES_CODE;
    }
  };
});
//# sourceURL=src/webgl/ShaderCoders_intoBytes.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders_intoFloats.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders_intoFloats.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/webgl/ShaderCoders_intoFloats.js")).DetailedError;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders_Base.js", "src/webgl/ShaderCoders_intoFloats.js")),
      ShaderPart = $__2.ShaderPart,
      SingleTypeCoder = $__2.SingleTypeCoder,
      ShaderCoder = $__2.ShaderCoder,
      BOOL_TYPE_CODER = $__2.BOOL_TYPE_CODER;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglArg.js", "src/webgl/ShaderCoders_intoFloats.js")).WglArg;
  function makeFloatCoderInput(vecSize, name) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    var pre = ("_gen_" + name);
    return new ShaderPart(("\n        ///////////// makeFloatCoderInput(" + vecSize + ", " + name + ") ////////////\n        uniform sampler2D " + pre + "_tex;\n        uniform vec2 " + pre + "_size;\n\n        " + type + " read_" + name + "(float k) {\n            vec2 uv = vec2(mod(k, " + pre + "_size.x) + 0.5,\n                           floor(k / " + pre + "_size.x) + 0.5) / " + pre + "_size;\n            return texture2D(" + pre + "_tex, uv)." + 'xyzw'.substring(0, vecSize) + ";\n        }\n\n        float len_" + name + "() {\n            return " + pre + "_size.x * " + pre + "_size.y;\n        }"), [], function(texture) {
      if (texture.pixelType !== WebGLRenderingContext.FLOAT) {
        throw new DetailedError(("vecInput" + vecSize + "_Float requires float texture"), {
          name: name,
          texture: texture
        });
      }
      return [WglArg.texture((pre + "_tex"), texture), WglArg.vec2((pre + "_size"), texture.width, texture.height)];
    });
  }
  function makeFloatCoderOutput(vecSize) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    var vIntoVec4 = ['vec4(v, 0.0, 0.0, 0.0)', 'vec4(v.x, v.y, 0.0, 0.0)', 'vec4(v.x, v.y, v.z, 0.0)', 'v'][vecSize - 1];
    return new ShaderPart(("\n        ///////////// makeFloatCoderOutput" + vecSize + " ////////////\n        " + type + " outputFor(float k);\n\n        uniform vec2 _gen_output_size;\n        uniform float _gen_secret_half;\n\n        float len_output() {\n            return _gen_output_size.x * _gen_output_size.y;\n        }\n\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(_gen_secret_half, _gen_secret_half);\n            float k = xy.y * _gen_output_size.x + xy.x;\n\n            " + type + " v = outputFor(k);\n\n            gl_FragColor = " + vIntoVec4 + ";\n        }"), [], function(texture) {
      return [WglArg.vec2('_gen_output_size', texture.width, texture.height), WglArg.float('_gen_secret_half', 0.5)];
    });
  }
  function spreadFloatVec1(vec1Data) {
    var result = new Float32Array(vec1Data.length << 2);
    for (var i = 0; i < vec1Data.length; i++) {
      result[4 * i] = vec1Data[i];
    }
    return result;
  }
  function spreadFloatVec2(vec2Data) {
    var result = new Float32Array(vec2Data.length << 1);
    for (var i = 0; i * 2 < vec2Data.length; i++) {
      result[4 * i] = vec2Data[2 * i];
      result[4 * i + 1] = vec2Data[2 * i + 1];
    }
    return result;
  }
  function unspreadFloatVec1(pixelData) {
    var result = new Float32Array(pixelData.length >> 2);
    for (var i = 0; i < result.length; i++) {
      result[i] = pixelData[4 * i];
    }
    return result;
  }
  function unspreadFloatVec2(pixelData) {
    var result = new Float32Array(pixelData.length >> 1);
    for (var i = 0; i * 2 < result.length; i++) {
      result[2 * i] = pixelData[4 * i];
      result[2 * i + 1] = pixelData[4 * i + 1];
    }
    return result;
  }
  var FLOAT_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeFloatCoderInput(1, name);
  }, makeFloatCoderOutput(1), 0, WebGLRenderingContext.FLOAT, spreadFloatVec1, unspreadFloatVec1, true);
  var VEC2_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeFloatCoderInput(2, name);
  }, makeFloatCoderOutput(2), 0, WebGLRenderingContext.FLOAT, spreadFloatVec2, unspreadFloatVec2, true);
  var VEC4_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeFloatCoderInput(4, name);
  }, makeFloatCoderOutput(4), 0, WebGLRenderingContext.FLOAT, function(e) {
    return e;
  }, function(e) {
    return e;
  }, false);
  var SHADER_CODER_FLOATS = new ShaderCoder(BOOL_TYPE_CODER, FLOAT_TYPE_CODER, VEC2_TYPE_CODER, VEC4_TYPE_CODER);
  return {get SHADER_CODER_FLOATS() {
      return SHADER_CODER_FLOATS;
    }};
});
//# sourceURL=src/webgl/ShaderCoders_intoFloats.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders.js";
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglArg.js", "src/webgl/ShaderCoders.js")).WglArg;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglShader.js", "src/webgl/ShaderCoders.js")).WglShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglTexture.js", "src/webgl/ShaderCoders.js")).WglTexture;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglContext.js", "src/webgl/ShaderCoders.js")).initializedWglContext;
  var $__24 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglConfiguredShader.js", "src/webgl/ShaderCoders.js")),
      provideWorkingShaderCoderToWglConfiguredShader = $__24.provideWorkingShaderCoderToWglConfiguredShader,
      WglConfiguredShader = $__24.WglConfiguredShader;
  var ShaderPart = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders_Base.js", "src/webgl/ShaderCoders.js")).ShaderPart;
  var SHADER_CODER_BYTES = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders_intoBytes.js", "src/webgl/ShaderCoders.js")).SHADER_CODER_BYTES;
  var SHADER_CODER_FLOATS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders_intoFloats.js", "src/webgl/ShaderCoders.js")).SHADER_CODER_FLOATS;
  var ShaderPartDescription = function() {
    function ShaderPartDescription(partMaker, description) {
      this._partMaker = partMaker;
      this.description = description;
    }
    return ($traceurRuntime.createClass)(ShaderPartDescription, {
      toConcretePart: function() {
        var coder = arguments[0];
        return this._partMaker(coder || currentShaderCoder());
      },
      toString: function() {
        return ("ShaderPartDescription(" + this.description + ")");
      }
    }, {});
  }();
  var Inputs = function() {
    function Inputs() {}
    return ($traceurRuntime.createClass)(Inputs, {}, {
      bool: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.bool.inputPartGetter(name);
        }, ("Inputs.bool(" + name + ")"));
      },
      float: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.float.inputPartGetter(name);
        }, ("Inputs.float(" + name + ")"));
      },
      vec2: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.vec2.inputPartGetter(name);
        }, ("Inputs.vec2(" + name + ")"));
      },
      vec4: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.vec4.inputPartGetter(name);
        }, ("Inputs.vec4(" + name + ")"));
      }
    });
  }();
  var Outputs = function() {
    function Outputs() {}
    return ($traceurRuntime.createClass)(Outputs, {}, {
      bool: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.bool.outputPart;
        }, "Outputs.bool()");
      },
      float: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.float.outputPart;
        }, "Outputs.float()");
      },
      vec2: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.vec2.outputPart;
        }, "Outputs.vec2()");
      },
      vec4: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.vec4.outputPart;
        }, "Outputs.vec4()");
      },
      vec4WithOutputCoder: function() {
        return new ShaderPartDescription(function(_) {
          return outputShaderCoder().vec4.outputPart;
        }, "Outputs.vec4WithOutputCoder()");
      }
    });
  }();
  function combinedShaderPartsWithCode(shaderPartsOrDescs, bodyCode) {
    var shaderPartDescs = shaderPartsOrDescs.map(function(partOrDesc) {
      return partOrDesc instanceof ShaderPart ? new ShaderPartDescription(function(_) {
        return partOrDesc;
      }, 'fixed') : partOrDesc;
    });
    var sourceMaker = function() {
      var libs = new Set();
      var $__13 = true;
      var $__14 = false;
      var $__15 = undefined;
      try {
        for (var $__11 = void 0,
            $__10 = (shaderPartDescs)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
          var part = $__11.value;
          {
            var $__6 = true;
            var $__7 = false;
            var $__8 = undefined;
            try {
              for (var $__4 = void 0,
                  $__3 = (part.toConcretePart().libs)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                var lib = $__4.value;
                {
                  libs.add(lib);
                }
              }
            } catch ($__9) {
              $__7 = true;
              $__8 = $__9;
            } finally {
              try {
                if (!$__6 && $__3.return != null) {
                  $__3.return();
                }
              } finally {
                if ($__7) {
                  throw $__8;
                }
              }
            }
          }
        }
      } catch ($__16) {
        $__14 = true;
        $__15 = $__16;
      } finally {
        try {
          if (!$__13 && $__10.return != null) {
            $__10.return();
          }
        } finally {
          if ($__14) {
            throw $__15;
          }
        }
      }
      var libCode = $traceurRuntime.spread(libs, shaderPartDescs.map(function(e) {
        return e.toConcretePart().code;
      })).join('');
      var afterLibCode = '\n//////// body ////////\n' + bodyCode + '\n';
      var mainIndex = libCode.indexOf('void main()');
      if (mainIndex !== -1) {
        return libCode.substring(0, mainIndex) + afterLibCode + libCode.substring(mainIndex);
      }
      return libCode + afterLibCode;
    };
    return new WglShader(sourceMaker);
  }
  function makePseudoShaderWithInputsAndOutputAndCode(inputs, output, bodyCode) {
    var shader = combinedShaderPartsWithCode($traceurRuntime.spread(inputs, [output]), bodyCode);
    return function() {
      var $__18,
          $__19;
      for (var inputsAndArgs = [],
          $__17 = 0; $__17 < arguments.length; $__17++)
        inputsAndArgs[$__17] = arguments[$__17];
      var args = [];
      for (var i = 0; i < inputs.length; i++) {
        ($__18 = args).push.apply($__18, $traceurRuntime.spread(inputs[i].toConcretePart().argsFor(inputsAndArgs[i])));
      }
      ($__19 = args).push.apply($__19, $traceurRuntime.spread(inputsAndArgs.slice(inputs.length)));
      return shaderWithOutputPartAndArgs(shader, output.toConcretePart(), args);
    };
  }
  function shaderWithOutputPartAndArgs(shader, outputShaderPart, args) {
    return new WglConfiguredShader(function(destinationTexture) {
      var $__18;
      return ($__18 = shader).withArgs.apply($__18, $traceurRuntime.spread(args, outputShaderPart.argsFor(destinationTexture))).renderTo(destinationTexture);
    });
  }
  var _curShaderCoder = SHADER_CODER_FLOATS;
  var _outShaderCoder = SHADER_CODER_BYTES;
  function currentShaderCoder() {
    return _curShaderCoder;
  }
  function outputShaderCoder() {
    return _outShaderCoder;
  }
  function changeShaderCoder(newCoder) {
    try {
      initializedWglContext().invalidateExistingResources();
    } catch (_) {}
    _curShaderCoder = newCoder;
    _outShaderCoder = newCoder;
  }
  function _tryWriteAndReadFloatingPointTexture() {
    var texture = new WglTexture(1, 1, WebGLRenderingContext.FLOAT);
    var shader = new WglShader("void main() { gl_FragColor = vec4(2.0, 3.5, 7.0, -7654321.0); }");
    try {
      shader.withArgs().renderTo(texture);
      var result = texture.readPixels(false);
      return result instanceof Float32Array && result.length === 4 && result[0] === 2 && result[1] === 3.5 && result[2] === 7 && result[3] === -7654321;
    } catch (ex) {
      console.warn(ex);
      return false;
    } finally {
      texture.ensureDeinitialized();
      shader.ensureDeinitialized();
    }
  }
  function _tryWriteAndPassFloatingPointWithByteReadTexture() {
    var textureFloat = new WglTexture(1, 1, WebGLRenderingContext.FLOAT);
    var textureByte = new WglTexture(1, 1, WebGLRenderingContext.UNSIGNED_BYTE);
    var shader = new WglShader("void main() { gl_FragColor = vec4(1.1, 3.0, 5.0, -7654321.0); }");
    var passer = new WglShader("uniform sampler2D t; void main() {\n        vec4 v = texture2D(t, gl_FragCoord.xy);\n        if (v == vec4(2.0, 3.0, 5.0, -7654321.0)) { // Testing that expected precision is present.\n            gl_FragColor = vec4(2.0, 3.0, 5.0, 254.0) / 255.0;\n        } else {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    }");
    try {
      shader.withArgs().renderTo(textureFloat);
      passer.withArgs(WglArg.texture('t', textureFloat)).renderTo(textureByte);
      var result = textureByte.readPixels(false);
      return result instanceof Uint8Array && result.length === 4 && result[0] === 2 && result[1] === 3 && result[2] === 5 && result[3] === 254;
    } catch (ex) {
      console.warn(ex);
      return false;
    } finally {
      textureFloat.ensureDeinitialized();
      textureByte.ensureDeinitialized();
      shader.ensureDeinitialized();
      passer.ensureDeinitialized();
    }
  }
  function _chooseShaderCoders() {
    if (_tryWriteAndReadFloatingPointTexture()) {
      _curShaderCoder = SHADER_CODER_FLOATS;
      _outShaderCoder = SHADER_CODER_FLOATS;
    } else if (_tryWriteAndPassFloatingPointWithByteReadTexture()) {
      console.warn("Wrote but failed to read a floating point texture. Falling back to float-as-byte output coding.");
      _curShaderCoder = SHADER_CODER_FLOATS;
      _outShaderCoder = SHADER_CODER_BYTES;
    } else {
      console.warn("Failed to write a floating point texture. Falling back to float-as-byte coding everywhere.");
      _curShaderCoder = SHADER_CODER_BYTES;
      _outShaderCoder = SHADER_CODER_BYTES;
    }
  }
  var _floatShadersWorkWell = undefined;
  function canTestFloatShaders() {
    if (_floatShadersWorkWell === undefined) {
      _floatShadersWorkWell = _tryWriteAndReadFloatingPointTexture();
    }
    return _floatShadersWorkWell;
  }
  _chooseShaderCoders();
  provideWorkingShaderCoderToWglConfiguredShader(currentShaderCoder);
  return {
    get combinedShaderPartsWithCode() {
      return combinedShaderPartsWithCode;
    },
    get shaderWithOutputPartAndArgs() {
      return shaderWithOutputPartAndArgs;
    },
    get currentShaderCoder() {
      return currentShaderCoder;
    },
    get makePseudoShaderWithInputsAndOutputAndCode() {
      return makePseudoShaderWithInputsAndOutputAndCode;
    },
    get changeShaderCoder() {
      return changeShaderCoder;
    },
    get Inputs() {
      return Inputs;
    },
    get Outputs() {
      return Outputs;
    },
    get outputShaderCoder() {
      return outputShaderCoder;
    },
    get canTestFloatShaders() {
      return canTestFloatShaders;
    }
  };
});
//# sourceURL=src/webgl/ShaderCoders.js
;$traceurRuntime.registerModule("src/webgl/Shaders.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/Shaders.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/webgl/Shaders.js")).DetailedError;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglArg.js", "src/webgl/Shaders.js")).WglArg;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglContext.js", "src/webgl/Shaders.js")).initializedWglContext;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglShader.js", "src/webgl/Shaders.js")).WglShader;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglConfiguredShader.js", "src/webgl/Shaders.js")).WglConfiguredShader;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders.js", "src/webgl/Shaders.js")),
      currentShaderCoder = $__10.currentShaderCoder,
      Inputs = $__10.Inputs,
      Outputs = $__10.Outputs,
      makePseudoShaderWithInputsAndOutputAndCode = $__10.makePseudoShaderWithInputsAndOutputAndCode;
  var Shaders = function() {
    function Shaders() {}
    return ($traceurRuntime.createClass)(Shaders, {}, {});
  }();
  Shaders.color = function(r, g, b, a) {
    return COLOR_SHADER.withArgs(WglArg.vec4("color", r, g, b, a));
  };
  var COLOR_SHADER = new WglShader("\n    uniform vec4 color;\n    void main() {\n        gl_FragColor = color;\n    }");
  Shaders.passthrough = function(inp) {
    return new WglConfiguredShader(function(dst) {
      if (dst.width !== inp.width || dst.height !== inp.height || dst.pixelType !== inp.pixelType) {
        throw new DetailedError("Expected same-shaped textures.", {
          inp: inp,
          dst: dst
        });
      }
      PASSTHROUGH_SHADER.withArgs(WglArg.vec2("textureSize", inp.width, inp.height), WglArg.texture("dataTexture", inp)).renderTo(dst);
    });
  };
  var PASSTHROUGH_SHADER = new WglShader("\n    uniform vec2 textureSize;\n    uniform sampler2D dataTexture;\n    void main() {\n        gl_FragColor = texture2D(dataTexture, gl_FragCoord.xy / textureSize.xy);\n    }");
  Shaders.data = function(rgbaData) {
    return new WglConfiguredShader(function(destinationTexture) {
      var $__3,
          $__4;
      var $__2 = [destinationTexture.width, destinationTexture.height],
          w = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
          h = ($__4 = $__3.next()).done ? void 0 : $__4.value;
      if (rgbaData.length !== w * h * 4) {
        throw new DetailedError("rgbaData.length isn't w * h * 4", {
          w: w,
          h: h,
          len: rgbaData.length,
          rgbaData: rgbaData
        });
      }
      var GL = WebGLRenderingContext;
      var gl = initializedWglContext().gl;
      var dataTexture = gl.createTexture();
      try {
        gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, dataTexture);
        gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
        gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
        gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, w, h, 0, GL.RGBA, rgbaData instanceof Uint8Array ? GL.UNSIGNED_BYTE : GL.FLOAT, rgbaData);
        PASSTHROUGH_SHADER.withArgs(WglArg.vec2("textureSize", w, h), WglArg.webGlTexture("dataTexture", dataTexture)).renderTo(destinationTexture);
      } finally {
        gl.deleteTexture(dataTexture);
      }
    });
  };
  Shaders.floatData = function(floats) {
    return Shaders.data(currentShaderCoder().float.dataToPixels(floats));
  };
  Shaders.vec2Data = function(floats) {
    return Shaders.data(currentShaderCoder().vec2.dataToPixels(floats));
  };
  Shaders.vec4Data = function(floats) {
    return Shaders.data(currentShaderCoder().vec4.dataToPixels(floats));
  };
  Shaders.packFloatIntoVec4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.vec4(), "vec4 outputFor(float k) {\n        return vec4(\n            read_input(k*4.0),\n            read_input(k*4.0 + 1.0),\n            read_input(k*4.0 + 2.0),\n            read_input(k*4.0 + 3.0));\n    }");
  Shaders.packVec2IntoVec4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec4(), 'vec4 outputFor(float k) { return vec4(read_input(k*2.0), read_input(k*2.0 + 1.0)); }');
  Shaders.sumFoldFloat = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.float(), "float outputFor(float k) {\n         return read_input(k) + read_input(k + len_output());\n     }");
  Shaders.sumFoldFloatAdjacents = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.float(), "float outputFor(float k) {\n         return read_input(k*2.0) + read_input(k*2.0 + 1.0);\n     }");
  Shaders.sumFoldVec2 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "vec2 outputFor(float k) {\n         return read_input(k) + read_input(k + len_output());\n     }");
  Shaders.sumFoldVec2Adjacents = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "vec2 outputFor(float k) {\n         return read_input(k*2.0) + read_input(k*2.0 + 1.0);\n     }");
  Shaders.sumFoldVec4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "vec4 outputFor(float k) {\n        return read_input(k) + read_input(k + len_output());\n    }");
  Shaders.convertVec4CodingForOutput = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4WithOutputCoder(), 'vec4 outputFor(float k) { return read_input(k); }');
  return {get Shaders() {
      return Shaders;
    }};
});
//# sourceURL=src/webgl/Shaders.js
;$traceurRuntime.registerModule("src/webgl/WglArg.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglArg.js";
  var WglArg = function() {
    function WglArg(type, name, value) {
      this.type = type;
      this.name = name;
      this.value = value;
    }
    return ($traceurRuntime.createClass)(WglArg, {toString: function() {
        return (this.type + " " + this.name + " = " + JSON.stringify(this.value));
      }}, {
      bool: function(name, value) {
        return new WglArg(WglArg.BOOL_TYPE, name, value);
      },
      float: function(name, value) {
        return new WglArg(WglArg.FLOAT_TYPE, name, value);
      },
      int: function(name, value) {
        return new WglArg(WglArg.INT_TYPE, name, value);
      },
      vec2: function(name, x, y) {
        return new WglArg(WglArg.VEC2_TYPE, name, [x, y]);
      },
      float_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.FLOAT_ARRAY_TYPE, name, buf);
      },
      vec2_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.VEC2_ARRAY_TYPE, name, buf);
      },
      vec4_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.VEC4_ARRAY_TYPE, name, buf);
      },
      mat4_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.MAT4_ARRAY_TYPE, name, buf);
      },
      vec4: function(name, x, y, z, t) {
        return new WglArg(WglArg.VEC4_TYPE, name, [x, y, z, t]);
      },
      mat4: function(name, cellsRowByRow) {
        return new WglArg(WglArg.MAT4_TYPE, name, cellsRowByRow);
      },
      texture: function(name, wglTexture) {
        return new WglArg(WglArg.WGL_TEXTURE_TYPE, name, wglTexture);
      },
      webGlTexture: function(name, webGlTexture) {
        return new WglArg(WglArg.WEB_GL_TEXTURE_TYPE, name, webGlTexture);
      }
    });
  }();
  WglArg.BOOL_TYPE = "bool";
  WglArg.FLOAT_TYPE = "float";
  WglArg.INT_TYPE = "int";
  WglArg.VEC2_TYPE = "vec2";
  WglArg.FLOAT_ARRAY_TYPE = "float[]";
  WglArg.VEC2_ARRAY_TYPE = "vec2[]";
  WglArg.VEC4_ARRAY_TYPE = "vec4[]";
  WglArg.MAT4_ARRAY_TYPE = "mat4[]";
  WglArg.VEC4_TYPE = "vec4";
  WglArg.MAT4_TYPE = "mat4";
  WglArg.WGL_TEXTURE_TYPE = "wgl_texture";
  WglArg.WEB_GL_TEXTURE_TYPE = "web_gl_texture";
  WglArg.INPUT_ACTION_MAP = new Map([[WglArg.BOOL_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniform1f(loc, val ? 1 : 0);
  }], [WglArg.INT_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniform1i(loc, val);
  }], [WglArg.FLOAT_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniform1f(loc, val);
  }], [WglArg.VEC2_TYPE, function(ctx, loc, $__1) {
    var $__3,
        $__4;
    var $__2 = $__1,
        x = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        y = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    return ctx.gl.uniform2f(loc, x, y);
  }], [WglArg.FLOAT_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniform1fv(loc, buf);
  }], [WglArg.VEC2_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniform2fv(loc, buf);
  }], [WglArg.VEC4_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniform4fv(loc, buf);
  }], [WglArg.MAT4_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniformMatrix4fv(loc, false, buf);
  }], [WglArg.VEC4_TYPE, function(ctx, loc, $__1) {
    var $__3,
        $__4;
    var $__2 = $__1,
        r = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        g = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        b = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        a = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    return ctx.gl.uniform4f(loc, r, g, b, a);
  }], [WglArg.MAT4_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniformMatrix4fv(loc, false, val);
  }], [WglArg.WGL_TEXTURE_TYPE, function(ctx, loc, texture, coop) {
    var unit = coop.coopTextureUnit++;
    if (unit >= ctx.maxTextureUnits) {
      throw new Error(("Uniform texture argument uses texture unit " + unit + " but max ") + ("is " + ctx.maxTextureUnits + "."));
    }
    if (texture.width > ctx.maxTextureSize || texture.height > ctx.maxTextureSize) {
      throw new Error(("Uniform texture argument is " + texture.width + "x" + texture.height + ", but max ") + ("texture diameter is " + ctx.maxTextureSize + "."));
    }
    var gl = ctx.gl;
    gl.uniform1i(loc, unit);
    gl.activeTexture(WebGLRenderingContext.TEXTURE0 + unit);
    gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, texture.initializedTexture());
  }], [WglArg.WEB_GL_TEXTURE_TYPE, function(ctx, loc, texture, coop) {
    var unit = coop.coopTextureUnit++;
    if (unit >= ctx.maxTextureUnits) {
      throw new Error(("Uniform texture argument uses texture unit " + unit + " but max ") + ("is " + ctx.maxTextureUnits + "."));
    }
    var gl = ctx.gl;
    gl.uniform1i(loc, unit);
    gl.activeTexture(WebGLRenderingContext.TEXTURE0 + unit);
    gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, texture);
  }]]);
  return {get WglArg() {
      return WglArg;
    }};
});
//# sourceURL=src/webgl/WglArg.js
;$traceurRuntime.registerModule("src/webgl/WglConfiguredShader.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglConfiguredShader.js";
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../math/Matrix.js", "src/webgl/WglConfiguredShader.js")).Matrix;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglTexture.js", "src/webgl/WglConfiguredShader.js")).WglTexture;
  var currentShaderCoder = undefined;
  var WglTexturePool;
  function provideWorkingShaderCoderToWglConfiguredShader(newCurrentShaderCoder) {
    currentShaderCoder = newCurrentShaderCoder;
  }
  function provideWglTexturePoolToWglConfiguredShader(pool) {
    WglTexturePool = pool;
  }
  var WglConfiguredShader = function() {
    function WglConfiguredShader(renderToFunc) {
      this.renderToFunc = renderToFunc;
    }
    return ($traceurRuntime.createClass)(WglConfiguredShader, {
      renderTo: function(texture) {
        var shouldBeUndefined = this.renderToFunc(texture);
        if (shouldBeUndefined instanceof WglConfiguredShader) {
          throw new Error("Returned a WglConfiguredShader instead of calling renderTo on it.");
        }
      },
      _renderToElseDealloc: function(texture) {
        var didPass = false;
        try {
          this.renderTo(texture);
          didPass = true;
        } finally {
          if (!didPass) {
            texture.deallocByDepositingInPool("_renderToElseDealloc");
          }
        }
      },
      _renderReadDealloc: function(texture) {
        try {
          this.renderTo(texture);
          return texture.readPixels();
        } finally {
          texture.deallocByDepositingInPool();
        }
      },
      toRawByteTexture: function(sizePower) {
        var texture = WglTexturePool.takeRawByteTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toRawFloatTexture: function(sizePower) {
        var texture = WglTexturePool.takeRawFloatTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      readRawFloatOutputs: function(sizePower) {
        return this._renderReadDealloc(WglTexturePool.takeRawFloatTex(sizePower));
      },
      readRawByteOutputs: function(sizePower) {
        return this._renderReadDealloc(WglTexturePool.takeRawByteTex(sizePower));
      },
      readBoolOutputs: function(sizePower) {
        var pixels = this._renderReadDealloc(WglTexturePool.takeBoolTex(sizePower));
        var result = new Uint8Array(pixels.length >> 2);
        for (var i = 0; i < result.length; i++) {
          result[i] = pixels[i << 2] & 1;
        }
        return result;
      },
      readVecFloatOutputs: function(sizePower) {
        return currentShaderCoder().float.pixelsToData(this._renderReadDealloc(WglTexturePool.takeVecFloatTex(sizePower)));
      },
      readVec2Outputs: function(sizePower) {
        return currentShaderCoder().vec2.pixelsToData(this._renderReadDealloc(WglTexturePool.takeVec2Tex(sizePower)));
      },
      readVec2OutputsAsKet: function(sizePower) {
        return new Matrix(1, 1 << sizePower, this.readVec2Outputs(sizePower));
      },
      readVec4Outputs: function(sizePower) {
        return currentShaderCoder().vec4.pixelsToData(this._renderReadDealloc(WglTexturePool.takeVec4Tex(sizePower)));
      },
      toVecFloatTexture: function(sizePower) {
        var texture = WglTexturePool.takeVecFloatTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toVec2Texture: function(sizePower) {
        var texture = WglTexturePool.takeVec2Tex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toVec4Texture: function(sizePower) {
        var texture = WglTexturePool.takeVec4Tex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toBoolTexture: function(sizePower) {
        var texture = WglTexturePool.takeBoolTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      }
    }, {});
  }();
  return {
    get WglConfiguredShader() {
      return WglConfiguredShader;
    },
    get provideWorkingShaderCoderToWglConfiguredShader() {
      return provideWorkingShaderCoderToWglConfiguredShader;
    },
    get provideWglTexturePoolToWglConfiguredShader() {
      return provideWglTexturePoolToWglConfiguredShader;
    }
  };
});
//# sourceURL=src/webgl/WglConfiguredShader.js
;$traceurRuntime.registerModule("src/webgl/WglContext.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglContext.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../issues.js", "src/webgl/WglContext.js")),
      canvasCreatedForTesting = $__2.canvasCreatedForTesting,
      webglContextCreatedForTesting = $__2.webglContextCreatedForTesting;
  var WglContext = function() {
    function WglContext() {
      var canvas = arguments[0];
      var context = arguments[1];
      var $__1 = this;
      if (canvas === undefined) {
        canvas = document.createElement('canvas');
        context = undefined;
      }
      if (context === undefined) {
        context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      }
      this.canvas = canvas;
      this.gl = context;
      if ((this.gl) === null) {
        throw new Error('Error creating WebGL context.');
      }
      if (this.gl.getExtension('OES_texture_float') === undefined) {
        console.warn("OES_texture_float webgl extension not present.");
      }
      if (this.gl.getExtension('WEBGL_color_buffer_float') === undefined) {
        console.warn("WEBGL_color_buffer_float webgl extension not present.");
      }
      this.onContextRestored = undefined;
      this.lifetimeCounter = 0;
      this.canvas.addEventListener("webglcontextrestored", function(event) {
        event.preventDefault();
        $__1.recomputeProperties();
        if ($__1.onContextRestored !== undefined) {
          $__1.onContextRestored();
        }
      }, false);
      this.canvas.addEventListener('webglcontextlost', function(event) {
        event.preventDefault();
        $__1.lifetimeCounter++;
      }, false);
      this.recomputeProperties();
    }
    return ($traceurRuntime.createClass)(WglContext, {
      invalidateExistingResources: function() {
        this.lifetimeCounter++;
      },
      recomputeProperties: function() {
        this.lifetimeCounter++;
        this.maxTextureUnits = this.gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_IMAGE_UNITS);
        this.maxTextureSize = this.gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_SIZE);
        this.maximumShaderFloatPrecision = this._getMaximumShaderFloatPrecision();
      },
      _getMaximumShaderFloatPrecision: function() {
        var gl = this.gl;
        var GL = WebGLRenderingContext;
        var check = function(shaderType, precisionType) {
          var format = gl.getShaderPrecisionFormat(shaderType, precisionType);
          return gl.getError() === GL.NO_ERROR && format !== undefined && format !== null && format.precision > 0;
        };
        var hasHighPrecision = check(GL.VERTEX_SHADER, GL.HIGH_FLOAT) && check(GL.FRAGMENT_SHADER, GL.HIGH_FLOAT);
        if (hasHighPrecision) {
          return 'highp';
        }
        console.warn('WebGL high precision not available.');
        var hasMediumPrecision = check(GL.VERTEX_SHADER, GL.MEDIUM_FLOAT) && check(GL.FRAGMENT_SHADER, GL.MEDIUM_FLOAT);
        if (hasMediumPrecision) {
          return 'mediump';
        }
        console.warn('WebGL medium precision not available.');
        return 'lowp';
      }
    }, {});
  }();
  var __sharedInstance = undefined;
  function initializedWglContext() {
    if (__sharedInstance === undefined) {
      __sharedInstance = new WglContext(canvasCreatedForTesting, webglContextCreatedForTesting);
    }
    return __sharedInstance;
  }
  return {get initializedWglContext() {
      return initializedWglContext;
    }};
});
//# sourceURL=src/webgl/WglContext.js
;$traceurRuntime.registerModule("src/webgl/WglMortalValueSlot.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglMortalValueSlot.js";
  var WglMortalValueSlot = function() {
    function WglMortalValueSlot(initializer, deinitializer) {
      this.initializer = initializer;
      this.deinitializer = deinitializer;
      this.lifetimeId = undefined;
      this.mortalValue = undefined;
    }
    return ($traceurRuntime.createClass)(WglMortalValueSlot, {
      initializedValue: function(lifetimeCounter) {
        if (this.lifetimeId !== lifetimeCounter) {
          this.ensureDeinitialized();
          this.mortalValue = this.initializer();
          this.lifetimeId = lifetimeCounter;
        }
        return this.mortalValue;
      },
      ensureInitialized: function(lifetimeCounter) {
        this.initializedValue(lifetimeCounter);
      },
      ensureDeinitialized: function() {
        if (this.lifetimeId !== undefined) {
          var val = this.mortalValue;
          this.lifetimeId = undefined;
          this.mortalValue = undefined;
          this.deinitializer(val);
        }
      }
    }, {});
  }();
  return {get WglMortalValueSlot() {
      return WglMortalValueSlot;
    }};
});
//# sourceURL=src/webgl/WglMortalValueSlot.js
;$traceurRuntime.registerModule("src/webgl/WglShader.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglShader.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/webgl/WglShader.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/webgl/WglShader.js")).DetailedError;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglArg.js", "src/webgl/WglShader.js")).WglArg;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglContext.js", "src/webgl/WglShader.js")).initializedWglContext;
  var WglMortalValueSlot = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglMortalValueSlot.js", "src/webgl/WglShader.js")).WglMortalValueSlot;
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglUtil.js", "src/webgl/WglShader.js")),
      checkGetErrorResult = $__16.checkGetErrorResult,
      checkFrameBufferStatusResult = $__16.checkFrameBufferStatusResult;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Seq.js", "src/webgl/WglShader.js")).Seq;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglConfiguredShader.js", "src/webgl/WglShader.js")).WglConfiguredShader;
  var ENSURE_ATTRIBUTES_BOUND_SLOT = new WglMortalValueSlot(function() {
    var GL = WebGLRenderingContext;
    var gl = initializedWglContext().gl;
    var positionBuffer = gl.createBuffer();
    var positions = new Float32Array([-1, +1, +1, +1, -1, -1, +1, -1]);
    gl.bindBuffer(GL.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(GL.ARRAY_BUFFER, positions, GL.STATIC_DRAW);
    var indexBuffer = gl.createBuffer();
    var indices = new Uint16Array([0, 2, 1, 2, 3, 1]);
    gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(GL.ELEMENT_ARRAY_BUFFER, indices, GL.STATIC_DRAW);
    return {
      positionBuffer: positionBuffer,
      indexBuffer: indexBuffer
    };
  }, function() {});
  var WglShader = function() {
    function WglShader(fragmentShaderSourceGenerator) {
      if (typeof fragmentShaderSourceGenerator === 'string') {
        var fixedSource = fragmentShaderSourceGenerator;
        fragmentShaderSourceGenerator = function() {
          return fixedSource;
        };
      }
      this.fragmentShaderSourceGenerator = fragmentShaderSourceGenerator;
      this._compiledShaderSlot = undefined;
    }
    return ($traceurRuntime.createClass)(WglShader, {
      withArgs: function() {
        for (var uniformArguments = [],
            $__10 = 0; $__10 < arguments.length; $__10++)
          uniformArguments[$__10] = arguments[$__10];
        var $__2 = this;
        if (this._compiledShaderSlot === undefined) {
          var parameterNames = uniformArguments.map(function(e) {
            return e.name;
          });
          this._compiledShaderSlot = new WglMortalValueSlot(function() {
            return new WglCompiledShader($__2.fragmentShaderSourceGenerator(), parameterNames);
          }, function(compiledShader) {
            return compiledShader.free();
          });
        }
        return new WglConfiguredShader(function(texture) {
          if (texture.width === 0 || texture.height === 0) {
            return;
          }
          var GL = WebGLRenderingContext;
          var ctx = initializedWglContext();
          var gl = ctx.gl;
          ENSURE_ATTRIBUTES_BOUND_SLOT.ensureInitialized(ctx.lifetimeCounter);
          gl.bindFramebuffer(GL.FRAMEBUFFER, texture.initializedFramebuffer());
          checkGetErrorResult(gl, "framebufferTexture2D", true);
          checkFrameBufferStatusResult(gl, true);
          $__2._compiledShaderSlot.initializedValue(ctx.lifetimeCounter).useWithArgs(uniformArguments);
          gl.viewport(0, 0, texture.width, texture.height);
          gl.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);
          checkGetErrorResult(gl, "drawElements", true);
          texture.markRendered();
        });
      },
      ensureDeinitialized: function() {
        if (this._compiledShaderSlot !== undefined) {
          this._compiledShaderSlot.ensureDeinitialized();
        }
      },
      toString: function() {
        return ("WglShader(fragmentShaderSource: " + this.fragmentShaderSourceGenerator() + ")");
      }
    }, {});
  }();
  var WglCompiledShader = function() {
    function WglCompiledShader(fragmentShaderSource, uniformParameterNames) {
      var ctx = initializedWglContext();
      var precision = ctx.maximumShaderFloatPrecision;
      var vertexShader = ("\n            precision " + precision + " float;\n            precision " + precision + " int;\n            attribute vec2 position;\n            void main() {\n              gl_Position = vec4(position, 0, 1);\n            }");
      var fullFragmentShader = ("\n            precision " + precision + " float;\n            precision " + precision + " int;\n            " + fragmentShaderSource);
      var GL = WebGLRenderingContext;
      var gl = ctx.gl;
      var glVertexShader = WglCompiledShader.compileShader(gl, GL.VERTEX_SHADER, vertexShader);
      var glFragmentShader = WglCompiledShader.compileShader(gl, GL.FRAGMENT_SHADER, fullFragmentShader);
      var program = gl.createProgram();
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      gl.linkProgram(program);
      var warnings = (gl.getProgramInfoLog(program) || '').trim();
      if (warnings !== '' && warnings !== '\0' && Config.SUPPRESSED_GLSL_WARNING_PATTERNS.every(function(e) {
        return !e.test(warnings);
      })) {
        console.warn('Shader compile caused warnings', 'gl.getProgramInfoLog()', warnings);
      }
      if (gl.getProgramParameter(program, GL.LINK_STATUS) === false) {
        throw new Error("Failed to link shader program." + "\n" + "\n" + ("gl.VALIDATE_STATUS: " + gl.getProgramParameter(program, GL.VALIDATE_STATUS)) + "\n" + ("gl.getError(): " + gl.getError()));
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      this.uniformLocations = new Seq(uniformParameterNames).toMap(function(e) {
        return e;
      }, function(e) {
        return gl.getUniformLocation(program, e);
      });
      this.positionAttributeLocation = gl.getAttribLocation(program, 'position');
      this.program = program;
    }
    return ($traceurRuntime.createClass)(WglCompiledShader, {
      useWithArgs: function(uniformArgs) {
        var ctx = initializedWglContext();
        var gl = ctx.gl;
        gl.useProgram(this.program);
        var coop = {coopTextureUnit: 0};
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (uniformArgs)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var arg = $__4.value;
            {
              var location = this.uniformLocations.get(arg.name);
              if (location === undefined) {
                throw new DetailedError("Unexpected uniform argument", {
                  arg: arg,
                  uniformArgs: uniformArgs
                });
              }
              WglArg.INPUT_ACTION_MAP.get(arg.type)(ctx, location, arg.value, coop);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        gl.enableVertexAttribArray(this.positionAttributeLocation);
        gl.vertexAttribPointer(this.positionAttributeLocation, 2, WebGLRenderingContext.FLOAT, false, 0, 0);
      },
      free: function() {
        var gl = initializedWglContext().gl;
        gl.deleteProgram(this.program);
      }
    }, {compileShader: function(gl, shaderType, sourceCode) {
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, sourceCode);
        gl.compileShader(shader);
        var info = gl.getShaderInfoLog(shader);
        if (info !== '') {
          var ignored = false;
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (Config.IGNORED_WEBGL_INFO_TERMS)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var term = $__4.value;
              {
                if (info.indexOf(term)) {
                  ignored = true;
                }
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
          if (!ignored) {
            console.warn("WebGLShader: gl.getShaderInfoLog() wasn't empty: " + gl.getShaderInfoLog(shader));
            console.warn("Source code was: " + sourceCode);
          }
        }
        if (gl.getShaderParameter(shader, WebGLRenderingContext.COMPILE_STATUS) === false) {
          throw new Error(("WebGLShader: Shader compile failed.\n                Info: " + info + "\n                Source: " + sourceCode));
        }
        return shader;
      }});
  }();
  return {get WglShader() {
      return WglShader;
    }};
});
//# sourceURL=src/webgl/WglShader.js
;$traceurRuntime.registerModule("src/webgl/WglTexture.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglTexture.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/webgl/WglTexture.js")).DetailedError;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/Util.js", "src/webgl/WglTexture.js")).Util;
  var WglMortalValueSlot = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglMortalValueSlot.js", "src/webgl/WglTexture.js")).WglMortalValueSlot;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglContext.js", "src/webgl/WglTexture.js")).initializedWglContext;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglUtil.js", "src/webgl/WglTexture.js")),
      checkGetErrorResult = $__9.checkGetErrorResult,
      checkFrameBufferStatusResult = $__9.checkFrameBufferStatusResult;
  var WglTexture = function() {
    function WglTexture(width, height) {
      var pixelType = arguments[2] !== (void 0) ? arguments[2] : WebGLRenderingContext.FLOAT;
      var $__2 = this;
      if (width === 0 && height === 0) {
        this.width = 0;
        this.height = 0;
        this.pixelType = pixelType;
        this._hasBeenRenderedTo = true;
        this._textureAndFrameBufferSlot = new WglMortalValueSlot(function() {
          throw new DetailedError("Touched a zero-size texture.", $__2);
        }, function() {
          throw new DetailedError("Touched a zero-size texture.", $__2);
        });
        return;
      }
      if (!Util.isPowerOf2(width) || !Util.isPowerOf2(height)) {
        throw new DetailedError("Sizes must be a power of 2.", {
          width: width,
          height: height,
          pixelType: pixelType
        });
      }
      this.width = width;
      this.height = height;
      this.pixelType = pixelType;
      this._hasBeenRenderedTo = false;
      this._textureAndFrameBufferSlot = new WglMortalValueSlot(function() {
        return $__2._textureAndFramebufferInitializer();
      }, function(e) {
        return WglTexture._deinitialize(e);
      });
    }
    return ($traceurRuntime.createClass)(WglTexture, {
      sizePower: function() {
        if (this.width === 0) {
          return -Infinity;
        }
        return Math.round(Math.log2(this.width * this.height));
      },
      toString: function() {
        return 'Texture(' + [this.width + 'x' + this.height, this.pixelType === WebGLRenderingContext.FLOAT ? 'FLOAT' : this.pixelType === WebGLRenderingContext.UNSIGNED_BYTE ? 'UNSIGNED_BYTE' : this.pixelType, this._hasBeenRenderedTo ? 'rendered' : 'not rendered'].join(', ') + ')';
      },
      markRendered: function() {
        this._hasBeenRenderedTo = true;
      },
      invalidateButMoveToNewInstance: function(details) {
        var result = new WglTexture(this.width, this.height, this.pixelType);
        result._textureAndFrameBufferSlot = this._textureAndFrameBufferSlot;
        var invalidated = function() {
          throw new DetailedError("WglTexture's value accessed after invalidation.", details);
        };
        this._textureAndFrameBufferSlot = new WglMortalValueSlot(invalidated, invalidated);
        return result;
      },
      initializedTexture: function() {
        if (!this._hasBeenRenderedTo) {
          throw new Error("Called initializedTexture on a texture that hasn't been rendered to.");
        }
        return this._textureAndFrameBufferSlot.initializedValue(initializedWglContext().lifetimeCounter).texture;
      },
      initializedFramebuffer: function() {
        return this._textureAndFrameBufferSlot.initializedValue(initializedWglContext().lifetimeCounter).framebuffer;
      },
      ensureDeinitialized: function() {
        this._textureAndFrameBufferSlot.ensureDeinitialized();
      },
      _textureAndFramebufferInitializer: function() {
        var GL = WebGLRenderingContext;
        var gl = initializedWglContext().gl;
        var result = {
          texture: gl.createTexture(),
          framebuffer: gl.createFramebuffer()
        };
        gl.bindTexture(GL.TEXTURE_2D, result.texture);
        gl.bindFramebuffer(GL.FRAMEBUFFER, result.framebuffer);
        try {
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
          gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, this.width, this.height, 0, GL.RGBA, this.pixelType, null);
          checkGetErrorResult(gl, "texImage2D");
          gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, result.texture, 0);
          checkGetErrorResult(gl, "framebufferTexture2D");
          checkFrameBufferStatusResult(gl);
        } finally {
          gl.bindTexture(GL.TEXTURE_2D, null);
          gl.bindFramebuffer(GL.FRAMEBUFFER, null);
        }
        return result;
      },
      readPixels: function() {
        var isOnHotPath = arguments[0] !== (void 0) ? arguments[0] : true;
        var GL = WebGLRenderingContext;
        if (!this._hasBeenRenderedTo) {
          throw new Error("Called readPixels on a texture that hasn't been rendered to.");
        }
        var outputBuffer;
        switch (this.pixelType) {
          case GL.UNSIGNED_BYTE:
            outputBuffer = new Uint8Array(this.width * this.height * 4);
            break;
          case GL.FLOAT:
            outputBuffer = new Float32Array(this.width * this.height * 4);
            break;
          default:
            throw new Error("Unrecognized pixel type.");
        }
        if (this.width === 0 || this.height === 0) {
          return outputBuffer;
        }
        var gl = initializedWglContext().gl;
        gl.bindFramebuffer(GL.FRAMEBUFFER, this.initializedFramebuffer());
        checkGetErrorResult(gl, "framebufferTexture2D", isOnHotPath);
        checkFrameBufferStatusResult(gl, isOnHotPath);
        gl.readPixels(0, 0, this.width, this.height, GL.RGBA, this.pixelType, outputBuffer);
        checkGetErrorResult(gl, ("readPixels(..., RGBA, " + this.pixelType + ", ...)"), isOnHotPath);
        return outputBuffer;
      }
    }, {
      preferredWidthHeightForSizePower: function(sizePower) {
        var w = 1 << Math.ceil(sizePower / 2);
        var h = 1 << Math.floor(sizePower / 2);
        if (w === 2 && h === 2) {
          w = 4;
          h = 1;
        }
        return {
          w: w,
          h: h
        };
      },
      _deinitialize: function($__3) {
        var $__4 = $__3,
            texture = $__4.texture,
            framebuffer = $__4.framebuffer;
        var gl = initializedWglContext().gl;
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(framebuffer);
      }
    });
  }();
  return {get WglTexture() {
      return WglTexture;
    }};
});
//# sourceURL=src/webgl/WglTexture.js
;$traceurRuntime.registerModule("src/webgl/WglTexturePool.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglTexturePool.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../base/DetailedError.js", "src/webgl/WglTexturePool.js")).DetailedError;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglTexture.js", "src/webgl/WglTexturePool.js")).WglTexture;
  var provideWglTexturePoolToWglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglConfiguredShader.js", "src/webgl/WglTexturePool.js")).provideWglTexturePoolToWglConfiguredShader;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ShaderCoders.js", "src/webgl/WglTexturePool.js")).currentShaderCoder;
  var FLOAT_POOL = [];
  var BYTE_POOL = [];
  var unreturnedTextureCount = 0;
  var WglTexturePool = function() {
    function WglTexturePool() {}
    return ($traceurRuntime.createClass)(WglTexturePool, {}, {
      _bucketFor: function(sizePower, pixelType) {
        if (!Number.isInteger(sizePower) || sizePower < 0 || sizePower > 50) {
          throw new DetailedError("Bad sizePower", {
            sizePower: sizePower,
            pixelType: pixelType
          });
        }
        var pool = pixelType === WebGLRenderingContext.FLOAT ? FLOAT_POOL : BYTE_POOL;
        while (pool.length <= sizePower) {
          pool.push([]);
        }
        return pool[sizePower];
      },
      take: function(sizePower, pixelType) {
        if (sizePower === -Infinity) {
          return new WglTexture(0, 0, pixelType);
        }
        var bucket = WglTexturePool._bucketFor(sizePower, pixelType);
        unreturnedTextureCount++;
        if (unreturnedTextureCount > 1000) {
          console.warn(("High borrowed texture count: " + unreturnedTextureCount + ". (Maybe a leak?)"));
        }
        if (bucket.length > 0) {
          return bucket.pop();
        }
        var $__2 = WglTexture.preferredWidthHeightForSizePower(sizePower),
            w = $__2.w,
            h = $__2.h;
        return new WglTexture(w, h, pixelType);
      },
      deposit: function(texture) {
        var detailsShownWhenUsedAfterDone = arguments[1] !== (void 0) ? arguments[1] : '[no dealloc details]';
        if (!(texture instanceof WglTexture)) {
          throw new DetailedError("Not a texture", {
            texture: texture,
            detailsShownWhenUsedAfterDone: detailsShownWhenUsedAfterDone
          });
        }
        if (texture.width === 0) {
          return;
        }
        var bucket = WglTexturePool._bucketFor(texture.sizePower(), texture.pixelType);
        unreturnedTextureCount--;
        bucket.push(texture.invalidateButMoveToNewInstance(detailsShownWhenUsedAfterDone));
      },
      takeSame: function(texture) {
        return WglTexturePool.take(texture.sizePower(), texture.pixelType);
      },
      getUnReturnedTextureCount: function() {
        return unreturnedTextureCount;
      },
      takeRawFloatTex: function(sizePower) {
        return WglTexturePool.take(sizePower, WebGLRenderingContext.FLOAT);
      },
      takeRawByteTex: function(sizePower) {
        return WglTexturePool.take(sizePower, WebGLRenderingContext.UNSIGNED_BYTE);
      },
      takeBoolTex: function(sizePower) {
        return WglTexturePool.take(sizePower, WebGLRenderingContext.UNSIGNED_BYTE);
      },
      takeVecFloatTex: function(sizePower) {
        return WglTexturePool.take(sizePower + currentShaderCoder().float.powerSizeOverhead, currentShaderCoder().float.pixelType);
      },
      takeVec2Tex: function(sizePower) {
        return WglTexturePool.take(sizePower + currentShaderCoder().vec2.powerSizeOverhead, currentShaderCoder().vec2.pixelType);
      },
      takeVec4Tex: function(sizePower) {
        return WglTexturePool.take(sizePower + currentShaderCoder().vec4.powerSizeOverhead, currentShaderCoder().vec4.pixelType);
      }
    });
  }();
  WglTexture.prototype.deallocByDepositingInPool = function() {
    var detailsShownWhenUsedAfterDone = arguments[0];
    WglTexturePool.deposit(this, detailsShownWhenUsedAfterDone);
  };
  provideWglTexturePoolToWglConfiguredShader(WglTexturePool);
  return {get WglTexturePool() {
      return WglTexturePool;
    }};
});
//# sourceURL=src/webgl/WglTexturePool.js
;$traceurRuntime.registerModule("src/webgl/WglTextureTrader.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglTextureTrader.js";
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglConfiguredShader.js", "src/webgl/WglTextureTrader.js")).WglConfiguredShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglTexture.js", "src/webgl/WglTextureTrader.js")).WglTexture;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WglTexturePool.js", "src/webgl/WglTextureTrader.js")).WglTexturePool;
  var WglTextureTrader = function() {
    function WglTextureTrader(texture) {
      this.currentTexture = texture;
      this._dontDeallocFlag = false;
    }
    return ($traceurRuntime.createClass)(WglTextureTrader, {
      dontDeallocCurrentTexture: function() {
        this._dontDeallocFlag = true;
        return this.currentTexture;
      },
      shadeAndTrade: function(shaderFunc) {
        var newTexture = arguments[1];
        var src = this.currentTexture;
        var deallocSrc = !this._dontDeallocFlag;
        var dst = newTexture || WglTexturePool.takeSame(src);
        var configuredShader = shaderFunc instanceof WglConfiguredShader ? shaderFunc : shaderFunc(src);
        configuredShader.renderTo(dst);
        this.currentTexture = dst;
        this._dontDeallocFlag = false;
        if (deallocSrc) {
          src.deallocByDepositingInPool('WglTexturePool shadeAndTrade');
        }
      },
      shadeHalveAndTrade: function(reducingShaderFunc) {
        this.shadeAndTrade(reducingShaderFunc, WglTexturePool.take(Math.max(0, this.currentTexture.sizePower() - 1), this.currentTexture.pixelType));
      },
      shadeQuarterAndTrade: function(reducingShaderFunc) {
        this.shadeAndTrade(reducingShaderFunc, WglTexturePool.take(Math.max(0, this.currentTexture.sizePower() - 2), this.currentTexture.pixelType));
      }
    }, {});
  }();
  WglTexture.prototype.tradeThrough = function(traderFunc) {
    var keepInput = arguments[1] !== (void 0) ? arguments[1] : false;
    var t = new WglTextureTrader(this);
    if (keepInput) {
      t.dontDeallocCurrentTexture();
    }
    traderFunc(t);
    return t.currentTexture;
  };
  return {get WglTextureTrader() {
      return WglTextureTrader;
    }};
});
//# sourceURL=src/webgl/WglTextureTrader.js
;$traceurRuntime.registerModule("src/webgl/WglUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglUtil.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Config.js", "src/webgl/WglUtil.js")).Config;
  function checkGetErrorResult(gl, previousOperationDescription) {
    var isOnHotPath = arguments[2] !== (void 0) ? arguments[2] : false;
    var $__1;
    if (isOnHotPath && !Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS) {
      return;
    }
    var code = gl.getError();
    var GL = WebGLRenderingContext;
    if (code === GL.NO_ERROR) {
      return;
    }
    var msgs = ($__1 = {}, Object.defineProperty($__1, 0x0500, {
      value: "INVALID_ENUM [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0501, {
      value: "INVALID_VALUE [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0502, {
      value: "INVALID_OPERATION [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0505, {
      value: "OUT_OF_MEMORY [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0506, {
      value: "INVALID_FRAMEBUFFER_OPERATION [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x9242, {
      value: "CONTEXT_LOST_WEBGL [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_ENUM, {
      value: "INVALID_ENUM",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_VALUE, {
      value: "INVALID_VALUE",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_OPERATION, {
      value: "INVALID_OPERATION",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.OUT_OF_MEMORY, {
      value: "OUT_OF_MEMORY",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_FRAMEBUFFER_OPERATION, {
      value: "INVALID_FRAMEBUFFER_OPERATION",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.CONTEXT_LOST_WEBGL, {
      value: "CONTEXT_LOST_WEBGL",
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1);
    var d = msgs[code] !== undefined ? msgs[code] : "?";
    throw new Error(("gl.getError() returned 0x" + code.toString(16) + " (" + d + ") after " + previousOperationDescription + "."));
  }
  function checkFrameBufferStatusResult(gl) {
    var isOnHotPath = arguments[1] !== (void 0) ? arguments[1] : false;
    var $__1;
    if (isOnHotPath && !Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS) {
      return;
    }
    var GL = WebGLRenderingContext;
    var code = gl.checkFramebufferStatus(GL.FRAMEBUFFER);
    if (code === GL.FRAMEBUFFER_COMPLETE) {
      return;
    }
    var msgs = ($__1 = {}, Object.defineProperty($__1, 0, {
      value: "Argument wasn't a frame buffer",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0500, {
      value: "INVALID_ENUM [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CD6, {
      value: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CD7, {
      value: "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CD9, {
      value: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CDD, {
      value: "FRAMEBUFFER_UNSUPPORTED [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_ENUM, {
      value: "INVALID_ENUM",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT, {
      value: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, {
      value: "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS, {
      value: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_UNSUPPORTED, {
      value: "FRAMEBUFFER_UNSUPPORTED",
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1);
    var d = msgs[code] !== undefined ? msgs[code] : "?";
    throw new Error(("gl.checkFramebufferStatus() returned 0x" + code.toString(16) + " (" + d + ")."));
  }
  return {
    get checkGetErrorResult() {
      return checkGetErrorResult;
    },
    get checkFrameBufferStatusResult() {
      return checkFrameBufferStatusResult;
    }
  };
});
//# sourceURL=src/webgl/WglUtil.js
;$traceurRuntime.registerModule("test/base/Describe.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Describe.test.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Describe.test.js")),
      Suite = $__5.Suite,
      assertThat = $__5.assertThat;
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Describe.js", "test/base/Describe.test.js")).describe;
  var suite = new Suite("Describe");
  var DescribableClass = function() {
    function DescribableClass() {
      this.x = 1;
    }
    return ($traceurRuntime.createClass)(DescribableClass, {}, {});
  }();
  var DescribedClass = function() {
    function DescribedClass() {
      this.x = 1;
    }
    return ($traceurRuntime.createClass)(DescribedClass, {toString: function() {
        return "described";
      }}, {});
  }();
  var SomeIterable = function() {
    var $__4;
    function SomeIterable() {}
    return ($traceurRuntime.createClass)(SomeIterable, ($__4 = {}, Object.defineProperty($__4, Symbol.iterator, {
      value: function() {
        return [1, 2, 3][Symbol.iterator]();
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__4), {});
  }();
  suite.test("trivial", function() {
    assertThat(describe(undefined)).isEqualTo("undefined");
    assertThat(describe(null)).isEqualTo("null");
    assertThat(describe(false)).isEqualTo("false");
    assertThat(describe("")).isEqualTo('""');
    assertThat(describe(0)).isEqualTo("0");
    assertThat(describe(Symbol())).isEqualTo("Symbol()");
    assertThat(describe([])).isEqualTo("[]");
    assertThat(describe({})).isEqualTo("{}");
    assertThat(describe(new Float32Array(0))).isEqualTo("Float32Array[]");
    assertThat(describe(new Int8Array(0))).isEqualTo("Int8Array[]");
    assertThat(describe(new Map())).isEqualTo("Map{}");
    assertThat(describe(new Set())).isEqualTo("Set{}");
  });
  suite.test("simple", function() {
    assertThat(describe(true)).isEqualTo("true");
    assertThat(describe(1.5)).isEqualTo("1.5");
    assertThat(describe("b")).isEqualTo('"b"');
    assertThat(describe(Symbol("a"))).isEqualTo('Symbol(a)');
    assertThat(describe(Infinity)).isEqualTo("Infinity");
    assertThat(describe(-Infinity)).isEqualTo("-Infinity");
    assertThat(describe(NaN)).isEqualTo("NaN");
    assertThat(describe([1, 2, 3])).isEqualTo("[1, 2, 3]");
    assertThat(describe(new Float32Array([1, 2, 3]))).isEqualTo("Float32Array[1, 2, 3]");
    assertThat(describe(new Int8Array([1, 2, 3]))).isEqualTo("Int8Array[1, 2, 3]");
    assertThat(describe(new Set([2]))).isEqualTo("Set{2}");
    assertThat(describe(new Map([[2, "b"]]))).isEqualTo('Map{2: "b"}');
    assertThat(describe({2: "b"})).isEqualTo('{"2": "b"}');
    assertThat(describe(new DescribedClass())).isEqualTo("described");
    assertThat(describe(new DescribableClass())).isEqualTo('(Type: DescribableClass){"x": 1}');
    assertThat(describe(new SomeIterable())).isEqualTo("SomeIterable[1, 2, 3]");
  });
  suite.test("recursion", function() {
    var a = [];
    a.push(a);
    assertThat(describe(a, 2)).isEqualTo("[[!recursion-limit!]]");
    assertThat(describe(a, 10)).isEqualTo("[[[[[[[[[[!recursion-limit!]]]]]]]]]]");
    var m = new Map();
    m.set(1, m);
    assertThat(describe(m, 2)).isEqualTo("Map{1: Map{1: !recursion-limit!}}");
    assertThat(describe(m, 10)).isEqualTo("Map{1: Map{1: Map{1: Map{1: Map{1: Map{1: Map{1: Map{1: Map{1: Map{1: !recursion-limit!}}}}}}}}}}");
    var s = new Set();
    s.add(s);
    assertThat(describe(s, 2)).isEqualTo("Set{Set{!recursion-limit!}}");
    assertThat(describe(s, 10)).isEqualTo("Set{Set{Set{Set{Set{Set{Set{Set{Set{Set{!recursion-limit!}}}}}}}}}}");
    var o = {};
    o[2] = o;
    assertThat(describe(o, 2)).isEqualTo('{"2": {"2": !recursion-limit!}}');
    assertThat(describe(o, 10)).isEqualTo('{"2": {"2": {"2": {"2": {"2": {"2": {"2": {"2": {"2": {"2": !recursion-limit!}}}}}}}}}}');
    assertThat(describe(a)).isNotEqualTo(undefined);
    assertThat(describe(m)).isNotEqualTo(undefined);
    assertThat(describe(s)).isNotEqualTo(undefined);
    assertThat(describe(o)).isNotEqualTo(undefined);
  });
  return {};
});
//# sourceURL=test/base/Describe.test.js
;$traceurRuntime.registerModule("test/base/DetailedError.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/DetailedError.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/DetailedError.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/DetailedError.js", "test/base/DetailedError.test.js")).DetailedError;
  var suite = new Suite("DetailedError");
  var ReentrantDescription = function() {
    function ReentrantDescription() {}
    return ($traceurRuntime.createClass)(ReentrantDescription, {toString: function() {
        return new DetailedError("re-enter", this).details;
      }}, {});
  }();
  suite.test("re-entrant_details", function() {
    assertThat(new DetailedError("test", new ReentrantDescription()).details).isEqualTo("(failed to describe detailsObj due to possibly re-entrancy)");
  });
  return {};
});
//# sourceURL=test/base/DetailedError.test.js
;$traceurRuntime.registerModule("test/base/Equate.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Equate.test.js";
  var $__39 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Equate.test.js")),
      Suite = $__39.Suite,
      fail = $__39.fail,
      assertTrue = $__39.assertTrue,
      assertFalse = $__39.assertFalse;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Equate.js", "test/base/Equate.test.js")).equate;
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Describe.js", "test/base/Equate.test.js")).describe;
  var suite = new Suite("Equate");
  var EmptyClass = function() {
    function EmptyClass() {}
    return ($traceurRuntime.createClass)(EmptyClass, {}, {});
  }();
  var EmptyClass2 = function() {
    function EmptyClass2() {}
    return ($traceurRuntime.createClass)(EmptyClass2, {}, {});
  }();
  var PropClass = function() {
    function PropClass(v) {
      this.v = v;
    }
    return ($traceurRuntime.createClass)(PropClass, {}, {});
  }();
  var SomeIterable = function() {
    var $__10;
    function SomeIterable() {}
    return ($traceurRuntime.createClass)(SomeIterable, ($__10 = {}, Object.defineProperty($__10, Symbol.iterator, {
      value: function() {
        return [1, 2, 3][Symbol.iterator]();
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__10), {});
  }();
  var One = function() {
    function One() {}
    return ($traceurRuntime.createClass)(One, {isEqualTo: function(other) {
        return this !== null && other === 1 || other instanceof One;
      }}, {});
  }();
  var First = function() {
    function First(x, y) {
      this.x = x;
      this.y = y;
    }
    return ($traceurRuntime.createClass)(First, {isEqualTo: function(other) {
        return other instanceof First && this.x === other.x;
      }}, {});
  }();
  var Iter = function() {
    function Iter(items) {
      this[Symbol.iterator] = function() {
        return items[Symbol.iterator]();
      };
    }
    return ($traceurRuntime.createClass)(Iter, {}, {});
  }();
  var Iter2 = function() {
    function Iter2(items) {
      this[Symbol.iterator] = function() {
        return items[Symbol.iterator]();
      };
    }
    return ($traceurRuntime.createClass)(Iter2, {}, {});
  }();
  suite.test("groups", function() {
    var groups = [[null, null], [undefined, undefined], [true, true], [false, false], [0, 0.0, 0], [1, 1.0, 1, new One(), new One()], [-1, -1.0, -1], [2, 2.0, 2], [Infinity, Infinity], [-Infinity, -Infinity], [NaN, NaN], ["", ""], ["0", "0"], [[], []], [[[]], [[]]], [new Iter([]), new Iter([])], [new Iter([1]), new Iter([1])], [new Iter([1, 2, 3]), new Iter([1, 2, 3])], [new Iter2([]), new Iter2([])], [new Float32Array(0), new Float32Array(0)], [new Int32Array(0), new Int32Array(0)], [new Int32Array([1, 2, 3]), new Int32Array([1, 2, 3])], [[1, 2, 3], [1, 2, 3]], [[1, 4, 3], [1, 4, 3]], [{}, {}], [{0: {}}, {0: {}}], [{a: 2}, {a: 2}], [new Map(), new Map()], [new Map([[1, 2]]), new Map([[1, 2]])], [new Map([[1, 3]]), new Map([[1, 3]])], [new Map([[3, 2]]), new Map([[3, 2]])], [new Map([[2, 1]]), new Map([[2, 1]])], [new Map([["2", 1]]), new Map([["2", 1]])], [new Map([[1, 2], ["a", 2]]), new Map([["a", 2], [1, 2]])], [new Set(), new Set()], [new Set(["a"]), new Set(["a"])], [new Set(["b"]), new Set(["b"])], [new Set([2, "a"]), new Set(["a", 2])], [new SomeIterable(), new SomeIterable()], [new EmptyClass(), new EmptyClass()], [new EmptyClass2(), new EmptyClass2()], [new PropClass(1), new PropClass(1)], [new PropClass(2), new PropClass(2)], [Symbol("a")], [new First(1, 2), new First(1, 3), new First(1, 2), new First(1, 3)], [new First(2, 2), new First(2, 3), new First(2, 2), new First(2, 3)], [{frump: new Map([["trump", [1, new Set([2, "a"]), new Float32Array(5)]]])}, {frump: new Map([["trump", [1, new Set([2, "a"]), new Float32Array(5)]]])}]];
    assertTrue(equate(1, 1));
    assertFalse(equate(1, 2));
    var $__35 = true;
    var $__36 = false;
    var $__37 = undefined;
    try {
      for (var $__33 = void 0,
          $__32 = (groups)[Symbol.iterator](); !($__35 = ($__33 = $__32.next()).done); $__35 = true) {
        var g1 = $__33.value;
        {
          var $__28 = true;
          var $__29 = false;
          var $__30 = undefined;
          try {
            for (var $__26 = void 0,
                $__25 = (groups)[Symbol.iterator](); !($__28 = ($__26 = $__25.next()).done); $__28 = true) {
              var g2 = $__26.value;
              {
                var $__21 = true;
                var $__22 = false;
                var $__23 = undefined;
                try {
                  for (var $__19 = void 0,
                      $__18 = (g1)[Symbol.iterator](); !($__21 = ($__19 = $__18.next()).done); $__21 = true) {
                    var e1 = $__19.value;
                    {
                      var $__14 = true;
                      var $__15 = false;
                      var $__16 = undefined;
                      try {
                        for (var $__12 = void 0,
                            $__11 = (g2)[Symbol.iterator](); !($__14 = ($__12 = $__11.next()).done); $__14 = true) {
                          var e2 = $__12.value;
                          {
                            var actual = equate(e1, e2);
                            var expected = g1 === g2;
                            var eq = expected ? "equal" : "NOT equal";
                            if (actual !== expected) {
                              fail(("Expected <" + describe(e1) + "> to " + eq + " <" + describe(e2) + ">."));
                            }
                          }
                        }
                      } catch ($__17) {
                        $__15 = true;
                        $__16 = $__17;
                      } finally {
                        try {
                          if (!$__14 && $__11.return != null) {
                            $__11.return();
                          }
                        } finally {
                          if ($__15) {
                            throw $__16;
                          }
                        }
                      }
                    }
                  }
                } catch ($__24) {
                  $__22 = true;
                  $__23 = $__24;
                } finally {
                  try {
                    if (!$__21 && $__18.return != null) {
                      $__18.return();
                    }
                  } finally {
                    if ($__22) {
                      throw $__23;
                    }
                  }
                }
              }
            }
          } catch ($__31) {
            $__29 = true;
            $__30 = $__31;
          } finally {
            try {
              if (!$__28 && $__25.return != null) {
                $__25.return();
              }
            } finally {
              if ($__29) {
                throw $__30;
              }
            }
          }
        }
      }
    } catch ($__38) {
      $__36 = true;
      $__37 = $__38;
    } finally {
      try {
        if (!$__35 && $__32.return != null) {
          $__32.return();
        }
      } finally {
        if ($__36) {
          throw $__37;
        }
      }
    }
  });
  return {};
});
//# sourceURL=test/base/Equate.test.js
;$traceurRuntime.registerModule("test/base/Format.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Format.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Format.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat,
      assertThrows = $__0.assertThrows;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Format.js", "test/base/Format.test.js")).Format;
  var suite = new Suite("Format");
  suite.test("formatFloat", function() {
    assertThat(Format.CONSISTENT.formatFloat(0)).isEqualTo("0.00");
    assertThat(Format.EXACT.formatFloat(0)).isEqualTo("0");
    assertThat(Format.MINIFIED.formatFloat(0)).isEqualTo("0");
    assertThat(Format.SIMPLIFIED.formatFloat(0)).isEqualTo("0");
    assertThat(Format.CONSISTENT.formatFloat(2)).isEqualTo("2.00");
    assertThat(Format.EXACT.formatFloat(2)).isEqualTo("2");
    assertThat(Format.MINIFIED.formatFloat(2)).isEqualTo("2");
    assertThat(Format.SIMPLIFIED.formatFloat(2)).isEqualTo("2");
    assertThat(Format.CONSISTENT.formatFloat(-3)).isEqualTo("-3.00");
    assertThat(Format.EXACT.formatFloat(-3)).isEqualTo("-3");
    assertThat(Format.MINIFIED.formatFloat(-3)).isEqualTo("-3");
    assertThat(Format.SIMPLIFIED.formatFloat(-3)).isEqualTo("-3");
    assertThat(Format.CONSISTENT.formatFloat(1 / 3)).isEqualTo("0.33");
    assertThat(Format.EXACT.formatFloat(1 / 3)).isEqualTo("\u2153");
    assertThat(Format.MINIFIED.formatFloat(1 / 3)).isEqualTo("\u2153");
    assertThat(Format.SIMPLIFIED.formatFloat(1 / 3)).isEqualTo("\u2153");
    assertThat(Format.CONSISTENT.formatFloat(1 / 3 + 0.00001)).isEqualTo("0.33");
    assertThat(Format.EXACT.formatFloat(1 / 3 + 0.00001)).isEqualTo("0.3333433333333333");
    assertThat(Format.MINIFIED.formatFloat(1 / 3 + 0.00001)).isEqualTo("0.3333433333333333");
    assertThat(Format.SIMPLIFIED.formatFloat(1 / 3 + 0.00001)).isEqualTo("\u2153");
  });
  suite.test("parseFloatFromCompactString", function() {
    assertThrows(function() {
      return Format.parseFloat("");
    });
    assertThrows(function() {
      return Format.parseFloat("a");
    });
    assertThrows(function() {
      return Format.parseFloat("one");
    });
    assertThat(Format.parseFloat("0")).isEqualTo(0);
    assertThat(Format.parseFloat("1")).isEqualTo(1);
    assertThat(Format.parseFloat("-1")).isEqualTo(-1);
    assertThat(Format.parseFloat("\u00BD")).isEqualTo(0.5);
    assertThat(Format.parseFloat("2")).isEqualTo(2);
    assertThat(Format.parseFloat("501")).isEqualTo(501);
    assertThat(Format.parseFloat("\u221A2")).isEqualTo(Math.sqrt(2));
    assertThat(Format.parseFloat("-\u221A3")).isEqualTo(-Math.sqrt(3));
    assertThat(Format.parseFloat("0.7071067811865475")).isEqualTo(1 / Math.sqrt(2));
    assertThat(Format.parseFloat("0.7071067811865476")).isEqualTo(Math.sqrt(1 / 2));
    assertThat(Format.parseFloat("\u221A\u00BD")).isEqualTo(Math.sqrt(1 / 2));
    assertThat(Format.parseFloat("-\u2153")).isEqualTo(-1 / 3);
    assertThat(Format.parseFloat("0.34")).isEqualTo(0.34);
    assertThat(Format.parseFloat("0.342123")).isEqualTo(0.342123);
    assertThat(Format.parseFloat("0.342123000")).isEqualTo(0.342123000);
  });
  suite.test("simplifyByRounding", function() {
    assertThat(Format.simplifyByRounding(1, 0.01)).isEqualTo(1);
    assertThat(Format.simplifyByRounding(1.00001, 0)).isEqualTo(1.00001);
    assertThat(Format.simplifyByRounding(1.00001, 0.01)).isEqualTo(1);
    assertThat(Format.simplifyByRounding(Math.sqrt(1 / 2) + 0.0001, 0.01)).isEqualTo(Math.sqrt(0.5));
    assertThat(Format.simplifyByRounding(1 / Math.sqrt(2), 0.0001)).isEqualTo(Math.sqrt(1 / 2));
    assertThat(Format.simplifyByRounding(-1 / 3 + 0.0000001, 0.001)).isEqualTo(-1 / 3);
    assertThat(Format.simplifyByRounding(1 / 3 + 0.0000001, 0.001)).isEqualTo(1 / 3);
    assertThat(Format.simplifyByRounding(1 / 3 + 0.01, 0.001)).isNotEqualTo(1 / 3);
    assertThat(Format.simplifyByRounding(0.1234, 0.0001)).isEqualTo(0.1234);
    assertThat(Format.simplifyByRounding(0, 0.0001)).isEqualTo(0);
  });
  return {};
});
//# sourceURL=test/base/Format.test.js
;$traceurRuntime.registerModule("test/base/Obs.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Obs.test.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Obs.test.js")),
      Suite = $__3.Suite,
      assertThat = $__3.assertThat;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Obs.js", "test/base/Obs.test.js")),
      Observable = $__4.Observable,
      ObservableValue = $__4.ObservableValue,
      ObservableSource = $__4.ObservableSource;
  var suite = new Suite("Obs");
  var record = function(observable) {
    var out = [];
    var stop = observable.subscribe(function(e) {
      return out.push(e);
    });
    return {
      out: out,
      stop: stop
    };
  };
  suite.test("Observable.of", function() {
    assertThat(record(Observable.of()).out).isEqualTo([]);
    assertThat(record(Observable.of(1, 2, 3)).out).isEqualTo([1, 2, 3]);
  });
  suite.test("Observable.snapshot", function() {
    assertThat(Observable.of().snapshot()).isEqualTo([]);
    assertThat(Observable.of(1, 2, 3).snapshot()).isEqualTo([1, 2, 3]);
  });
  suite.test("Observable.map", function() {
    assertThat(Observable.of(1, 2, 3).map(function(e) {
      return e * 2;
    }).snapshot()).isEqualTo([2, 4, 6]);
  });
  suite.test("Observable.filter", function() {
    assertThat(Observable.of(1, 2, 3).filter(function(e) {
      return e !== 2;
    }).snapshot()).isEqualTo([1, 3]);
  });
  suite.test("Observable.zipLatest", function() {
    var v1 = new ObservableSource();
    var v2 = new ObservableSource();
    var seen = [];
    var unreg = v1.observable().zipLatest(v2.observable(), function(e1, e2) {
      return e1 + e2;
    }).subscribe(function(e) {
      return seen.push(e);
    });
    assertThat(seen).isEqualTo([]);
    v1.send(1);
    assertThat(seen).isEqualTo([]);
    v1.send(2);
    assertThat(seen).isEqualTo([]);
    v2.send(10);
    assertThat(seen).isEqualTo([12]);
    v1.send(3);
    assertThat(seen).isEqualTo([12, 13]);
    v1.send(4);
    assertThat(seen).isEqualTo([12, 13, 14]);
    v2.send(20);
    assertThat(seen).isEqualTo([12, 13, 14, 24]);
    unreg();
    v2.send(30);
    assertThat(seen).isEqualTo([12, 13, 14, 24]);
  });
  suite.test("Observable.flattenLatest", function() {
    var c = new ObservableSource();
    var v1 = new ObservableSource();
    var v2 = new ObservableSource();
    var v3 = new ObservableSource();
    var seen = [];
    var unreg = c.observable().flattenLatest().subscribe(function(e) {
      return seen.push(e);
    });
    assertThat(seen).isEqualTo([]);
    c.send(v1.observable());
    assertThat(seen).isEqualTo([]);
    v1.send(1);
    assertThat(seen).isEqualTo([1]);
    v1.send(2);
    assertThat(seen).isEqualTo([1, 2]);
    c.send(v2.observable());
    assertThat(seen).isEqualTo([1, 2]);
    v1.send(3);
    assertThat(seen).isEqualTo([1, 2]);
    v2.send(4);
    assertThat(seen).isEqualTo([1, 2, 4]);
    c.send(v1.observable());
    c.send(v2.observable());
    c.send(v3.observable());
    assertThat(seen).isEqualTo([1, 2, 4]);
    v1.send(5);
    v2.send(6);
    v3.send(7);
    assertThat(seen).isEqualTo([1, 2, 4, 7]);
    unreg();
    v1.send(8);
    v2.send(9);
    v3.send(10);
    assertThat(seen).isEqualTo([1, 2, 4, 7]);
  });
  suite.test("Observable.whenDifferent", function() {
    assertThat(Observable.of(1, 2, 2, 3).whenDifferent().snapshot()).isEqualTo([1, 2, 3]);
    assertThat(Observable.of(undefined, 2, 2, 3).whenDifferent().snapshot()).isEqualTo([undefined, 2, 3]);
    assertThat(Observable.of(2, 3, 5, 7, 10, 13, 17, 19, 23).whenDifferent(function(e1, e2) {
      return e1 % 3 === e2 % 3;
    }).snapshot()).isEqualTo([2, 3, 5, 7, 17, 19, 23]);
  });
  suite.test("Observable.skip", function() {
    assertThat(Observable.of(1, 2, 3).skip(0).snapshot()).isEqualTo([1, 2, 3]);
    assertThat(Observable.of(1, 2, 3).skip(1).snapshot()).isEqualTo([2, 3]);
    assertThat(Observable.of(1, 2, 3).skip(2).snapshot()).isEqualTo([3]);
    assertThat(Observable.of(1, 2, 3).skip(3).snapshot()).isEqualTo([]);
    assertThat(Observable.of(1, 2, 3).skip(5).snapshot()).isEqualTo([]);
  });
  suite.test("Observable.flatten", function() {
    assertThat(Observable.of(Observable.of(1, 2, 3), Observable.of(4, 5, 6), Observable.of(7, 8)).flatten().snapshot()).isEqualTo([1, 2, 3, 4, 5, 6, 7, 8]);
    var v1 = new ObservableSource();
    var v2 = new ObservableSource();
    var c = new ObservableSource();
    var $__1 = record(c.observable().flatten()),
        out = $__1.out,
        stop = $__1.stop;
    assertThat(out).isEqualTo([]);
    c.send(v1.observable());
    assertThat(out).isEqualTo([]);
    v1.send('a');
    assertThat(out).isEqualTo(['a']);
    c.send(v2.observable());
    assertThat(out).isEqualTo(['a']);
    c.send(v2.observable());
    assertThat(out).isEqualTo(['a']);
    v2.send('b');
    assertThat(out).isEqualTo(['a', 'b', 'b']);
    stop();
    v1.send('c');
    v2.send('c');
    c.send(new ObservableValue('c').observable());
    assertThat(out).isEqualTo(['a', 'b', 'b']);
  });
  suite.test("ObservableValue_setVsGet", function() {
    var v = new ObservableValue('a');
    assertThat(v.get()).isEqualTo('a');
    v.set('b');
    assertThat(v.get()).isEqualTo('b');
  });
  suite.test("ObservableValue_observable", function() {
    var v = new ObservableValue('a');
    var $__1 = record(v.observable()),
        out = $__1.out,
        stop = $__1.stop;
    assertThat(out).isEqualTo(['a']);
    v.set('b');
    assertThat(out).isEqualTo(['a', 'b']);
    v.set('c');
    assertThat(out).isEqualTo(['a', 'b', 'c']);
    stop();
    v.set('d');
    assertThat(out).isEqualTo(['a', 'b', 'c']);
  });
  suite.test("ObservableValue_observable_multiple", function() {
    var v = new ObservableValue('a');
    var $__1 = record(v.observable()),
        out1 = $__1.out,
        stop1 = $__1.stop;
    var $__2 = record(v.observable()),
        out2 = $__2.out,
        stop2 = $__2.stop;
    assertThat(out1).isEqualTo(['a']);
    assertThat(out2).isEqualTo(['a']);
    stop2();
    assertThat(out1).isEqualTo(['a']);
    assertThat(out2).isEqualTo(['a']);
    v.set('b');
    assertThat(out1).isEqualTo(['a', 'b']);
    assertThat(out2).isEqualTo(['a']);
    stop1();
    assertThat(out1).isEqualTo(['a', 'b']);
    assertThat(out2).isEqualTo(['a']);
  });
  suite.test("ObservableSource_observable", function() {
    var v = new ObservableSource();
    var $__1 = record(v.observable()),
        out = $__1.out,
        stop = $__1.stop;
    assertThat(out).isEqualTo([]);
    v.send('b');
    assertThat(out).isEqualTo(['b']);
    v.send('c');
    assertThat(out).isEqualTo(['b', 'c']);
    stop();
    v.send('d');
    assertThat(out).isEqualTo(['b', 'c']);
  });
  suite.test("ObservableSource_observable_multiple", function() {
    var v = new ObservableSource();
    var $__1 = record(v.observable()),
        out1 = $__1.out,
        stop1 = $__1.stop;
    var $__2 = record(v.observable()),
        out2 = $__2.out,
        stop2 = $__2.stop;
    assertThat(out1).isEqualTo([]);
    assertThat(out2).isEqualTo([]);
    v.send('a');
    assertThat(out1).isEqualTo(['a']);
    assertThat(out2).isEqualTo(['a']);
    stop2();
    assertThat(out1).isEqualTo(['a']);
    assertThat(out2).isEqualTo(['a']);
    v.send('b');
    assertThat(out1).isEqualTo(['a', 'b']);
    assertThat(out2).isEqualTo(['a']);
    stop1();
    assertThat(out1).isEqualTo(['a', 'b']);
    assertThat(out2).isEqualTo(['a']);
  });
  suite.test("peek", function() {
    var a = [];
    var v = new ObservableSource();
    v.observable().peek(function(e) {
      return a.push(e);
    }).subscribe(function() {});
    assertThat(a).isEqualTo([]);
    v.send(2);
    assertThat(a).isEqualTo([2]);
  });
  return {};
});
//# sourceURL=test/base/Obs.test.js
;$traceurRuntime.registerModule("test/base/RestartableRng.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/RestartableRng.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/RestartableRng.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/RestartableRng.js", "test/base/RestartableRng.test.js")).RestartableRng;
  var suite = new Suite("RestartableRng");
  suite.test("pre-repeat_multiple-copies", function() {
    var rng1 = new RestartableRng();
    var v1 = rng1.random();
    var v2 = rng1.random();
    var rng2 = rng1.restarted();
    assertThat(rng2.random()).isEqualTo(v1);
    assertThat(rng2.random()).isEqualTo(v2);
    var rng3 = rng2.restarted();
    assertThat(rng3.random()).isEqualTo(v1);
    assertThat(rng3.random()).isEqualTo(v2);
    var rng4 = rng1.restarted();
    assertThat(rng4.random()).isEqualTo(v1);
    assertThat(rng4.random()).isEqualTo(v2);
  });
  suite.test("post-repeat", function() {
    var rng1 = new RestartableRng();
    var rng2 = rng1.restarted();
    var v1 = rng1.random();
    assertThat(rng2.random()).isEqualTo(v1);
  });
  suite.test("reverse-repeat", function() {
    var rng1 = new RestartableRng();
    var rng2 = rng1.restarted();
    var v1 = rng2.random();
    assertThat(rng1.random()).isEqualTo(v1);
  });
  return {};
});
//# sourceURL=test/base/RestartableRng.test.js
;$traceurRuntime.registerModule("test/base/Revision.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Revision.test.js";
  var $__28 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Revision.test.js")),
      Suite = $__28.Suite,
      assertThat = $__28.assertThat,
      assertThrows = $__28.assertThrows,
      assertTrue = $__28.assertTrue,
      assertFalse = $__28.assertFalse;
  var Revision = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Revision.js", "test/base/Revision.test.js")).Revision;
  var suite = new Suite("Revision");
  suite.test("constructor_isEqualTo", function() {
    assertThrows(function() {
      return new Revision([], 0, false);
    });
    assertThrows(function() {
      return new Revision(["a"], -1, false);
    });
    assertThrows(function() {
      return new Revision(["a"], 1, false);
    });
    assertThrows(function() {
      return new Revision(["a", "b"], 2, false);
    });
    var r = new Revision(["a", "b", "c"], 1, true);
    assertThat(r).isEqualTo(new Revision(["a", "b", "c"], 1, true));
    assertThat(r).isNotEqualTo(new Revision(["a", "b"], 1, true));
    assertThat(r).isNotEqualTo(new Revision(["a", "b", "d"], 1, true));
    assertThat(r).isNotEqualTo(new Revision(["a", "b", "c"], 2, true));
    assertThat(r).isNotEqualTo(new Revision(["a", "b", "c"], 1, false));
    assertThat(r).isNotEqualTo(undefined);
    assertThat(r).isNotEqualTo(5);
    var groups = [[new Revision(["a"], 0, false), new Revision(["a"], 0, false)], [new Revision(["a"], 0, true), new Revision(["a"], 0, true)], [new Revision(["a", "b"], 0, false), new Revision(["a", "b"], 0, false)], [new Revision(["b", "a"], 0, false), new Revision(["b", "a"], 0, false)], [new Revision(["b", "a"], 1, false), new Revision(["b", "a"], 1, false)]];
    var $__24 = true;
    var $__25 = false;
    var $__26 = undefined;
    try {
      for (var $__22 = void 0,
          $__21 = (groups)[Symbol.iterator](); !($__24 = ($__22 = $__21.next()).done); $__24 = true) {
        var g1 = $__22.value;
        {
          var $__17 = true;
          var $__18 = false;
          var $__19 = undefined;
          try {
            for (var $__15 = void 0,
                $__14 = (groups)[Symbol.iterator](); !($__17 = ($__15 = $__14.next()).done); $__17 = true) {
              var g2 = $__15.value;
              {
                var $__10 = true;
                var $__11 = false;
                var $__12 = undefined;
                try {
                  for (var $__8 = void 0,
                      $__7 = (g1)[Symbol.iterator](); !($__10 = ($__8 = $__7.next()).done); $__10 = true) {
                    var e1 = $__8.value;
                    {
                      var $__3 = true;
                      var $__4 = false;
                      var $__5 = undefined;
                      try {
                        for (var $__1 = void 0,
                            $__0 = (g2)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
                          var e2 = $__1.value;
                          {
                            if (g1 === g2) {
                              assertThat(e1).isEqualTo(e2);
                            } else {
                              assertThat(e1).isNotEqualTo(e2);
                            }
                          }
                        }
                      } catch ($__6) {
                        $__4 = true;
                        $__5 = $__6;
                      } finally {
                        try {
                          if (!$__3 && $__0.return != null) {
                            $__0.return();
                          }
                        } finally {
                          if ($__4) {
                            throw $__5;
                          }
                        }
                      }
                    }
                  }
                } catch ($__13) {
                  $__11 = true;
                  $__12 = $__13;
                } finally {
                  try {
                    if (!$__10 && $__7.return != null) {
                      $__7.return();
                    }
                  } finally {
                    if ($__11) {
                      throw $__12;
                    }
                  }
                }
              }
            }
          } catch ($__20) {
            $__18 = true;
            $__19 = $__20;
          } finally {
            try {
              if (!$__17 && $__14.return != null) {
                $__14.return();
              }
            } finally {
              if ($__18) {
                throw $__19;
              }
            }
          }
        }
      }
    } catch ($__27) {
      $__25 = true;
      $__26 = $__27;
    } finally {
      try {
        if (!$__24 && $__21.return != null) {
          $__21.return();
        }
      } finally {
        if ($__25) {
          throw $__26;
        }
      }
    }
  });
  suite.test("toString_exists", function() {
    assertThat(new Revision(["a", "b"], 1, false).toString()).isNotEqualTo(undefined);
  });
  suite.test("startingAt", function() {
    assertThat(Revision.startingAt("abc")).isEqualTo(new Revision(["abc"], 0, false));
  });
  suite.test("clear", function() {
    var r;
    r = new Revision(["abc"], 0, false);
    r.clear("xyz");
    assertThat(r).isEqualTo(new Revision(["xyz"], 0, false));
    r = new Revision(["r", "s", "t"], 2, true);
    r.clear("wxyz");
    assertThat(r).isEqualTo(new Revision(["wxyz"], 0, false));
  });
  suite.test("undo", function() {
    var r;
    r = new Revision(["abc"], 0, false);
    assertThat(r.undo()).isEqualTo(undefined);
    assertThat(r).isEqualTo(new Revision(["abc"], 0, false));
    r = new Revision(["abc", "def"], 0, false);
    assertThat(r.undo()).isEqualTo(undefined);
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, false));
    r = new Revision(["abc", "def"], 0, true);
    assertThat(r.undo()).isEqualTo("abc");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, false));
    r = new Revision(["abc", "def"], 1, false);
    assertThat(r.undo()).isEqualTo("abc");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, false));
    r = new Revision(["abc", "def"], 1, true);
    assertThat(r.undo()).isEqualTo("def");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    assertThat(new Revision(["abc", "def", "xyz"], 2, true).undo()).isEqualTo("xyz");
    assertThat(new Revision(["abc", "def", "xyz"], 2, false).undo()).isEqualTo("def");
    assertThat(new Revision(["abc", "def", "xyz"], 1, true).undo()).isEqualTo("def");
    assertThat(new Revision(["abc", "def", "xyz"], 1, false).undo()).isEqualTo("abc");
    assertThat(new Revision(["abc", "def", "xyz"], 0, true).undo()).isEqualTo("abc");
    assertThat(new Revision(["abc", "def", "xyz"], 0, false).undo()).isEqualTo(undefined);
  });
  suite.test("isAtBeginningOfHistory", function() {
    assertTrue(new Revision(["abc"], 0, false).isAtBeginningOfHistory());
    assertFalse(new Revision(["abc"], 0, true).isAtBeginningOfHistory());
    assertTrue(new Revision(["abc", "123"], 0, false).isAtBeginningOfHistory());
    assertFalse(new Revision(["abc", "123"], 0, true).isAtBeginningOfHistory());
    assertFalse(new Revision(["abc", "123"], 1, false).isAtBeginningOfHistory());
    assertFalse(new Revision(["abc", "123"], 1, true).isAtBeginningOfHistory());
  });
  suite.test("isAtBeginningOfHistory", function() {
    assertTrue(new Revision(["abc"], 0, false).isAtEndOfHistory());
    assertTrue(new Revision(["abc"], 0, true).isAtEndOfHistory());
    assertFalse(new Revision(["abc", "123"], 0, false).isAtEndOfHistory());
    assertFalse(new Revision(["abc", "123"], 0, true).isAtEndOfHistory());
    assertTrue(new Revision(["abc", "123"], 1, false).isAtEndOfHistory());
    assertTrue(new Revision(["abc", "123"], 1, true).isAtEndOfHistory());
  });
  suite.test("redo", function() {
    var r;
    r = new Revision(["abc"], 0, false);
    assertThat(r.redo()).isEqualTo(undefined);
    assertThat(r).isEqualTo(new Revision(["abc"], 0, false));
    r = new Revision(["abc", "def"], 0, false);
    assertThat(r.redo()).isEqualTo("def");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    r = new Revision(["abc", "def"], 0, true);
    assertThat(r.redo()).isEqualTo("def");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    r = new Revision(["abc", "def"], 1, false);
    assertThat(r.redo()).isEqualTo(undefined);
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    r = new Revision(["abc", "def"], 1, true);
    assertThat(r.redo()).isEqualTo(undefined);
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, true));
    assertThat(new Revision(["abc", "def", "xyz"], 0, false).redo()).isEqualTo("def");
    assertThat(new Revision(["abc", "def", "xyz"], 0, true).redo()).isEqualTo("def");
    assertThat(new Revision(["abc", "def", "xyz"], 1, false).redo()).isEqualTo("xyz");
    assertThat(new Revision(["abc", "def", "xyz"], 1, true).redo()).isEqualTo("xyz");
    assertThat(new Revision(["abc", "def", "xyz"], 2, false).redo()).isEqualTo(undefined);
    assertThat(new Revision(["abc", "def", "xyz"], 2, true).redo()).isEqualTo(undefined);
  });
  suite.test("startedWorkingOnCommit", function() {
    var r;
    r = new Revision(["abc"], 0, false);
    r.startedWorkingOnCommit();
    assertThat(r).isEqualTo(new Revision(["abc"], 0, true));
    r.startedWorkingOnCommit();
    assertThat(r).isEqualTo(new Revision(["abc"], 0, true));
    r = new Revision(["abc", "def"], 0, false);
    r.startedWorkingOnCommit();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, true));
    r.startedWorkingOnCommit();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, true));
    r = new Revision(["abc", "def"], 1, false);
    r.startedWorkingOnCommit();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, true));
    r.startedWorkingOnCommit();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, true));
  });
  suite.test("cancelCommitBeingWorkedOn", function() {
    var r;
    r = new Revision(["abc"], 0, true);
    r.cancelCommitBeingWorkedOn();
    assertThat(r).isEqualTo(new Revision(["abc"], 0, false));
    r.cancelCommitBeingWorkedOn();
    assertThat(r).isEqualTo(new Revision(["abc"], 0, false));
    r = new Revision(["abc", "def"], 0, true);
    r.cancelCommitBeingWorkedOn();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, false));
    r.cancelCommitBeingWorkedOn();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 0, false));
    r = new Revision(["abc", "def"], 1, true);
    r.cancelCommitBeingWorkedOn();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    r.cancelCommitBeingWorkedOn();
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
  });
  suite.test("commit", function() {
    var r;
    r = new Revision(["abc"], 0, false);
    r.commit("def");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    r.commit("xyz");
    assertThat(r).isEqualTo(new Revision(["abc", "def", "xyz"], 2, false));
    r = new Revision(["abc"], 0, true);
    r.commit("def");
    assertThat(r).isEqualTo(new Revision(["abc", "def"], 1, false));
    r = new Revision(["abc", "def"], 0, true);
    r.commit("xyz");
    assertThat(r).isEqualTo(new Revision(["abc", "xyz"], 1, false));
    r = new Revision(["abc", "def", "so", "long"], 1, true);
    r.commit("t");
    assertThat(r).isEqualTo(new Revision(["abc", "def", "t"], 2, false));
    r = new Revision(["abc", "def", "so", "long"], 1, false);
    r.commit("t");
    assertThat(r).isEqualTo(new Revision(["abc", "def", "t"], 2, false));
  });
  suite.test("changes", function() {
    var r = Revision.startingAt('abc');
    var a = [];
    var s = r.changes().subscribe(function(e) {
      return a.push(e);
    });
    assertThat(a).isEqualTo([]);
    r.commit('123');
    assertThat(a).isEqualTo(['123']);
    r.undo();
    assertThat(a).isEqualTo(['123', 'abc']);
    r.undo();
    assertThat(a).isEqualTo(['123', 'abc']);
    r.redo();
    assertThat(a).isEqualTo(['123', 'abc', '123']);
    r.redo();
    assertThat(a).isEqualTo(['123', 'abc', '123']);
    r.startedWorkingOnCommit();
    assertThat(a).isEqualTo(['123', 'abc', '123', undefined]);
    r.cancelCommitBeingWorkedOn();
    assertThat(a).isEqualTo(['123', 'abc', '123', undefined, '123']);
    r.clear('xyz');
    assertThat(a).isEqualTo(['123', 'abc', '123', undefined, '123', 'xyz']);
    s();
    r.clear('nope');
    assertThat(a).isEqualTo(['123', 'abc', '123', undefined, '123', 'xyz']);
  });
  suite.test("latestActiveCommit", function() {
    var r = Revision.startingAt('abc');
    var a = [];
    var s = r.latestActiveCommit().subscribe(function(e) {
      return a.push(e);
    });
    assertThat(a).isEqualTo(['abc']);
    r.commit('123');
    assertThat(a).isEqualTo(['abc', '123']);
    r.undo();
    assertThat(a).isEqualTo(['abc', '123', 'abc']);
    r.undo();
    assertThat(a).isEqualTo(['abc', '123', 'abc']);
    r.redo();
    assertThat(a).isEqualTo(['abc', '123', 'abc', '123']);
    r.redo();
    assertThat(a).isEqualTo(['abc', '123', 'abc', '123']);
    r.startedWorkingOnCommit();
    assertThat(a).isEqualTo(['abc', '123', 'abc', '123']);
    r.cancelCommitBeingWorkedOn();
    assertThat(a).isEqualTo(['abc', '123', 'abc', '123', '123']);
    r.clear('xyz');
    assertThat(a).isEqualTo(['abc', '123', 'abc', '123', '123', 'xyz']);
    s();
    r.clear('nope');
    assertThat(a).isEqualTo(['abc', '123', 'abc', '123', '123', 'xyz']);
  });
  return {};
});
//# sourceURL=test/base/Revision.test.js
;$traceurRuntime.registerModule("test/base/Seq.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Seq.test.js";
  var $__33 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Seq.test.js")),
      Suite = $__33.Suite,
      assertThat = $__33.assertThat,
      assertThrows = $__33.assertThrows,
      assertTrue = $__33.assertTrue,
      assertFalse = $__33.assertFalse;
  var $__34 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/base/Seq.test.js")),
      seq = $__34.seq,
      Seq = $__34.Seq;
  var suite = new Suite("Seq");
  suite.test("constructor_Array", function() {
    assertThat(new Seq([])).iteratesAs();
    assertThat(new Seq(["a"])).iteratesAs("a");
    assertThat(new Seq(["a", "b", 3])).iteratesAs("a", "b", 3);
    assertThat(seq([])).iteratesAs();
    assertThat(seq(["a"])).iteratesAs("a");
    assertThat(seq(["a", "b", 3])).iteratesAs("a", "b", 3);
  });
  suite.test("constructor_OtherArrays", function() {
    var candidates = [new Float32Array([1, 2, 3]), new Int16Array([-1, 2, 3]), new Int32Array([1, -2, 3]), new Int8Array([1, 2, -3]), new Uint8Array([1, 2, 3]), new Uint16Array([1, 2, 3]), new Uint32Array([1, 2, 3, 4, 5]), new Uint32Array([]), ["a", "b", 3]];
    var $__17 = true;
    var $__18 = false;
    var $__19 = undefined;
    try {
      for (var $__15 = void 0,
          $__14 = (candidates)[Symbol.iterator](); !($__17 = ($__15 = $__14.next()).done); $__17 = true) {
        var candidate = $__15.value;
        {
          for (var runs = 0; runs < 2; runs++) {
            var seq1 = new Seq(candidate);
            var seq2 = seq(candidate);
            var n = 0;
            var $__3 = true;
            var $__4 = false;
            var $__5 = undefined;
            try {
              for (var $__1 = void 0,
                  $__0 = (seq1)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
                var e = $__1.value;
                {
                  assertThat(e).isEqualTo(candidate[n]);
                  n++;
                }
              }
            } catch ($__6) {
              $__4 = true;
              $__5 = $__6;
            } finally {
              try {
                if (!$__3 && $__0.return != null) {
                  $__0.return();
                }
              } finally {
                if ($__4) {
                  throw $__5;
                }
              }
            }
            assertThat(n).isEqualTo(candidate.length);
            var n2 = 0;
            var $__10 = true;
            var $__11 = false;
            var $__12 = undefined;
            try {
              for (var $__8 = void 0,
                  $__7 = (seq2)[Symbol.iterator](); !($__10 = ($__8 = $__7.next()).done); $__10 = true) {
                var e$__28 = $__8.value;
                {
                  assertThat(e$__28).isEqualTo(candidate[n2]);
                  n2++;
                }
              }
            } catch ($__13) {
              $__11 = true;
              $__12 = $__13;
            } finally {
              try {
                if (!$__10 && $__7.return != null) {
                  $__7.return();
                }
              } finally {
                if ($__11) {
                  throw $__12;
                }
              }
            }
            assertThat(n2).isEqualTo(candidate.length);
          }
        }
      }
    } catch ($__20) {
      $__18 = true;
      $__19 = $__20;
    } finally {
      try {
        if (!$__17 && $__14.return != null) {
          $__14.return();
        }
      } finally {
        if ($__18) {
          throw $__19;
        }
      }
    }
  });
  suite.test("constructor_RawGeneratorSinglePass", function() {
    var s = seq($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return 1;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return 2;
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })());
    assertThat(s).iteratesAs(1, 2);
  });
  suite.test("fromGenerator_MultipleUses", function() {
    var s = Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return 1;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return 2;
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    }));
    assertThat(s).iteratesAs(1, 2);
    assertThat(s).iteratesAs(1, 2);
    assertThat(s).iteratesAs(1, 2);
  });
  suite.test("isEqualTo", function() {
    assertFalse(seq([]).isEqualTo(null));
    assertFalse(seq([]).isEqualTo("a"));
    assertFalse(seq([]).isEqualTo(0));
    assertTrue(seq(["a", "b", "c"]).isEqualTo("abc"));
    assertTrue(seq([1, 2, 3]).isEqualTo([1, 2, 3]));
    assertFalse(seq([1, 2, 3]).isEqualTo([1, 2]));
    assertTrue(seq([]).isEqualTo(seq([])));
    assertTrue(seq([2.5]).isEqualTo(seq(new Float32Array([2.5]))));
    assertFalse(seq([]).isEqualTo(seq([1])));
    var groups = [[seq([]), seq([]), Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })), seq(new Int32Array([]))], [seq(["a"]), seq(["a"]), Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__30() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__30, this);
    }))], [seq([2.5]), Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__31() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return 2.5;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__31, this);
    })), seq(new Float32Array([2.5]))], [seq(["a", "b", "c"]), Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__32() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return "b";
            case 6:
              $ctx.maybeThrow();
              $ctx.state = 8;
              break;
            case 8:
              $ctx.state = 10;
              return "c";
            case 10:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__32, this);
    }))]];
    var $__24 = true;
    var $__25 = false;
    var $__26 = undefined;
    try {
      for (var $__22 = void 0,
          $__21 = (groups)[Symbol.iterator](); !($__24 = ($__22 = $__21.next()).done); $__24 = true) {
        var g1 = $__22.value;
        {
          var $__17 = true;
          var $__18 = false;
          var $__19 = undefined;
          try {
            for (var $__15 = void 0,
                $__14 = (groups)[Symbol.iterator](); !($__17 = ($__15 = $__14.next()).done); $__17 = true) {
              var g2 = $__15.value;
              {
                var $__10 = true;
                var $__11 = false;
                var $__12 = undefined;
                try {
                  for (var $__8 = void 0,
                      $__7 = (g1)[Symbol.iterator](); !($__10 = ($__8 = $__7.next()).done); $__10 = true) {
                    var e1 = $__8.value;
                    {
                      var $__3 = true;
                      var $__4 = false;
                      var $__5 = undefined;
                      try {
                        for (var $__1 = void 0,
                            $__0 = (g2)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
                          var e2 = $__1.value;
                          {
                            assertThat(e1.isEqualTo(e2)).isEqualTo(g1 === g2);
                          }
                        }
                      } catch ($__6) {
                        $__4 = true;
                        $__5 = $__6;
                      } finally {
                        try {
                          if (!$__3 && $__0.return != null) {
                            $__0.return();
                          }
                        } finally {
                          if ($__4) {
                            throw $__5;
                          }
                        }
                      }
                    }
                  }
                } catch ($__13) {
                  $__11 = true;
                  $__12 = $__13;
                } finally {
                  try {
                    if (!$__10 && $__7.return != null) {
                      $__7.return();
                    }
                  } finally {
                    if ($__11) {
                      throw $__12;
                    }
                  }
                }
              }
            }
          } catch ($__20) {
            $__18 = true;
            $__19 = $__20;
          } finally {
            try {
              if (!$__17 && $__14.return != null) {
                $__14.return();
              }
            } finally {
              if ($__18) {
                throw $__19;
              }
            }
          }
        }
      }
    } catch ($__27) {
      $__25 = true;
      $__26 = $__27;
    } finally {
      try {
        if (!$__24 && $__21.return != null) {
          $__21.return();
        }
      } finally {
        if ($__25) {
          throw $__26;
        }
      }
    }
    assertThat(seq(["a"])).isEqualTo(seq(["a"]));
    assertThat(seq(["a"])).isNotEqualTo(seq(["a", "b"]));
    assertThat(seq(["a"])).isNotEqualTo(seq([]));
    assertThat(seq(["a"])).isNotEqualTo(seq(["b"]));
  });
  suite.test("toArray", function() {
    var a0 = Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })).toArray();
    assertTrue(Array.isArray(a0));
    assertThat(a0).isEqualTo([]);
    var a2 = Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__30() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return 1;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return "a";
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__30, this);
    })).toArray();
    assertTrue(Array.isArray(a2));
    assertThat(a2).isEqualTo([1, "a"]);
  });
  suite.test("toFloat32Array", function() {
    assertThat(seq([]).toFloat32Array()).isEqualTo(new Float32Array([]));
    assertThat(seq([1, 2, Infinity]).toFloat32Array()).isEqualTo(new Float32Array([1, 2, Infinity]));
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })).toFloat32Array()).isEqualTo(new Float32Array([]));
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__30() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return 1;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return 0.5;
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__30, this);
    })).toFloat32Array()).isEqualTo(new Float32Array([1, 0.5]));
  });
  suite.test("toSet", function() {
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })).toSet()).isEqualTo(new Set());
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__30() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return 1;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return "a";
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__30, this);
    })).toSet()).isEqualTo(new Set([1, "a"]));
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__31() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return 1;
            case 6:
              $ctx.maybeThrow();
              $ctx.state = 8;
              break;
            case 8:
              $ctx.state = 10;
              return "a";
            case 10:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__31, this);
    })).toSet()).isEqualTo(new Set([1, "a"]));
    assertThat(seq([]).toSet()).isEqualTo(new Set());
    assertThat(seq([1]).toSet()).isEqualTo(new Set([1]));
    assertThat(seq([1, 2]).toSet()).isEqualTo(new Set([1, 2]));
    assertThat(seq([1, 2, 1, 3]).toSet()).isEqualTo(new Set([3, 1, 2]));
  });
  suite.test("join", function() {
    assertThat(seq([]).join("||")).isEqualTo("");
    assertThat(seq([1]).join("||")).isEqualTo("1");
    assertThat(seq([1, 2]).join("||")).isEqualTo("1||2");
    assertThat(seq([1, 2, 3]).join("||")).isEqualTo("1||2||3");
  });
  suite.test("toString", function() {
    assertThat(seq([]).toString()).isEqualTo("Seq[]");
    assertThat(seq([1]).toString()).isEqualTo("Seq[1]");
    assertThat(seq([1, 2]).toString()).isEqualTo("Seq[1, 2]");
    assertThat(seq([1, 2, 3]).toString()).isEqualTo("Seq[1, 2, 3]");
  });
  suite.test("range", function() {
    assertThrows(function() {
      return Seq.range(-1);
    });
    assertThat(Seq.range(0)).iteratesAs();
    assertThat(Seq.range(1)).iteratesAs(0);
    assertThat(Seq.range(2)).iteratesAs(0, 1);
    assertThat(Seq.range(3)).iteratesAs(0, 1, 2);
    assertThat(Seq.range(10)).iteratesAs(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
  });
  suite.test("naturals", function() {
    var n = 0;
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (Seq.naturals())[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var i = $__1.value;
        {
          assertThat(i).isEqualTo(n);
          n++;
          if (n > 1000) {
            break;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
  });
  suite.test("repeat", function() {
    assertThrows(function() {
      return Seq.repeat("a", -1);
    });
    assertThat(Seq.repeat("a", 0)).iteratesAs();
    assertThat(Seq.repeat("a", 1)).iteratesAs("a");
    assertThat(Seq.repeat("a", 2)).iteratesAs("a", "a");
    assertThat(Seq.repeat(1.5, 5)).iteratesAs(1.5, 1.5, 1.5, 1.5, 1.5);
  });
  suite.test("solidify", function() {
    var s1 = seq([1, 2, 3]);
    var s2 = seq(new Float32Array([1, 2, 3]));
    assertTrue(s1 === s1.solidify());
    assertTrue(s2 === s2.solidify());
    var i = 0;
    var s3 = Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = (i < 4) ? 1 : -2;
              break;
            case 1:
              $ctx.state = 2;
              return i++;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 0;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    }));
    var s4 = s3.solidify();
    var s5 = s3.solidify();
    assertThat(s4).iteratesAs(0, 1, 2, 3);
    assertThat(s5).iteratesAs();
    assertThat(i).isEqualTo(4);
  });
  suite.test("map", function() {
    assertThat(seq([]).map(function(e) {
      return e + 1;
    })).iteratesAs();
    assertThat(seq([1]).map(function(e) {
      return e + 1;
    })).iteratesAs(2);
    assertThat(seq([1, 2]).map(function(e) {
      return e + 1;
    })).iteratesAs(2, 3);
    assertThat(seq([3, 1, 2]).map(function(e) {
      return e * 2;
    })).iteratesAs(6, 2, 4);
  });
  suite.test("flatMap", function() {
    assertThat(seq([]).flatMap(function(e) {
      return [];
    })).iteratesAs();
    assertThat(seq([]).flatMap(function(e) {
      return [1, 2, 3];
    })).iteratesAs();
    assertThat(seq([1, 2, 3]).flatMap(function(e) {
      return [];
    })).iteratesAs();
    assertThat(seq([1]).flatMap(function(e) {
      return [e * 2, e * 2 + 1];
    })).iteratesAs(2, 3);
    assertThat(seq([1, 2, 3]).flatMap(function(e) {
      return [e * 2, e * 2 + 1];
    })).iteratesAs(2, 3, 4, 5, 6, 7);
    assertThat(seq([1, 2, 3]).flatMap(Seq.range)).iteratesAs(0, 0, 1, 0, 1, 2);
  });
  suite.test("filter", function() {
    assertThat(seq([]).filter(function(e) {
      return e % 2 === 0;
    })).iteratesAs();
    assertThat(seq([1]).filter(function(e) {
      return e % 2 === 0;
    })).iteratesAs();
    assertThat(seq([2]).filter(function(e) {
      return e % 2 === 0;
    })).iteratesAs(2);
    assertThat(seq([1, 2]).filter(function(e) {
      return e % 2 === 0;
    })).iteratesAs(2);
    assertThat(seq([2, 0, 1, 4]).filter(function(e) {
      return e % 2 === 0;
    })).iteratesAs(2, 0, 4);
    assertThat(seq([2, 0, 1, 4]).filter(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1);
  });
  suite.test("filterWithIndex", function() {
    assertThat(seq([]).filterWithIndex(function(e, i) {
      return e % 2 === 0;
    })).iteratesAs();
    assertThat(seq([1]).filterWithIndex(function(e, i) {
      return e % 2 === 0;
    })).iteratesAs();
    assertThat(seq([2]).filterWithIndex(function(e, i) {
      return e % 2 === 0;
    })).iteratesAs(2);
    assertThat(seq([1, 2]).filterWithIndex(function(e, i) {
      return e % 2 === 0;
    })).iteratesAs(2);
    assertThat(seq([2, 0, 1, 4]).filterWithIndex(function(e, i) {
      return e % 2 === 0;
    })).iteratesAs(2, 0, 4);
    assertThat(seq([2, 0, 1, 4]).filterWithIndex(function(e, i) {
      return e % 2 === 1;
    })).iteratesAs(1);
    assertThat(seq([2, 0, 1, 4]).filterWithIndex(function(e, i) {
      return i % 2 === 0;
    })).iteratesAs(2, 1);
    assertThat(seq([2, 0, 1, 4]).filterWithIndex(function(e, i) {
      return i % 2 === 1;
    })).iteratesAs(0, 4);
    assertThat(seq([2, 0, 1, 4]).filterWithIndex(function(e, i) {
      return (e + i) % 2 === 1;
    })).iteratesAs(0, 1, 4);
  });
  suite.test("fold", function() {
    assertThrows(function() {
      return seq([]).fold(function(e1, e2) {
        return undefined;
      });
    });
    assertThat(seq([]).fold(function() {
      throw new Error();
    }, "abc")).isEqualTo("abc");
    assertThat(seq([1]).fold(function() {
      throw new Error();
    })).isEqualTo(1);
    assertThat(seq([1, 2]).fold(function(e1, e2) {
      return e1 + e2;
    })).isEqualTo(3);
    assertThat(seq([1, 2, 3]).fold(function(e1, e2) {
      return e1 + e2;
    })).isEqualTo(6);
    assertThat(seq([1, 2, 3, 4]).fold(function(e1, e2) {
      return e1 + e2;
    })).isEqualTo(10);
    assertThat(seq([1, 2, 3, 4]).fold(function(e1, e2) {
      return e1 * e2;
    })).isEqualTo(24);
  });
  suite.test("aggregate", function() {
    assertThat(seq([]).aggregate("abc", function() {
      throw new Error();
    })).isEqualTo("abc");
    assertThat(seq([1]).aggregate(-1, function(a, e) {
      return a + e;
    })).isEqualTo(0);
    assertThat(seq([1, 2]).aggregate(-1, function(a, e) {
      return a + e;
    })).isEqualTo(2);
    assertThat(seq([1, 2]).aggregate(-3, function(a, e) {
      return a + e;
    })).isEqualTo(0);
    assertThat(seq([1, 2, 3, 4]).aggregate(-1, function(a, e) {
      return a * e;
    })).isEqualTo(-24);
    assertThat(seq([1, 2, 3, 4]).aggregate(-1, function(a, e) {
      return a * 2 + e;
    })).isEqualTo(10);
    assertThat(seq([1, 2, 3, 4]).aggregate("x", function(a, e) {
      return a + "," + e;
    })).isEqualTo("x,1,2,3,4");
  });
  suite.test("zip", function() {
    assertThat(seq([]).zip([], function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([1]).zip([], function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([]).zip([1], function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq(["a"]).zip([2], function(e1, e2) {
      return e1 + e2;
    })).iteratesAs("a2");
    assertThat(seq(["a"]).zip([2, 3], function(e1, e2) {
      return e1 + e2;
    })).iteratesAs("a2");
    assertThat(seq(["a", "b"]).zip([2], function(e1, e2) {
      return e1 + e2;
    })).iteratesAs("a2");
    assertThat(seq(["a", "b"]).zip([2, 3], function(e1, e2) {
      return e1 + e2;
    })).iteratesAs("a2", "b3");
  });
  suite.test("max", function() {
    assertThrows(function() {
      return seq([]).max();
    });
    assertThat(seq([]).max("abc")).isEqualTo("abc");
    assertThat(seq([1]).max("abc")).isEqualTo(1);
    assertThat(seq([1]).max()).isEqualTo(1);
    assertThat(seq([1, 2]).max()).isEqualTo(2);
    assertThat(seq([2, 1]).max()).isEqualTo(2);
    assertThat(seq([2, 1, -5, 102, -3, 4]).max()).isEqualTo(102);
    assertThat(seq(["a", "c", "b"]).max()).isEqualTo("c");
  });
  suite.test("min", function() {
    assertThrows(function() {
      return seq([]).min();
    });
    assertThat(seq([]).min("abc")).isEqualTo("abc");
    assertThat(seq([1]).min("abc")).isEqualTo(1);
    assertThat(seq([1]).min()).isEqualTo(1);
    assertThat(seq([1, 2]).min()).isEqualTo(1);
    assertThat(seq([2, 1]).min()).isEqualTo(1);
    assertThat(seq([2, 1, -5, 102, -3, 4]).min()).isEqualTo(-5);
    assertThat(seq(["a", "c", "b"]).min()).isEqualTo("a");
  });
  suite.test("maxBy", function() {
    assertThrows(function() {
      return seq([]).maxBy(function() {
        return undefined;
      });
    });
    assertThat(seq([]).maxBy(function() {
      return undefined;
    }, "abc")).isEqualTo("abc");
    assertThat(seq(["abc"]).maxBy(function() {
      throw new Error();
    })).isEqualTo("abc");
    assertThat(seq([1, 2]).maxBy(function(e) {
      return e;
    })).isEqualTo(2);
    assertThat(seq([1, 2]).maxBy(function(e) {
      return -e;
    })).isEqualTo(1);
    assertThat(seq([1, 2]).maxBy(function(e) {
      return e;
    }, undefined, function(e1, e2) {
      return e1 < e2;
    })).isEqualTo(2);
    assertThat(seq([1, 2]).maxBy(function(e) {
      return e;
    }, undefined, function(e1, e2) {
      return e1 > e2;
    })).isEqualTo(1);
    assertThat(seq([-2, -1, 0, 1, 2]).maxBy(function(e) {
      return e * (2 - e);
    })).isEqualTo(1);
    assertThat(seq([-2, -1, 0, 1, 2]).maxBy(function(e) {
      return e * (e - 2);
    })).isEqualTo(-2);
  });
  suite.test("minBy", function() {
    assertThrows(function() {
      return seq([]).minBy(function() {
        return undefined;
      });
    });
    assertThat(seq([]).minBy(function() {
      return undefined;
    }, "abc")).isEqualTo("abc");
    assertThat(seq(["abc"]).minBy(function() {
      throw new Error();
    })).isEqualTo("abc");
    assertThat(seq([1, 2]).minBy(function(e) {
      return e;
    })).isEqualTo(1);
    assertThat(seq([1, 2]).minBy(function(e) {
      return -e;
    })).isEqualTo(2);
    assertThat(seq([1, 2]).minBy(function(e) {
      return e;
    }, undefined, function(e1, e2) {
      return e1 < e2;
    })).isEqualTo(1);
    assertThat(seq([1, 2]).minBy(function(e) {
      return e;
    }, undefined, function(e1, e2) {
      return e1 > e2;
    })).isEqualTo(2);
    assertThat(seq([-2, -1, 0, 1, 2]).minBy(function(e) {
      return e * (2 - e);
    })).isEqualTo(-2);
    assertThat(seq([-2, -1, 0, 1, 2]).minBy(function(e) {
      return e * (e - 2);
    })).isEqualTo(1);
  });
  suite.test("any", function() {
    assertFalse(seq([]).any(function() {
      throw new Error();
    }));
    assertFalse(seq([1]).any(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([2]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([3]).any(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([1, 1]).any(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([4, 2]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([7, 3]).any(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([2, 1]).any(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([5, 2]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([8, 3]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([3, 1]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([6, 2]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([9, 3]).any(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([1, 4, 7, 10, 13]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([0, 1, 2, 3, 4, 5, 6]).any(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([3, 6, 9, 12]).any(function(e) {
      return e % 3 === 0;
    }));
  });
  suite.test("every", function() {
    assertTrue(seq([]).every(function() {
      throw new Error();
    }));
    assertFalse(seq([1]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([2]).every(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([3]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([1, 1]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([4, 2]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([7, 3]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([2, 1]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([5, 2]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([8, 3]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([3, 1]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([6, 2]).every(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([9, 3]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([1, 4, 7, 10, 13]).every(function(e) {
      return e % 3 === 0;
    }));
    assertFalse(seq([0, 1, 2, 3, 4, 5, 6]).every(function(e) {
      return e % 3 === 0;
    }));
    assertTrue(seq([3, 6, 9, 12]).every(function(e) {
      return e % 3 === 0;
    }));
  });
  suite.test("contains", function() {
    assertFalse(seq([]).contains(1));
    assertFalse(seq([0]).contains(1));
    assertFalse(seq([0]).contains(""));
    assertTrue(seq([1]).contains(1));
    assertFalse(seq([[]]).contains([]));
    assertTrue(seq([1, 2, 3]).contains(1));
    assertTrue(seq([1, 2, 3]).contains(2));
    assertTrue(seq([1, 2, 3]).contains(3));
    assertFalse(seq([1, 2, 3]).contains(4));
  });
  suite.test("sum", function() {
    assertThat(seq([]).sum()).isEqualTo(0);
    assertThat(seq([11]).sum()).isEqualTo(11);
    assertThat(seq([1, 2]).sum()).isEqualTo(3);
    assertThat(seq([1, 2, 3, 4]).sum()).isEqualTo(10);
    assertThat(seq(["abc"]).sum()).isEqualTo("abc");
    assertThat(seq(["a", "b"]).sum()).isEqualTo("ab");
  });
  suite.test("product", function() {
    assertThat(seq([]).product()).isEqualTo(1);
    assertThat(seq([11]).product()).isEqualTo(11);
    assertThat(seq([11, 2]).product()).isEqualTo(22);
    assertThat(seq([11, 2, 3, 4]).product()).isEqualTo(264);
    assertThat(seq(["abc"]).product()).isEqualTo("abc");
  });
  suite.test("scan", function() {
    assertThat(seq([]).scan("abc", function(a, e) {
      return a + e;
    })).iteratesAs("abc");
    assertThat(seq([1, 2, 3]).scan("abc", function(a, e) {
      return a + e;
    })).iteratesAs("abc", "abc1", "abc12", "abc123");
    assertThat(seq([]).scan(10, function(a, e) {
      return a + e;
    })).iteratesAs(10);
    assertThat(seq([1]).scan(10, function(a, e) {
      return a + e;
    })).iteratesAs(10, 11);
    assertThat(seq([1, 2]).scan(10, function(a, e) {
      return a + e;
    })).iteratesAs(10, 11, 13);
    assertThat(seq([1, 2, 3]).scan(10, function(a, e) {
      return a + e;
    })).iteratesAs(10, 11, 13, 16);
  });
  suite.test("concat", function() {
    assertThat(seq([]).concat([])).iteratesAs();
    assertThat(seq([1]).concat([])).iteratesAs(1);
    assertThat(seq([]).concat([2])).iteratesAs(2);
    assertThat(seq([3]).concat([4])).iteratesAs(3, 4);
    assertThat(seq([5, 6]).concat([7, 8])).iteratesAs(5, 6, 7, 8);
  });
  suite.test("withOverlayedItem", function() {
    var f = "abc";
    assertThrows(function() {
      return seq([]).withOverlayedItem(-1, f);
    });
    assertThrows(function() {
      return seq([1]).withOverlayedItem(-1, f);
    });
    assertThat(seq([]).withOverlayedItem(100, f)).isNotEqualTo(null);
    assertThrows(function() {
      return seq([]).withOverlayedItem(0, f).toArray();
    });
    assertThrows(function() {
      return seq([]).withOverlayedItem(1, f).toArray();
    });
    assertThrows(function() {
      return seq([1]).withOverlayedItem(1, f).toArray();
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withOverlayedItem(3, f).toArray();
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withOverlayedItem(3, f).take(1).toArray();
    });
    assertThrows(function() {
      return seq($traceurRuntime.initGeneratorFunction(function $__29() {
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $ctx.state = 2;
                return "a";
              case 2:
                $ctx.maybeThrow();
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__29, this);
      })).withOverlayedItem(1, f).toArray();
    });
    assertThat(seq([1]).withOverlayedItem(0, f)).iteratesAs("abc");
    assertThat(seq([1, 2]).withOverlayedItem(0, f)).iteratesAs("abc", 2);
    assertThat(seq([1, 2]).withOverlayedItem(1, f)).iteratesAs(1, "abc");
    assertThat(seq([1, 2, 3]).withOverlayedItem(0, f)).iteratesAs("abc", 2, 3);
    assertThat(seq([1, 2, 3]).withOverlayedItem(1, f)).iteratesAs(1, "abc", 3);
    assertThat(seq([1, 2, 3]).withOverlayedItem(2, f)).iteratesAs(1, 2, "abc");
  });
  suite.test("withTransformedItem", function() {
    var f = function(e) {
      return e + "a";
    };
    assertThrows(function() {
      return seq([]).withTransformedItem(-1, f);
    });
    assertThrows(function() {
      return seq([1]).withTransformedItem(-1, f);
    });
    assertThat(seq([]).withTransformedItem(100, f)).isNotEqualTo(null);
    assertThrows(function() {
      return seq([]).withTransformedItem(0, f).toArray();
    });
    assertThrows(function() {
      return seq([]).withTransformedItem(1, f).toArray();
    });
    assertThrows(function() {
      return seq([1]).withTransformedItem(1, f).toArray();
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withTransformedItem(3, f).toArray();
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withTransformedItem(3, f).take(1).toArray();
    });
    assertThrows(function() {
      return seq($traceurRuntime.initGeneratorFunction(function $__29() {
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $ctx.state = 2;
                return "a";
              case 2:
                $ctx.maybeThrow();
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__29, this);
      })).withTransformedItem(1, f).toArray();
    });
    assertThat(seq([1]).withTransformedItem(0, f)).iteratesAs("1a");
    assertThat(seq([1, 2]).withTransformedItem(0, f)).iteratesAs("1a", 2);
    assertThat(seq([1, 2]).withTransformedItem(1, f)).iteratesAs(1, "2a");
    assertThat(seq([1, 2, 3]).withTransformedItem(0, f)).iteratesAs("1a", 2, 3);
    assertThat(seq([1, 2, 3]).withTransformedItem(1, f)).iteratesAs(1, "2a", 3);
    assertThat(seq([1, 2, 3]).withTransformedItem(2, f)).iteratesAs(1, 2, "3a");
  });
  suite.test("withInsertedItem", function() {
    var f = "abc";
    assertThrows(function() {
      return seq([]).withInsertedItem(-1, f);
    });
    assertThrows(function() {
      return seq([1]).withInsertedItem(-1, f);
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withInsertedItem(-1, f);
    });
    assertThat(seq([]).withInsertedItem(100, f)).isNotEqualTo(null);
    assertThrows(function() {
      return seq([]).withInsertedItem(1, f).toArray();
    });
    assertThrows(function() {
      return seq([1]).withInsertedItem(2, f).toArray();
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withInsertedItem(4, f).toArray();
    });
    assertThrows(function() {
      return seq([1, 2, 3]).withInsertedItem(4, f).take(1).toArray();
    });
    assertThrows(function() {
      return seq($traceurRuntime.initGeneratorFunction(function $__29() {
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $ctx.state = 2;
                return "a";
              case 2:
                $ctx.maybeThrow();
                $ctx.state = -2;
                break;
              default:
                return $ctx.end();
            }
        }, $__29, this);
      })).withInsertedItem(2, f).toArray();
    });
    assertThat(seq([]).withInsertedItem(0, f)).iteratesAs("abc");
    assertThat(seq([1]).withInsertedItem(0, f)).iteratesAs("abc", 1);
    assertThat(seq([1]).withInsertedItem(1, f)).iteratesAs(1, "abc");
    assertThat(seq([1, 2]).withInsertedItem(0, f)).iteratesAs("abc", 1, 2);
    assertThat(seq([1, 2]).withInsertedItem(1, f)).iteratesAs(1, "abc", 2);
    assertThat(seq([1, 2]).withInsertedItem(2, f)).iteratesAs(1, 2, "abc");
    assertThat(seq([1, 2, 3]).withInsertedItem(0, f)).iteratesAs("abc", 1, 2, 3);
    assertThat(seq([1, 2, 3]).withInsertedItem(1, f)).iteratesAs(1, "abc", 2, 3);
    assertThat(seq([1, 2, 3]).withInsertedItem(2, f)).iteratesAs(1, 2, "abc", 3);
    assertThat(seq([1, 2, 3]).withInsertedItem(3, f)).iteratesAs(1, 2, 3, "abc");
  });
  suite.test("takeWhile", function() {
    assertThat(seq([]).takeWhile(function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([1]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1);
    assertThat(seq([2]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([1, 3]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1, 3);
    assertThat(seq([1, 4]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1);
    assertThat(seq([2, 3]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([2, 4]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([1, 3, 5, 2, 4, 7]).takeWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1, 3, 5);
  });
  suite.test("skipWhile", function() {
    assertThat(seq([]).skipWhile(function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([1]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([2]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2);
    assertThat(seq([1, 3]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([1, 4]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(4);
    assertThat(seq([2, 3]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2, 3);
    assertThat(seq([2, 4]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2, 4);
    assertThat(seq([1, 3, 5, 2, 4, 7]).skipWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2, 4, 7);
  });
  suite.test("skipTailWhile", function() {
    assertThat(seq([]).skipTailWhile(function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([1]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([2]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2);
    assertThat(seq([1, 3]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs();
    assertThat(seq([1, 4]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1, 4);
    assertThat(seq([2, 3]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2);
    assertThat(seq([2, 4]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(2, 4);
    assertThat(seq([1, 3, 5, 2, 4, 7]).skipTailWhile(function(e) {
      return e % 2 === 1;
    })).iteratesAs(1, 3, 5, 2, 4);
  });
  suite.test("take", function() {
    assertThrows(function() {
      return seq([]).take(-1);
    });
    assertThat(seq([]).take(0)).iteratesAs();
    assertThat(seq([]).take(1)).iteratesAs();
    assertThat(seq([]).take(2)).iteratesAs();
    assertThat(seq([1]).take(0)).iteratesAs();
    assertThat(seq([1]).take(1)).iteratesAs(1);
    assertThat(seq([1]).take(2)).iteratesAs(1);
    assertThat(seq([1, 2]).take(0)).iteratesAs();
    assertThat(seq([1, 2]).take(1)).iteratesAs(1);
    assertThat(seq([1, 2]).take(2)).iteratesAs(1, 2);
    assertThat(seq([1, 2, 3]).take(0)).iteratesAs();
    assertThat(seq([1, 2, 3]).take(1)).iteratesAs(1);
    assertThat(seq([1, 2, 3]).take(2)).iteratesAs(1, 2);
    assertThat(seq([1, 2, 3]).take(3)).iteratesAs(1, 2, 3);
    assertThat(seq([1, 2, 3]).take(1000)).iteratesAs(1, 2, 3);
  });
  suite.test("concat", function() {
    assertThrows(function() {
      return seq([]).skip(-1);
    });
    assertThat(seq([]).skip(0)).iteratesAs();
    assertThat(seq([3]).skip(0)).iteratesAs(3);
    assertThat(seq([4, 5]).skip(0)).iteratesAs(4, 5);
    assertThat(seq([6, 7, 8]).skip(0)).iteratesAs(6, 7, 8);
    assertThat(seq([]).skip(1)).iteratesAs();
    assertThat(seq([3]).skip(1)).iteratesAs();
    assertThat(seq([4, 5]).skip(1)).iteratesAs(5);
    assertThat(seq([6, 7, 8]).skip(1)).iteratesAs(7, 8);
    assertThat(seq([]).skip(2)).iteratesAs();
    assertThat(seq([3]).skip(2)).iteratesAs();
    assertThat(seq([4, 5]).skip(2)).iteratesAs();
    assertThat(seq([6, 7, 8]).skip(2)).iteratesAs(8);
  });
  suite.test("reverse", function() {
    assertThat(seq([]).reverse()).iteratesAs();
    assertThat(seq([1]).reverse()).iteratesAs(1);
    assertThat(seq([1, 2]).reverse()).iteratesAs(2, 1);
    assertThat(seq(["a", "b", "c"]).reverse()).iteratesAs("c", "b", "a");
    assertThat(seq("12345").reverse()).iteratesAs("5", "4", "3", "2", "1");
  });
  suite.test("distinctBy", function() {
    assertThat(seq([]).distinctBy(function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq(["abc"]).distinctBy(function(e) {
      return e;
    })).iteratesAs("abc");
    assertThat(seq([1, 1]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(1);
    assertThat(seq([1, 2]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(1, 2);
    assertThat(seq([1, 3]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(1);
    assertThat(seq([1, 1]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(1);
    assertThat(seq([2, 1]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(2, 1);
    assertThat(seq([3, 1]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(3);
    assertThat(seq([1, 1, 1]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(1);
    assertThat(seq([2, 5, 3]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(2, 5);
    assertThat(seq([3, 2, 5]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(3, 2);
    assertThat(seq([4, 6, 7]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(4, 7);
    assertThat(seq([5, 3, 2]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(5, 2);
    assertThat(seq([6, 7, 4]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(6, 7);
    assertThat(seq([7, 4, 6]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(7, 4);
    assertThat(seq([8, 8, 8]).distinctBy(function(e) {
      return e % 2;
    })).iteratesAs(8);
  });
  suite.test("distinct", function() {
    assertThat(seq([]).distinct()).iteratesAs();
    assertThat(seq(["abc"]).distinct()).iteratesAs("abc");
    assertThat(seq(["a", "b", "a"]).distinct()).iteratesAs("a", "b");
    assertThat(seq(["a", "a", "c", "c", "d", "c"]).distinct()).iteratesAs("a", "c", "d");
  });
  suite.test("flatten", function() {
    assertThat(seq([]).flatten()).iteratesAs();
    assertThat(seq([[]]).flatten()).iteratesAs();
    assertThat(seq([[], []]).flatten()).iteratesAs();
    assertThat(seq([["a"], []]).flatten()).iteratesAs("a");
    assertThat(seq([[], ["b"]]).flatten()).iteratesAs("b");
    assertThat(seq([["a"], ["b"]]).flatten()).iteratesAs("a", "b");
    assertThat(seq([[1, 2, 3], ["a", "b"], "cd"]).flatten()).iteratesAs(1, 2, 3, "a", "b", "c", "d");
  });
  suite.test("single", function() {
    assertThrows(function() {
      return seq([]).single();
    });
    assertThat(seq([]).single("abc")).isEqualTo("abc");
    assertThat(seq([11]).single("abc")).isEqualTo(11);
    assertThat(seq([11]).single()).isEqualTo(11);
    assertThrows(function() {
      return seq([2, 3]).single();
    });
    assertThat(seq([2, 3]).single("abc")).isEqualTo("abc");
  });
  suite.test("first", function() {
    assertThrows(function() {
      return seq([]).first();
    });
    assertThat(seq([]).first("abc")).isEqualTo("abc");
    assertThat(seq([11]).first("abc")).isEqualTo(11);
    assertThat(seq([11]).first()).isEqualTo(11);
    assertThat(seq([2, 3]).first()).isEqualTo(2);
    assertThat(seq([2, 3]).first("abc")).isEqualTo(2);
  });
  suite.test("last", function() {
    assertThrows(function() {
      return seq([]).last();
    });
    assertThat(seq([]).last("abc")).isEqualTo("abc");
    assertThat(seq([11]).last("abc")).isEqualTo(11);
    assertThat(seq([11]).last()).isEqualTo(11);
    assertThat(seq([2, 3]).last()).isEqualTo(3);
    assertThat(seq([2, 3]).last("abc")).isEqualTo(3);
  });
  suite.test("tryPeekCount", function() {
    assertThat(seq([]).tryPeekCount()).isEqualTo(0);
    assertThat(seq([11]).tryPeekCount()).isEqualTo(1);
    assertThat(seq([11, 12]).tryPeekCount()).isEqualTo(2);
    assertThat(seq([11, 12, 13]).tryPeekCount()).isEqualTo(3);
    assertThat(seq([11, 12, 13, 4, 5, 6]).count()).isEqualTo(6);
    assertThat(seq(new Map()).tryPeekCount()).isEqualTo(0);
    assertThat(seq(new Map([["a", "b"]])).tryPeekCount()).isEqualTo(1);
    assertThat(seq(new Set()).tryPeekCount()).isEqualTo(0);
    assertThat(seq(new Set("a")).tryPeekCount()).isEqualTo(1);
    assertThat(seq(new Float32Array([1, 2, 3])).tryPeekCount()).isEqualTo(3);
    assertThat(seq([11, 12, 13]).map(function(e) {
      return e + 1;
    }).tryPeekCount()).isEqualTo(undefined);
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })).tryPeekCount()).isEqualTo(undefined);
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__30() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__30, this);
    })).tryPeekCount()).isEqualTo(undefined);
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__31() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return "b";
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__31, this);
    })).tryPeekCount()).isEqualTo(undefined);
  });
  suite.test("count", function() {
    assertThat(seq([]).count()).isEqualTo(0);
    assertThat(seq([11]).count()).isEqualTo(1);
    assertThat(seq([11, 12]).count()).isEqualTo(2);
    assertThat(seq([11, 12, 13]).count()).isEqualTo(3);
    assertThat(seq([11, 12, 13, 4, 5, 6]).count()).isEqualTo(6);
    assertThat(seq(new Map()).count()).isEqualTo(0);
    assertThat(seq(new Map([["a", "b"]])).count()).isEqualTo(1);
    assertThat(seq(new Set()).count()).isEqualTo(0);
    assertThat(seq(new Set("a")).count()).isEqualTo(1);
    assertThat(seq(new Float32Array([1, 2, 3])).count()).isEqualTo(3);
    assertThat(seq([11, 12, 13]).map(function(e) {
      return e + 1;
    }).count()).isEqualTo(3);
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__29() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__29, this);
    })).count()).isEqualTo(0);
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__30() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__30, this);
    })).count()).isEqualTo(1);
    assertThat(Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__31() {
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return "a";
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            case 4:
              $ctx.state = 6;
              return "b";
            case 6:
              $ctx.maybeThrow();
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__31, this);
    })).count()).isEqualTo(2);
  });
  suite.test("padded", function() {
    assertThat(seq([]).padded(0, "a")).iteratesAs();
    assertThat(seq([]).padded(1, "a")).iteratesAs("a");
    assertThat(seq([]).padded(2, "a")).iteratesAs("a", "a");
    assertThat(seq([]).padded(3, "a")).iteratesAs("a", "a", "a");
    assertThat(seq([]).padded(3)).iteratesAs(undefined, undefined, undefined);
    assertThat(seq([2]).padded(0, "a")).iteratesAs(2);
    assertThat(seq([2]).padded(1, "a")).iteratesAs(2);
    assertThat(seq([2]).padded(2, "a")).iteratesAs(2, "a");
    assertThat(seq([2]).padded(3, "a")).iteratesAs(2, "a", "a");
    assertThat(seq([2, 3]).padded(0, "a")).iteratesAs(2, 3);
    assertThat(seq([2, 3]).padded(1, "a")).iteratesAs(2, 3);
    assertThat(seq([2, 3]).padded(2, "a")).iteratesAs(2, 3);
    assertThat(seq([2, 3]).padded(3, "a")).iteratesAs(2, 3, "a");
    assertThat(seq([2, 3, 5]).padded(0, "a")).iteratesAs(2, 3, 5);
    assertThat(seq([2, 3, 5]).padded(1, "a")).iteratesAs(2, 3, 5);
    assertThat(seq([2, 3, 5]).padded(2, "a")).iteratesAs(2, 3, 5);
    assertThat(seq([2, 3, 5]).padded(3, "a")).iteratesAs(2, 3, 5);
  });
  suite.test("ifThen", function() {
    assertThat(seq([1, 2, 3]).ifThen(false, function(s) {
      return [4, 5, 6];
    })).iteratesAs(1, 2, 3);
    assertThat(seq([1, 2, 3]).ifThen(true, function(s) {
      return [4, 5, 6];
    })).iteratesAs(4, 5, 6);
    assertThat(seq([1, 2, 3]).ifThen(false, function(s) {
      return s.map(function(e) {
        return e * 2;
      });
    })).iteratesAs(1, 2, 3);
    assertThat(seq([1, 2, 3]).ifThen(true, function(s) {
      return s.map(function(e) {
        return e * 2;
      });
    })).iteratesAs(2, 4, 6);
  });
  suite.test("partitioned", function() {
    assertThrows(function() {
      return seq([]).partitioned(-1);
    });
    assertThrows(function() {
      return seq([]).partitioned(0);
    });
    assertThat(seq([]).partitioned(1)).iteratesAs();
    assertThat(seq(["a"]).partitioned(1)).iteratesAs(["a"]);
    assertThat(seq(["a"]).partitioned(2)).iteratesAs(["a"]);
    assertThat(seq(["a", "b"]).partitioned(1)).iteratesAs(["a"], ["b"]);
    assertThat(seq(["a", "b"]).partitioned(2)).iteratesAs(["a", "b"]);
    assertThat(seq(["a", "b"]).partitioned(3)).iteratesAs(["a", "b"]);
    assertThat(seq(["a", "b", "c"]).partitioned(1)).iteratesAs(["a"], ["b"], ["c"]);
    assertThat(seq(["a", "b", "c"]).partitioned(2)).iteratesAs(["a", "b"], ["c"]);
    assertThat(seq(["a", "b", "c"]).partitioned(3)).iteratesAs(["a", "b", "c"]);
    assertThat(seq(["a", "b", "c", "d"]).partitioned(1)).iteratesAs(["a"], ["b"], ["c"], ["d"]);
    assertThat(seq(["a", "b", "c", "d"]).partitioned(2)).iteratesAs(["a", "b"], ["c", "d"]);
    assertThat(seq(["a", "b", "c", "d"]).partitioned(3)).iteratesAs(["a", "b", "c"], ["d"]);
    assertThat(seq(["a", "b", "c", "d"]).partitioned(4)).iteratesAs(["a", "b", "c", "d"]);
  });
  suite.test("toMap", function() {
    assertThat(seq([]).toMap(function() {
      throw new Error();
    }, function() {
      throw new Error();
    })).isEqualTo(new Map());
    assertThat(seq([2]).toMap(function(e) {
      return e * e;
    }, function(e) {
      return e;
    })).isEqualTo(new Map([[4, 2]]));
    assertThat(seq([2, 3, 4]).toMap(function(e) {
      return e;
    }, function(e) {
      return e * e;
    })).isEqualTo(new Map([[2, 4], [3, 9], [4, 16]]));
  });
  suite.test("groupBy", function() {
    assertThat(seq([]).groupBy(function() {
      throw new Error();
    })).isEqualTo(new Map());
    assertThat(seq([32]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[2, [32]]]));
    assertThat(seq([32, 2]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[2, [32, 2]]]));
    assertThat(seq([32, 2, 62]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[2, [32, 2, 62]]]));
    assertThat(seq([32, 3]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[0, [3]], [2, [32]]]));
    assertThat(seq([32, 3, 63]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[0, [3, 63]], [2, [32]]]));
    assertThat(seq([1, 2, 3]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[0, [3]], [1, [1]], [2, [2]]]));
    assertThat(seq([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).groupBy(function(e) {
      return e % 3;
    })).isEqualTo(new Map([[0, [0, 3, 6, 9]], [1, [1, 4, 7, 10]], [2, [2, 5, 8]]]));
  });
  suite.test("breadthFirstSearch", function() {
    assertThat(seq([]).breadthFirstSearch(function() {
      throw new Error();
    }, function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([1, 4]).breadthFirstSearch(function(e) {
      return [];
    })).iteratesAs(1, 4);
    assertThat(seq([1, 4]).breadthFirstSearch(function(e) {
      return e >= 5 ? [] : [e * 2, e * 2 + 1];
    })).iteratesAs(1, 4, 2, 3, 8, 9, 5, 6, 7);
    assertThat(seq([1, 4]).breadthFirstSearch(function(e) {
      return e >= 10 ? [] : [e * 2, e * 2 + 1];
    })).iteratesAs(1, 4, 2, 3, 8, 9, 5, 6, 7, 16, 17, 18, 19, 10, 11, 12, 13, 14, 15);
    assertThat(seq([1, 4]).breadthFirstSearch(function(e) {
      return e >= 10 ? [] : [e * 2, e * 2 + 1];
    }, function(e) {
      return e % 3;
    })).iteratesAs(1, 2, 3);
  });
  suite.test("sorted", function() {
    assertThat(seq([]).sorted()).isEqualTo([]);
    assertThat(seq([1]).sorted()).isEqualTo([1]);
    assertThat(seq([1, 2]).sorted()).isEqualTo([1, 2]);
    assertThat(seq([2, 1]).sorted()).isEqualTo([1, 2]);
    assertThat(seq([1, 2, 3]).sorted()).isEqualTo([1, 2, 3]);
    assertThat(seq([3, 1, 2]).sorted()).isEqualTo([1, 2, 3]);
    assertThat(seq([3, 2, 1]).sorted()).isEqualTo([1, 2, 3]);
    assertThat(seq([-Infinity, Infinity, 3, 2, 1]).sorted()).isEqualTo([-Infinity, 1, 2, 3, Infinity]);
    assertThat(seq(["d", "a", "c", "b"]).sorted()).isEqualTo(["a", "b", "c", "d"]);
    assertThat(seq(["one", "two", "three"]).sorted()).isEqualTo(["one", "three", "two"]);
  });
  suite.test("sortedBy", function() {
    assertThat(seq([]).sortedBy(function(e) {
      return e % 5;
    })).isEqualTo([]);
    assertThat(seq([1]).sortedBy(function(e) {
      return e % 5;
    })).isEqualTo([1]);
    assertThat(seq([1, 2]).sortedBy(function(e) {
      return e % 5;
    })).isEqualTo([1, 2]);
    assertThat(seq([2, 1]).sortedBy(function(e) {
      return e % 5;
    })).isEqualTo([1, 2]);
    assertThat(seq([1, 5]).sortedBy(function(e) {
      return e % 5;
    })).isEqualTo([5, 1]);
    assertThat(seq([5, 1]).sortedBy(function(e) {
      return e % 5;
    })).isEqualTo([5, 1]);
  });
  suite.test("stride", function() {
    assertThat(seq([]).stride(1)).isEqualTo([]);
    assertThat(seq([]).stride(2)).isEqualTo([]);
    assertThat(seq([]).stride(3)).isEqualTo([]);
    assertThat(seq(["a"]).stride(1)).isEqualTo(["a"]);
    assertThat(seq(["a"]).stride(2)).isEqualTo(["a"]);
    assertThat(seq(["a"]).stride(3)).isEqualTo(["a"]);
    assertThat(seq(["a", "b"]).stride(1)).isEqualTo(["a", "b"]);
    assertThat(seq(["a", "b"]).stride(2)).isEqualTo(["a"]);
    assertThat(seq(["a", "b"]).stride(3)).isEqualTo(["a"]);
    assertThat(seq(["a", "b", "c"]).stride(1)).isEqualTo(["a", "b", "c"]);
    assertThat(seq(["a", "b", "c"]).stride(2)).isEqualTo(["a", "c"]);
    assertThat(seq(["a", "b", "c"]).stride(3)).isEqualTo(["a"]);
    assertThat(seq(["a", "b", "c", "d"]).stride(1)).isEqualTo(["a", "b", "c", "d"]);
    assertThat(seq(["a", "b", "c", "d"]).stride(2)).isEqualTo(["a", "c"]);
    assertThat(seq(["a", "b", "c", "d"]).stride(3)).isEqualTo(["a", "d"]);
    assertThat(seq(["a", "b", "c", "d", "e"]).stride(1)).isEqualTo(["a", "b", "c", "d", "e"]);
    assertThat(seq(["a", "b", "c", "d", "e"]).stride(2)).isEqualTo(["a", "c", "e"]);
    assertThat(seq(["a", "b", "c", "d", "e"]).stride(3)).isEqualTo(["a", "d"]);
    assertThat(seq(["a", "b", "c", "d", "e", "f"]).stride(1)).isEqualTo(["a", "b", "c", "d", "e", "f"]);
    assertThat(seq(["a", "b", "c", "d", "e", "f"]).stride(2)).isEqualTo(["a", "c", "e"]);
    assertThat(seq(["a", "b", "c", "d", "e", "f"]).stride(3)).isEqualTo(["a", "d"]);
    assertThat(seq(["a", "b", "c", "d", "e", "f", "g"]).stride(1)).isEqualTo(["a", "b", "c", "d", "e", "f", "g"]);
    assertThat(seq(["a", "b", "c", "d", "e", "f", "g"]).stride(2)).isEqualTo(["a", "c", "e", "g"]);
    assertThat(seq(["a", "b", "c", "d", "e", "f", "g"]).stride(3)).isEqualTo(["a", "d", "g"]);
    assertThat(Seq.range(100).stride(10)).isEqualTo(Seq.range(10).map(function(e) {
      return e * 10;
    }));
  });
  suite.test("segmentBy", function() {
    assertThat(seq([]).segmentBy(function() {
      throw new Error();
    })).iteratesAs();
    assertThat(seq([1]).segmentBy(function(e) {
      return e + 1;
    })).iteratesAs([1]);
    assertThat(seq([2, 3, 5, 7, 11, 13]).segmentBy(function(e) {
      return e % 4;
    })).iteratesAs([2], [3], [5], [7, 11], [13]);
    assertThat(seq([1, 2, 3, 4, 5, 6, 7, 8, 9]).segmentBy(function(e) {
      return e >> 2;
    })).iteratesAs([1, 2, 3], [4, 5, 6, 7], [8, 9]);
    assertThat(seq([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3]).segmentBy(function(e) {
      return e >> 2;
    })).iteratesAs([1, 2, 3], [4, 5, 6, 7], [8, 9], [1, 2, 3]);
  });
  return {};
});
//# sourceURL=test/base/Seq.test.js
;$traceurRuntime.registerModule("test/base/Util.test.js", [], function() {
  "use strict";
  var __moduleName = "test/base/Util.test.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/base/Util.test.js")),
      Suite = $__3.Suite,
      assertThat = $__3.assertThat,
      assertThrows = $__3.assertThrows,
      assertTrue = $__3.assertTrue,
      assertFalse = $__3.assertFalse;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/base/Util.test.js")).Util;
  var suite = new Suite("Util");
  suite.test("need", function() {
    assertThrows(function() {
      return Util.need(false);
    });
    Util.need(true);
  });
  suite.test("notNull", function() {
    assertThrows(function() {
      return Util.notNull(null);
    });
    assertThat(Util.notNull([])).isEqualTo([]);
    assertThat(Util.notNull("")).isEqualTo("");
  });
  suite.test("isPowerOf2", function() {
    assertFalse(Util.isPowerOf2(-1));
    assertFalse(Util.isPowerOf2(0));
    assertTrue(Util.isPowerOf2(1));
    assertTrue(Util.isPowerOf2(2));
    assertFalse(Util.isPowerOf2(3));
    assertTrue(Util.isPowerOf2(4));
    assertFalse(Util.isPowerOf2(5));
  });
  suite.test("ceilLg2", function() {
    assertThat(Util.ceilLg2(0)).isEqualTo(0);
    assertThat(Util.ceilLg2(1)).isEqualTo(0);
    assertThat(Util.ceilLg2(2)).isEqualTo(1);
    assertThat(Util.ceilLg2(3)).isEqualTo(2);
    assertThat(Util.ceilLg2(4)).isEqualTo(2);
    assertThat(Util.ceilLg2(5)).isEqualTo(3);
    assertThat(Util.ceilLg2(6)).isEqualTo(3);
    assertThat(Util.ceilLg2(7)).isEqualTo(3);
    assertThat(Util.ceilLg2(8)).isEqualTo(3);
    assertThat(Util.ceilLg2(9)).isEqualTo(4);
    assertThat(Util.ceilLg2((1 << 20) - 1)).isEqualTo(20);
    assertThat(Util.ceilLg2((1 << 20))).isEqualTo(20);
    assertThat(Util.ceilLg2((1 << 20) + 1)).isEqualTo(21);
  });
  suite.test("popcnt", function() {
    assertThat(Util.popcnt(-2)).isEqualTo(Math.POSITIVE_INFINITY);
    assertThat(Util.popcnt(-1)).isEqualTo(Math.POSITIVE_INFINITY);
    assertThat(Util.popcnt(0)).isEqualTo(0);
    assertThat(Util.popcnt(1)).isEqualTo(1);
    assertThat(Util.popcnt(2)).isEqualTo(1);
    assertThat(Util.popcnt(3)).isEqualTo(2);
    assertThat(Util.popcnt(4)).isEqualTo(1);
    assertThat(Util.popcnt(5)).isEqualTo(2);
    assertThat(Util.popcnt(6)).isEqualTo(2);
    assertThat(Util.popcnt(7)).isEqualTo(3);
    assertThat(Util.popcnt(8)).isEqualTo(1);
    assertThat(Util.popcnt(9)).isEqualTo(2);
    assertThat(Util.popcnt((1 << 20) - 1)).isEqualTo(20);
    assertThat(Util.popcnt((1 << 20))).isEqualTo(1);
    assertThat(Util.popcnt((1 << 20) + 1)).isEqualTo(2);
  });
  suite.test("floorLg2", function() {
    assertThat(Util.floorLg2(0)).isEqualTo(0);
    assertThat(Util.floorLg2(1)).isEqualTo(0);
    assertThat(Util.floorLg2(2)).isEqualTo(1);
    assertThat(Util.floorLg2(3)).isEqualTo(1);
    assertThat(Util.floorLg2(4)).isEqualTo(2);
    assertThat(Util.floorLg2(5)).isEqualTo(2);
    assertThat(Util.floorLg2(6)).isEqualTo(2);
    assertThat(Util.floorLg2(7)).isEqualTo(2);
    assertThat(Util.floorLg2(8)).isEqualTo(3);
    assertThat(Util.floorLg2(9)).isEqualTo(3);
    assertThat(Util.floorLg2((1 << 20) - 1)).isEqualTo(19);
    assertThat(Util.floorLg2((1 << 20))).isEqualTo(20);
    assertThat(Util.floorLg2((1 << 20) + 1)).isEqualTo(20);
  });
  suite.test("bitSize", function() {
    assertThat(Util.bitSize(0)).isEqualTo(0);
    assertThat(Util.bitSize(1)).isEqualTo(1);
    assertThat(Util.bitSize(2)).isEqualTo(2);
    assertThat(Util.bitSize(3)).isEqualTo(2);
    assertThat(Util.bitSize(4)).isEqualTo(3);
    assertThat(Util.bitSize(5)).isEqualTo(3);
    assertThat(Util.bitSize(6)).isEqualTo(3);
    assertThat(Util.bitSize(7)).isEqualTo(3);
    assertThat(Util.bitSize(8)).isEqualTo(4);
    assertThat(Util.bitSize(9)).isEqualTo(4);
    assertThat(Util.bitSize(1 << 20)).isEqualTo(21);
    assertThat(Util.bitSize((1 << 20) + (1 << 19))).isEqualTo(21);
  });
  suite.test("ceilingPowerOf2", function() {
    assertThat(Util.ceilingPowerOf2(-1)).isEqualTo(1);
    assertThat(Util.ceilingPowerOf2(0)).isEqualTo(1);
    assertThat(Util.ceilingPowerOf2(1)).isEqualTo(1);
    assertThat(Util.ceilingPowerOf2(2)).isEqualTo(2);
    assertThat(Util.ceilingPowerOf2(3)).isEqualTo(4);
    assertThat(Util.ceilingPowerOf2(4)).isEqualTo(4);
    assertThat(Util.ceilingPowerOf2(5)).isEqualTo(8);
    assertThat(Util.ceilingPowerOf2(6)).isEqualTo(8);
    assertThat(Util.ceilingPowerOf2(7)).isEqualTo(8);
    assertThat(Util.ceilingPowerOf2(8)).isEqualTo(8);
    assertThat(Util.ceilingPowerOf2(9)).isEqualTo(16);
    assertThat(Util.ceilingPowerOf2((1 << 20) - 1)).isEqualTo(1 << 20);
    assertThat(Util.ceilingPowerOf2(1 << 20)).isEqualTo(1 << 20);
    assertThat(Util.ceilingPowerOf2((1 << 20) + 1)).isEqualTo(1 << 21);
  });
  suite.test("powerOfTwoness", function() {
    assertThat(Util.powerOfTwoness(-2)).isEqualTo(1);
    assertThat(Util.powerOfTwoness(-1)).isEqualTo(0);
    assertThat(Util.powerOfTwoness(-1, 'z')).isEqualTo(0);
    assertThat(Util.powerOfTwoness(0)).isEqualTo(Math.POSITIVE_INFINITY);
    assertThat(Util.powerOfTwoness(0, 'z')).isEqualTo('z');
    assertThat(Util.powerOfTwoness(1, 'z')).isEqualTo(0);
    assertThat(Util.powerOfTwoness(1)).isEqualTo(0);
    assertThat(Util.powerOfTwoness(2)).isEqualTo(1);
    assertThat(Util.powerOfTwoness(3)).isEqualTo(0);
    assertThat(Util.powerOfTwoness(4)).isEqualTo(2);
    assertThat(Util.powerOfTwoness(5)).isEqualTo(0);
    assertThat(Util.powerOfTwoness(6)).isEqualTo(1);
    assertThat(Util.powerOfTwoness(7)).isEqualTo(0);
    assertThat(Util.powerOfTwoness(8)).isEqualTo(3);
    assertThat(Util.powerOfTwoness(9)).isEqualTo(0);
    assertThat(Util.powerOfTwoness(1 << 20)).isEqualTo(20);
    assertThat(Util.powerOfTwoness(1 + (1 << 20))).isEqualTo(0);
    assertThat(Util.powerOfTwoness(2 + (1 << 20))).isEqualTo(1);
  });
  suite.test("reverseGroupMap", function() {
    assertThat(Util.reverseGroupMap(new Map())).isEqualTo(new Map());
    assertThat(Util.reverseGroupMap(new Map([["a", ["b"]]]))).isEqualTo(new Map([["b", ["a"]]]));
    assertThat(Util.reverseGroupMap(new Map([["a", ["b", "c"]]]))).isEqualTo(new Map([["b", ["a"]], ["c", ["a"]]]));
    assertThat(Util.reverseGroupMap(new Map([["a", ["b"]], ["c", ["b"]]]))).isEqualTo(new Map([["b", ["a", "c"]]]));
    assertThat(Util.reverseGroupMap(new Map([["a", [1, 2, 3]], ["b", [2, 3, 4]], ["c", [3, 4, 5]]]))).isEqualTo(new Map([[1, ["a"]], [2, ["a", "b"]], [3, ["a", "b", "c"]], [4, ["b", "c"]], [5, ["c"]]]));
    assertThat(Util.reverseGroupMap(new Map([["a", [1, 2, 3]], ["b", [2, 3, 4]], ["c", [3, 4, 5]]]), true)).isEqualTo(new Map([[1, ["a"]], [2, ["a", "b"]], [3, ["a", "b", "c"]], [4, ["b", "c"]], [5, ["c"]], ["a", []], ["b", []], ["c", []]]));
    assertThat(Util.reverseGroupMap(new Map([[3, [1, 2]], [2, [1]]]), true)).isEqualTo(new Map([[1, [3, 2]], [2, [3]], [3, []]]));
  });
  suite.test("binarySearchForTransitionFromTrueToFalse", function() {
    var r = ["axe", "cat", "def", "g"];
    assertThat(Util.binarySearchForTransitionFromTrueToFalse(r.length, function(i) {
      return r[i] < "a";
    })).isEqualTo(0);
    assertThat(Util.binarySearchForTransitionFromTrueToFalse(r.length, function(i) {
      return r[i] < "b";
    })).isEqualTo(1);
    assertThat(Util.binarySearchForTransitionFromTrueToFalse(r.length, function(i) {
      return r[i] < "d";
    })).isEqualTo(2);
    assertThat(Util.binarySearchForTransitionFromTrueToFalse(r.length, function(i) {
      return r[i] < "e";
    })).isEqualTo(3);
    for (var n = 0; n < 10; n++) {
      var $__2 = function(t) {
        assertThat(Util.binarySearchForTransitionFromTrueToFalse(n, function(i) {
          return i < t;
        })).isEqualTo(t);
        assertThat(Util.binarySearchForTransitionFromTrueToFalse(n, function(i) {
          return i <= t;
        })).isEqualTo(Math.min(n, t + 1));
      };
      for (var t = 0; t <= n; t++) {
        $__2(t);
      }
    }
  });
  suite.test("breakLine", function() {
    assertThat(Util.breakLine("a long line can be broken between words", 21, function(e) {
      return e.length;
    })).isEqualTo(["a long line can be", "broken between words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 20, function(e) {
      return e.length;
    })).isEqualTo(["a long line can be", "broken between words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 19, function(e) {
      return e.length;
    })).isEqualTo(["a long line can be", "broken between", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 11, function(e) {
      return e.length;
    })).isEqualTo(["a long line", "can be", "broken", "between", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 10, function(e) {
      return e.length;
    })).isEqualTo(["a long", "line can", "be broken", "between", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 9, function(e) {
      return e.length;
    })).isEqualTo(["a long", "line can", "be broken", "between", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 8, function(e) {
      return e.length;
    })).isEqualTo(["a long", "line can", "be", "broken", "between", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 7, function(e) {
      return e.length;
    })).isEqualTo(["a long", "line", "can be", "broken", "between", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 6, function(e) {
      return e.length;
    })).isEqualTo(["a long", "line", "can be", "broken", "betwee", "n", "words"]);
    assertThat(Util.breakLine("a long line can be broken between words", 5, function(e) {
      return e.length;
    })).isEqualTo(["a", "long", "line", "can", "be", "broke", "n", "betwe", "en", "words"]);
    assertThat(Util.breakLine("multiple     spaces       can get         \t\tcollapsed", 10, function(e) {
      return e.length;
    })).isEqualTo(["multiple", "spaces", "can get", "collapsed"]);
    assertThat(Util.breakLine("Wide Wide narrow narrow", 13, function(e) {
      return (e.match(/W/) || []).length * 8 + e.length;
    })).isEqualTo(["Wide", "Wide", "narrow narrow"]);
  });
  suite.test("decomposeObjectValues", function() {
    assertThat(Util.decomposeObjectValues({})).isEqualTo([]);
    assertThat(Util.decomposeObjectValues({a: "x"})).isEqualTo(["x"]);
    assertThat(Util.decomposeObjectValues({a: {b: "y"}})).isEqualTo([{b: "y"}]);
    assertThat(Util.decomposeObjectValues({
      a: "x",
      b: "y"
    })).isEqualTo(["x", "y"]);
    assertThat(Util.decomposeObjectValues({
      b: "y",
      a: "x"
    })).isEqualTo(["x", "y"]);
    assertThat(Util.decomposeObjectValues({a: []})).isEqualTo([]);
    assertThat(Util.decomposeObjectValues({a: [1, 2, 3]})).isEqualTo([1, 2, 3]);
    assertThat(Util.decomposeObjectValues({
      a: [1, 2, 3],
      b: "x",
      c: [4, 5]
    })).isEqualTo([1, 2, 3, "x", 4, 5]);
    assertThat(Util.decomposeObjectValues({a: [1, [2, 4], 3]})).isEqualTo([1, 2, 4, 3]);
    assertThat(Util.decomposeObjectValues({a: [1, [], 3]})).isEqualTo([1, 3]);
  });
  suite.test("recomposedObjectValues", function() {
    assertThrows(function() {
      return Util.recomposedObjectValues({}, [1]);
    });
    assertThrows(function() {
      return Util.recomposedObjectValues({a: []}, [1]);
    });
    assertThrows(function() {
      return Util.recomposedObjectValues({a: ""}, []);
    });
    assertThat(Util.recomposedObjectValues({}, [])).isEqualTo({});
    assertThat(Util.recomposedObjectValues({a: "x"}, ["r"])).isEqualTo({a: "r"});
    assertThat(Util.recomposedObjectValues({a: {b: "y"}}, ["r"])).isEqualTo({a: "r"});
    assertThat(Util.recomposedObjectValues({
      a: "x",
      b: "y"
    }, [2, 3])).isEqualTo({
      a: 2,
      b: 3
    });
    assertThat(Util.recomposedObjectValues({
      b: "y",
      a: "x"
    }, [2, 3])).isEqualTo({
      a: 2,
      b: 3
    });
    assertThat(Util.recomposedObjectValues({a: []}, [])).isEqualTo({a: []});
    assertThat(Util.recomposedObjectValues({a: [2, 3]}, [4, 5])).isEqualTo({a: [4, 5]});
    assertThat(Util.recomposedObjectValues({
      a: [1, 2, 3],
      b: "x",
      c: [4, 5]
    }, ["a", "b", "c", "d", "e", "f"])).isEqualTo({
      a: ["a", "b", "c"],
      b: "d",
      c: ["e", "f"]
    });
    assertThat(Util.recomposedObjectValues({a: [1, [2, 4], 3]}, ["a", "b", "c", "d"])).isEqualTo({a: ["a", ["b", "c"], "d"]});
    assertThat(Util.recomposedObjectValues({a: [1, [], 3]}, ["a", "b"])).isEqualTo({a: ["a", [], "b"]});
  });
  suite.test("snappedCosSin", function() {
    var r = Math.PI / 4;
    var s = Math.sqrt(0.5);
    assertThat(Util.snappedCosSin(0.123)).isEqualTo([Math.cos(0.123), Math.sin(0.123)]);
    assertThat(Util.snappedCosSin(0)).isEqualTo([1, 0]);
    assertThat(Util.snappedCosSin(r)).isEqualTo([s, s]);
    assertThat(Util.snappedCosSin(2 * r)).isEqualTo([0, 1]);
    assertThat(Util.snappedCosSin(3 * r)).isEqualTo([-s, s]);
    assertThat(Util.snappedCosSin(4 * r)).isEqualTo([-1, 0]);
    assertThat(Util.snappedCosSin(5 * r)).isEqualTo([-s, -s]);
    assertThat(Util.snappedCosSin(6 * r)).isEqualTo([0, -1]);
    assertThat(Util.snappedCosSin(7 * r)).isEqualTo([s, -s]);
    assertThat(Util.snappedCosSin(8 * r)).isEqualTo([1, 0]);
    assertThat(Util.snappedCosSin(-8 * r)).isEqualTo([1, 0]);
    assertThat(Util.snappedCosSin(-7 * r)).isEqualTo([s, s]);
    assertThat(Util.snappedCosSin(-6 * r)).isEqualTo([0, 1]);
    assertThat(Util.snappedCosSin(-5 * r)).isEqualTo([-s, s]);
    assertThat(Util.snappedCosSin(-4 * r)).isEqualTo([-1, 0]);
    assertThat(Util.snappedCosSin(-3 * r)).isEqualTo([-s, -s]);
    assertThat(Util.snappedCosSin(-2 * r)).isEqualTo([0, -1]);
    assertThat(Util.snappedCosSin(-1 * r)).isEqualTo([s, -s]);
  });
  suite.test("numberOfSetBits", function() {
    assertThrows(function() {
      return Util.numberOfSetBits(-1);
    });
    assertThrows(function() {
      return Util.numberOfSetBits("what");
    });
    assertThrows(function() {
      return Util.numberOfSetBits(NaN);
    });
    assertThrows(function() {
      return Util.numberOfSetBits(Infinity);
    });
    assertThrows(function() {
      return Util.numberOfSetBits(Math.pow(2, 32));
    });
    assertThrows(function() {
      return Util.numberOfSetBits(0.1);
    });
    assertThat(Util.numberOfSetBits(0)).isEqualTo(0);
    assertThat(Util.numberOfSetBits(1)).isEqualTo(1);
    assertThat(Util.numberOfSetBits(2)).isEqualTo(1);
    assertThat(Util.numberOfSetBits(3)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(4)).isEqualTo(1);
    assertThat(Util.numberOfSetBits(5)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(6)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(7)).isEqualTo(3);
    assertThat(Util.numberOfSetBits(8)).isEqualTo(1);
    assertThat(Util.numberOfSetBits(9)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(10)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(11)).isEqualTo(3);
    assertThat(Util.numberOfSetBits(12)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(13)).isEqualTo(3);
    assertThat(Util.numberOfSetBits(14)).isEqualTo(3);
    assertThat(Util.numberOfSetBits(15)).isEqualTo(4);
    assertThat(Util.numberOfSetBits(16)).isEqualTo(1);
    assertThat(Util.numberOfSetBits(17)).isEqualTo(2);
    assertThat(Util.numberOfSetBits(0x11111111)).isEqualTo(8);
    assertThat(Util.numberOfSetBits(0x22222222)).isEqualTo(8);
    assertThat(Util.numberOfSetBits(0x01234567)).isEqualTo(12);
    assertThat(Util.numberOfSetBits(0x89ABCDEF)).isEqualTo(20);
    assertThat(Util.numberOfSetBits(0xFFFFFFFF)).isEqualTo(32);
  });
  suite.test("properMod", function() {
    assertThrows(function() {
      return Util.properMod(0, 0);
    });
    assertThrows(function() {
      return Util.properMod(1, 0);
    });
    assertThrows(function() {
      return Util.properMod(1, -1);
    });
    assertThat(Util.properMod(502, 501)).isEqualTo(1);
    assertThat(Util.properMod(-502, 501)).isEqualTo(500);
    assertThat(Util.properMod(-2, 1.5)).isEqualTo(1);
    assertThat(Util.properMod(-1.5, 1.5)).isEqualTo(0);
    assertThat(Util.properMod(-1, 1.5)).isEqualTo(0.5);
    assertThat(Util.properMod(-0.5, 1.5)).isEqualTo(1);
    assertThat(Util.properMod(0, 1.5)).isEqualTo(0);
    assertThat(Util.properMod(0.5, 1.5)).isEqualTo(0.5);
    assertThat(Util.properMod(1, 1.5)).isEqualTo(1);
    assertThat(Util.properMod(1.5, 1.5)).isEqualTo(0);
    assertThat(Util.properMod(2, 1.5)).isEqualTo(0.5);
  });
  suite.test("extended_gcd", function() {
    assertThat(Util.extended_gcd(2, 2)).isEqualTo({
      x: 0,
      y: 1,
      gcd: 2
    });
    assertThat(Util.extended_gcd(2, 3)).isEqualTo({
      x: -1,
      y: 1,
      gcd: 1
    });
    assertThat(Util.extended_gcd(3, 2)).isEqualTo({
      x: 1,
      y: -1,
      gcd: 1
    });
    assertThat(Util.extended_gcd(11, 0)).isEqualTo({
      x: 1,
      y: 0,
      gcd: 11
    });
    assertThat(Util.extended_gcd(11, 1)).isEqualTo({
      x: 0,
      y: 1,
      gcd: 1
    });
    assertThat(Util.extended_gcd(240, 46)).isEqualTo({
      x: -9,
      y: 47,
      gcd: 2
    });
    assertThat(Util.extended_gcd(3655, 3826)).isEqualTo({
      x: -179,
      y: 171,
      gcd: 1
    });
  });
  suite.test("modular_multiplicative_inverse", function() {
    assertThat(Util.modular_multiplicative_inverse(10, 11)).isEqualTo(10);
    assertThat(Util.modular_multiplicative_inverse(2, 4)).isEqualTo(undefined);
    assertThat(Util.modular_multiplicative_inverse(2, 11)).isEqualTo(6);
    assertThat(Util.modular_multiplicative_inverse(3, 1024)).isEqualTo(683);
    assertThat(Util.modular_multiplicative_inverse(683, 1024)).isEqualTo(3);
  });
  return {};
});
//# sourceURL=test/base/Util.test.js
;$traceurRuntime.registerModule("test/circuit/CircuitComputeUtil.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/CircuitComputeUtil.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/CircuitComputeUtil.test.js")).Suite;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/circuit/CircuitComputeUtil.test.js")).CircuitDefinition;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/circuit/CircuitComputeUtil.test.js")),
      setGateBuilderEffectToCircuit = $__3.setGateBuilderEffectToCircuit,
      advanceStateWithCircuit = $__3.advanceStateWithCircuit;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/circuit/CircuitComputeUtil.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Gate.js", "test/circuit/CircuitComputeUtil.test.js")).GateBuilder;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/circuit/CircuitComputeUtil.test.js")).Controls;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/circuit/CircuitComputeUtil.test.js")).Gates;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/CircuitComputeUtil.test.js")).Matrix;
  var suite = new Suite("CircuitComputeUtil");
  var circuit = function(diagram) {
    for (var extras = [],
        $__0 = 1; $__0 < arguments.length; $__0++)
      extras[$__0 - 1] = arguments[$__0];
    return CircuitDefinition.fromTextDiagram(new Map($traceurRuntime.spread([['X', Gates.HalfTurns.X], ['Y', Gates.HalfTurns.Y], ['Z', Gates.HalfTurns.Z], ['H', Gates.HalfTurns.H], ['•', Gates.Controls.Control], ['a', Gates.InputGates.InputAFamily.ofSize(1)], ['b', Gates.InputGates.InputBFamily.ofSize(1)], ['*', Gates.MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(1)], ['-', undefined], ['/', undefined]], extras)), diagram);
  };
  function circuitDefinitionToGate(circ) {
    return setGateBuilderEffectToCircuit(new GateBuilder(), circ).gate;
  }
  suite.testUsingWebGL("nestedControls", function() {
    var cnot = circuitDefinitionToGate(circuit("-•-\n                                                -X-"));
    var ccnot_circuit = circuit("-•-\n                                 -?-\n                                 -/-", ['?', cnot]);
    var ccnot_matrix = Matrix.PAULI_X.expandedForQubitInRegister(2, 3, new Controls(3, 3));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, ccnot_circuit, false);
    }, ccnot_matrix);
  });
  suite.testUsingWebGL("multiNestedControls", function() {
    var notc = circuitDefinitionToGate(circuit("-X-\n                                                -•-"));
    var i_notcc = circuitDefinitionToGate(circuit("---\n                                                   -?-\n                                                   -/-\n                                                   -•-", ['?', notc]));
    var shifted_notccc_circuit = circuit("---\n                                          -?-\n                                          -/-\n                                          -/-\n                                          -/-\n                                          -•-", ['?', i_notcc]);
    var shifted_notccc_matrix = Matrix.PAULI_X.expandedForQubitInRegister(2, 6, new Controls(7 << 3, 7 << 3));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, shifted_notccc_circuit, false);
    }, shifted_notccc_matrix);
  });
  suite.testUsingWebGL("innerAndOuterInputs", function() {
    var plus_a_times = circuitDefinitionToGate(circuit("-*-\n                                                        -a-"));
    var notcc_circuit = circuit("-?-\n                                 -/-\n                                 -b-", ['?', plus_a_times]);
    var notcc_matrix = Matrix.PAULI_X.expandedForQubitInRegister(0, 3, new Controls(6, 6));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, notcc_circuit, false);
    }, notcc_matrix);
  });
  suite.testUsingWebGL("doublyNestedInputs", function() {
    var plus_a_times = circuitDefinitionToGate(circuit("-*-\n                                                        -a-"));
    var plus_a_times_b = circuitDefinitionToGate(circuit("-?-\n                                                          -/-\n                                                          -b-", ['?', plus_a_times]));
    var shifted_notcc_circuit = circuit("---\n                                         -?-\n                                         -/-\n                                         -/-", ['?', plus_a_times_b]);
    var shifted_notcc_matrix = Matrix.PAULI_X.expandedForQubitInRegister(1, 4, new Controls(12, 12));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, shifted_notcc_circuit, false);
    }, shifted_notcc_matrix);
  });
  suite.testUsingWebGL("rawAddition", function() {
    var adder = circuit("-+-\n                         -/-\n                         -/-\n                         -/-\n                         -A-\n                         -/-", ['A', Gates.InputGates.InputAFamily.ofSize(2)], ['+', Gates.Arithmetic.PlusAFamily.ofSize(4)]);
    var matrix = Matrix.generateTransition(1 << 6, function(e) {
      var a = e & 15;
      var b = (e >> 4) & 3;
      a += b;
      a &= 15;
      return a | (b << 4);
    });
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, adder, false);
    }, matrix);
  });
  suite.testUsingWebGL('swap', function() {
    var circ = circuit("-S-\n                        -S-", ['S', Gates.Special.SwapHalf]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Gates.Special.SwapHalf.knownMatrixAt(0));
  });
  return {};
});
//# sourceURL=test/circuit/CircuitComputeUtil.test.js
;$traceurRuntime.registerModule("test/circuit/CircuitDefinition.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/CircuitDefinition.test.js";
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/CircuitDefinition.test.js")),
      Suite = $__12.Suite,
      assertThat = $__12.assertThat,
      assertThrows = $__12.assertThrows,
      assertTrue = $__12.assertTrue,
      assertFalse = $__12.assertFalse;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/circuit/CircuitDefinition.test.js")).CircuitDefinition;
  var setGateBuilderEffectToCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/circuit/CircuitDefinition.test.js")).setGateBuilderEffectToCircuit;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/circuit/CircuitDefinition.test.js")).Complex;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/circuit/CircuitDefinition.test.js")).Controls;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Gate.js", "test/circuit/CircuitDefinition.test.js")),
      Gate = $__17.Gate,
      GateBuilder = $__17.GateBuilder;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/circuit/CircuitDefinition.test.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/circuit/CircuitDefinition.test.js")).Gates;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/CircuitDefinition.test.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Point.js", "test/circuit/CircuitDefinition.test.js")).Point;
  var $__22 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/circuit/CircuitDefinition.test.js")),
      Seq = $__22.Seq,
      seq = $__22.seq;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Serializer.js", "test/circuit/CircuitDefinition.test.js")).Serializer;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/circuit/CircuitDefinition.test.js")).Util;
  var suite = new Suite("CircuitDefinition");
  var X = Gates.HalfTurns.X;
  var Y = Gates.HalfTurns.Y;
  var Z = Gates.HalfTurns.Z;
  var H = Gates.HalfTurns.H;
  var C = Gates.Controls.Control;
  var _ = undefined;
  var TEST_GATES = new Map([['X', X], ['Y', Y], ['Z', Z], ['H', H], ['●', C], ['○', Gates.Controls.AntiControl], ['⊖', Gates.Controls.XControl], ['⊕', Gates.Controls.XAntiControl], ['⊗', Gates.Controls.YAntiControl], ['.', Gates.SpacerGate], ['A', Gates.InputGates.InputAFamily], ['B', Gates.InputGates.InputBFamily], ['M', Gates.Special.Measurement], ['%', Gates.Displays.ChanceDisplay], ['D', Gates.Displays.DensityMatrixDisplayFamily], ['@', Gates.Displays.BlochSphereDisplay], ['s', Gates.Special.SwapHalf], ['!', Gates.PostSelectionGates.PostSelectOn], ['-', undefined], ['=', undefined], ['+', undefined], ['|', undefined], ['/', null], ['#', new GateBuilder().setKnownEffectToMatrix(Matrix.zero(4, 4)).setWidth(2).setHeight(2).gate], ['~', new GateBuilder().setKnownEffectToMatrix(Matrix.zero(2, 2)).setWidth(3).gate], ['2', Gates.IncrementGates.IncrementFamily.ofSize(2)], ['3', Gates.IncrementGates.IncrementFamily.ofSize(3)], ['Q', new GateBuilder().setKnownEffectToMatrix(Matrix.square(1, 1, 1, 1, 1, Complex.I, -1, Complex.I.neg(), 1, -1, 1, -1, 1, Complex.I.neg(), -1, Complex.I)).setHeight(2).gate], ['t', Gates.Exponentiating.XForward]]);
  var circuit = function(diagram) {
    for (var extraGates = [],
        $__8 = 1; $__8 < arguments.length; $__8++)
      extraGates[$__8 - 1] = arguments[$__8];
    return CircuitDefinition.fromTextDiagram(Util.mergeMaps(TEST_GATES, new Map(extraGates)), diagram);
  };
  function circuitDefinitionToGate(circ) {
    return setGateBuilderEffectToCircuit(new GateBuilder(), circ).gate;
  }
  suite.test("isEqualTo", function() {
    var c1 = new CircuitDefinition(2, [new GateColumn([_, H]), new GateColumn([X, C])]);
    var c2 = new CircuitDefinition(2, [new GateColumn([_, H]), new GateColumn([X, C])]);
    var d1 = new CircuitDefinition(2, [new GateColumn([_, X]), new GateColumn([X, C])]);
    var d2 = new CircuitDefinition(2, [new GateColumn([_, H])]);
    var d3 = new CircuitDefinition(3, [new GateColumn([_, X, _]), new GateColumn([X, C, _])]);
    assertThat(c1).isEqualTo(c1);
    assertThat(c1).isEqualTo(c2);
    assertThat(c1).isNotEqualTo(d1);
    assertThat(c1).isNotEqualTo(d2);
    assertThat(c1).isNotEqualTo(d3);
    assertThat(new CircuitDefinition(2, [])).isEqualTo(new CircuitDefinition(2, []));
    assertThat(new CircuitDefinition(2, [])).isNotEqualTo(new CircuitDefinition(3, []));
    assertThat(CircuitDefinition.EMPTY).isEqualTo(new CircuitDefinition(0, []));
  });
  suite.test("fromTextDiagram", function() {
    assertThrows(function() {
      return circuit('∞');
    });
    assertThrows(function() {
      return circuit('--\n-');
    });
    assertThat(circuit('')).isEqualTo(new CircuitDefinition(0, []));
    assertThat(circuit("\n        -\n        ")).isEqualTo(new CircuitDefinition(1, [new GateColumn([_])]));
    assertThat(circuit("\n        -X-\n        -Y-\n        ")).isEqualTo(new CircuitDefinition(2, [new GateColumn([_, _]), new GateColumn([X, Y]), new GateColumn([_, _])]));
    assertThat(circuit("\n        -●\n        -|\n        -Z\n        ")).isEqualTo(new CircuitDefinition(3, [new GateColumn([_, _, _]), new GateColumn([C, _, Z])]));
    var qftFamily = Gates.FourierTransformGates.FourierTransformFamily;
    var qftMap = new Map([['Q', qftFamily], ['-', undefined], ['/', null]]);
    assertThat(CircuitDefinition.fromTextDiagram(qftMap, "Q")).isEqualTo(new CircuitDefinition(1, [new GateColumn([qftFamily.ofSize(1)])]));
    assertThat(CircuitDefinition.fromTextDiagram(qftMap, "Q\n                                                          -")).isEqualTo(new CircuitDefinition(2, [new GateColumn([qftFamily.ofSize(1), _])]));
    assertThat(CircuitDefinition.fromTextDiagram(qftMap, "Q\n                                                          /")).isEqualTo(new CircuitDefinition(2, [new GateColumn([qftFamily.ofSize(2), _])]));
    assertThat(CircuitDefinition.fromTextDiagram(qftMap, "QQQ\n                                                          //-\n                                                          /--")).isEqualTo(new CircuitDefinition(3, [new GateColumn([qftFamily.ofSize(3), _, _]), new GateColumn([qftFamily.ofSize(2), _, _]), new GateColumn([qftFamily.ofSize(1), _, _])]));
  });
  suite.test("stableDuration", function() {
    assertThat(circuit('----').stableDuration()).isEqualTo(Infinity);
    assertThat(circuit('-XY-').stableDuration()).isEqualTo(Infinity);
    assertThat(circuit("-XY-\n                        --X-").stableDuration()).isEqualTo(Infinity);
    assertThat(circuit("●Z#M\n                        --X/").stableDuration()).isEqualTo(Infinity);
    assertThat(circuit('t').stableDuration()).isEqualTo(0);
    assertThat(circuit('---t---').stableDuration()).isEqualTo(0);
    assertThat(circuit('-X-t-Y-').stableDuration()).isEqualTo(0);
    assertThat(circuit('-t-t---').stableDuration()).isEqualTo(0);
    assertThat(circuit("-t-t---\n                        -----X-").stableDuration()).isEqualTo(0);
    assertThat(circuit("-------\n                        -t-----").stableDuration()).isEqualTo(0);
  });
  suite.test("readableHash", function() {
    assertThat($traceurRuntime.typeof(CircuitDefinition.EMPTY.readableHash())).isEqualTo('string');
    assertThat($traceurRuntime.typeof(circuit('----').readableHash())).isEqualTo('string');
    assertThat($traceurRuntime.typeof(circuit('-\n-').readableHash())).isEqualTo('string');
    assertThat($traceurRuntime.typeof(circuit('tXY●').readableHash())).isEqualTo('string');
  });
  suite.test("readableHash", function() {
    assertThrows(function() {
      return circuit('-').withColumns(circuit('-\n-').columns);
    });
    assertThat(circuit('----').withColumns(circuit('XYZt').columns)).isEqualTo(circuit('XYZt'));
    assertThat(circuit('-').withColumns(circuit('XYZt').columns)).isEqualTo(circuit('XYZt'));
    assertThat(circuit('-\n-').withColumns(circuit('X\nY').columns)).isEqualTo(circuit('X\nY'));
  });
  suite.test("withWidthOverlapsFixed", function() {
    assertThat(circuit('----').withWidthOverlapsFixed()).isEqualTo(circuit('----'));
    assertThat(circuit("----\n                        ----").withWidthOverlapsFixed()).isEqualTo(circuit("----\n                                                                            ----"));
    assertThat(circuit("-XZ-\n                        -Yt-").withWidthOverlapsFixed()).isEqualTo(circuit("-XZ-\n                                                                            -Yt-"));
    assertThat(circuit("-2Z-\n                        -Yt-").withWidthOverlapsFixed()).isEqualTo(circuit("-2Z-\n                                                                            -Yt-"));
    assertThat(circuit("-#Z-\n                        -Yt-").withWidthOverlapsFixed()).isEqualTo(circuit("-#-Z-\n                                                                            -Y-t-"));
    assertThat(circuit("-#/-\n                        -Yt-").withWidthOverlapsFixed()).isEqualTo(circuit("-#---\n                                                                            -Y-t-"));
    assertThat(circuit("-#Z-\n                        -Y/-").withWidthOverlapsFixed()).isEqualTo(circuit("-#-Z-\n                                                                            -Y---"));
    assertThat(circuit("-#Z-\n                        -/t-").withWidthOverlapsFixed()).isEqualTo(circuit("-#-Z-\n                                                                            ---t-"));
    assertThat(circuit("--#/-\n                        -#//-\n                        -//--").withWidthOverlapsFixed()).isEqualTo(circuit("---#/-\n                                                                             -#///-\n                                                                             -//---"));
    assertThat(circuit("-###/-\n                        -/#//-\n                        --//--").withWidthOverlapsFixed()).isEqualTo(circuit("-#/#/#/-\n                                                                              -//#///-\n                                                                              ---//---"));
    assertThat(circuit("--3--\n                        -#/--\n                        -//--").withWidthOverlapsFixed()).isEqualTo(circuit("---3--\n                                                                             -#//--\n                                                                             -///--"));
    assertThat(circuit("-3---\n                        -/#/-\n                        -///-").withWidthOverlapsFixed()).isEqualTo(circuit("-3---\n                                                                             -/#/-\n                                                                             -///-"));
    assertThat(circuit("-3--\n                        -#/-\n                        -//-").withWidthOverlapsFixed()).isEqualTo(circuit("-3--\n                                                                            -#/-\n                                                                            -//-"));
    assertThat(circuit("~3/-\n                        -#/-\n                        -//-").withWidthOverlapsFixed()).isEqualTo(circuit("~//3--\n                                                                            ---#/-\n                                                                            ---//-"));
    assertThat(circuit("~~~~//-").withWidthOverlapsFixed()).isEqualTo(circuit("~//~//~//~//-"));
  });
  suite.test("withWidthOverlapsFixed", function() {
    assertThat(circuit('----').withHeightOverlapsFixed()).isEqualTo(circuit('----'));
    assertThat(circuit("----\n                        ----").withHeightOverlapsFixed()).isEqualTo(circuit("----\n                                                                             ----"));
    assertThat(circuit("-XZ-\n                        -Yt-").withHeightOverlapsFixed()).isEqualTo(circuit("-XZ-\n                                                                             -Yt-"));
    assertThat(circuit("-2Z-\n                        -Yt-").withHeightOverlapsFixed()).isEqualTo(circuit("-2-Z-\n                                                                             -/Yt-"));
    assertThat(circuit("-2Z-\n                        -Yt-\n                        -●--\n                        -○--").withHeightOverlapsFixed()).isEqualTo(circuit("-2-Z-\n                                                                             -/Yt-\n                                                                             -●●--\n                                                                             -○○--"));
    assertThat(circuit("-3-\n                        -●-\n                        -●-\n                        -○-").withHeightOverlapsFixed()).isEqualTo(circuit("-3--\n                                                                            -/●-\n                                                                            -/●-\n                                                                            -○○-"));
    assertThat(circuit("-3-\n                        -●-\n                        -●-\n                        -X-").withHeightOverlapsFixed()).isEqualTo(circuit("-3--\n                                                                            -/●-\n                                                                            -/●-\n                                                                            -X--"));
    assertThat(circuit("-3-\n                        -3-\n                        -2-\n                        -X-").withHeightOverlapsFixed()).isEqualTo(circuit("-3----\n                                                                            -/3---\n                                                                            -//2--\n                                                                            -///X-"));
    assertThat(circuit("-3-\n                        -2-\n                        -Y-\n                        -X-").withHeightOverlapsFixed()).isEqualTo(circuit("-3---\n                                                                            -/2--\n                                                                            -//Y-\n                                                                            -X---"));
  });
  suite.test("withTrailingSpacersIncluded", function() {
    assertThat(circuit('---').withTrailingSpacersIncluded()).isEqualTo(circuit('---'));
    assertThat(circuit('~XY').withTrailingSpacersIncluded()).isEqualTo(circuit('~XY'));
    assertThat(circuit('XY~').withTrailingSpacersIncluded()).isEqualTo(circuit('XY~--'));
    assertThat(circuit('#').withTrailingSpacersIncluded()).isEqualTo(circuit('#-'));
    assertThat(circuit("---\n                        --~").withTrailingSpacersIncluded()).isEqualTo(circuit("-----\n                                                                                --~--"));
  });
  suite.test("withUncoveredColumnsRemoved", function() {
    assertThat(circuit('---').withUncoveredColumnsRemoved()).isEqualTo(new CircuitDefinition(1, []));
    assertThat(circuit('~XY').withUncoveredColumnsRemoved()).isEqualTo(circuit('~XY'));
    assertThat(circuit('XY~//--').withUncoveredColumnsRemoved()).isEqualTo(circuit('XY~//'));
    assertThat(circuit('XY~//-').withUncoveredColumnsRemoved()).isEqualTo(circuit('XY~//'));
    assertThat(circuit('XY~//').withUncoveredColumnsRemoved()).isEqualTo(circuit('XY~//'));
    assertThat(circuit('XY~/').withUncoveredColumnsRemoved()).isEqualTo(circuit('XY~/'));
    assertThat(circuit('XY~').withUncoveredColumnsRemoved()).isEqualTo(circuit('XY~'));
    assertThat(circuit("-----\n                        --~//").withUncoveredColumnsRemoved()).isEqualTo(circuit("---\n                                                                                  ~//"));
    assertThat(circuit("--#/-\n                        --//-").withUncoveredColumnsRemoved()).isEqualTo(circuit("#/\n                                                                                  //"));
  });
  suite.test("withWireCount", function() {
    assertThat(circuit('---').withWireCount(1)).isEqualTo(circuit('---'));
    assertThat(circuit('-X-').withWireCount(2)).isEqualTo(circuit("-X-\n                                                                   ---"));
    assertThat(circuit('-XY').withWireCount(4)).isEqualTo(circuit("-XY\n                                                                   ---\n                                                                   ---\n                                                                   ---"));
    assertThat(circuit("-XY\n                        Zt!\n                        MMX").withWireCount(4)).isEqualTo(circuit("-XY\n                                                                   Zt!\n                                                                   MMX\n                                                                   ---"));
    assertThat(circuit("-XY\n                        Zt!\n                        MMX").withWireCount(3)).isEqualTo(circuit("-XY\n                                                                   Zt!\n                                                                   MMX"));
    assertThat(circuit("-XY\n                        Zt!\n                        MMX").withWireCount(2)).isEqualTo(circuit("-XY\n                                                                   Zt!"));
    assertThat(circuit("-XY\n                        Zt!\n                        MMX").withWireCount(1)).isEqualTo(circuit("-XY"));
  });
  suite.test("minimumRequiredWireCount", function() {
    assertThat(circuit('---').minimumRequiredWireCount()).isEqualTo(1);
    assertThat(circuit('-X-').minimumRequiredWireCount()).isEqualTo(1);
    assertThat(circuit("-X-\n                        ---").minimumRequiredWireCount()).isEqualTo(1);
    assertThat(circuit("---\n                        -X-").minimumRequiredWireCount()).isEqualTo(2);
    assertThat(circuit("-Y-\n                        --X").minimumRequiredWireCount()).isEqualTo(2);
    assertThat(circuit("-Y-\n                        --2").minimumRequiredWireCount()).isEqualTo(3);
    assertThat(circuit("-Y-\n                        --3").minimumRequiredWireCount()).isEqualTo(4);
    assertThat(circuit("-Y-\n                        --#").minimumRequiredWireCount()).isEqualTo(3);
    assertThat(circuit("-Y-\n                        --~").minimumRequiredWireCount()).isEqualTo(2);
    assertThat(circuit("-#-\n                        --X").minimumRequiredWireCount()).isEqualTo(2);
    assertThat(circuit("-#-\n                        ---\n                        ---").minimumRequiredWireCount()).isEqualTo(2);
  });
  suite.test("minimumRequiredColCount", function() {
    assertThat(circuit('---').minimumRequiredColCount()).isEqualTo(0);
    assertThat(circuit('X--').minimumRequiredColCount()).isEqualTo(1);
    assertThat(circuit('-X-').minimumRequiredColCount()).isEqualTo(2);
    assertThat(circuit('--X').minimumRequiredColCount()).isEqualTo(3);
    assertThat(circuit("-X-\n                        ---").minimumRequiredColCount()).isEqualTo(2);
    assertThat(circuit("---\n                        -X-").minimumRequiredColCount()).isEqualTo(2);
    assertThat(circuit("-Y-\n                        --X").minimumRequiredColCount()).isEqualTo(3);
    assertThat(circuit("-Y-\n                        --2").minimumRequiredColCount()).isEqualTo(3);
    assertThat(circuit("-Y-\n                        --3").minimumRequiredColCount()).isEqualTo(3);
    assertThat(circuit("-Y-\n                        --#").minimumRequiredColCount()).isEqualTo(4);
    assertThat(circuit("-Y-\n                        --~").minimumRequiredColCount()).isEqualTo(5);
    assertThat(circuit("-#-\n                        --X").minimumRequiredColCount()).isEqualTo(3);
    assertThat(circuit("-#-\n                        ---").minimumRequiredColCount()).isEqualTo(3);
  });
  suite.test("colIsMeasuredMask", function() {
    var assertAbout = function(diagram) {
      for (var extraGates = [],
          $__9 = 1; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 1] = arguments[$__9];
      var c = circuit.apply((void 0), $traceurRuntime.spread([diagram, ['D', Gates.Detectors.ZDetector], ['R', Gates.Detectors.ZDetectControlClear]], extraGates));
      return assertThat(Seq.range(c.columns.length + 3).map(function(i) {
        return c.colIsMeasuredMask(i - 1);
      }).toArray());
    };
    assertAbout('M').isEqualTo([0, 0, 1, 1]);
    assertAbout("-M---\n                 ---M-\n                 --M--").isEqualTo([0, 0, 0, 1, 5, 7, 7, 7]);
    assertAbout('-').isEqualTo([0, 0, 0, 0]);
    assertAbout('XYZt!D%').isEqualTo([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    assertAbout('MM').isEqualTo([0, 0, 1, 1, 1]);
    assertAbout("M!").isEqualTo([0, 0, 1, 0, 0]);
    assertAbout("MD").isEqualTo([0, 0, 1, 0, 0]);
    assertAbout("MR").isEqualTo([0, 0, 1, 0, 0]);
    assertAbout("MR\n                 -X").isEqualTo([0, 0, 1, 0, 0]);
    assertAbout("MD\n                 -●").isEqualTo([0, 0, 1, 1, 1]);
    assertAbout("MD\n                 M●").isEqualTo([0, 0, 3, 3, 3]);
    assertAbout("---s=\n                 -M=s-").isEqualTo([0, 0, 0, 2, 2, 1, 1, 1]);
    assertAbout("---↡=↡-\n                 ---/-/=\n                 -M=/-/-", ['↡', Gates.CycleBitsGates.CycleBitsFamily]).isEqualTo([0, 0, 0, 4, 4, 1, 1, 2, 2, 2]);
    assertAbout("---R=R-\n                 ---/-/-\n                 -M=/-/=", ['R', Gates.ReverseBitsGateFamily]).isEqualTo([0, 0, 0, 4, 4, 1, 1, 4, 4, 4]);
    assertAbout("●\n                 M").isEqualTo([0, 0, 0, 0]);
    assertAbout("-s\n                 Ms\n                 -●").isEqualTo([0, 0, 2, 2, 2]);
    assertAbout("-s\n                 Ms\n                 M●").isEqualTo([0, 0, 6, 6, 6]);
    assertAbout("-s\n                 -s\n                 M●").isEqualTo([0, 0, 4, 4, 4]);
    assertAbout("M!\n                 -●").isEqualTo([0, 0, 1, 1, 1]);
    assertAbout("M!\n                 M●").isEqualTo([0, 0, 3, 3, 3]);
  });
  suite.test("colDesiredSingleQubitStatsMask", function() {
    var assertAbout = function(diagram) {
      for (var extraGates = [],
          $__9 = 1; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 1] = arguments[$__9];
      var c = circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates));
      return assertThat(Seq.range(c.columns.length + 3).map(function(i) {
        return c.colDesiredSingleQubitStatsMask(i - 1);
      }).toArray());
    };
    assertAbout('XYZH●○M%D?@s!-#~23t', ['?', Gates.Displays.DensityMatrixDisplay2]).isEqualTo([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    assertAbout('%D@').isEqualTo([0, 1, 1, 1, 0, 0]);
    assertAbout("---%--\n                 %--%-!\n                 --D%--\n                 -@-%--").isEqualTo([0, 2, 8, 4, 15, 0, 0, 0, 0]);
  });
  suite.test("nonUnitaryGates", function() {
    var c = circuit("-M-●-\n                     --!--\n                     ---X-");
    assertFalse(c.hasOnlyUnitaryGates());
    assertThat(c.columns[0].indexOfNonUnitaryGate()).isEqualTo(undefined);
    assertThat(c.columns[1].indexOfNonUnitaryGate()).isEqualTo(undefined);
    assertThat(c.columns[2].indexOfNonUnitaryGate()).isEqualTo(1);
    assertThat(c.columns[3].indexOfNonUnitaryGate()).isEqualTo(undefined);
    assertThat(c.columns[4].indexOfNonUnitaryGate()).isEqualTo(undefined);
  });
  suite.test("locIsMeasured", function() {
    var c = circuit("-M---\n                     ---M-\n                     --M--");
    assertFalse(c.locIsMeasured(new Point(100, 100)));
    assertTrue(c.locIsMeasured(new Point(100, 0)));
    assertFalse(c.locIsMeasured(new Point(100, -100)));
    assertFalse(c.locIsMeasured(new Point(-100, 100)));
    assertFalse(c.locIsMeasured(new Point(-100, 0)));
    assertFalse(c.locIsMeasured(new Point(-100, -100)));
    assertFalse(c.locIsMeasured(new Point(0, -100)));
    assertFalse(c.locIsMeasured(new Point(1, 0)));
    assertTrue(c.locIsMeasured(new Point(2, 0)));
    assertFalse(c.locIsMeasured(new Point(3, 1)));
    assertTrue(c.locIsMeasured(new Point(4, 1)));
  });
  suite.test("gateInSlot", function() {
    var c = circuit("ZXY--\n                     -#/%-\n                     -//●-");
    assertThat(c.gateInSlot(-10, 0)).isEqualTo(undefined);
    assertThat(c.gateInSlot(+10, 0)).isEqualTo(undefined);
    assertThat(c.gateInSlot(0, -10)).isEqualTo(undefined);
    assertThat(c.gateInSlot(0, +10)).isEqualTo(undefined);
    assertThat(c.gateInSlot(0, 0)).isEqualTo(Z);
    assertThat(c.gateInSlot(1, 0)).isEqualTo(X);
    assertThat(c.gateInSlot(2, 0)).isEqualTo(Y);
    assertThat(c.gateInSlot(3, 0)).isEqualTo(undefined);
    assertThat(c.gateInSlot(0, 1)).isEqualTo(undefined);
    assertThat(c.gateInSlot(1, 1)).isEqualTo(TEST_GATES.get('#'));
    assertThat(c.gateInSlot(2, 1)).isEqualTo(undefined);
    assertThat(c.gateInSlot(3, 1)).isEqualTo(Gates.Displays.ChanceDisplay);
    assertThat(c.gateInSlot(0, 2)).isEqualTo(undefined);
    assertThat(c.gateInSlot(1, 2)).isEqualTo(undefined);
    assertThat(c.gateInSlot(2, 2)).isEqualTo(undefined);
    assertThat(c.gateInSlot(3, 2)).isEqualTo(Gates.Controls.Control);
  });
  suite.test("findGateCoveringSlot", function() {
    var c = circuit("ZXY--\n                     -#/%-\n                     -//●-");
    assertThat(c.findGateCoveringSlot(-10, 0)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(+10, 0)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(0, -10)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(0, +10)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(0, 0)).isEqualTo({
      col: 0,
      row: 0,
      gate: Z
    });
    assertThat(c.findGateCoveringSlot(1, 0)).isEqualTo({
      col: 1,
      row: 0,
      gate: X
    });
    assertThat(c.findGateCoveringSlot(2, 0)).isEqualTo({
      col: 2,
      row: 0,
      gate: Y
    });
    assertThat(c.findGateCoveringSlot(3, 0)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(0, 1)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(1, 1)).isEqualTo({
      col: 1,
      row: 1,
      gate: TEST_GATES.get('#')
    });
    assertThat(c.findGateCoveringSlot(2, 1)).isEqualTo({
      col: 1,
      row: 1,
      gate: TEST_GATES.get('#')
    });
    assertThat(c.findGateCoveringSlot(3, 1)).isEqualTo({
      col: 3,
      row: 1,
      gate: Gates.Displays.ChanceDisplay
    });
    assertThat(c.findGateCoveringSlot(0, 2)).isEqualTo(undefined);
    assertThat(c.findGateCoveringSlot(1, 2)).isEqualTo({
      col: 1,
      row: 1,
      gate: TEST_GATES.get('#')
    });
    assertThat(c.findGateCoveringSlot(2, 2)).isEqualTo({
      col: 1,
      row: 1,
      gate: TEST_GATES.get('#')
    });
    assertThat(c.findGateCoveringSlot(3, 2)).isEqualTo({
      col: 3,
      row: 2,
      gate: Gates.Controls.Control
    });
    assertThat(circuit('#X\nYZ').findGateCoveringSlot(1, 0)).isEqualTo({
      col: 1,
      row: 0,
      gate: X
    });
    assertThat(circuit('#X\nYZ').findGateCoveringSlot(0, 1)).isEqualTo({
      col: 0,
      row: 1,
      gate: Y
    });
    assertThat(circuit('#X\nYZ').findGateCoveringSlot(1, 1)).isEqualTo({
      col: 1,
      row: 1,
      gate: Z
    });
  });
  suite.test("colControls", function() {
    var c = circuit("-●-○-⊖⊗⊕-M-⊕⊗⊖-○-●-");
    assertThat(c.colControls(-1)).isEqualTo(Controls.NONE);
    assertThat(c.colControls(0)).isEqualTo(Controls.NONE);
    assertThat(c.colControls(1)).isEqualTo(Controls.bit(0, true));
    assertThat(c.colControls(3)).isEqualTo(Controls.bit(0, false));
    assertThat(c.colControls(5)).isEqualTo(Controls.bit(0, true));
    assertThat(c.colControls(6)).isEqualTo(Controls.bit(0, false));
    assertThat(c.colControls(7)).isEqualTo(Controls.bit(0, false));
    assertThat(c.colControls(9)).isEqualTo(Controls.NONE);
    assertThat(c.colControls(11)).isEqualTo(Controls.NONE);
    assertThat(c.colControls(12)).isEqualTo(Controls.NONE);
    assertThat(c.colControls(13)).isEqualTo(Controls.NONE);
    assertThat(c.colControls(15)).isEqualTo(Controls.bit(0, false));
    assertThat(c.colControls(17)).isEqualTo(Controls.bit(0, true));
    assertThat(c.colControls(102)).isEqualTo(Controls.NONE);
    var c2 = circuit("--●○○-P-\n                      -X○●s-P-\n                      ---s●-X-", ['P', Gates.Controls.ZParityControl]);
    assertThat(c2.colControls(0)).isEqualTo(Controls.NONE);
    assertThat(c2.colControls(1)).isEqualTo(Controls.NONE);
    assertThat(c2.colControls(2)).isEqualTo(new Controls(3, 1));
    assertThat(c2.colControls(3)).isEqualTo(new Controls(3, 2));
    assertThat(c2.colControls(4)).isEqualTo(new Controls(5, 4));
    assertThat(c2.colControls(5)).isEqualTo(Controls.NONE);
    assertThat(c2.colControls(6)).isEqualTo(new Controls(1, 1, 3));
    assertThat(c2.colControls(7)).isEqualTo(Controls.NONE);
  });
  suite.test("locIsControlWireStarter", function() {
    var c = circuit("Z●Y--\n                     -#/%○\n                     -/○●-");
    assertFalse(c.locIsControlWireStarter(new Point(-10, 0)));
    assertFalse(c.locIsControlWireStarter(new Point(+10, 0)));
    assertFalse(c.locIsControlWireStarter(new Point(0, -10)));
    assertFalse(c.locIsControlWireStarter(new Point(0, +10)));
    assertFalse(c.locIsControlWireStarter(new Point(0, 0)));
    assertTrue(c.locIsControlWireStarter(new Point(1, 0)));
    assertFalse(c.locIsControlWireStarter(new Point(2, 0)));
    assertFalse(c.locIsControlWireStarter(new Point(3, 0)));
    assertFalse(c.locIsControlWireStarter(new Point(4, 0)));
    assertFalse(c.locIsControlWireStarter(new Point(0, 1)));
    assertFalse(c.locIsControlWireStarter(new Point(1, 1)));
    assertFalse(c.locIsControlWireStarter(new Point(2, 1)));
    assertFalse(c.locIsControlWireStarter(new Point(3, 1)));
    assertTrue(c.locIsControlWireStarter(new Point(4, 1)));
    assertFalse(c.locIsControlWireStarter(new Point(0, 2)));
    assertFalse(c.locIsControlWireStarter(new Point(1, 2)));
    assertTrue(c.locIsControlWireStarter(new Point(2, 2)));
    assertTrue(c.locIsControlWireStarter(new Point(3, 2)));
    assertFalse(c.locIsControlWireStarter(new Point(4, 2)));
  });
  suite.test("locStartsSingleControlWire", function() {
    var c = circuit("-M-●-\n                     -M-○-\n                     ---●-\n                     ---○-\n                     ---X-");
    assertFalse(c.locStartsSingleControlWire(new Point(-10, 0)));
    assertFalse(c.locStartsSingleControlWire(new Point(+10, 0)));
    assertFalse(c.locStartsSingleControlWire(new Point(0, -10)));
    assertFalse(c.locStartsSingleControlWire(new Point(0, +10)));
    assertFalse(c.locStartsSingleControlWire(new Point(3, 0)));
    assertFalse(c.locStartsSingleControlWire(new Point(3, 1)));
    assertTrue(c.locStartsSingleControlWire(new Point(3, 2)));
    assertTrue(c.locStartsSingleControlWire(new Point(3, 3)));
    assertFalse(c.locStartsSingleControlWire(new Point(3, 4)));
    assertFalse(c.locStartsSingleControlWire(new Point(2, 3)));
    assertFalse(c.locStartsSingleControlWire(new Point(4, 3)));
  });
  suite.test("locStartsDoubleControlWire", function() {
    var c = circuit("-M-●-\n                     -M-○-\n                     ---●-\n                     ---○-\n                     ---X-");
    assertFalse(c.locStartsDoubleControlWire(new Point(-10, 0)));
    assertFalse(c.locStartsDoubleControlWire(new Point(+10, 0)));
    assertFalse(c.locStartsDoubleControlWire(new Point(0, -10)));
    assertFalse(c.locStartsDoubleControlWire(new Point(0, +10)));
    assertTrue(c.locStartsDoubleControlWire(new Point(3, 0)));
    assertTrue(c.locStartsDoubleControlWire(new Point(3, 1)));
    assertFalse(c.locStartsDoubleControlWire(new Point(3, 2)));
    assertFalse(c.locStartsDoubleControlWire(new Point(3, 3)));
    assertFalse(c.locStartsDoubleControlWire(new Point(3, 4)));
    assertFalse(c.locStartsDoubleControlWire(new Point(2, 1)));
    assertFalse(c.locStartsDoubleControlWire(new Point(4, 1)));
  });
  suite.test("colGetEnabledSwapGate", function() {
    var c = circuit("-s-●-s-●-●\n                     --ss---sMs\n                     --X-ss-s-s\n                     ----s-----\n                     -----s----");
    assertThat(c.colGetEnabledSwapGate(-1)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(0)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(1)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(2)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(3)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(5)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(6)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(8)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(9)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(10)).isEqualTo(undefined);
    assertThat(c.colGetEnabledSwapGate(4)).isEqualTo([2, 3]);
    assertThat(c.colGetEnabledSwapGate(7)).isEqualTo([1, 2]);
  });
  suite.test("locHasControllableGate", function() {
    var c = circuit("●H-M-H-X-----\n                     -%-.--s------\n                     ------s-s----");
    assertFalse(c.locHasControllableGate(new Point(-100, 0)));
    assertFalse(c.locHasControllableGate(new Point(+100, 0)));
    assertFalse(c.locHasControllableGate(new Point(0, -100)));
    assertFalse(c.locHasControllableGate(new Point(0, +100)));
    assertFalse(c.locHasControllableGate(new Point(2, 0)));
    assertTrue(c.locHasControllableGate(new Point(1, 0)));
    assertTrue(c.locHasControllableGate(new Point(1, 1)));
    assertTrue(c.locHasControllableGate(new Point(7, 0)));
    assertTrue(c.locHasControllableGate(new Point(6, 1)));
    assertTrue(c.locHasControllableGate(new Point(6, 2)));
    assertTrue(c.locHasControllableGate(new Point(3, 0)));
    assertTrue(c.locHasControllableGate(new Point(5, 0)));
    assertFalse(c.locHasControllableGate(new Point(3, 1)));
    assertFalse(c.locHasControllableGate(new Point(0, 0)));
    assertTrue(c.locHasControllableGate(new Point(8, 2)));
  });
  suite.test("colHasControls", function() {
    var c = circuit("-●-●----\n                     M-○-X-●-\n                     ---○----");
    assertFalse(c.colHasControls(-1));
    assertFalse(c.colHasControls(0));
    assertTrue(c.colHasControls(1));
    assertTrue(c.colHasControls(2));
    assertTrue(c.colHasControls(3));
    assertFalse(c.colHasControls(4));
    assertFalse(c.colHasControls(5));
    assertTrue(c.colHasControls(6));
    assertFalse(c.colHasControls(7));
    assertFalse(c.colHasControls(8));
    assertFalse(c.colHasControls(9));
  });
  suite.test("colHasSingleWireControl", function() {
    var c = circuit("-●-●----\n                     M-○-X-●-\n                     ---○----");
    assertFalse(c.colHasSingleWireControl(-1));
    assertFalse(c.colHasSingleWireControl(0));
    assertTrue(c.colHasSingleWireControl(1));
    assertFalse(c.colHasSingleWireControl(2));
    assertTrue(c.colHasSingleWireControl(3));
    assertFalse(c.colHasSingleWireControl(4));
    assertFalse(c.colHasSingleWireControl(5));
    assertFalse(c.colHasSingleWireControl(6));
    assertFalse(c.colHasSingleWireControl(7));
    assertFalse(c.colHasSingleWireControl(8));
    assertFalse(c.colHasSingleWireControl(9));
  });
  suite.test("colHasDoubleWireControl", function() {
    var c = circuit("-●-●----\n                     M-○-X-●-\n                     ---○----");
    assertFalse(c.colHasDoubleWireControl(-1));
    assertFalse(c.colHasDoubleWireControl(0));
    assertFalse(c.colHasDoubleWireControl(1));
    assertTrue(c.colHasDoubleWireControl(2));
    assertFalse(c.colHasDoubleWireControl(3));
    assertFalse(c.colHasDoubleWireControl(4));
    assertFalse(c.colHasDoubleWireControl(5));
    assertTrue(c.colHasDoubleWireControl(6));
    assertFalse(c.colHasDoubleWireControl(7));
    assertFalse(c.colHasDoubleWireControl(8));
    assertFalse(c.colHasDoubleWireControl(9));
  });
  suite.test("gateAtLocIsDisabledReason", function() {
    var bad = function(col, row, diagram) {
      for (var extraGates = [],
          $__9 = 3; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 3] = arguments[$__9];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates)).gateAtLocIsDisabledReason(col, row)).withInfo({diagram: diagram}).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      for (var extraGates = [],
          $__10 = 3; $__10 < arguments.length; $__10++)
        extraGates[$__10 - 3] = arguments[$__10];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates)).gateAtLocIsDisabledReason(col, row)).withInfo({diagram: diagram}).isEqualTo(undefined);
    };
    good(-100, 0, "-");
    good(+100, 0, "-");
    good(0, -100, "-");
    good(0, +100, "-");
    bad(1, 1, "-●-\n               -M-\n               ---");
    good(1, 1, "---\n                -M-\n                ---");
    bad(1, 1, "---\n               -s-\n               ---");
    bad(1, 1, "-s-\n               -s-\n               -s-");
    good(1, 1, "-s-\n                -s-\n                ---");
    bad(1, 1, "-s-\n               Ms-\n               -●-");
    bad(1, 1, "-s-\n               Ms-\n               M●-");
    bad(1, 1, "Ms-\n               Ms-\n               -●-");
    good(1, 1, "-s-\n                -s-\n                -●-");
    good(1, 1, "-s-\n                -s-\n                M●-");
    good(1, 1, "Ms-\n                Ms-\n                M●-");
    bad(1, 1, "---\n               MH-\n               ---");
    good(1, 1, "---\n                -H-\n                ---");
    bad(1, 1, "---\n               MX-\n               -●-");
    good(1, 1, "---\n                MX-\n                M●-");
    good(1, 1, "---\n                MZ-\n                -●-");
    good(1, 1, "---\n                M%-\n                -●-");
    good(1, 1, "---\n                -X-\n                ---");
    bad(1, 1, "---\n               -2-\n               -●-");
    bad(1, 1, "---\n               -?/\n               -○/", ['?', Gates.Displays.DensityMatrixDisplay2]);
    good(1, 1, "---\n               -?●\n               -X○", ['?', Gates.Displays.DensityMatrixDisplay2]);
    good(1, 1, "-●-\n                -<-\n                -/-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    good(1, 1, "M●-\n                -<-\n                -/-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    good(1, 1, "M●-\n                M<-\n                M/-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    bad(1, 1, "M●-\n               M<-\n               -/-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    bad(1, 1, "-●-\n               M<-\n               -/-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    bad(1, 1, "-●-\n               M<-\n               M/-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    bad(1, 0, "MD", ['D', Gates.Detectors.XDetectControlClear]);
    bad(1, 0, "MD", ['D', Gates.Detectors.YDetectControlClear]);
    good(1, 0, "MD", ['D', Gates.Detectors.ZDetectControlClear]);
    bad(1, 0, "MR", ['R', Gates.Detectors.XDetectControlClear]);
    bad(1, 0, "MR", ['R', Gates.Detectors.YDetectControlClear]);
    good(1, 0, "MR", ['R', Gates.Detectors.ZDetectControlClear]);
    good(3, 1, "---]-\n                -M-X-", [']', Gates.Detectors.XDetectControlClear]);
    good(3, 1, "---]-\n                -M-X-", [']', Gates.Detectors.YDetectControlClear]);
    good(3, 1, "---]-\n                -M-X-", [']', Gates.Detectors.ZDetectControlClear]);
    good(2, 0, "--P-\n                --/-\n                --/-\n                --/-\n                H-●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    good(2, 0, "-MP-\n                --/-\n                --/-\n                -M/-\n                H-●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    good(2, 0, "--P-\n                --/-\n                --/-\n                -M/-\n                HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    good(2, 0, "-MP-\n                --/-\n                --/-\n                -M/-\n                HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    good(2, 0, "--P-\n                -M/-\n                -M/-\n                --/-\n                HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    good(2, 0, "-MP-\n                -M/-\n                -M/-\n                -M/-\n                HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    bad(2, 0, "--P-\n               -M/-\n               -M/-\n               --/-\n               H-●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    bad(2, 0, "--P-\n               -M/-\n               --/-\n               --/-\n               HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    good(2, 0, "--P-\n                -M/-\n                -M/-\n                --/-\n                -M/-\n                --/-\n                --/-\n                HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
    bad(2, 0, "--P-\n               -M/-\n               --/-\n               -M/-\n               -M/-\n               --/-\n               --/-\n               HM●-", ['P', Gates.InterleaveBitsGates.InterleaveBitsGateFamily]);
  });
  suite.test("gateAtLocIsDisabledReason_controls", function() {
    assertThat(circuit("-●-○-⊖-⊕-M-⊕-⊖-○-●-")).isNotEqualTo(undefined);
    var bad = function(col, row, diagram) {
      return assertThat(circuit(diagram).gateAtLocIsDisabledReason(col, row)).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      return assertThat(circuit(diagram).gateAtLocIsDisabledReason(col, row)).isEqualTo(undefined);
    };
    good(1, 1, "---\n                M●-\n                ---");
    good(1, 1, "---\n                M○-\n                ---");
    bad(1, 1, "---\n               M⊖-\n               ---");
    bad(1, 1, "---\n               M⊕-\n               ---");
    good(1, 1, "---\n                -●M\n                ---");
    good(1, 1, "---\n                -○M\n                ---");
    good(1, 1, "---\n                -⊖M\n                ---");
    good(1, 1, "---\n                -⊕M\n                ---");
  });
  suite.test("gateAtLocIsDisabledReason_tagCollision", function() {
    var bad = function(col, row, diagram) {
      for (var extraGates = [],
          $__9 = 3; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 3] = arguments[$__9];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates)).gateAtLocIsDisabledReason(col, row)).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      for (var extraGates = [],
          $__10 = 3; $__10 < arguments.length; $__10++)
        extraGates[$__10 - 3] = arguments[$__10];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates)).gateAtLocIsDisabledReason(col, row)).isEqualTo(undefined);
    };
    good(1, 1, "---\n                -A-\n                ---");
    good(1, 1, "---\n                AA-\n                ---");
    good(1, 1, "---\n                -A-\n                -A-");
    bad(1, 1, "-A-\n               -A-\n               ---");
    bad(1, 1, "-A-\n               -?-\n               -#-", ['?', Gates.InputGates.InputAFamily.ofSize(2)]);
    bad(1, 1, "-B-\n               -B-\n               ---");
    good(1, 1, "-B-\n                -A-\n                ---");
  });
  suite.test("gateAtLocIsDisabledReason_needInput", function() {
    var ownExtraGates = [['*', Gates.MultiplyAccumulateGates.MultiplyAddInputsFamily], ['⩲', Gates.Arithmetic.PlusAFamily], ['⨧', Gates.Arithmetic.PlusAFamily.ofSize(2)], ['?', Gates.InputGates.InputAFamily.ofSize(2)]];
    var bad = function(col, row, diagram) {
      for (var extraGates = [],
          $__9 = 3; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 3] = arguments[$__9];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], ownExtraGates, extraGates)).gateAtLocIsDisabledReason(col, row)).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      for (var extraGates = [],
          $__10 = 3; $__10 < arguments.length; $__10++)
        extraGates[$__10 - 3] = arguments[$__10];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], ownExtraGates, extraGates)).gateAtLocIsDisabledReason(col, row)).isEqualTo(undefined);
    };
    good(1, 1, "---\n                -X-\n                ---");
    bad(1, 1, "---\n               -⩲-\n               ---");
    bad(1, 1, "-B-\n               -⩲-\n               ---");
    good(1, 1, "-A-\n                -⩲-\n                ---");
    good(1, 1, "-A-\n                -⩲-\n                -A-");
    bad(1, 1, "---\n               -⨧-\n               -#-");
    good(1, 1, "-A-\n                -⨧-\n                -#-");
    bad(1, 1, "-?-\n               -⨧-\n               -#-");
    bad(1, 1, "---\n               -*-\n               ---");
    bad(1, 1, "-A-\n               -*-\n               ---");
    bad(1, 1, "-B-\n               -*-\n               ---");
    good(1, 1, "-A-\n                -*-\n                -B-");
  });
  suite.test("gateAtLocIsDisabledReason_tagWithWrongCoherence", function() {
    var ownExtraGates = [['*', Gates.MultiplyAccumulateGates.MultiplyAddInputsFamily], ['⩲', Gates.Arithmetic.PlusAFamily], ['⨧', Gates.Arithmetic.PlusAFamily.ofSize(2)], ['?', Gates.InputGates.InputAFamily.ofSize(2)]];
    var bad = function(col, row, diagram) {
      for (var extraGates = [],
          $__9 = 3; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 3] = arguments[$__9];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], ownExtraGates, extraGates)).gateAtLocIsDisabledReason(col, row)).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      for (var extraGates = [],
          $__10 = 3; $__10 < arguments.length; $__10++)
        extraGates[$__10 - 3] = arguments[$__10];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], ownExtraGates, extraGates)).gateAtLocIsDisabledReason(col, row)).isEqualTo(undefined);
    };
    good(3, 1, "---A-\n                ---⩲-\n                -----");
    good(3, 1, "-M-A-\n                ---⩲-\n                -----");
    bad(3, 1, "---A-\n               -M-⩲-\n               -----");
    good(3, 1, "-M-A-\n                -M-⩲-\n                -----");
    good(3, 2, "---?-\n                ---#-\n                ---⨧-\n                ---#-");
    good(3, 2, "---?-\n                -M-#-\n                ---⨧-\n                ---#-");
    bad(3, 2, "---?-\n               ---#-\n               -M-⨧-\n               ---#-");
    bad(3, 2, "---?-\n               ---#-\n               ---⨧-\n               -M-#-");
    bad(3, 2, "---?-\n               ---#-\n               -M-⨧-\n               -M-#-");
    good(3, 2, "-M-?-\n                -M-#-\n                ---⨧-\n                ---#-");
    good(3, 2, "-M-?-\n                -M-#-\n                -M-⨧-\n                -M-#-");
    good(3, 1, "---A-\n                ---*-\n                ---B-");
    good(3, 1, "-M-A-\n                ---*-\n                ---B-");
    good(3, 1, "---A-\n                ---*-\n                -M-B-");
    good(3, 1, "-M-A-\n                ---*-\n                -M-B-");
    bad(3, 1, "---A-\n               -M-*-\n               ---B-");
    bad(3, 1, "-M-A-\n               -M-*-\n               ---B-");
    bad(3, 1, "---A-\n               -M-*-\n               -M-B-");
    good(3, 1, "-M-A-\n                -M-*-\n                -M-B-");
  });
  suite.test("getUnmetContextKeys", function() {
    var ownExtraGates = [['⩲', Gates.Arithmetic.PlusAFamily], ['*', Gates.MultiplyAccumulateGates.MultiplyAddInputsFamily], ['x', Gates.ParametrizedRotationGates.XToA], ['a', Gates.InputGates.SetA]];
    var query = function(diagram) {
      for (var extraGates = [],
          $__9 = 1; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 1] = arguments[$__9];
      return circuit.apply((void 0), $traceurRuntime.spread([diagram], ownExtraGates, extraGates)).getUnmetContextKeys();
    };
    assertThat(query("---\n                      -Y-")).isEqualTo(new Set());
    assertThat(query("-A-\n                      -x-")).isEqualTo(new Set());
    assertThat(query("-A-\n                      -⩲-")).isEqualTo(new Set());
    assertThat(query("a--\n                      -⩲-")).isEqualTo(new Set());
    assertThat(query("---\n                      -⩲-")).isEqualTo(new Set(['Input Range A']));
    assertThat(query("---\n                      -*-")).isEqualTo(new Set(['Input Range A', 'Input Range B']));
    assertThat(query("-A-\n                      -*-")).isEqualTo(new Set(['Input Range B']));
    assertThat(query("aB-\n                      -*-")).isEqualTo(new Set());
    assertThat(query("---\n                      -x-")).isEqualTo(new Set(['Input NO_DEFAULT Range A']));
    assertThat(query("a--\n                      -x-")).isEqualTo(new Set(['Input NO_DEFAULT Range A']));
  });
  suite.test("gateAtLocIsDisabledReason_multiwireOperations", function() {
    var bad = function(col, row, diagram) {
      for (var extraGates = [],
          $__9 = 3; $__9 < arguments.length; $__9++)
        extraGates[$__9 - 3] = arguments[$__9];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates)).gateAtLocIsDisabledReason(col, row)).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      for (var extraGates = [],
          $__10 = 3; $__10 < arguments.length; $__10++)
        extraGates[$__10 - 3] = arguments[$__10];
      return assertThat(circuit.apply((void 0), $traceurRuntime.spread([diagram], extraGates)).gateAtLocIsDisabledReason(col, row)).isEqualTo(undefined);
    };
    bad(1, 1, "---\n               M2-\n               -/-");
    bad(1, 1, "---\n               -2-\n               M/-");
    bad(1, 1, "-●-\n               M2-\n               M/-");
    bad(1, 1, "---\n               MQ-\n               M/-");
    good(1, 1, "---\n                -Q-\n                -/-");
    good(1, 1, "---\n                -2-\n                -/-");
    good(1, 1, "---\n                M2-\n                M/-");
    good(1, 1, "-●-\n                MD/\n                M//");
  });
  suite.test("withSwitchedInitialStateOn", function() {
    var c = circuit("-\n                     -");
    assertThat(c.customInitialValues).isEqualTo(new Map());
    c = c.withSwitchedInitialStateOn(0);
    assertThat(c.customInitialValues).isEqualTo(new Map([[0, '1']]));
    c = c.withSwitchedInitialStateOn(0);
    assertThat(c.customInitialValues).isEqualTo(new Map([[0, '+']]));
    c = c.withSwitchedInitialStateOn(0, 0);
    assertThat(c.customInitialValues).isEqualTo(new Map());
  });
  suite.test("colCustomContextFromGates", function() {
    var c = circuit("-A-B-\n                     -A-A-\n                     --X--");
    assertThat(c.colCustomContextFromGates(-10, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(0, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(1, 0)).isEqualTo(new Map([["Input Range A", {
      offset: 0,
      length: 1
    }]]));
    assertThat(c.colCustomContextFromGates(2, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(3, 0)).isEqualTo(new Map([["Input Range A", {
      offset: 1,
      length: 1
    }], ["Input Range B", {
      offset: 0,
      length: 1
    }]]));
    assertThat(c.colCustomContextFromGates(3, 10)).isEqualTo(new Map([["Input Range A", {
      offset: 11,
      length: 1
    }], ["Input Range B", {
      offset: 10,
      length: 1
    }]]));
    assertThat(c.colCustomContextFromGates(4, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(4, 10)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(5, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(100, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(Infinity, 0)).isEqualTo(new Map());
    assertThat(c.colCustomContextFromGates(Infinity, 1)).isEqualTo(new Map());
  });
  suite.test("isSlotRectCoveredByGateInSameColumn", function() {
    assertFalse(circuit("-\n                         -\n                         -").isSlotRectCoveredByGateInSameColumn(0, 0, 2));
    assertTrue(circuit("X\n                        -\n                        -").isSlotRectCoveredByGateInSameColumn(0, 0, 2));
    assertFalse(circuit("X\n                         -\n                         -").isSlotRectCoveredByGateInSameColumn(0, 1, 2));
    assertTrue(circuit("-\n                        X\n                        -").isSlotRectCoveredByGateInSameColumn(0, 0, 2));
    assertFalse(circuit("-\n                         X\n                         -").isSlotRectCoveredByGateInSameColumn(0, 0, 1));
    assertTrue(circuit("2\n                        /\n                        -").isSlotRectCoveredByGateInSameColumn(0, 1, 1));
  });
  suite.test("controlLineRanges", function() {
    assertControlLinesMatchDiagram("-●-X-●-X-M=●=\n                                         | |   ║\n                                    -●-X-X-●---X-");
    assertControlLinesMatchDiagram("---●-X-\n                                       | ┃\n                                    ---X-●-\n                                       ║ ║\n                                    -M-●=●=");
    assertControlLinesMatchDiagram("-s-s-s-s-s---s===s=\n                                       | |   |   |   ┃\n                                    ---s-+-s-s-M=s-M=s=\n                                         |   |       ║\n                                    -----s-s-●-----M=●=");
    assertControlLinesMatchDiagram("-A-A-A-A---A-P-P-P-\n                                       | | |   | ┃ ┃ ║\n                                    ---/-P-P---P-A-A-+-\n                                       |   |   ║ ║ ║ ║\n                                    -●-P---●-M=●=●=A=A=", ['P', Gates.Arithmetic.PlusAFamily]);
    var N = circuitDefinitionToGate(circuit("-P-", ['P', Gates.Arithmetic.PlusAFamily]));
    assertControlLinesMatchDiagram("-A-A-A---A-N-\n                                       | |   | ┃\n                                    ---N-N---N-A-\n                                         |   ║ ║\n                                    -●---●-M=●=●=", ['N', N]);
    var I = circuitDefinitionToGate(circuit("-A-"));
    assertControlLinesMatchDiagram("-I-I-I---I-P-\n                                     |   |   ║ ║\n                                    -+-P-P---P-I-\n                                     |   |   ║ ║\n                                    -●---●-M=●=●=", ['P', Gates.Arithmetic.PlusAFamily], ['I', I]);
    var customIdentityGate = Serializer.fromJson(Gate, {
      id: "~stay",
      name: "id",
      matrix: "{{1,0},{0,1}}"
    });
    var customOtherGate = Serializer.fromJson(Gate, {
      id: "~jump",
      name: "id",
      matrix: "{{1,0},{0,i}}"
    });
    assertControlLinesMatchDiagram("-I-J-\n                                       |\n                                    -●-●-", ['I', customIdentityGate], ['J', customOtherGate]);
  });
  function assertControlLinesMatchDiagram(diagram) {
    for (var extraGates = [],
        $__9 = 1; $__9 < arguments.length; $__9++)
      extraGates[$__9 - 1] = arguments[$__9];
    var lines = diagram.split('\n');
    var indentation = lines[2].search(/\S/);
    var c = circuit.apply((void 0), $traceurRuntime.spread([seq(lines).stride(2).join('\n')], extraGates));
    var controlLines = seq(lines).skip(1).stride(2).map(function(e) {
      return e.substring(indentation);
    }).map(function(e) {
      return seq(e).map(function(c) {
        return c === '┃' ? 3 : c === '║' ? 2 : c === '|' || c === '│' ? 1 : 0;
      }).padded(c.columns.length, 0).toArray();
    }).toArray();
    for (var col = 0; col < c.columns.length; col++) {
      var diagramColControlLines = new Array(c.numWires - 1).fill(0);
      var $__4 = true;
      var $__5 = false;
      var $__6 = undefined;
      try {
        for (var $__2 = void 0,
            $__1 = (c.controlLinesRanges(col))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
          var $__11 = $__2.value,
              first = $__11.first,
              last = $__11.last,
              measured = $__11.measured;
          {
            for (var i = first; i < last; i++) {
              diagramColControlLines[i] |= measured ? 2 : 1;
            }
          }
        }
      } catch ($__7) {
        $__5 = true;
        $__6 = $__7;
      } finally {
        try {
          if (!$__4 && $__1.return != null) {
            $__1.return();
          }
        } finally {
          if ($__5) {
            throw $__6;
          }
        }
      }
      for (var row = 0; row < c.numWires - 1; row++) {
        assertThat(controlLines[row][col]).withInfo({
          col: col,
          row: row,
          diagram: diagram
        }).isEqualTo(diagramColControlLines[row]);
      }
    }
  }
  return {};
});
//# sourceURL=test/circuit/CircuitDefinition.test.js
;$traceurRuntime.registerModule("test/circuit/CircuitShaders.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/CircuitShaders.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/CircuitShaders.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var assertThatCircuitShaderActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/circuit/CircuitShaders.test.js")).assertThatCircuitShaderActsLikeMatrix;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitShaders.js", "test/circuit/CircuitShaders.test.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/circuit/CircuitShaders.test.js")).Controls;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/circuit/CircuitShaders.test.js")).Seq;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/circuit/CircuitShaders.test.js")).Shaders;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/CircuitShaders.test.js")).Matrix;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/circuit/CircuitShaders.test.js")),
      Outputs = $__7.Outputs,
      makePseudoShaderWithInputsAndOutputAndCode = $__7.makePseudoShaderWithInputsAndOutputAndCode;
  var suite = new Suite("CircuitShaders");
  suite.testUsingWebGL("classicalState", function() {
    assertThat(CircuitShaders.classicalState(0).readVec2OutputsAsKet(2)).isEqualTo(Matrix.col(1, 0, 0, 0));
    assertThat(CircuitShaders.classicalState(1).readVec2OutputsAsKet(2)).isEqualTo(Matrix.col(0, 1, 0, 0));
    assertThat(CircuitShaders.classicalState(2).readVec2OutputsAsKet(2)).isEqualTo(Matrix.col(0, 0, 1, 0));
    assertThat(CircuitShaders.classicalState(3).readVec2OutputsAsKet(2)).isEqualTo(Matrix.col(0, 0, 0, 1));
    assertThat(CircuitShaders.classicalState(0).readVec2OutputsAsKet(3)).isEqualTo(Matrix.col(1, 0, 0, 0, 0, 0, 0, 0));
    assertThat(CircuitShaders.classicalState(5).readVec2OutputsAsKet(3)).isEqualTo(Matrix.col(0, 0, 0, 0, 0, 1, 0, 0));
  });
  suite.testUsingWebGL("linearOverlay", function() {
    var fore = Shaders.vec4Data(new Float32Array(Seq.range(2 * 2 * 4).map(function(e) {
      return e + 900;
    }).toArray())).toVec4Texture(2);
    var back = Shaders.vec4Data(new Float32Array(Seq.range(4 * 4 * 4).map(function(e) {
      return -e;
    }).toArray())).toVec4Texture(4);
    assertThat(CircuitShaders.linearOverlay(0, fore, back).readVec4Outputs(4)).isEqualTo(new Float32Array([900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63]));
    assertThat(CircuitShaders.linearOverlay(1, fore, back).readVec4Outputs(4)).isEqualTo(new Float32Array([-0, -1, -2, -3, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63]));
    assertThat(CircuitShaders.linearOverlay(2, fore, back).readVec4Outputs(4)).isEqualTo(new Float32Array([-0, -1, -2, -3, -4, -5, -6, -7, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63]));
    assertThat(CircuitShaders.linearOverlay(4, fore, back).readVec4Outputs(4)).isEqualTo(new Float32Array([-0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63]));
    assertThat(CircuitShaders.linearOverlay(12, fore, back).readVec4Outputs(4)).isEqualTo(new Float32Array([-0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915]));
    assertThat(CircuitShaders.linearOverlay(13, fore, back).readVec4Outputs(4)).isEqualTo(new Float32Array([-0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911]));
    fore.deallocByDepositingInPool();
    back.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("controlMask", function() {
    assertThat(CircuitShaders.controlMask(new Controls(0x3, 0x1)).readBoolOutputs(2)).isEqualTo(new Uint8Array([0, 1, 0, 0]));
    assertThat(CircuitShaders.controlMask(new Controls(0x3, 0x1)).readBoolOutputs(2)).isEqualTo(new Uint8Array([0, 1, 0, 0]));
    assertThat(CircuitShaders.controlMask(new Controls(0x3, 0x0)).readBoolOutputs(2)).isEqualTo(new Uint8Array([1, 0, 0, 0]));
    assertThat(CircuitShaders.controlMask(new Controls(0x1, 0x0)).readBoolOutputs(2)).isEqualTo(new Uint8Array([1, 0, 1, 0]));
    assertThat(CircuitShaders.controlMask(new Controls(0x5, 0x4)).readBoolOutputs(3)).isEqualTo(new Uint8Array([0, 0, 0, 0, 1, 0, 1, 0]));
  });
  suite.testUsingWebGL("controlMask_largeReference", function() {
    var mask = new Controls(95575, 77905);
    var expected = new Uint8Array(Seq.range(1 << 13).map(function(i) {
      return mask.allowsState(i) ? 1 : 0;
    }).toArray());
    assertThat(CircuitShaders.controlMask(mask).readBoolOutputs(13)).isEqualTo(expected);
  });
  suite.testUsingWebGL("controlSelect_simple", function() {
    var coords = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec2(), "\n        vec2 outputFor(float k) {\n            return vec2(mod(k, 4.0), floor(k/4.0));\n        }\n    ")().toVec2Texture(4);
    assertThat(CircuitShaders.controlSelect(Controls.NONE, coords).readVec2Outputs(4)).isEqualTo(new Float32Array([0, 0, 1, 0, 2, 0, 3, 0, 0, 1, 1, 1, 2, 1, 3, 1, 0, 2, 1, 2, 2, 2, 3, 2, 0, 3, 1, 3, 2, 3, 3, 3]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(0, false), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([0, 0, 2, 0, 0, 1, 2, 1, 0, 2, 2, 2, 0, 3, 2, 3]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(0, true), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([1, 0, 3, 0, 1, 1, 3, 1, 1, 2, 3, 2, 1, 3, 3, 3]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(1, false), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2, 0, 3, 1, 3]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(1, true), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([2, 0, 3, 0, 2, 1, 3, 1, 2, 2, 3, 2, 2, 3, 3, 3]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(2, false), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([0, 0, 1, 0, 2, 0, 3, 0, 0, 2, 1, 2, 2, 2, 3, 2]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(2, true), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([0, 1, 1, 1, 2, 1, 3, 1, 0, 3, 1, 3, 2, 3, 3, 3]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(3, false), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([0, 0, 1, 0, 2, 0, 3, 0, 0, 1, 1, 1, 2, 1, 3, 1]));
    assertThat(CircuitShaders.controlSelect(Controls.bit(3, true), coords).readVec2Outputs(3)).isEqualTo(new Float32Array([0, 2, 1, 2, 2, 2, 3, 2, 0, 3, 1, 3, 2, 3, 3, 3]));
    coords.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("controlSelect_multiple", function() {
    var coords = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec2(), "\n        vec2 outputFor(float k) {\n            return vec2(mod(k, 4.0), floor(k/4.0));\n        }\n    ")().toVec2Texture(4);
    assertThat(CircuitShaders.controlSelect(new Controls(0x3, 0x3), coords).readVec2Outputs(2)).isEqualTo(new Float32Array([3, 0, 3, 1, 3, 2, 3, 3]));
    assertThat(CircuitShaders.controlSelect(new Controls(0x3, 0x2), coords).readVec2Outputs(2)).isEqualTo(new Float32Array([2, 0, 2, 1, 2, 2, 2, 3]));
    assertThat(CircuitShaders.controlSelect(new Controls(0xC, 0xC), coords).readVec2Outputs(2)).isEqualTo(new Float32Array([0, 3, 1, 3, 2, 3, 3, 3]));
    assertThat(CircuitShaders.controlSelect(new Controls(0xF, 0x3), coords).readVec2Outputs(0)).isEqualTo(new Float32Array([3, 0]));
    coords.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("qubitDensities", function() {
    var s = Math.sqrt(0.5);
    var q = 0.25;
    var h = 0.5;
    var _ = 0;
    var assertAmpsToDensities = function(amps, dens) {
      var tex = Shaders.vec2Data(new Float32Array(amps)).toVec2Texture(1);
      assertThat(CircuitShaders.qubitDensities(tex).readVec4Outputs(0)).isApproximatelyEqualTo(new Float32Array(dens));
      tex.deallocByDepositingInPool();
    };
    assertAmpsToDensities([1, _, _, _], [1, 0, 0, 0]);
    assertAmpsToDensities([_, 1, _, _], [1, 0, 0, 0]);
    assertAmpsToDensities([_, _, 1, _], [0, 0, 0, 1]);
    assertAmpsToDensities([_, _, _, 1], [0, 0, 0, 1]);
    assertAmpsToDensities([s, _, s, _], [h, h, 0, h]);
    assertAmpsToDensities([s, _, _, s], [h, 0, h, h]);
    assertAmpsToDensities([_, s, s, _], [h, 0, -h, h]);
    assertAmpsToDensities([_, s, -s, _], [h, 0, h, h]);
    assertAmpsToDensities([0.4, _, _, 0.6], [0.16, 0, 0.24, 0.36]);
    var allQubitsZero = Shaders.vec2Data(new Float32Array([1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _])).toVec2Texture(4);
    assertThat(CircuitShaders.qubitDensities(allQubitsZero).readVec4Outputs(5)).isEqualTo(new Float32Array([1, _, _, _, 1, _, _, _, 1, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]));
    allQubitsZero.deallocByDepositingInPool();
    var ent = Shaders.vec2Data(new Float32Array([s, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, s, _])).toVec2Texture(4);
    assertThat(CircuitShaders.qubitDensities(ent).readVec4Outputs(5)).isApproximatelyEqualTo(new Float32Array([h, _, _, _, h, _, _, _, h, _, _, _, h, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, h, _, _, _, h, _, _, _, h, _, _, _, h]));
    assertThat(CircuitShaders.qubitDensities(ent, 3).readVec4Outputs(4)).isApproximatelyEqualTo(new Float32Array([h, _, _, _, h, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, h, _, _, _, h]));
    ent.deallocByDepositingInPool();
    var mix = Shaders.vec2Data(new Float32Array([_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, h, _, _, _, h, _, _, _, _, h, _, _, _, h, _, _])).toVec2Texture(4);
    assertThat(CircuitShaders.qubitDensities(mix).readVec4Outputs(5)).isApproximatelyEqualTo(new Float32Array([_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, q, q, _, q, q, _, q, q, _, _, _, q, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, q, q, _, q, q, _, q, q, _, _, _, q, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]));
    assertThat(CircuitShaders.qubitDensities(mix, 12).readVec4Outputs(4)).isApproximatelyEqualTo(new Float32Array([_, _, _, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, _, _, _, _, _, q, _, q, q, _, _, _, q, _, _, _, _, _, _, _, _, q, _, q, q, _, _, _, q, _, _, _, _, _, _, _, _]));
    assertThat(CircuitShaders.qubitDensities(mix, 13).readVec4Outputs(5)).isApproximatelyEqualTo(new Float32Array([_, _, _, _, _, _, _, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, q, _, q, q, _, _, _, q, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, q, _, _, _, q, _, q, q, _, _, _, q, _, _, _, _, q, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _]));
    mix.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("swap", function() {
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      return CircuitShaders.swap(ctx, ctx.row + 1);
    }, Matrix.square(1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1));
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      return CircuitShaders.swap(ctx, ctx.row + 2);
    }, Matrix.square(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1));
  });
  return {};
});
//# sourceURL=test/circuit/CircuitShaders.test.js
;$traceurRuntime.registerModule("test/circuit/CircuitStats.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/CircuitStats.test.js";
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/CircuitStats.test.js")),
      Suite = $__16.Suite,
      assertThat = $__16.assertThat,
      assertTrue = $__16.assertTrue;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/circuit/CircuitStats.test.js")).CircuitStats;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/circuit/CircuitStats.test.js")).CircuitDefinition;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/circuit/CircuitStats.test.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/circuit/CircuitStats.test.js")).Gates;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/CircuitStats.test.js")).Matrix;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Serializer.js", "test/circuit/CircuitStats.test.js")).Serializer;
  var $__23 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/circuit/CircuitStats.test.js")),
      seq = $__23.seq,
      Seq = $__23.Seq;
  var suite = new Suite("CircuitStats");
  var circuit = function(diagram) {
    for (var extras = [],
        $__10 = 1; $__10 < arguments.length; $__10++)
      extras[$__10 - 1] = arguments[$__10];
    return CircuitDefinition.fromTextDiagram(new Map($traceurRuntime.spread(extras, [['X', Gates.HalfTurns.X], ['Y', Gates.HalfTurns.Y], ['Z', Gates.HalfTurns.Z], ['H', Gates.HalfTurns.H], ['•', Gates.Controls.Control], ['◦', Gates.Controls.AntiControl], ['⊕', Gates.Controls.XAntiControl], ['M', Gates.Special.Measurement], ['@', Gates.Displays.BlochSphereDisplay], ['!', Gates.PostSelectionGates.PostSelectOn], ['-', undefined], ['+', undefined], ['|', undefined], ['/', null]])), diagram);
  };
  suite.testUsingWebGL("empty", function() {
    var stats = CircuitStats.fromCircuitAtTime(CircuitDefinition.EMPTY.withWireCount(1), 0.1);
    assertThat(stats.finalState).isApproximatelyEqualTo(Matrix.col(1, 0));
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 0));
  });
  suite.testUsingWebGL("smoke", function() {
    var c = circuit("--X-H---•⊕-\n                     --•-H---XX-\n                     -H--M--@---");
    var stats = CircuitStats.fromCircuitAtTime(c, 0.1);
    assertTrue(stats.circuitDefinition.colHasControls(2));
    assertThat(stats.qubitDensityMatrix(7, 2)).isEqualTo(Matrix.square(0.5, 0, 0, 0.5));
  });
  function tryGateSequence(gates, maxHeight) {
    var pad = new Array(maxHeight - 1).fill(undefined);
    var cols = gates.filter(function(e) {
      return e !== Gates.Special.Measurement && e !== Gates.ErrorInjection && e.height <= maxHeight;
    }).map(function(e) {
      return new GateColumn($traceurRuntime.spread([e], pad));
    });
    var c = new CircuitDefinition(maxHeight, cols);
    var stats = CircuitStats.fromCircuitAtTime(c, 0.1);
    assertThat(stats).isNotEqualTo(undefined);
  }
  var knownGateStripes = 32;
  var $__6 = true;
  var $__7 = false;
  var $__8 = undefined;
  try {
    var $__14 = function() {
      var knownGateOffset = $__4.value;
      {
        suite.testUsingWebGL(("try-known-gates-in-sequence-" + (knownGateOffset + 1) + "-of-" + knownGateStripes), function() {
          var stripe = seq(Gates.KnownToSerializer).skip(knownGateOffset).stride(knownGateStripes).toArray();
          tryGateSequence(stripe, 5);
        });
      }
    };
    for (var $__4 = void 0,
        $__3 = (Seq.range(knownGateStripes))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
      $__14();
    }
  } catch ($__9) {
    $__7 = true;
    $__8 = $__9;
  } finally {
    try {
      if (!$__6 && $__3.return != null) {
        $__3.return();
      }
    } finally {
      if ($__7) {
        throw $__8;
      }
    }
  }
  suite.testUsingWebGL("nested-addition-gate", function() {
    var circuitDef = Serializer.fromJson(CircuitDefinition, {
      cols: [[1, "X"], [1, "~f2fa"]],
      gates: [{
        id: "~f2fa",
        circuit: {cols: [["+=A1", "inputA1"]]}
      }]
    });
    var stats = CircuitStats.fromCircuitAtTime(circuitDef, 0);
    var off = Matrix.square(1, 0, 0, 0);
    var on = Matrix.square(0, 0, 0, 1);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isEqualTo(off);
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isEqualTo(on);
    assertThat(stats.qubitDensityMatrix(Infinity, 2)).isEqualTo(off);
  });
  suite.testUsingWebGL('controlled-displays', function() {
    var c = circuit("-H-•-@@-\n                     ---X-⊕•-");
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(5, 0)).isApproximatelyEqualTo(Matrix.square(0.5, 0.5, 0.5, 0.5));
    assertThat(stats.qubitDensityMatrix(6, 0)).isApproximatelyEqualTo(Matrix.square(0, 0, 0, 1));
  });
  suite.testUsingWebGL('incoherent-amplitude-display', function() {
    var c = circuit("-H-•-a-\n                     ---X---", ['a', Gates.Displays.AmplitudeDisplayFamily.ofSize(1)]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isApproximatelyEqualTo(Matrix.square(0.5, 0, 0, 0.5));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isApproximatelyEqualTo(Matrix.square(0.5, 0, 0, 0.5));
    assertThat(stats.customStatsForSlot(5, 0)).isApproximatelyEqualTo({
      quality: 0.5,
      ket: Matrix.row(1, 0),
      phaseLockIndex: 0,
      incoherentKet: Matrix.row(Math.sqrt(0.5), Math.sqrt(0.5))
    });
  });
  suite.testUsingWebGL('coherent-amplitude-display', function() {
    var c = circuit("-H-•-a/--\n                     ---X-//--\n                     -H-------", ['a', Gates.Displays.AmplitudeDisplayFamily]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isApproximatelyEqualTo(Matrix.square(0.5, 0, 0, 0.5));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isApproximatelyEqualTo(Matrix.square(0.5, 0, 0, 0.5));
    assertThat(stats.qubitDensityMatrix(Infinity, 2)).isApproximatelyEqualTo(Matrix.square(0.5, 0.5, 0.5, 0.5));
    assertThat(stats.customStatsForSlot(5, 0)).isApproximatelyEqualTo({
      quality: 1,
      ket: Matrix.square(1, 0, 0, 1).times(Math.sqrt(0.5)),
      incoherentKet: Matrix.square(1, 0, 0, 1).times(Math.sqrt(0.5)),
      phaseLockIndex: 0
    });
  });
  suite.testUsingWebGL('conditional-bloch-display', function() {
    var c = circuit("-H-@-\n                     -H-•-");
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isApproximatelyEqualTo(Matrix.square(0.5, 0.5, 0.5, 0.5));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isApproximatelyEqualTo(Matrix.square(0.5, 0.5, 0.5, 0.5));
    assertThat(stats.qubitDensityMatrix(3, 0)).isApproximatelyEqualTo(Matrix.square(0.5, 0.5, 0.5, 0.5));
    assertThat(stats.customStatsForSlot(3, 0)).isEqualTo(undefined);
  });
  suite.testUsingWebGL('probability-display', function() {
    var c = circuit("-H-•-%-\n                     ---X-/-", ['%', Gates.Displays.ProbabilityDisplayFamily]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isApproximatelyEqualTo(Matrix.square(0.5, 0, 0, 0.5));
    assertThat(stats.customStatsForSlot(5, 0)).isApproximatelyEqualTo(Matrix.col(0.5, 0, 0, 0.5));
  });
  suite.testUsingWebGL('controlled-multi-probability-display', function() {
    var c = circuit("---◦-\n                     -H-%-\n                     ---/-", ['%', Gates.Displays.ProbabilityDisplayFamily]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.customStatsForSlot(3, 1)).isApproximatelyEqualTo(Matrix.col(0.5, 0.5, 0, 0));
  });
  suite.testUsingWebGL('density-display', function() {
    var c = circuit("-d/-\n                     -//-", ['d', Gates.Displays.DensityMatrixDisplayFamily]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.customStatsForSlot(1, 0)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));
  });
  suite.testUsingWebGL('shifted-density-display', function() {
    var c = circuit("----\n                     -d/-\n                     -//-", ['d', Gates.Displays.DensityMatrixDisplayFamily]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.customStatsForSlot(1, 1)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0));
  });
  suite.testUsingWebGL('16-qubit-hadamard-transform', function() {
    var stats = CircuitStats.fromCircuitAtTime(circuit("-H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-\n                                                        -H-"), 0);
    var buf = stats.finalState.rawBuffer();
    for (var i = 0; i * 2 < buf.length; i++) {
      if (buf[i * 2 + 1] !== 0) {
        assertThat(buf[i * 2 + 1]).withInfo({i: i}).isEqualTo(0);
      }
      if (Math.abs(buf[i * 2] * 256.0 - 1.0) > 0.00001) {
        assertThat(buf[i * 2]).withInfo({i: i}).isApproximatelyEqualTo(1 / 256);
      }
    }
    for (var i$__15 = 0; i$__15 < 16; i$__15++) {
      assertThat(stats.qubitDensityMatrix(Infinity, i$__15)).withInfo({i: i$__15}).isApproximatelyEqualTo(Matrix.square(0.5, 0.5, 0.5, 0.5), 0.000001);
    }
    assertThat(stats.survivalRate(Infinity)).isApproximatelyEqualTo(1, 0.0001);
  });
  suite.testUsingWebGL('survival-rates', function() {
    var stats = CircuitStats.fromCircuitAtTime(circuit("-H-!-------\n                                                        ---X-!-----\n                                                        -------H-!-\n                                                        -----------"), 0);
    assertThat(stats.survivalRate(-1)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(0)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(1)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(2)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(3)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(4)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(5)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(6)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(7)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(8)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(7)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(8)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(9)).isApproximatelyEqualTo(0.25);
    assertThat(stats.survivalRate(10)).isApproximatelyEqualTo(0.25);
    assertThat(stats.survivalRate(Infinity)).isApproximatelyEqualTo(0.25);
  });
  suite.testUsingWebGL('survival-rates-controlled-postselection', function() {
    var stats = CircuitStats.fromCircuitAtTime(circuit("---•-H-•-!---•-\n                                                        -X-!-X-X-•-X-!-"), 0);
    assertThat(stats.survivalRate(2)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(3)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(4)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(5)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(6)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(7)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(8)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(9)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(10)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(11)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(12)).isApproximatelyEqualTo(1);
    assertThat(stats.survivalRate(13)).isApproximatelyEqualTo(0.5);
    assertThat(stats.survivalRate(14)).isApproximatelyEqualTo(0.5);
  });
  suite.testUsingWebGL('dynamic-phase-gradient-keeps-qubits-coherent', function() {
    var $__12,
        $__13;
    var stats = CircuitStats.fromCircuitAtTime(circuit("-H-P-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-\n                 -H-/-", ['P', Gates.PhaseGradientGates.DynamicPhaseGradientFamily]), 0.9);
    for (var i = 0; i < 16; i++) {
      var $__11 = stats.qubitDensityMatrix(Infinity, i).qubitDensityMatrixToBlochVector(),
          x = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
          y = ($__13 = $__12.next()).done ? void 0 : $__13.value,
          z = ($__13 = $__12.next()).done ? void 0 : $__13.value;
      var r = x * x + y * y + z * z;
      assertThat(r).withInfo({
        i: i,
        x: x,
        y: y,
        z: z
      }).isApproximatelyEqualTo(1, 0.00001);
    }
  });
  suite.testUsingWebGL('classical-swap-with-quantum-control-does-not-fire', function() {
    var c = circuit("-M-X-S-\n                     -M---S-\n                     ---X-•-", ['S', Gates.Special.SwapHalf]);
    assertThat(c.gateAtLocIsDisabledReason(5, 0)).isNotEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 1)).isNotEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 2)).isEqualTo(undefined);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isEqualTo(Matrix.square(0, 0, 0, 1));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isEqualTo(Matrix.square(1, 0, 0, 0));
    assertThat(stats.qubitDensityMatrix(Infinity, 2)).isEqualTo(Matrix.square(0, 0, 0, 1));
  });
  suite.testUsingWebGL('classical-swap-with-classical-control-does-fire', function() {
    var c = circuit("-M-X-S-\n                     -M---S-\n                     -M-X-•-", ['S', Gates.Special.SwapHalf]);
    assertThat(c.gateAtLocIsDisabledReason(5, 0)).isEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 1)).isEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 2)).isEqualTo(undefined);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isEqualTo(Matrix.square(1, 0, 0, 0));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isEqualTo(Matrix.square(0, 0, 0, 1));
    assertThat(stats.qubitDensityMatrix(Infinity, 2)).isEqualTo(Matrix.square(0, 0, 0, 1));
  });
  suite.testUsingWebGL('classical-bit-rotate-with-quantum-control-does-not-fire', function() {
    var c = circuit("-M-X-<-\n                     -M---/-\n                     ---X-•-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    assertThat(c.gateAtLocIsDisabledReason(5, 0)).isNotEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 2)).isEqualTo(undefined);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isEqualTo(Matrix.square(0, 0, 0, 1));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isEqualTo(Matrix.square(1, 0, 0, 0));
    assertThat(stats.qubitDensityMatrix(Infinity, 2)).isEqualTo(Matrix.square(0, 0, 0, 1));
  });
  suite.testUsingWebGL('classical-bit-rotate-with-classical-control-does-fire', function() {
    var c = circuit("-M-X-<-\n                     -M---/-\n                     -M-X-•-", ['<', Gates.CycleBitsGates.CycleBitsFamily]);
    assertThat(c.gateAtLocIsDisabledReason(5, 0)).isEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 2)).isEqualTo(undefined);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.qubitDensityMatrix(Infinity, 0)).isEqualTo(Matrix.square(1, 0, 0, 0));
    assertThat(stats.qubitDensityMatrix(Infinity, 1)).isEqualTo(Matrix.square(0, 0, 0, 1));
    assertThat(stats.qubitDensityMatrix(Infinity, 2)).isEqualTo(Matrix.square(0, 0, 0, 1));
  });
  suite.testUsingWebGL("initial_states", function() {
    var circuit = Serializer.fromJson(CircuitDefinition, {
      init: [0, 1, '+', '-', 'i', '-i'],
      cols: []
    });
    var stats = CircuitStats.fromCircuitAtTime(circuit, 0);
    assertThat(stats.qubitDensityMatrix(9, 0).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([0, 0, -1]);
    assertThat(stats.qubitDensityMatrix(9, 1).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([0, 0, +1]);
    assertThat(stats.qubitDensityMatrix(9, 2).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([-1, 0, 0]);
    assertThat(stats.qubitDensityMatrix(9, 3).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([+1, 0, 0]);
    assertThat(stats.qubitDensityMatrix(9, 4).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([0, +1, 0]);
    assertThat(stats.qubitDensityMatrix(9, 5).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([0, -1, 0]);
  });
  suite.testUsingWebGL("distillation", function() {
    var c = circuit("\n        -X-X--X-X--X-X--X-X-------X-X--X-X-------X-X------------HTH-0-\n        -X-X--X-X--X-X-------X-X--X-X-------X-X-------X-X-------HTH-0-\n        -X-X--X-X-------X-X--X-X-------X-X--X-X------------X-X--HTH-0-\n        -X-X-------X-X--X-X--X-X-----------------X-X--X-X--X-X--HTH-0-\n        -X-X----------------------X-X--X-X--X-X--X-X--X-X--X-X--------\n        -#T]--#T]--#T]--#T]--#T]--#T]--#T]--#T]--#T]--#T]--#T]--------\n        ", [']', Gates.Detectors.XDetectControlClear], ['0', Gates.PostSelectionGates.PostSelectOff], ['#', Gates.Controls.XControl], ['T', Gates.OtherZ.Z4]);
    for (var i = 0; i < 5; i++) {
      var stats = CircuitStats.fromCircuitAtTime(c, 0);
      assertThat(stats.qubitDensityMatrix(Infinity, 4).qubitDensityMatrixToBlochVector()).isApproximatelyEqualTo([0, Math.sqrt(0.5), -Math.sqrt(0.5)]);
      assertThat(stats.survivalRate(Infinity)).isApproximatelyEqualTo(1, 0.001);
    }
  });
  suite.testUsingWebGL("toReadableJson", function() {
    var c = circuit("\n        --%D\n        H@/-\n        ", ['%', Gates.Displays.ProbabilityDisplayFamily], ['D', Gates.Detectors.ZDetector]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0.5);
    var json = stats.toReadableJson();
    assertThat(json).isApproximatelyEqualTo({
      circuit: Serializer.toJson(c),
      output_amplitudes: [{
        r: Math.sqrt(0.5),
        i: 0
      }, {
        r: 0,
        i: 0
      }, {
        r: Math.sqrt(0.5),
        i: 0
      }, {
        r: 0,
        i: 0
      }],
      time_parameter: 0.5,
      chance_of_surviving_to_each_column: [1, 1, 1, 1],
      computed_bloch_vectors_by_column_then_wire: [[null, null], [null, {
        x: +1,
        y: 0,
        z: 0
      }], [null, null], [null, null], [{
        x: 0,
        y: 0,
        z: +1
      }, {
        x: +1,
        y: 0,
        z: 0
      }]],
      displays: [{
        location: {
          wire: 0,
          column: 2
        },
        type: {
          serialized_id: "Chance2",
          name: "Probability Display"
        },
        data: {probabilities: [0.5, 0, 0.5, 0]}
      }, {
        location: {
          wire: 0,
          column: 3
        },
        type: {
          serialized_id: "ZDetector",
          name: "Z Axis Detector"
        },
        data: false
      }]
    });
  });
  return {};
});
//# sourceURL=test/circuit/CircuitStats.test.js
;$traceurRuntime.registerModule("test/circuit/Controls.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/Controls.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/Controls.test.js")),
      assertTrue = $__0.assertTrue,
      assertFalse = $__0.assertFalse,
      assertThat = $__0.assertThat,
      assertThrows = $__0.assertThrows,
      Suite = $__0.Suite;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/circuit/Controls.test.js")).Controls;
  var suite = new Suite("Controls");
  suite.test("isEqualTo", function() {
    var s = new Controls(0xF, 0xE);
    assertTrue(s.isEqualTo(s));
    assertFalse(s.isEqualTo(""));
    assertFalse(s.isEqualTo(null));
    assertThat(s.desiredValueMask).isEqualTo(0xE);
    assertThat(s.inclusionMask).isEqualTo(0xF);
    assertTrue(s.isEqualTo(new Controls(0xF, 0xE)));
    assertFalse(s.isEqualTo(new Controls(0, 0)));
    assertFalse(s.isEqualTo(new Controls(0xF, 0xF)));
    assertFalse(s.isEqualTo(new Controls(0xE, 0xE)));
    assertTrue(new Controls(0x3, 0x2).isEqualTo(new Controls(0x3, 0x2)));
    assertTrue(Controls.NONE.isEqualTo(new Controls(0, 0)));
  });
  suite.test("allowsState", function() {
    assertTrue(Controls.NONE.allowsState(0));
    assertTrue(Controls.NONE.allowsState(1));
    var m = new Controls(0x5, 0x1);
    assertFalse(m.allowsState(0));
    assertTrue(m.allowsState(1));
    assertFalse(m.allowsState(2));
    assertTrue(m.allowsState(3));
    assertFalse(m.allowsState(4));
    assertFalse(m.allowsState(5));
    assertFalse(m.allowsState(6));
    assertFalse(m.allowsState(7));
    assertFalse(m.allowsState(8));
    assertTrue(m.allowsState(9));
  });
  suite.test("desiredValueFor", function() {
    assertThat(Controls.NONE.desiredValueFor(0)).isEqualTo(undefined);
    assertThat(Controls.NONE.desiredValueFor(1)).isEqualTo(undefined);
    var m = new Controls(0x5, 0x1);
    assertThat(m.desiredValueFor(0)).isEqualTo(true);
    assertThat(m.desiredValueFor(1)).isEqualTo(undefined);
    assertThat(m.desiredValueFor(2)).isEqualTo(false);
    assertThat(m.desiredValueFor(3)).isEqualTo(undefined);
  });
  suite.test("bit", function() {
    assertThat(Controls.bit(0, true)).isEqualTo(new Controls(0x1, 0x1));
    assertThat(Controls.bit(0, false)).isEqualTo(new Controls(0x1, 0x0));
    assertThat(Controls.bit(2, true)).isEqualTo(new Controls(0x4, 0x4));
    assertThat(Controls.bit(2, false)).isEqualTo(new Controls(0x4, 0x0));
  });
  suite.test("and", function() {
    assertThat(Controls.NONE.and(Controls.NONE)).isEqualTo(Controls.NONE);
    assertThat(Controls.NONE.desiredValueFor(1)).isEqualTo(undefined);
    var m = new Controls(0x5, 0x1);
    assertThat(Controls.bit(0, true).and(Controls.bit(2, false))).isEqualTo(m);
    assertThat(Controls.bit(2, false).and(Controls.bit(0, true))).isEqualTo(m);
    assertThat(Controls.NONE.and(m)).isEqualTo(m);
    assertThat(m.and(m)).isEqualTo(m);
    assertThrows(function() {
      return Controls.bit(0, true).and(Controls.bit(0, false));
    });
  });
  suite.test("toString", function() {
    assertTrue(typeof(Controls.NONE.toString()) === "string");
    assertTrue(typeof(new Controls(0x5, 0x1).toString()) === "string");
  });
  return {};
});
//# sourceURL=test/circuit/Controls.test.js
;$traceurRuntime.registerModule("test/circuit/Gate.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/Gate.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/Gate.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Gate.js", "test/circuit/Gate.test.js")),
      Gate = $__1.Gate,
      GateBuilder = $__1.GateBuilder;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/Gate.test.js")).Matrix;
  var suite = new Suite("Gate");
  suite.test("toString_runsWithoutFailing", function() {
    var g = new GateBuilder().setEffectToTimeVaryingMatrix(function(_) {
      return Matrix.HADAMARD;
    }).gate;
    assertThat(g.toString()).isNotEqualTo(null);
  });
  suite.test("stableDuration", function() {
    var m0 = Gate.fromKnownMatrix("symbol", Matrix.HADAMARD, "name", "blurb");
    var mt = new GateBuilder().setEffectToTimeVaryingMatrix(function(t) {
      return Matrix.square(t, 0, 0, 0);
    }).gate;
    assertThat(m0.stableDuration()).isEqualTo(Infinity);
    assertThat(mt.stableDuration()).isEqualTo(0);
  });
  suite.test("knownMatrixAt", function() {
    var m0 = Gate.fromKnownMatrix("symbol", Matrix.HADAMARD, "name", "blurb");
    var mt = new GateBuilder().setEffectToTimeVaryingMatrix(function(t) {
      return Matrix.square(t, 0, 0, 0);
    }).gate;
    assertThat(m0.knownMatrixAt(0)).isEqualTo(Matrix.HADAMARD);
    assertThat(m0.knownMatrixAt(0.5)).isEqualTo(Matrix.HADAMARD);
    assertThat(mt.knownMatrixAt(0)).isEqualTo(Matrix.square(0, 0, 0, 0));
    assertThat(mt.knownMatrixAt(0.5)).isEqualTo(Matrix.square(0.5, 0, 0, 0));
  });
  return {};
});
//# sourceURL=test/circuit/Gate.test.js
;$traceurRuntime.registerModule("test/circuit/GateColumn.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/GateColumn.test.js";
  var $__28 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/GateColumn.test.js")),
      Suite = $__28.Suite,
      assertThat = $__28.assertThat,
      assertTrue = $__28.assertTrue,
      assertFalse = $__28.assertFalse;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/circuit/GateColumn.test.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/circuit/GateColumn.test.js")).Gates;
  var suite = new Suite("GateColumn");
  suite.test("isEqualTo", function() {
    assertThat(GateColumn.empty(1)).isEqualTo(GateColumn.empty(1));
    assertThat(GateColumn.empty(2)).isNotEqualTo(GateColumn.empty(1));
    var groups = [[GateColumn.empty(0), GateColumn.empty(0), new GateColumn([]), new GateColumn([])], [GateColumn.empty(1), GateColumn.empty(1), new GateColumn([undefined]), new GateColumn([undefined])], [GateColumn.empty(2), GateColumn.empty(2), new GateColumn([undefined, undefined]), new GateColumn([undefined, undefined])], [new GateColumn([Gates.HalfTurns.X]), new GateColumn([Gates.HalfTurns.X])], [new GateColumn([Gates.Controls.Control]), new GateColumn([Gates.Controls.Control])], [new GateColumn([Gates.HalfTurns.X, undefined]), new GateColumn([Gates.HalfTurns.X, undefined])], [new GateColumn([undefined, Gates.HalfTurns.X]), new GateColumn([undefined, Gates.HalfTurns.X])]];
    var $__24 = true;
    var $__25 = false;
    var $__26 = undefined;
    try {
      for (var $__22 = void 0,
          $__21 = (groups)[Symbol.iterator](); !($__24 = ($__22 = $__21.next()).done); $__24 = true) {
        var g1 = $__22.value;
        {
          var $__17 = true;
          var $__18 = false;
          var $__19 = undefined;
          try {
            for (var $__15 = void 0,
                $__14 = (groups)[Symbol.iterator](); !($__17 = ($__15 = $__14.next()).done); $__17 = true) {
              var g2 = $__15.value;
              {
                var $__10 = true;
                var $__11 = false;
                var $__12 = undefined;
                try {
                  for (var $__8 = void 0,
                      $__7 = (g1)[Symbol.iterator](); !($__10 = ($__8 = $__7.next()).done); $__10 = true) {
                    var e1 = $__8.value;
                    {
                      var $__3 = true;
                      var $__4 = false;
                      var $__5 = undefined;
                      try {
                        for (var $__1 = void 0,
                            $__0 = (g2)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
                          var e2 = $__1.value;
                          {
                            if (g1 === g2) {
                              assertThat(e1).isEqualTo(e2);
                              assertTrue(e1.isEqualTo(e2));
                            } else {
                              assertThat(e1).isNotEqualTo(e2);
                              assertFalse(e1.isEqualTo(e2));
                            }
                          }
                        }
                      } catch ($__6) {
                        $__4 = true;
                        $__5 = $__6;
                      } finally {
                        try {
                          if (!$__3 && $__0.return != null) {
                            $__0.return();
                          }
                        } finally {
                          if ($__4) {
                            throw $__5;
                          }
                        }
                      }
                    }
                  }
                } catch ($__13) {
                  $__11 = true;
                  $__12 = $__13;
                } finally {
                  try {
                    if (!$__10 && $__7.return != null) {
                      $__7.return();
                    }
                  } finally {
                    if ($__11) {
                      throw $__12;
                    }
                  }
                }
              }
            }
          } catch ($__20) {
            $__18 = true;
            $__19 = $__20;
          } finally {
            try {
              if (!$__17 && $__14.return != null) {
                $__14.return();
              }
            } finally {
              if ($__18) {
                throw $__19;
              }
            }
          }
        }
      }
    } catch ($__27) {
      $__25 = true;
      $__26 = $__27;
    } finally {
      try {
        if (!$__24 && $__21.return != null) {
          $__21.return();
        }
      } finally {
        if ($__25) {
          throw $__26;
        }
      }
    }
  });
  suite.test("isEmpty", function() {
    assertTrue(GateColumn.empty(0).isEmpty());
    assertTrue(GateColumn.empty(1).isEmpty());
    assertTrue(GateColumn.empty(2).isEmpty());
    assertTrue(GateColumn.empty(10).isEmpty());
    assertTrue(new GateColumn([]).isEmpty());
    assertTrue(new GateColumn([undefined]).isEmpty());
    assertTrue(new GateColumn([undefined, undefined]).isEmpty());
    assertFalse(new GateColumn([Gates.Controls.Control]).isEmpty());
    assertFalse(new GateColumn([Gates.Special.SwapHalf]).isEmpty());
    assertFalse(new GateColumn([Gates.HalfTurns.X]).isEmpty());
    assertFalse(new GateColumn([Gates.HalfTurns.X, undefined]).isEmpty());
    assertFalse(new GateColumn([Gates.HalfTurns.X, Gates.HalfTurns.X]).isEmpty());
  });
  return {};
});
//# sourceURL=test/circuit/GateColumn.test.js
;$traceurRuntime.registerModule("test/circuit/GateShaders.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/GateShaders.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/GateShaders.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateShaders.js", "test/circuit/GateShaders.test.js")).GateShaders;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/circuit/GateShaders.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/circuit/GateShaders.test.js")).Complex;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/circuit/GateShaders.test.js")).Seq;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/circuit/GateShaders.test.js")).Shaders;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/GateShaders.test.js")).Matrix;
  var suite = new Suite("GateShaders");
  suite.testUsingWebGL('cycleAllBits', function() {
    var inp = Shaders.vec2Data(Seq.range(16).flatMap(function(e) {
      return [e * 4 + 1, e * 4 + 2];
    }).toFloat32Array()).toVec2Texture(4);
    var actual = GateShaders.cycleAllBits(inp, -1).readVec2Outputs(4);
    assertThat(actual).isEqualTo(new Float32Array([1, 2, 9, 10, 17, 18, 25, 26, 33, 34, 41, 42, 49, 50, 57, 58, 5, 6, 13, 14, 21, 22, 29, 30, 37, 38, 45, 46, 53, 54, 61, 62]));
    inp.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("matrixOperation", function() {
    var repeats = 3;
    var $__0 = function(size) {
      var d = 1 << size;
      var matrix = Matrix.generate(d, d, function() {
        return new Complex(Math.random() - 0.5, Math.random() - 0.5);
      });
      assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
        return GateShaders.applyMatrixOperation(ctx, matrix);
      }, matrix, repeats);
    };
    for (var size = 1; size < 5; size++) {
      $__0(size);
    }
  });
  return {};
});
//# sourceURL=test/circuit/GateShaders.test.js
;$traceurRuntime.registerModule("test/circuit/KetShaderUtil.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/KetShaderUtil.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/KetShaderUtil.test.js")).Suite;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/KetShaderUtil.js", "test/circuit/KetShaderUtil.test.js")),
      ketArgs = $__2.ketArgs,
      ketShader = $__2.ketShader,
      ketShaderPermute = $__2.ketShaderPermute,
      ketShaderPhase = $__2.ketShaderPhase;
  var assertThatCircuitShaderActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/circuit/KetShaderUtil.test.js")).assertThatCircuitShaderActsLikeMatrix;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/circuit/KetShaderUtil.test.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/KetShaderUtil.test.js")).Matrix;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/circuit/KetShaderUtil.test.js")).WglArg;
  var suite = new Suite("KetShaderUtil");
  suite.testUsingWebGL("ketShader", function() {
    var shader = ketShader('uniform vec2 a, b, c, d;', 'return cmul(inp(0.0), a+(c-a)*out_id) + cmul(inp(1.0), b+(d-b)*out_id);', 1);
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      var $__0;
      return ($__0 = shader).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx), [WglArg.vec2("a", 2, 3), WglArg.vec2("b", 5, 7), WglArg.vec2("c", 11, 13), WglArg.vec2("d", 17, 19)]));
    }, new Matrix(2, 2, new Float32Array([2, 3, 5, 7, 11, 13, 17, 19])));
  });
  suite.testUsingWebGL("ketShaderPermute", function() {
    var shader = ketShaderPermute('', 'return mod(out_id + 1.0, 4.0);', 2);
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      var $__0;
      return ($__0 = shader).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx)));
    }, Matrix.generateTransition(4, function(i) {
      return (i - 1) & 3;
    }));
  });
  suite.testUsingWebGL("ketShaderPhase", function() {
    var shader = ketShaderPhase('', 'return out_id/10.0;', 3);
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      var $__0;
      return ($__0 = shader).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx)));
    }, Matrix.generateDiagonal(8, function(i) {
      return Complex.polar(1, i / 10);
    }));
  });
  return {};
});
//# sourceURL=test/circuit/KetShaderUtil.test.js
;$traceurRuntime.registerModule("test/circuit/Serializer.test.js", [], function() {
  "use strict";
  var __moduleName = "test/circuit/Serializer.test.js";
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/circuit/Serializer.test.js")),
      Suite = $__9.Suite,
      assertThat = $__9.assertThat,
      assertTrue = $__9.assertTrue;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Serializer.js", "test/circuit/Serializer.test.js")).Serializer;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/circuit/Serializer.test.js")).CircuitDefinition;
  var setGateBuilderEffectToCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/circuit/Serializer.test.js")).setGateBuilderEffectToCircuit;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/circuit/Serializer.test.js")).Complex;
  var CustomGateSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CustomGateSet.js", "test/circuit/Serializer.test.js")).CustomGateSet;
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Describe.js", "test/circuit/Serializer.test.js")).describe;
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Gate.js", "test/circuit/Serializer.test.js")),
      Gate = $__16.Gate,
      GateBuilder = $__16.GateBuilder;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/circuit/Serializer.test.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/circuit/Serializer.test.js")).Gates;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/circuit/Serializer.test.js")).Matrix;
  var MysteryGateMaker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/Joke_MysteryGate.js", "test/circuit/Serializer.test.js")).MysteryGateMaker;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/circuit/Serializer.test.js")).seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/circuit/Serializer.test.js")).Util;
  var suite = new Suite("Serializer");
  var assertRoundTrip = function(t, v, s) {
    var equater = arguments[3];
    try {
      var from = Serializer.fromJson(t, s);
      var to = Serializer.toJson(v);
      if (equater === undefined) {
        assertThat(from).isEqualTo(v);
        assertThat(to).isEqualTo(s);
      } else {
        assertThat(equater(from, v)).isEqualTo(true);
        assertThat(equater(to, s)).isEqualTo(true);
      }
    } catch (failure) {
      console.error(("Failed to round-trip: " + describe(s) + " <--> " + describe(v)));
      throw failure;
    }
  };
  suite.test("roundTrip_Complex", function() {
    assertRoundTrip(Complex, Complex.ONE, "1");
    assertRoundTrip(Complex, new Complex(2, -3), "2-3i");
    assertRoundTrip(Complex, Complex.I, "i");
    assertRoundTrip(Complex, new Complex(0, -1), "-i");
    assertRoundTrip(Complex, new Complex(1 / 3, 0), "\u2153");
    assertRoundTrip(Complex, new Complex(1 / 3 + 0.00001, 0), "0.3333433333333333");
  });
  suite.test("roundTrip_Matrix", function() {
    assertRoundTrip(Matrix, Matrix.row(1, Complex.I), "{{1,i}}");
    assertRoundTrip(Matrix, Matrix.col(1, Complex.I), "{{1},{i}}");
    assertRoundTrip(Matrix, Matrix.square(1 / 3 + 0.00001, Complex.I.plus(1), -1 / 3, 0), "{{0.3333433333333333,1+i},{-\u2153,0}}");
  });
  suite.test("roundTrip_Gate", function() {
    assertRoundTrip(Gate, Gates.HalfTurns.X, "X", Util.STRICT_EQUALITY);
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var g$__8 = $__2.value;
        {
          assertRoundTrip(Gate, g$__8, g$__8.serializedId, Util.STRICT_EQUALITY);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var f = MysteryGateMaker();
    var f2 = Serializer.fromJson(Gate, Serializer.toJson(f));
    assertThat(f.name).isEqualTo(f2.name);
    assertThat(f.blurb).isEqualTo(f2.blurb);
    assertThat(f.knownMatrixAt(0)).isEqualTo(f2.knownMatrixAt(0));
    assertThat(f.serializedId).isEqualTo(f2.serializedId);
    var g = Gate.fromKnownMatrix("custom_id", Matrix.square(Complex.I, -1, 2, 3), "custom_name", "custom_blurb");
    var v = Serializer.toJson(g);
    var g2 = Serializer.fromJson(Gate, v);
    assertThat(v).isEqualTo({
      id: "custom_id",
      matrix: "{{i,-1},{2,3}}"
    });
    assertThat(g.knownMatrixAt(0)).isEqualTo(g2.knownMatrixAt(0));
    assertThat(g.symbol).isEqualTo(g2.symbol);
  });
  suite.test("roundTrip_CircuitDefinitionWithCustomGate", function() {
    var customGate = new GateBuilder().setSerializedId("~test").setSymbol('sym').setTitle('nam').setBlurb('blur').setKnownEffectToMatrix(Matrix.square(2, 3, 5, 7)).gate;
    var circuit = new CircuitDefinition(2, [new GateColumn([undefined, customGate])], undefined, undefined, new CustomGateSet(customGate));
    var json = Serializer.toJson(circuit);
    assertThat(json).isEqualTo({
      cols: [[1, '~test']],
      gates: [{
        id: '~test',
        name: 'sym',
        matrix: '{{2,3},{5,7}}'
      }]
    });
    var circuit2 = Serializer.fromJson(CircuitDefinition, json);
    assertThat(circuit2.columns.length).isEqualTo(1);
    assertThat(circuit2.columns[0].gates.length).isEqualTo(2);
    assertThat(circuit2.columns[0].gates[0]).isEqualTo(undefined);
    assertThat(circuit2.columns[0].gates[1].matrix).isEqualTo(customGate.matrix);
    assertThat(circuit2.columns[0].gates[1].symbol).isEqualTo(customGate.symbol);
    assertThat(circuit2.columns[0].gates[1].serializedId).isEqualTo(customGate.serializedId);
    assertThat(circuit2.customGateSet.gates.length).isEqualTo(1);
    assertTrue(circuit2.customGateSet.gates[0] === circuit2.columns[0].gates[1]);
  });
  suite.test("roundTrip_CircuitDefinitionWithDependentCustomGates", function() {
    var customGate = new GateBuilder().setSerializedId("~test").setSymbol('sym').setTitle('nam').setBlurb('blur').setKnownEffectToMatrix(Matrix.square(2, 3, 5, 7)).gate;
    var circuitForGate = new CircuitDefinition(2, [new GateColumn([customGate, customGate])], undefined, undefined, new CustomGateSet(customGate));
    var circuitGate = setGateBuilderEffectToCircuit(new GateBuilder(), circuitForGate).setSerializedId("~wombo").setSymbol('combo').gate;
    var circuit = new CircuitDefinition(3, [new GateColumn([customGate, circuitGate, undefined])], undefined, undefined, new CustomGateSet(customGate, circuitGate));
    var json = Serializer.toJson(circuit);
    assertThat(json).isEqualTo({
      cols: [['~test', '~wombo']],
      gates: [{
        id: '~test',
        name: 'sym',
        matrix: '{{2,3},{5,7}}'
      }, {
        id: '~wombo',
        name: 'combo',
        circuit: {cols: [['~test', '~test']]}
      }]
    });
  });
  suite.test("roundTrip_GateColumn", function() {
    assertRoundTrip(GateColumn, new GateColumn([undefined, Gates.HalfTurns.X, Gates.Powering.XForward, Gates.Special.SwapHalf, Gates.Controls.Control, undefined]), [1, "X", "X^t", "Swap", "\u2022", 1]);
  });
  suite.test("roundTrip_circuitDefinition", function() {
    assertRoundTrip(CircuitDefinition, new CircuitDefinition(3, [new GateColumn([undefined, undefined, Gates.HalfTurns.X])]), {cols: [[1, 1, "X"]]});
  });
  var IDS_THAT_SHOULD_BE_KNOWN = ["•", "◦", "⊕", "⊖", "⊗", "(/)", "xpar", "ypar", "zpar", "|0⟩⟨0|", "|1⟩⟨1|", "|+⟩⟨+|", "|-⟩⟨-|", "|X⟩⟨X|", "|/⟩⟨/|", "Measure", "XDetector", "YDetector", "ZDetector", "XDetectControlReset", "YDetectControlReset", "ZDetectControlReset", "Swap", "…", "inputA1", "inputA2", "inputA3", "inputA4", "inputA5", "inputA6", "inputA7", "inputA8", "inputA9", "inputA10", "inputA11", "inputA12", "inputA13", "inputA14", "inputA15", "inputA16", "inputB1", "inputB2", "inputB3", "inputB4", "inputB5", "inputB6", "inputB7", "inputB8", "inputB9", "inputB10", "inputB11", "inputB12", "inputB13", "inputB14", "inputB15", "inputB16", "inputR1", "inputR2", "inputR3", "inputR4", "inputR5", "inputR6", "inputR7", "inputR8", "inputR9", "inputR10", "inputR11", "inputR12", "inputR13", "inputR14", "inputR15", "inputR16", "setA", "setB", "setR", "revinputA1", "revinputA2", "revinputA3", "revinputA4", "revinputA5", "revinputA6", "revinputA7", "revinputA8", "revinputA9", "revinputA10", "revinputA11", "revinputA12", "revinputA13", "revinputA14", "revinputA15", "revinputA16", "revinputB1", "revinputB2", "revinputB3", "revinputB4", "revinputB5", "revinputB6", "revinputB7", "revinputB8", "revinputB9", "revinputB10", "revinputB11", "revinputB12", "revinputB13", "revinputB14", "revinputB15", "revinputB16", "__error__", "0", "NeGate", "i", "-i", "√i", "√-i", "H", "X", "Y", "Z", "X^ft", "Y^ft", "Z^ft", "Rxft", "Ryft", "Rzft", "X^½", "X^⅓", "X^¼", "X^⅛", "X^⅟₁₆", "X^⅟₃₂", "X^-½", "X^-⅓", "X^-¼", "X^-⅛", "X^-⅟₁₆", "X^-⅟₃₂", "Y^½", "Y^⅓", "Y^¼", "Y^⅛", "Y^⅟₁₆", "Y^⅟₃₂", "Y^-½", "Y^-⅓", "Y^-¼", "Y^-⅛", "Y^-⅟₁₆", "Y^-⅟₃₂", "Z^½", "Z^⅓", "Z^¼", "Z^⅛", "Z^⅟₁₆", "Z^⅟₃₂", "Z^⅟₆₄", "Z^⅟₁₂₈", "Z^-½", "Z^-⅓", "Z^-¼", "Z^-⅛", "Z^-⅟₁₆", "X^t", "Y^t", "Z^t", "X^-t", "Y^-t", "Z^-t", "X^(A/2^n)", "Y^(A/2^n)", "Z^(A/2^n)", "X^(-A/2^n)", "Y^(-A/2^n)", "Z^(-A/2^n)", "e^iXt", "e^iYt", "e^iZt", "e^-iXt", "e^-iYt", "e^-iZt", "Amps1", "Amps2", "Amps3", "Amps4", "Amps5", "Amps6", "Amps7", "Amps8", "Amps9", "Amps10", "Amps11", "Amps12", "Amps13", "Amps14", "Amps15", "Amps16", "Chance", "Chance2", "Chance3", "Chance4", "Chance5", "Chance6", "Chance7", "Chance8", "Chance9", "Chance10", "Chance11", "Chance12", "Chance13", "Chance14", "Chance15", "Chance16", "Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15", "Sample16", "Density", "Density2", "Density3", "Density4", "Density5", "Density6", "Density7", "Density8", "Bloch", "inc1", "inc2", "inc3", "inc4", "inc5", "inc6", "inc7", "inc8", "inc9", "inc10", "inc11", "inc12", "inc13", "inc14", "inc15", "inc16", "dec1", "dec2", "dec3", "dec4", "dec5", "dec6", "dec7", "dec8", "dec9", "dec10", "dec11", "dec12", "dec13", "dec14", "dec15", "dec16", "incmodR1", "incmodR2", "incmodR3", "incmodR4", "incmodR5", "incmodR6", "incmodR7", "incmodR8", "incmodR9", "incmodR10", "incmodR11", "incmodR12", "incmodR13", "incmodR14", "incmodR15", "incmodR16", "decmodR1", "decmodR2", "decmodR3", "decmodR4", "decmodR5", "decmodR6", "decmodR7", "decmodR8", "decmodR9", "decmodR10", "decmodR11", "decmodR12", "decmodR13", "decmodR14", "decmodR15", "decmodR16", "add2", "add3", "add4", "add5", "add6", "add7", "add8", "add9", "add10", "add11", "add12", "add13", "add14", "add15", "add16", "+=A1", "+=A2", "+=A3", "+=A4", "+=A5", "+=A6", "+=A7", "+=A8", "+=A9", "+=A10", "+=A11", "+=A12", "+=A13", "+=A14", "+=A15", "+=A16", "+AmodR1", "+AmodR2", "+AmodR3", "+AmodR4", "+AmodR5", "+AmodR6", "+AmodR7", "+AmodR8", "+AmodR9", "+AmodR10", "+AmodR11", "+AmodR12", "+AmodR13", "+AmodR14", "+AmodR15", "+AmodR16", "+ABmodR1", "+ABmodR2", "+ABmodR3", "+ABmodR4", "+ABmodR5", "+ABmodR6", "+ABmodR7", "+ABmodR8", "+ABmodR9", "+ABmodR10", "+ABmodR11", "+ABmodR12", "+ABmodR13", "+ABmodR14", "+ABmodR15", "+ABmodR16", "+=AA1", "+=AA2", "+=AA3", "+=AA4", "+=AA5", "+=AA6", "+=AA7", "+=AA8", "+=AA9", "+=AA10", "+=AA11", "+=AA12", "+=AA13", "+=AA14", "+=AA15", "+=AA16", "^=A1", "^=A2", "^=A3", "^=A4", "^=A5", "^=A6", "^=A7", "^=A8", "^=A9", "^=A10", "^=A11", "^=A12", "^=A13", "^=A14", "^=A15", "^=A16", "sub2", "sub3", "sub4", "sub5", "sub6", "sub7", "sub8", "sub9", "sub10", "sub11", "sub12", "sub13", "sub14", "sub15", "sub16", "-=A1", "-=A2", "-=A3", "-=A4", "-=A5", "-=A6", "-=A7", "-=A8", "-=A9", "-=A10", "-=A11", "-=A12", "-=A13", "-=A14", "-=A15", "-=A16", "-AmodR1", "-AmodR2", "-AmodR3", "-AmodR4", "-AmodR5", "-AmodR6", "-AmodR7", "-AmodR8", "-AmodR9", "-AmodR10", "-AmodR11", "-AmodR12", "-AmodR13", "-AmodR14", "-AmodR15", "-AmodR16", "-ABmodR1", "-ABmodR2", "-ABmodR3", "-ABmodR4", "-ABmodR5", "-ABmodR6", "-ABmodR7", "-ABmodR8", "-ABmodR9", "-ABmodR10", "-ABmodR11", "-ABmodR12", "-ABmodR13", "-ABmodR14", "-ABmodR15", "-ABmodR16", "-=AA1", "-=AA2", "-=AA3", "-=AA4", "-=AA5", "-=AA6", "-=AA7", "-=AA8", "-=AA9", "-=AA10", "-=AA11", "-=AA12", "-=AA13", "-=AA14", "-=AA15", "-=AA16", "*A1", "*A2", "*A3", "*A4", "*A5", "*A6", "*A7", "*A8", "*A9", "*A10", "*A11", "*A12", "*A13", "*A14", "*A15", "*A16", "/A1", "/A2", "/A3", "/A4", "/A5", "/A6", "/A7", "/A8", "/A9", "/A10", "/A11", "/A12", "/A13", "/A14", "/A15", "/A16", "*AmodR1", "*AmodR2", "*AmodR3", "*AmodR4", "*AmodR5", "*AmodR6", "*AmodR7", "*AmodR8", "*AmodR9", "*AmodR10", "*AmodR11", "*AmodR12", "*AmodR13", "*AmodR14", "*AmodR15", "*AmodR16", "/AmodR1", "/AmodR2", "/AmodR3", "/AmodR4", "/AmodR5", "/AmodR6", "/AmodR7", "/AmodR8", "/AmodR9", "/AmodR10", "/AmodR11", "/AmodR12", "/AmodR13", "/AmodR14", "/AmodR15", "/AmodR16", "*BToAmodR1", "*BToAmodR2", "*BToAmodR3", "*BToAmodR4", "*BToAmodR5", "*BToAmodR6", "*BToAmodR7", "*BToAmodR8", "*BToAmodR9", "*BToAmodR10", "*BToAmodR11", "*BToAmodR12", "*BToAmodR13", "*BToAmodR14", "*BToAmodR15", "*BToAmodR16", "/BToAmodR1", "/BToAmodR2", "/BToAmodR3", "/BToAmodR4", "/BToAmodR5", "/BToAmodR6", "/BToAmodR7", "/BToAmodR8", "/BToAmodR9", "/BToAmodR10", "/BToAmodR11", "/BToAmodR12", "/BToAmodR13", "/BToAmodR14", "/BToAmodR15", "/BToAmodR16", "+cntA1", "+cntA2", "+cntA3", "+cntA4", "+cntA5", "+cntA6", "+cntA7", "+cntA8", "+cntA9", "+cntA10", "+cntA11", "+cntA12", "+cntA13", "+cntA14", "+cntA15", "+cntA16", "-cntA1", "-cntA2", "-cntA3", "-cntA4", "-cntA5", "-cntA6", "-cntA7", "-cntA8", "-cntA9", "-cntA10", "-cntA11", "-cntA12", "-cntA13", "-cntA14", "-cntA15", "-cntA16", "^A<B", "^A>B", "^A<=B", "^A>=B", "^A=B", "^A!=B", "X^⌈t⌉", "X^⌈t-¼⌉", "Counting1", "Counting2", "Counting3", "Counting4", "Counting5", "Counting6", "Counting7", "Counting8", "Counting9", "Counting10", "Counting11", "Counting12", "Counting13", "Counting14", "Counting15", "Counting16", "Uncounting1", "Uncounting2", "Uncounting3", "Uncounting4", "Uncounting5", "Uncounting6", "Uncounting7", "Uncounting8", "Uncounting9", "Uncounting10", "Uncounting11", "Uncounting12", "Uncounting13", "Uncounting14", "Uncounting15", "Uncounting16", ">>t2", ">>t3", ">>t4", ">>t5", ">>t6", ">>t7", ">>t8", ">>t9", ">>t10", ">>t11", ">>t12", ">>t13", ">>t14", ">>t15", ">>t16", "<<t2", "<<t3", "<<t4", "<<t5", "<<t6", "<<t7", "<<t8", "<<t9", "<<t10", "<<t11", "<<t12", "<<t13", "<<t14", "<<t15", "<<t16", "<<2", "<<3", "<<4", "<<5", "<<6", "<<7", "<<8", "<<9", "<<10", "<<11", "<<12", "<<13", "<<14", "<<15", "<<16", ">>2", ">>3", ">>4", ">>5", ">>6", ">>7", ">>8", ">>9", ">>10", ">>11", ">>12", ">>13", ">>14", ">>15", ">>16", "QFT1", "QFT2", "QFT3", "QFT4", "QFT5", "QFT6", "QFT7", "QFT8", "QFT9", "QFT10", "QFT11", "QFT12", "QFT13", "QFT14", "QFT15", "QFT16", "QFT†1", "QFT†2", "QFT†3", "QFT†4", "QFT†5", "QFT†6", "QFT†7", "QFT†8", "QFT†9", "QFT†10", "QFT†11", "QFT†12", "QFT†13", "QFT†14", "QFT†15", "QFT†16", "c+=ab3", "c+=ab4", "c+=ab5", "c+=ab6", "c+=ab7", "c+=ab8", "c+=ab9", "c+=ab10", "c+=ab11", "c+=ab12", "c+=ab13", "c+=ab14", "c+=ab15", "c+=ab16", "c-=ab3", "c-=ab4", "c-=ab5", "c-=ab6", "c-=ab7", "c-=ab8", "c-=ab9", "c-=ab10", "c-=ab11", "c-=ab12", "c-=ab13", "c-=ab14", "c-=ab15", "c-=ab16", "+=AB1", "+=AB2", "+=AB3", "+=AB4", "+=AB5", "+=AB6", "+=AB7", "+=AB8", "+=AB9", "+=AB10", "+=AB11", "+=AB12", "+=AB13", "+=AB14", "+=AB15", "+=AB16", "-=AB1", "-=AB2", "-=AB3", "-=AB4", "-=AB5", "-=AB6", "-=AB7", "-=AB8", "-=AB9", "-=AB10", "-=AB11", "-=AB12", "-=AB13", "-=AB14", "-=AB15", "-=AB16", "PhaseGradient1", "PhaseGradient2", "PhaseGradient3", "PhaseGradient4", "PhaseGradient5", "PhaseGradient6", "PhaseGradient7", "PhaseGradient8", "PhaseGradient9", "PhaseGradient10", "PhaseGradient11", "PhaseGradient12", "PhaseGradient13", "PhaseGradient14", "PhaseGradient15", "PhaseGradient16", "PhaseUngradient1", "PhaseUngradient2", "PhaseUngradient3", "PhaseUngradient4", "PhaseUngradient5", "PhaseUngradient6", "PhaseUngradient7", "PhaseUngradient8", "PhaseUngradient9", "PhaseUngradient10", "PhaseUngradient11", "PhaseUngradient12", "PhaseUngradient13", "PhaseUngradient14", "PhaseUngradient15", "PhaseUngradient16", "Flip<A1", "Flip<A2", "Flip<A3", "Flip<A4", "Flip<A5", "Flip<A6", "Flip<A7", "Flip<A8", "Flip<A9", "Flip<A10", "Flip<A11", "Flip<A12", "Flip<A13", "Flip<A14", "Flip<A15", "Flip<A16", "rev2", "rev3", "rev4", "rev5", "rev6", "rev7", "rev8", "rev9", "rev10", "rev11", "rev12", "rev13", "rev14", "rev15", "rev16", "weave4", "weave5", "weave6", "weave7", "weave8", "weave9", "weave10", "weave11", "weave12", "weave13", "weave14", "weave15", "weave16", "split4", "split5", "split6", "split7", "split8", "split9", "split10", "split11", "split12", "split13", "split14", "split15", "split16", "grad^t1", "grad^t2", "grad^t3", "grad^t4", "grad^t5", "grad^t6", "grad^t7", "grad^t8", "grad^t9", "grad^t10", "grad^t11", "grad^t12", "grad^t13", "grad^t14", "grad^t15", "grad^t16", "grad^-t1", "grad^-t2", "grad^-t3", "grad^-t4", "grad^-t5", "grad^-t6", "grad^-t7", "grad^-t8", "grad^-t9", "grad^-t10", "grad^-t11", "grad^-t12", "grad^-t13", "grad^-t14", "grad^-t15", "grad^-t16"];
  suite.test("known_gates_backwards_compatible", function() {
    var knownIds = new Set(Gates.KnownToSerializer.map(function(e) {
      return e.serializedId;
    }));
    knownIds.add(MysteryGateMaker().serializedId);
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (IDS_THAT_SHOULD_BE_KNOWN)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var id = $__2.value;
        {
          assertThat(knownIds.has(id)).withInfo(id).isEqualTo(true);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.test("known_gates_forward_compatible", function(meta) {
    var shouldBeKnownIds = new Set(IDS_THAT_SHOULD_BE_KNOWN);
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer.map(function(e) {
            return e.serializedId;
          }))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var id = $__2.value;
        {
          if (id.startsWith("__unstable__")) {
            continue;
          }
          meta.warn_only = "New id: " + id;
          assertThat(shouldBeKnownIds.has(id)).withInfo(id).isEqualTo(true);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    meta.warn_only = false;
  });
  suite.test("parse_nested_circuits", function() {
    var json = {
      cols: [["H"], ["•", "X"], ["~oc3t"], ["~qoc2"]],
      gates: [{
        id: "~oc3t",
        circuit: {cols: [["H"], ["•", "X"]]}
      }, {
        id: "~v9rj",
        circuit: {cols: [["H"], ["•", "X"], ["~oc3t"]]}
      }, {
        id: "~qoc2",
        circuit: {"cols": [["H"], ["•", "X"], ["~oc3t"]]}
      }]
    };
    var circuitDef = Serializer.fromJson(CircuitDefinition, json);
    var reJson = Serializer.toJson(circuitDef);
    assertThat(JSON.stringify(reJson)).isEqualTo(JSON.stringify(json));
  });
  suite.test("known_gates_toolbox", function() {
    var allToolboxGates = seq(Gates.TopToolboxGroups).concat(Gates.BottomToolboxGroups).flatMap(function(e) {
      return e.gates;
    }).filter(function(e) {
      return e !== undefined;
    }).flatMap(function(e) {
      return e.gateFamily;
    }).toArray();
    var knownIds = new Set(Gates.KnownToSerializer.map(function(e) {
      return e.serializedId;
    }));
    knownIds.add(MysteryGateMaker().serializedId);
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (allToolboxGates)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var gate = $__2.value;
        {
          assertThat(knownIds.has(gate.serializedId)).withInfo(gate).isEqualTo(true);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  return {};
});
//# sourceURL=test/circuit/Serializer.test.js
;$traceurRuntime.registerModule("test/CircuitOperationTestUtil.js", [], function() {
  "use strict";
  var __moduleName = "test/CircuitOperationTestUtil.js";
  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TestUtil.js", "test/CircuitOperationTestUtil.js")),
      assertThat = $__13.assertThat,
      assertTrue = $__13.assertTrue;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/CircuitComputeUtil.js", "test/CircuitOperationTestUtil.js")).advanceStateWithCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/CircuitDefinition.js", "test/CircuitOperationTestUtil.js")).CircuitDefinition;
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/CircuitEvalContext.js", "test/CircuitOperationTestUtil.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/CircuitShaders.js", "test/CircuitOperationTestUtil.js")).CircuitShaders;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/CircuitStats.js", "test/CircuitOperationTestUtil.js")).CircuitStats;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/math/Complex.js", "test/CircuitOperationTestUtil.js")).Complex;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/Controls.js", "test/CircuitOperationTestUtil.js")).Controls;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/GateColumn.js", "test/CircuitOperationTestUtil.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/gates/AllGates.js", "test/CircuitOperationTestUtil.js")).Gates;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/webgl/Shaders.js", "test/CircuitOperationTestUtil.js")).Shaders;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/math/Matrix.js", "test/CircuitOperationTestUtil.js")).Matrix;
  var KetTextureUtil = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/circuit/KetTextureUtil.js", "test/CircuitOperationTestUtil.js")).KetTextureUtil;
  var $__26 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/base/Seq.js", "test/CircuitOperationTestUtil.js")),
      seq = $__26.seq,
      Seq = $__26.Seq;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/webgl/WglTextureTrader.js", "test/CircuitOperationTestUtil.js")).WglTextureTrader;
  var USE_SIMPLE_VALUES = false;
  if (USE_SIMPLE_VALUES) {
    console.warn("Using simplified random values for circuit operation testing.");
  }
  function assertThatCircuitOutputsBasisKet(circuit, expected_output) {
    var stats = CircuitStats.fromCircuitAtTime(circuit, 0);
    assertThat(stats.finalState.hasNaN()).isEqualTo(false);
    var actualOut = Seq.range(stats.finalState.height()).filter(function(i) {
      return stats.finalState.cell(0, i).isEqualTo(1);
    }).first('no solo ket found');
    assertThat(actualOut).isEqualTo(expected_output);
    var b = stats.finalState.rawBuffer();
    for (var i = 0; i < b.length; i++) {
      if (i !== expected_output * 2) {
        assertThat(b[i]).withInfo({i: i}).isEqualTo(0);
      }
    }
  }
  function assertThatCircuitShaderActsLikeMatrix(shaderFunc, matrix) {
    var repeats = arguments[2] !== (void 0) ? arguments[2] : 5;
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return ctx.applyOperation(shaderFunc);
    }, matrix, repeats);
  }
  function assertThatGateActsLikePermutation(gate, permutationFunc) {
    var $__9,
        $__10;
    var inputSpans = arguments[2] !== (void 0) ? arguments[2] : [];
    var ignoreTargetEndsUpDisabled = arguments[3] !== (void 0) ? arguments[3] : false;
    var inputGates = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = ([['Input Range A', Gates.InputGates.InputAFamily], ['Input Range B', Gates.InputGates.InputBFamily], ['Input Range R', Gates.InputGates.InputRFamily]])[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var $__8 = $__2.value,
            key = ($__9 = $__8[Symbol.iterator](), ($__10 = $__9.next()).done ? void 0 : $__10.value),
            inputGate = ($__10 = $__9.next()).done ? void 0 : $__10.value;
        {
          if (gate.getUnmetContextKeys().has(key)) {
            inputGates.push(inputGate.ofSize(inputSpans[inputGates.length]));
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    inputSpans = inputSpans.slice(0, inputGates.length);
    var dstWire = 0;
    var wireCount = dstWire + gate.height;
    var inpWires = new Array(inputGates.length);
    for (var i = 0; i < inputGates.length; i++) {
      if (Math.random() < 0.2) {
        wireCount += 1;
      }
      inpWires[i] = wireCount;
      wireCount += inputGates[i].height;
    }
    var dstMask = ((1 << gate.height) - 1) << dstWire;
    var inpMasks = seq(inpWires).zip(inputGates, function(off, g) {
      return ((1 << g.height) - 1) << off;
    }).toArray();
    var fullPermutation = function(val) {
      var dst = (val & dstMask) >> dstWire;
      var inps = seq(inpMasks).zip(inpWires, function(m, w) {
        return (val & m) >> w;
      }).toArray();
      var out = permutationFunc.apply((void 0), $traceurRuntime.spread([dst], inps));
      return (val & ~dstMask) | out;
    };
    var col = new Array(wireCount).fill(undefined);
    for (var i$__11 = 0; i$__11 < inputSpans.length; i$__11++) {
      col[inpWires[i$__11]] = inputGates[i$__11];
    }
    col[dstWire] = gate;
    var circuit = new CircuitDefinition(wireCount, [new GateColumn(col)]);
    if (circuit.gateAtLocIsDisabledReason(0, 0) !== undefined) {
      if (ignoreTargetEndsUpDisabled) {
        return;
      }
      assertThat(circuit.gateAtLocIsDisabledReason(0, 0)).withInfo({gate: gate}).isEqualTo(undefined);
    }
    var updateAction = function(ctx) {
      return advanceStateWithCircuit(ctx, circuit, false);
    };
    assertThatCircuitUpdateActsLikePermutation(wireCount, updateAction, fullPermutation, {
      gate_id: gate.serializedId,
      dstWire: dstWire,
      inpWires: inpWires,
      inputSpans: inputSpans
    });
  }
  function assertThatGateActsLikePhaser(gate, phaserFunc) {
    var forcedTime = arguments[2];
    var wireCount = gate.height;
    var col = new Array(wireCount).fill(undefined);
    col[0] = gate;
    var circuit = new CircuitDefinition(wireCount, [new GateColumn(col)]);
    var matrix = Matrix.generateDiagonal(1 << wireCount, function(k) {
      return Complex.polar(1, phaserFunc(k) * Math.PI * 2);
    });
    var updateAction = function(ctx) {
      return advanceStateWithCircuit(ctx, circuit, false);
    };
    assertThatCircuitMutationActsLikeMatrix_single(updateAction, matrix, forcedTime);
  }
  function assertThatCircuitUpdateActsLikeMatrix(updateAction, matrix) {
    var repeats = arguments[2] !== (void 0) ? arguments[2] : 5;
    var forcedTime = arguments[3];
    for (var i = 0; i < repeats; i++) {
      assertThatCircuitMutationActsLikeMatrix_single(updateAction, matrix, forcedTime);
    }
  }
  function assertThatCircuitMutationActsLikeMatrix_single(updateAction, matrix) {
    var forcedTime = arguments[2];
    var qubitSpan = Math.round(Math.log2(matrix.height()));
    var extraWires = Math.floor(Math.random() * 5);
    var time = Math.random();
    var qubitIndex = Math.floor(Math.random() * extraWires);
    if (USE_SIMPLE_VALUES) {
      extraWires = 0;
      time = 0;
      qubitIndex = 0;
    }
    if (forcedTime !== undefined) {
      time = forcedTime;
    }
    var wireCount = qubitSpan + extraWires;
    var controls = Controls.NONE;
    for (var i = 0; i < extraWires; i++) {
      if (Math.random() < 0.5) {
        controls = controls.and(Controls.bit(i + (i < qubitIndex ? 0 : qubitSpan), Math.random() < 0.5));
      }
    }
    var ampCount = 1 << wireCount;
    var inVec = Matrix.generate(1, ampCount, function() {
      return USE_SIMPLE_VALUES ? (Math.random() < 0.5 ? 1 : 0) : new Complex(Math.random() * 10 - 5, Math.random() * 10 - 5);
    });
    var tex = Shaders.vec2Data(inVec.rawBuffer()).toVec2Texture(wireCount);
    var trader = new WglTextureTrader(tex);
    var controlsTexture = CircuitShaders.controlMask(controls).toBoolTexture(wireCount);
    var ctx = new CircuitEvalContext(time, qubitIndex, wireCount, controls, controlsTexture, controls, trader, new Map());
    updateAction(ctx);
    controlsTexture.deallocByDepositingInPool();
    var outData = KetTextureUtil.tradeTextureForVec2Output(trader);
    var outVec = new Matrix(1, ampCount, outData);
    var expectedOutVec = matrix.applyToStateVectorAtQubitWithControls(inVec, qubitIndex, controls);
    assertThat(outVec).withInfo({
      matrix: matrix,
      inVec: inVec,
      ctx: ctx
    }).isApproximatelyEqualTo(expectedOutVec, 0.005);
  }
  function assertThatCircuitShaderActsLikePermutation(wireCount, shaderMaker, permutation) {
    var permuteInfo = arguments[3];
    assertThatCircuitUpdateActsLikePermutation(wireCount, function(ctx) {
      return ctx.applyOperation(shaderMaker(ctx));
    }, permutation, permuteInfo);
  }
  function assertThatCircuitUpdateActsLikePermutation(wireCount, updateAction, permutation) {
    var permuteInfo = arguments[3];
    var time = Math.random();
    var ampCount = 1 << wireCount;
    var inVec = Matrix.generate(1, ampCount, function(r) {
      return new Complex(r + Math.random(), Math.random() * 1000);
    });
    var tex = Shaders.vec2Data(inVec.rawBuffer()).toVec2Texture(wireCount);
    var trader = new WglTextureTrader(tex);
    var controlsTexture = CircuitShaders.controlMask(Controls.NONE).toBoolTexture(wireCount);
    var ctx = new CircuitEvalContext(time, 0, wireCount, Controls.NONE, controlsTexture, Controls.NONE, trader, new Map());
    updateAction(ctx);
    controlsTexture.deallocByDepositingInPool();
    var outData = KetTextureUtil.tradeTextureForVec2Output(trader);
    var outVec = new Matrix(1, ampCount, outData);
    var $__12 = function(i) {
      var j = permutation(i);
      var inVal = inVec.cell(0, i);
      var outVal = outVec.cell(0, j);
      if (!outVal.isApproximatelyEqualTo(inVal, 0.001)) {
        var actualIn = Math.floor(outVec.cell(0, j).real);
        var actualOut = Seq.range(ampCount).filter(function(k) {
          return Math.floor(outVec.cell(0, k).real) === i;
        }).first('[NONE]');
        assertThat(outVal).withInfo({
          i: i,
          j: j,
          actualIn: actualIn,
          actualOut: actualOut,
          permuteInfo: permuteInfo
        }).isApproximatelyEqualTo(inVal, 0.01);
      }
    };
    for (var i = 0; i < ampCount; i++) {
      $__12(i);
    }
    assertTrue(true);
  }
  return {
    get assertThatCircuitUpdateActsLikeMatrix() {
      return assertThatCircuitUpdateActsLikeMatrix;
    },
    get assertThatCircuitShaderActsLikeMatrix() {
      return assertThatCircuitShaderActsLikeMatrix;
    },
    get assertThatGateActsLikePermutation() {
      return assertThatGateActsLikePermutation;
    },
    get assertThatCircuitOutputsBasisKet() {
      return assertThatCircuitOutputsBasisKet;
    },
    get assertThatCircuitUpdateActsLikePermutation() {
      return assertThatCircuitUpdateActsLikePermutation;
    },
    get assertThatCircuitShaderActsLikePermutation() {
      return assertThatCircuitShaderActsLikePermutation;
    },
    get assertThatGateActsLikePhaser() {
      return assertThatGateActsLikePhaser;
    }
  };
});
//# sourceURL=test/CircuitOperationTestUtil.js
;$traceurRuntime.registerModule("test/gates/AllGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/AllGates.test.js";
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/AllGates.test.js")),
      Suite = $__8.Suite,
      assertThat = $__8.assertThat;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/AllGates.test.js")).Gates;
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitEvalContext.js", "test/gates/AllGates.test.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitShaders.js", "test/gates/AllGates.test.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/gates/AllGates.test.js")).Controls;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/AllGates.test.js")).Matrix;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Gate.js", "test/gates/AllGates.test.js")).Gate;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/gates/AllGates.test.js")).seq;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTextureTrader.js", "test/gates/AllGates.test.js")).WglTextureTrader;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/gates/AllGates.test.js")).currentShaderCoder;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/AllGates.test.js")),
      assertThatGateActsLikePermutation = $__18.assertThatGateActsLikePermutation,
      assertThatGateActsLikePhaser = $__18.assertThatGateActsLikePhaser;
  var suite = new Suite("AllGates");
  var reconstructMatrixFromGateCustomOperation = function(gate, time) {
    if (gate.customOperation === undefined) {
      return undefined;
    }
    var bit = 0;
    var numQubits = gate.height;
    var n = 1 << numQubits;
    var control = CircuitShaders.controlMask(Controls.NONE).toBoolTexture(numQubits);
    var cols = [];
    for (var i = 0; i < n; i++) {
      var trader = new WglTextureTrader(CircuitShaders.classicalState(i).toVec2Texture(numQubits));
      var ctx = new CircuitEvalContext(time, bit, numQubits, Controls.NONE, control, Controls.NONE, trader, new Map());
      gate.customOperation(ctx);
      var buf = currentShaderCoder().vec2.pixelsToData(trader.currentTexture.readPixels());
      var col = new Matrix(1, 1 << numQubits, buf);
      trader.currentTexture.deallocByDepositingInPool();
      cols.push(col);
    }
    control.deallocByDepositingInPool();
    var raw = seq(cols).flatMap(function(e) {
      return e.rawBuffer();
    }).toFloat32Array();
    var flipped = new Matrix(n, n, raw);
    return flipped.transpose();
  };
  var reconstructMatrixFromKnownBitPermutation = function(gate) {
    return Matrix.generateTransition(1 << gate.height, function(input) {
      var out = 0;
      for (var i = 0; i < gate.height; i++) {
        if ((input & (1 << i)) !== 0) {
          out |= 1 << gate.knownBitPermutationFunc(i);
        }
      }
      return out;
    });
  };
  suite.test("allGatesAreGates", function() {
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var gate = $__2.value;
        {
          assertThat(gate instanceof Gate).withInfo({
            gate: gate,
            type: (typeof gate === 'undefined' ? 'undefined' : $traceurRuntime.typeof(gate))
          }).isEqualTo(true);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.testUsingWebGL("customShaderMatchesKnownMatrix", function() {
    var time = 6 / 7;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var gate = $__2.value;
        {
          if (gate.height > 4) {
            continue;
          }
          var matrix = gate.knownMatrixAt(time);
          if (matrix === undefined) {
            continue;
          }
          var reconstructed = reconstructMatrixFromGateCustomOperation(gate, time);
          if (reconstructed === undefined) {
            continue;
          }
          assertThat(reconstructed).withInfo({
            gate: gate,
            time: time
          }).isApproximatelyEqualTo(matrix, 0.0005);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.testUsingWebGL("knownBitPermutationMatchesKnowMatrixAndCustomShader", function() {
    var time = 6 / 7;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var gate = $__2.value;
        {
          if (gate.height > 6 || gate.knownBitPermutationFunc === undefined) {
            continue;
          }
          var permuteBitsMatrix = reconstructMatrixFromKnownBitPermutation(gate);
          var knownMatrix = gate.knownMatrixAt(time);
          if (knownMatrix !== undefined) {
            assertThat(knownMatrix).withInfo(gate).isEqualTo(permuteBitsMatrix);
          }
          var shaderMatrix = reconstructMatrixFromGateCustomOperation(gate, time);
          if (shaderMatrix !== undefined) {
            assertThat(shaderMatrix).withInfo(gate).isEqualTo(permuteBitsMatrix);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.testUsingWebGL("gatesActLikeTheirKnownPermutation", function() {
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var gate = $__2.value;
        {
          if (gate.knownPermutationFuncTakingInputs !== undefined && gate.height <= 3) {
            assertThatGateActsLikePermutation(gate, gate.knownPermutationFuncTakingInputs, [2, 2, 2], true);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.testUsingWebGL("gatesActLikeTheirKnownPhasingFunction", function() {
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Gates.KnownToSerializer)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var gate = $__2.value;
        {
          if (gate.knownPhaseTurnsFunc !== undefined && gate.height <= 3) {
            assertThatGateActsLikePhaser(gate, gate.knownPhaseTurnsFunc);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.test("knownNonUnitaryGates", function() {
    var nonUnitaryGates = new Set(Gates.KnownToSerializer.filter(function(g) {
      return !g.isDefinitelyUnitary();
    }).map(function(g) {
      return g.serializedId;
    }));
    assertThat(nonUnitaryGates).isEqualTo(new Set(['__error__', '__unstable__UniversalNot', '0', '|0⟩⟨0|', '|1⟩⟨1|', '|+⟩⟨+|', '|-⟩⟨-|', '|X⟩⟨X|', '|/⟩⟨/|', 'XDetector', 'YDetector', 'ZDetector', 'XDetectControlReset', 'YDetectControlReset', 'ZDetectControlReset']));
  });
  suite.test("knownDoNothingGateFamilies", function() {
    var doNothingFamilies = new Set(Gates.KnownToSerializer.filter(function(g) {
      return g.definitelyHasNoEffect();
    }).map(function(g) {
      return g.gateFamily[0].serializedId;
    }));
    assertThat(doNothingFamilies).isEqualTo(new Set(['Measure', '•', '◦', 'zpar', 'inputA1', 'inputB1', 'inputR1', 'revinputA1', 'revinputB1', 'setA', 'setB', 'setR', 'Amps1', 'Chance', 'Sample1', 'Density', 'Bloch', '…']));
  });
  suite.test("knownDynamicGateFamilies", function() {
    var dynamicFamilies = new Set(Gates.KnownToSerializer.filter(function(g) {
      return g.stableDuration() !== Infinity;
    }).map(function(g) {
      return g.gateFamily[0].serializedId;
    }));
    assertThat(dynamicFamilies).isEqualTo(new Set(['Sample1', 'X^t', 'Y^t', 'Z^t', 'X^-t', 'Y^-t', 'Z^-t', 'X^ft', 'Y^ft', 'Z^ft', 'Rxft', 'Ryft', 'Rzft', 'e^iXt', 'e^iYt', 'e^iZt', 'e^-iXt', 'e^-iYt', 'e^-iZt', 'Counting1', 'Uncounting1', '>>t2', '<<t2', 'X^⌈t⌉', 'X^⌈t-¼⌉', 'grad^t1', 'grad^-t1', 'XDetector', 'YDetector', 'ZDetector', 'XDetectControlReset', 'YDetectControlReset', 'ZDetectControlReset']));
  });
  return {};
});
//# sourceURL=test/gates/AllGates.test.js
;$traceurRuntime.registerModule("test/gates/AmplitudeDisplay.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/AmplitudeDisplay.test.js";
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/AmplitudeDisplay.test.js")),
      Suite = $__4.Suite,
      assertThat = $__4.assertThat;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AmplitudeDisplay.js", "test/gates/AmplitudeDisplay.test.js")),
      amplitudeDisplayStatTextures = $__5.amplitudeDisplayStatTextures,
      AMPS_TO_SQUARED_MAGS_SHADER = $__5.AMPS_TO_SQUARED_MAGS_SHADER,
      MAGS_TO_INDEXED_MAGS_SHADER = $__5.MAGS_TO_INDEXED_MAGS_SHADER,
      FOLD_MAX_INDEXED_MAG_SHADER = $__5.FOLD_MAX_INDEXED_MAG_SHADER,
      LOOKUP_KET_AT_INDEXED_MAG_SHADER = $__5.LOOKUP_KET_AT_INDEXED_MAG_SHADER,
      POINTWISE_CMUL_CONJ_SHADER = $__5.POINTWISE_CMUL_CONJ_SHADER;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/gates/AmplitudeDisplay.test.js")).Complex;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/gates/AmplitudeDisplay.test.js")).Controls;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/AmplitudeDisplay.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/AmplitudeDisplay.test.js")).CircuitStats;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitShaders.js", "test/gates/AmplitudeDisplay.test.js")).CircuitShaders;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Serializer.js", "test/gates/AmplitudeDisplay.test.js")).Serializer;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/gates/AmplitudeDisplay.test.js")).seq;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/gates/AmplitudeDisplay.test.js")).Shaders;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/gates/AmplitudeDisplay.test.js")).currentShaderCoder;
  var suite = new Suite("AmplitudeDisplay");
  suite.testUsingWebGL("AMPS_TO_SQUARED_MAGS_SHADER", function() {
    var input = Shaders.vec2Data(new Float32Array([1, 0, 3, 4, -1, 1, 0, 0.5])).toVec2Texture(2);
    assertThat(AMPS_TO_SQUARED_MAGS_SHADER(input).readVecFloatOutputs(2)).isApproximatelyEqualTo(new Float32Array([1, 25, 2, 0.25]), 0.001);
    input.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("MAGS_TO_INDEXED_MAGS_SHADER", function() {
    var input = Shaders.floatData(new Float32Array([2, 3, 5, 7])).toVecFloatTexture(2);
    assertThat(MAGS_TO_INDEXED_MAGS_SHADER(input).readVec2Outputs(2)).isApproximatelyEqualTo(new Float32Array([0, 2, 1, 3, 2, 5, 3, 7]), 0.001);
    input.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("FOLD_MAX_INDEXED_MAG_SHADER", function() {
    var input = Shaders.vec2Data(new Float32Array([0, 4.2, 8, 2.1, 13, 1.5, 23, 3.3])).toVec2Texture(2);
    assertThat(FOLD_MAX_INDEXED_MAG_SHADER(input).readVec2Outputs(1)).isApproximatelyEqualTo(new Float32Array([0, 4.2, 23, 3.3]), 0.001);
    input.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("LOOKUP_KET_AT_INDEXED_MAG_SHADER", function() {
    var input = Shaders.vec2Data(new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 2, 3, 5, 7, 11, 13, 17, 19, 0, 1, 4, 9, 16, 25, 36, 49, 1, 2, 4, 8, 16, 32, 64, 128])).toVec2Texture(4);
    var index = Shaders.vec2Data(new Float32Array([1, 5000.3])).toVec2Texture(0);
    assertThat(LOOKUP_KET_AT_INDEXED_MAG_SHADER(input, index).readVec2Outputs(2)).isApproximatelyEqualTo(new Float32Array([2, 3, 5, 7, 11, 13, 17, 19]), 0.001);
    index.deallocByDepositingInPool();
    input.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("POINTWISE_CMUL_CONJ_SHADER", function() {
    var small_input = Shaders.vec2Data(new Float32Array([1, 2])).toVec2Texture(0);
    var large_input = Shaders.vec2Data(new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 2, 3, 5, 7, 11, 13, 17, 19, 0, 1, 4, 9, 16, 25, 36, 49, 1, 2, 4, 8, 16, 32, 64, 128])).toVec2Texture(4);
    assertThat(POINTWISE_CMUL_CONJ_SHADER(small_input, large_input).readVec2Outputs(4)).isApproximatelyEqualTo(new Float32Array([2, 1, 8, -1, 14, -3, 20, -5, 8, -1, 19, -3, 37, -9, 55, -15, 2, 1, 22, 1, 66, -7, 134, -23, 5, 0, 20, 0, 80, 0, 320, 0]), 0.001);
    small_input.deallocByDepositingInPool();
    large_input.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("makeAmplitudeSpanPipeline_coherent", function() {
    var $__2,
        $__3;
    var inp = Shaders.vec2Data(new Float32Array([0.6, 0.8, 0, 0, 0, 0, 0, 0])).toVec2Texture(2);
    var controlTex = CircuitShaders.controlMask(Controls.NONE).toBoolTexture(2);
    var $__1 = amplitudeDisplayStatTextures(inp, Controls.NONE, controlTex, 0, 2),
        ketData = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
        qualityData = ($__3 = $__2.next()).done ? void 0 : $__3.value,
        incoherentKetData = ($__3 = $__2.next()).done ? void 0 : $__3.value;
    var ket = currentShaderCoder().vec4.pixelsToData(ketData.readPixels());
    var quality = currentShaderCoder().float.pixelsToData(qualityData.readPixels());
    var incoherentKet = currentShaderCoder().vec4.pixelsToData(incoherentKetData.readPixels());
    assertThat(ket).isApproximatelyEqualTo(new Float32Array([0.6, 0.8, 0, 0, 0, 0, 0, 0]));
    assertThat(incoherentKet).isApproximatelyEqualTo(new Float32Array([1, 0, 0, 0]));
    assertThat(quality).isApproximatelyEqualTo(new Float32Array([1]));
    inp.deallocByDepositingInPool();
    controlTex.deallocByDepositingInPool();
    ketData.deallocByDepositingInPool();
    qualityData.deallocByDepositingInPool();
    incoherentKetData.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("AmplitudesDisplayWithOtherQubit_Minus", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      cols: [["Amps2"]],
      init: [0, 0, "-"]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.ket).isApproximatelyEqualTo([{
      r: 1,
      i: 0
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }]);
    assertThat(out.displays[0].data.coherence_measure).isApproximatelyEqualTo(1);
  });
  suite.testUsingWebGL("AmplitudesDisplayWithOtherQubit_i", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      cols: [["Amps2"]],
      init: [0, 0, "i"]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.ket).isApproximatelyEqualTo([{
      r: 1,
      i: 0
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }]);
    assertThat(out.displays[0].data.coherence_measure).isApproximatelyEqualTo(1);
  });
  suite.testUsingWebGL("AmplitudesDisplayWithOtherQubit_postselect", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      cols: [["Amps2", 1, "|0⟩⟨0|"]],
      init: [0, 0, "+"]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.ket).isApproximatelyEqualTo([{
      r: 1,
      i: 0
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }]);
    assertThat(out.displays[0].data.coherence_measure).isApproximatelyEqualTo(1);
  });
  suite.testUsingWebGL("AmplitudesDisplayWithOtherQubit_own_i", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      cols: [["Amps2"]],
      init: ["i", 0, 1]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.ket).isApproximatelyEqualTo([{
      r: Math.sqrt(0.5),
      i: 0
    }, {
      r: 0,
      i: Math.sqrt(0.5)
    }, {
      r: 0,
      i: 0
    }, {
      r: 0,
      i: 0
    }]);
    assertThat(out.displays[0].data.coherence_measure).isApproximatelyEqualTo(1);
  });
  suite.testUsingWebGL("AmplitudesDisplayIncoherent_sqrt_x", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      cols: [[1, "•", "X^½"], ["Amps2"]],
      init: [0, "+", 1]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.incoherentKet).isApproximatelyEqualTo([Math.sqrt(0.5), 0, Math.sqrt(0.5), 0]);
    assertThat(out.displays[0].data.coherence_measure).isLessThan(0.85);
  });
  suite.testUsingWebGL("AmplitudesDisplayIncoherent_hadamard", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      cols: [[1, "•", "H"], ["Amps2"]],
      init: [0, "+", 1]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.incoherentKet).isApproximatelyEqualTo([Math.sqrt(0.5), 0, Math.sqrt(0.5), 0]);
    assertThat(out.displays[0].data.coherence_measure).isLessThan(0.85);
  });
  suite.testUsingWebGL("AmplitudesDisplayIncoherent_conditioned", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {
      "cols": [[1, "•", "Z"], ["•", "Amps1"]],
      "init": ["+", "+", "+"]
    }), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.incoherentKet).isApproximatelyEqualTo([Math.sqrt(0.5), Math.sqrt(0.5)]);
    assertThat(out.displays[0].data.coherence_measure).isLessThan(0.85);
  });
  return {};
});
//# sourceURL=test/gates/AmplitudeDisplay.test.js
;$traceurRuntime.registerModule("test/gates/ArithmeticGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ArithmeticGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ArithmeticGates.test.js")).Suite;
  var ArithmeticGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ArithmeticGates.js", "test/gates/ArithmeticGates.test.js")).ArithmeticGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InputGates.js", "test/gates/ArithmeticGates.test.js")).InputGates;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/ArithmeticGates.test.js")),
      assertThatCircuitUpdateActsLikeMatrix = $__3.assertThatCircuitUpdateActsLikeMatrix,
      assertThatGateActsLikePermutation = $__3.assertThatGateActsLikePermutation;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/ArithmeticGates.test.js")).advanceStateWithCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/ArithmeticGates.test.js")).CircuitDefinition;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/gates/ArithmeticGates.test.js")).GateColumn;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/ArithmeticGates.test.js")).Matrix;
  var suite = new Suite("ArithmeticGates");
  suite.testUsingWebGL('plus_A', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(4, [new GateColumn([ArithmeticGates.PlusAFamily.ofSize(2), undefined, InputGates.InputAFamily.ofSize(2), undefined])]), false);
    }, Matrix.generateTransition(16, function(i) {
      var a = (i >> 2) & 3;
      var t = i & 3;
      return (a << 2) | (t + a) & 3;
    }));
  });
  suite.testUsingWebGL('minus_A', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(4, [new GateColumn([InputGates.InputAFamily.ofSize(2), undefined, ArithmeticGates.MinusAFamily.ofSize(2), undefined])]), false);
    }, Matrix.generateTransition(16, function(i) {
      var a = i & 3;
      var t = (i >> 2) & 3;
      return a | (((t - a) & 3) << 2);
    }));
  });
  suite.testUsingWebGL('plus_minus_A_like_permutation', function() {
    assertThatGateActsLikePermutation(ArithmeticGates.PlusAFamily.ofSize(3), function(t, a) {
      return (t + a) & 7;
    }, [2]);
    assertThatGateActsLikePermutation(ArithmeticGates.MinusAFamily.ofSize(3), function(t, a) {
      return (t - a) & 7;
    }, [4]);
  });
  return {};
});
//# sourceURL=test/gates/ArithmeticGates.test.js
;$traceurRuntime.registerModule("test/gates/BitCountGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/BitCountGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/BitCountGates.test.js")).Suite;
  var BitCountGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/BitCountGates.js", "test/gates/BitCountGates.test.js")).BitCountGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InputGates.js", "test/gates/BitCountGates.test.js")).InputGates;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/BitCountGates.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/BitCountGates.test.js")).advanceStateWithCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/BitCountGates.test.js")).CircuitDefinition;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/BitCountGates.test.js")).Matrix;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/gates/BitCountGates.test.js")).Util;
  var suite = new Suite("BitCountGates");
  var GATE_SET = new Map([['A', InputGates.InputAFamily], ['-', undefined], ['/', null], ['P', BitCountGates.PlusBitCountAFamily], ['M', BitCountGates.MinusBitCountAFamily]]);
  suite.testUsingWebGL('PlusBitCountA', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, CircuitDefinition.fromTextDiagram(GATE_SET, "-A-\n                 -/-\n                 -/-\n                 -P-\n                 -/-"), false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = i & 7;
      var t = (i >> 3) & 3;
      t += Util.numberOfSetBits(a);
      t &= 3;
      return a | (t << 3);
    }));
  });
  suite.testUsingWebGL('MinusBitCountA', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, CircuitDefinition.fromTextDiagram(GATE_SET, "-A-\n                 -/-\n                 -/-\n                 -M-\n                 -/-"), false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = i & 7;
      var t = (i >> 3) & 3;
      t -= Util.numberOfSetBits(a);
      t &= 3;
      return a | (t << 3);
    }));
  });
  return {};
});
//# sourceURL=test/gates/BitCountGates.test.js
;$traceurRuntime.registerModule("test/gates/ComparisonGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ComparisonGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ComparisonGates.test.js")).Suite;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/ComparisonGates.test.js")).Gates;
  var ComparisonGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ComparisonGates.js", "test/gates/ComparisonGates.test.js")).ComparisonGates;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/ComparisonGates.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/ComparisonGates.test.js")).advanceStateWithCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/ComparisonGates.test.js")).CircuitDefinition;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/ComparisonGates.test.js")).Matrix;
  var suite = new Suite("ComparisonGates");
  var circuit = function(diagram) {
    for (var extras = [],
        $__0 = 1; $__0 < arguments.length; $__0++)
      extras[$__0 - 1] = arguments[$__0];
    return CircuitDefinition.fromTextDiagram(new Map($traceurRuntime.spread(extras, [['-', undefined], ['/', null], ['A', Gates.InputGates.InputAFamily], ['B', Gates.InputGates.InputBFamily], ['•', Gates.Controls.Control], ['X', Gates.HalfTurns.X], ['Y', Gates.HalfTurns.Y], ['Z', Gates.HalfTurns.Z], ['H', Gates.HalfTurns.H]])), diagram);
  };
  suite.testUsingWebGL('A_less_than_B', function() {
    var circ = circuit("-<-\n                        ---\n                        -A-\n                        -/-\n                        -B-\n                        -/-", ['<', ComparisonGates.ALessThanB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 6, function(i) {
      var a = (i >> 2) & 3;
      var b = (i >> 4) & 3;
      var t = (i & 1) ^ (a < b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_less_than_larger_B', function() {
    var circ = circuit("-<-\n                        -A-\n                        -/-\n                        -B-\n                        -/-\n                        -/-", ['<', ComparisonGates.ALessThanB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 6, function(i) {
      var a = (i >> 1) & 3;
      var b = (i >> 3) & 7;
      var t = (i & 1) ^ (a < b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_less_than_smaller_B', function() {
    var circ = circuit("-<-\n                        -A-\n                        -/-\n                        -/-\n                        -B-\n                        -/-", ['<', ComparisonGates.ALessThanB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 6, function(i) {
      var a = (i >> 1) & 7;
      var b = (i >> 4) & 3;
      var t = (i & 1) ^ (a < b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_less_than_or_equal_to_B', function() {
    var circ = circuit("-?-\n                        -A-\n                        -/-\n                        -B-\n                        -/-", ['?', ComparisonGates.ALessThanOrEqualToB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = (i >> 1) & 3;
      var b = (i >> 3) & 3;
      var t = (i & 1) ^ (a <= b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_greater_than_B', function() {
    var circ = circuit("-?-\n                        -A-\n                        -/-\n                        -B-\n                        -/-", ['?', ComparisonGates.AGreaterThanB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = (i >> 1) & 3;
      var b = (i >> 3) & 3;
      var t = (i & 1) ^ (a > b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_greater_than_or_equal_to_B', function() {
    var circ = circuit("-?-\n                        -A-\n                        -/-\n                        -B-\n                        -/-", ['?', ComparisonGates.AGreaterThanOrEqualToB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = (i >> 1) & 3;
      var b = (i >> 3) & 3;
      var t = (i & 1) ^ (a >= b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_equal_to_B', function() {
    var circ = circuit("-?-\n                        -A-\n                        -/-\n                        -B-\n                        -/-", ['?', ComparisonGates.AEqualToB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = (i >> 1) & 3;
      var b = (i >> 3) & 3;
      var t = (i & 1) ^ (a === b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  suite.testUsingWebGL('A_not_equal_to_B', function() {
    var circ = circuit("-?-\n                        -A-\n                        -/-\n                        -B-\n                        -/-", ['?', ComparisonGates.ANotEqualToB]);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, circ, false);
    }, Matrix.generateTransition(1 << 5, function(i) {
      var a = (i >> 1) & 3;
      var b = (i >> 3) & 3;
      var t = (i & 1) ^ (a !== b ? 1 : 0);
      return t | (i & ~1);
    }));
  });
  return {};
});
//# sourceURL=test/gates/ComparisonGates.test.js
;$traceurRuntime.registerModule("test/gates/Controls.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/Controls.test.js";
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/Controls.test.js")),
      assertThat = $__4.assertThat,
      Suite = $__4.Suite;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/Controls.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/Controls.test.js")).CircuitStats;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Gate.js", "test/gates/Controls.test.js")).Gate;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/gates/Controls.test.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/Controls.test.js")).Gates;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/gates/Controls.test.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/Controls.test.js")).Matrix;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/gates/Controls.test.js")).Util;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/Controls.test.js")).advanceStateWithCircuit;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/Controls.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var suite = new Suite("Gates.Controls");
  function assertControlOverlapState(control, expectedOverlap, state) {
    var $__2,
        $__3;
    var $__1 = state,
        a = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
        b = ($__3 = $__2.next()).done ? void 0 : $__3.value;
    var u = Matrix.square(a, Complex.from(b).conjugate().neg(), b, Complex.from(a).conjugate());
    u = u.times(1 / Math.sqrt(u.determinant().abs()));
    assertThat(u.isUnitary(0.00001)).withInfo({
      state: state,
      u: u
    }).isEqualTo(true);
    var circuit = new CircuitDefinition(2, [new GateColumn([Gate.fromKnownMatrix('****', u, '', ''), undefined]), new GateColumn([control, Gates.HalfTurns.X])]);
    var stats = CircuitStats.fromCircuitAtTime(circuit, 0);
    var overlap = stats.controlledWireProbabilityJustAfter(1, Infinity);
    assertThat(overlap).isApproximatelyEqualTo(expectedOverlap);
  }
  suite.testUsingWebGL('control', function() {
    var i = Complex.I;
    var c = Gates.Controls.Control;
    assertControlOverlapState(c, 0, [1, 0]);
    assertControlOverlapState(c, 1, [0, 1]);
    assertControlOverlapState(c, 0.5, [1, 1]);
    assertControlOverlapState(c, 0.5, [-1, 1]);
    assertControlOverlapState(c, 0.5, [1, i]);
    assertControlOverlapState(c, 0.5, [-1, i]);
  });
  suite.testUsingWebGL('anti-control', function() {
    var i = Complex.I;
    var c = Gates.Controls.AntiControl;
    assertControlOverlapState(c, 1, [1, 0]);
    assertControlOverlapState(c, 0, [0, 1]);
    assertControlOverlapState(c, 0.5, [1, 1]);
    assertControlOverlapState(c, 0.5, [-1, 1]);
    assertControlOverlapState(c, 0.5, [1, i]);
    assertControlOverlapState(c, 0.5, [-1, i]);
  });
  suite.testUsingWebGL('X-anti-control', function() {
    var i = Complex.I;
    var c = Gates.Controls.XAntiControl;
    assertControlOverlapState(c, 0.5, [1, 0]);
    assertControlOverlapState(c, 0.5, [0, 1]);
    assertControlOverlapState(c, 1, [1, 1]);
    assertControlOverlapState(c, 0, [-1, 1]);
    assertControlOverlapState(c, 0.5, [1, i]);
    assertControlOverlapState(c, 0.5, [-1, i]);
  });
  suite.testUsingWebGL('X-control', function() {
    var i = Complex.I;
    var c = Gates.Controls.XControl;
    assertControlOverlapState(c, 0.5, [1, 0]);
    assertControlOverlapState(c, 0.5, [0, 1]);
    assertControlOverlapState(c, 0, [1, 1]);
    assertControlOverlapState(c, 1, [-1, 1]);
    assertControlOverlapState(c, 0.5, [1, i]);
    assertControlOverlapState(c, 0.5, [-1, i]);
  });
  suite.testUsingWebGL('Y-anti-control', function() {
    var i = Complex.I;
    var c = Gates.Controls.YAntiControl;
    assertControlOverlapState(c, 0.5, [1, 0]);
    assertControlOverlapState(c, 0.5, [0, 1]);
    assertControlOverlapState(c, 0.5, [1, 1]);
    assertControlOverlapState(c, 0.5, [-1, 1]);
    assertControlOverlapState(c, 1, [1, i]);
    assertControlOverlapState(c, 0, [-1, i]);
  });
  suite.testUsingWebGL('Y-control', function() {
    var i = Complex.I;
    var c = Gates.Controls.YControl;
    assertControlOverlapState(c, 0.5, [1, 0]);
    assertControlOverlapState(c, 0.5, [0, 1]);
    assertControlOverlapState(c, 0.5, [1, 1]);
    assertControlOverlapState(c, 0.5, [-1, 1]);
    assertControlOverlapState(c, 0, [1, i]);
    assertControlOverlapState(c, 1, [-1, i]);
  });
  suite.testUsingWebGL('Z-parity', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(2, [new GateColumn([Gates.Controls.ZParityControl, Gates.HalfTurns.Z])]), false);
    }, Matrix.generateDiagonal(1 << 2, function(i) {
      return i === 3 ? -1 : 1;
    }));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(4, [new GateColumn([Gates.Controls.ZParityControl, undefined, Gates.Controls.ZParityControl, Gates.HalfTurns.Z])]), false);
    }, Matrix.generateDiagonal(1 << 4, function(i) {
      return Util.popcnt(i & 5) % 2 === 1 && ((i & 8) !== 0) ? -1 : 1;
    }));
  });
  suite.testUsingWebGL('X-parity', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(4, [new GateColumn([Gates.HalfTurns.H, Gates.HalfTurns.H, Gates.HalfTurns.H, undefined]), new GateColumn([Gates.Controls.XParityControl, Gates.Controls.XParityControl, Gates.Controls.XParityControl, Gates.HalfTurns.Z]), new GateColumn([Gates.HalfTurns.H, Gates.HalfTurns.H, Gates.HalfTurns.H, undefined])]), false);
    }, Matrix.generateDiagonal(1 << 4, function(i) {
      return Util.popcnt(i & 7) % 2 === 1 && ((i & 8) !== 0) ? -1 : 1;
    }));
  });
  suite.testUsingWebGL('X-parity', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(4, [new GateColumn([Gates.QuarterTurns.SqrtXBackward, Gates.QuarterTurns.SqrtXBackward, Gates.QuarterTurns.SqrtXBackward, undefined]), new GateColumn([Gates.Controls.YParityControl, Gates.Controls.YParityControl, Gates.Controls.YParityControl, Gates.HalfTurns.Z]), new GateColumn([Gates.QuarterTurns.SqrtXForward, Gates.QuarterTurns.SqrtXForward, Gates.QuarterTurns.SqrtXForward, undefined])]), false);
    }, Matrix.generateDiagonal(1 << 4, function(i) {
      return Util.popcnt(i & 7) % 2 === 1 && ((i & 8) !== 0) ? -1 : 1;
    }));
  });
  suite.test('xyParityControlsDisabledByMeasurement', function() {
    var c = CircuitDefinition.fromTextDiagram(new Map([['M', Gates.Special.Measurement], ['H', Gates.HalfTurns.H], ['x', Gates.Controls.XParityControl], ['y', Gates.Controls.YParityControl], ['z', Gates.Controls.ZParityControl], ['-', undefined]]), "-x-M-x-\n         -y-M-y-\n         -z-M-z-\n         -H---H-");
    assertThat(c.gateAtLocIsDisabledReason(1, 0)).isEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(1, 1)).isEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(1, 2)).isEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 0)).isNotEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 1)).isNotEqualTo(undefined);
    assertThat(c.gateAtLocIsDisabledReason(5, 2)).isEqualTo(undefined);
  });
  return {};
});
//# sourceURL=test/gates/Controls.test.js
;$traceurRuntime.registerModule("test/gates/CycleBitsGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/CycleBitsGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/CycleBitsGates.test.js")).Suite;
  var assertThatCircuitShaderActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/CycleBitsGates.test.js")).assertThatCircuitShaderActsLikeMatrix;
  var cycleBitsShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/CycleBitsGates.js", "test/gates/CycleBitsGates.test.js")).cycleBitsShader;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/CycleBitsGates.test.js")).Matrix;
  var suite = new Suite("CycleBitsGates");
  suite.testUsingWebGL('cycleBitsShader', function() {
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      return cycleBitsShader(ctx, 3, 2);
    }, Matrix.generateTransition(8, function(i) {
      return ((i & 1) << 2) | ((i >> 1) & 3);
    }));
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      return cycleBitsShader(ctx, 4, -2);
    }, Matrix.generateTransition(16, function(i) {
      return ((i & 3) << 2) | ((i >> 2) & 3);
    }));
  });
  return {};
});
//# sourceURL=test/gates/CycleBitsGates.test.js
;$traceurRuntime.registerModule("test/gates/DensityMatrixDisplay.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/DensityMatrixDisplay.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/DensityMatrixDisplay.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var amplitudesToCouplings = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/DensityMatrixDisplay.js", "test/gates/DensityMatrixDisplay.test.js")).amplitudesToCouplings;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/gates/DensityMatrixDisplay.test.js")).Shaders;
  var suite = new Suite("DensityMatrixDisplay");
  suite.testUsingWebGL("amplitudesToCouplings", function() {
    var s = Math.sqrt(0.5);
    var inp = Shaders.vec2Data(new Float32Array([s, 0, 0, 0, 0, 0, s, 0])).toVec2Texture(2);
    assertThat(amplitudesToCouplings(inp, 1).readVec2Outputs(3)).isApproximatelyEqualTo(new Float32Array([0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.5, 0]));
    assertThat(amplitudesToCouplings(inp, 2).readVec2Outputs(4)).isApproximatelyEqualTo(new Float32Array([0.5, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0, 0.5, 0]));
    inp.deallocByDepositingInPool();
  });
  return {};
});
//# sourceURL=test/gates/DensityMatrixDisplay.test.js
;$traceurRuntime.registerModule("test/gates/Detector.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/Detector.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/Detector.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/Detector.test.js")).Gates;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/Detector.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/Detector.test.js")).CircuitStats;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/Detector.test.js")).Matrix;
  var suite = new Suite("Detector");
  var circuit = function(diagram) {
    for (var extras = [],
        $__0 = 1; $__0 < arguments.length; $__0++)
      extras[$__0 - 1] = arguments[$__0];
    return CircuitDefinition.fromTextDiagram(new Map($traceurRuntime.spread(extras, [['-', undefined], ['●', Gates.Controls.Control], ['D', Gates.Detectors.ZDetector], ['X', Gates.HalfTurns.X], ['Z', Gates.HalfTurns.Z], ['H', Gates.HalfTurns.H]])), diagram);
  };
  suite.testUsingWebGL("guaranteed-clicks", function() {
    var c = CircuitStats.fromCircuitAtTime(circuit("\n        -X-D-\n        ---D-\n    "), 0);
    assertThat(c.customStatsForSlot(3, 0)).isEqualTo(true);
    assertThat(c.customStatsForSlot(3, 1)).isEqualTo(false);
  });
  suite.testUsingWebGL("collapse-clicks", function() {
    var c = CircuitStats.fromCircuitAtTime(circuit("\n        -H-D-\n        -H-D-\n    "), 0);
    var a = c.customStatsForSlot(3, 0);
    var b = c.customStatsForSlot(3, 1);
    assertThat(c.qubitDensityMatrix(Infinity, 0).cell(0, 0)).isEqualTo(a ? 0 : 1);
    assertThat(c.qubitDensityMatrix(Infinity, 1).cell(0, 0)).isEqualTo(b ? 0 : 1);
  });
  suite.testUsingWebGL("guaranteed-agreement", function() {
    var c = CircuitStats.fromCircuitAtTime(circuit("\n        -H-●-D-\n        ---X-D-\n    "), 0);
    var a = c.customStatsForSlot(5, 0);
    var b = c.customStatsForSlot(5, 1);
    assertThat(a).isEqualTo(b);
    assertThat(c.qubitDensityMatrix(Infinity, 0).cell(0, 0)).isEqualTo(a ? 0 : 1);
    assertThat(c.qubitDensityMatrix(Infinity, 1).cell(0, 0)).isEqualTo(b ? 0 : 1);
  });
  suite.testUsingWebGL("guaranteed-control-clicks", function() {
    var c = CircuitStats.fromCircuitAtTime(circuit("\n        ---●---\n        -X-D-D-\n        -X---●-\n    "), 0);
    assertThat(c.customStatsForSlot(3, 1)).isEqualTo(false);
    assertThat(c.customStatsForSlot(5, 1)).isEqualTo(true);
  });
  suite.testUsingWebGL("collapsed-control-clicks", function() {
    for (var i = 0; i < 10; i++) {
      var c = CircuitStats.fromCircuitAtTime(circuit("\n        -H-●-\n        -H-D-\n    "), 0);
      var a = c.customStatsForSlot(3, 1);
      if (a) {
        assertThat(c.finalState).isApproximatelyEqualTo(Matrix.col(0, 0, 0, 1));
      } else {
        var s = Math.sqrt(1 / 3);
        assertThat(c.finalState).isApproximatelyEqualTo(Matrix.col(s, s, s, 0));
      }
    }
  });
  suite.testUsingWebGL("renormalizes", function() {
    var c = circuit('-]-D-]-D-]-D-]-', [']', Gates.Detectors.XDetector], ['0', Gates.PostSelectionGates.PostSelectOff]);
    var stats = CircuitStats.fromCircuitAtTime(c, 0);
    assertThat(stats.survivalRate(Infinity)).isApproximatelyEqualTo(1, 0.001);
    var c2 = circuit('-]-0-D-]-D-]-D-]-', [']', Gates.Detectors.XDetector], ['0', Gates.PostSelectionGates.PostSelectOff]);
    var stats2 = CircuitStats.fromCircuitAtTime(c2, 0);
    assertThat(stats2.survivalRate(Infinity)).isApproximatelyEqualTo(0.5, 0.001);
  });
  return {};
});
//# sourceURL=test/gates/Detector.test.js
;$traceurRuntime.registerModule("test/gates/ExponentiatingGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ExponentiatingGates.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ExponentiatingGates.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/ExponentiatingGates.test.js")).Gates;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/gates/ExponentiatingGates.test.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/ExponentiatingGates.test.js")).Matrix;
  var suite = new Suite("ExponentiatingGates");
  suite.test("timeBased_matchUnoptimized", function() {
    var matches = function(gate, func) {
      for (var t = 0; t < 1; t += 0.05) {
        assertThat(gate.knownMatrixAt(t)).isApproximatelyEqualTo(func(t), 0.0000001);
      }
    };
    var i = Complex.I;
    var τ = Math.PI * 2;
    matches(Gates.Exponentiating.XForward, function(t) {
      return Matrix.PAULI_X.liftApply(function(c) {
        return c.times(τ * -t).times(i).exp();
      });
    });
    matches(Gates.Exponentiating.XBackward, function(t) {
      return Matrix.PAULI_X.liftApply(function(c) {
        return c.times(τ * t).times(i).exp();
      });
    });
    matches(Gates.Exponentiating.YForward, function(t) {
      return Matrix.PAULI_Y.liftApply(function(c) {
        return c.times(τ * -t).times(i).exp();
      });
    });
    matches(Gates.Exponentiating.YBackward, function(t) {
      return Matrix.PAULI_Y.liftApply(function(c) {
        return c.times(τ * t).times(i).exp();
      });
    });
    matches(Gates.Exponentiating.ZForward, function(t) {
      return Matrix.PAULI_Z.liftApply(function(c) {
        return c.times(τ * -t).times(i).exp();
      });
    });
    matches(Gates.Exponentiating.ZBackward, function(t) {
      return Matrix.PAULI_Z.liftApply(function(c) {
        return c.times(τ * t).times(i).exp();
      });
    });
    matches(Gates.Powering.XForward, function(t) {
      return Matrix.PAULI_X.liftApply(function(c) {
        return c.raisedTo(t * 2);
      });
    });
    matches(Gates.Powering.XBackward, function(t) {
      return Matrix.PAULI_X.liftApply(function(c) {
        return c.raisedTo(-t * 2);
      });
    });
    matches(Gates.Powering.YForward, function(t) {
      return Matrix.PAULI_Y.liftApply(function(c) {
        return c.raisedTo(t * 2);
      });
    });
    matches(Gates.Powering.YBackward, function(t) {
      return Matrix.PAULI_Y.liftApply(function(c) {
        return c.raisedTo(-t * 2);
      });
    });
    matches(Gates.Powering.ZForward, function(t) {
      return Matrix.PAULI_Z.liftApply(function(c) {
        return c.raisedTo(t * 2);
      });
    });
    matches(Gates.Powering.ZBackward, function(t) {
      return Matrix.PAULI_Z.liftApply(function(c) {
        return c.raisedTo(-t * 2);
      });
    });
  });
  return {};
});
//# sourceURL=test/gates/ExponentiatingGates.test.js
;$traceurRuntime.registerModule("test/gates/FourierTransformGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/FourierTransformGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/FourierTransformGates.test.js")).Suite;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/FourierTransformGates.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/FourierTransformGates.js", "test/gates/FourierTransformGates.test.js")),
      applyControlledPhaseGradient = $__2.applyControlledPhaseGradient,
      FourierTransformGates = $__2.FourierTransformGates;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/FourierTransformGates.test.js")).CircuitDefinition;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/gates/FourierTransformGates.test.js")).GateColumn;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/FourierTransformGates.test.js")).advanceStateWithCircuit;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/gates/FourierTransformGates.test.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/FourierTransformGates.test.js")).Matrix;
  var suite = new Suite("FourierTransformGates");
  suite.testUsingWebGL('controlledPhaseGradient', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return applyControlledPhaseGradient(ctx, 3, 1);
    }, Matrix.generateDiagonal(8, function(i) {
      return i < 4 ? 1 : Complex.polar(1, (i - 4) * Math.PI / 4);
    }));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return applyControlledPhaseGradient(ctx, 4, -1);
    }, Matrix.generateDiagonal(16, function(i) {
      return i < 8 ? 1 : Complex.polar(1, -(i - 8) * Math.PI / 8);
    }));
  });
  suite.testUsingWebGL('fourierTransform', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(2, [new GateColumn([FourierTransformGates.FourierTransformFamily.ofSize(2), undefined])]), false).output;
    }, Matrix.generate(4, 4, function(i, j) {
      return Complex.polar(0.5, i * j * Math.PI / 2);
    }));
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(3, [new GateColumn([FourierTransformGates.InverseFourierTransformFamily.ofSize(3), undefined, undefined])]), false).output;
    }, Matrix.generate(8, 8, function(i, j) {
      return Complex.polar(Math.sqrt(1 / 8), -i * j * Math.PI / 4);
    }));
  });
  return {};
});
//# sourceURL=test/gates/FourierTransformGates.test.js
;$traceurRuntime.registerModule("test/gates/Impossible_UniversalNotGate.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/Impossible_UniversalNotGate.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/Impossible_UniversalNotGate.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitEvalContext.js", "test/gates/Impossible_UniversalNotGate.test.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitShaders.js", "test/gates/Impossible_UniversalNotGate.test.js")).CircuitShaders;
  var universalNot = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/Impossible_UniversalNotGate.js", "test/gates/Impossible_UniversalNotGate.test.js")).universalNot;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/gates/Impossible_UniversalNotGate.test.js")).Controls;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/gates/Impossible_UniversalNotGate.test.js")).Shaders;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTextureTrader.js", "test/gates/Impossible_UniversalNotGate.test.js")).WglTextureTrader;
  var suite = new Suite("Impossible_UniverseNotGate");
  suite.testUsingWebGL('universalNot', function() {
    var input = Shaders.vec2Data(new Float32Array([1, 2, 3, 4, 5, 6, 7, 8])).toVec2Texture(2);
    var assertAbout = function(index, control) {
      var controlTex = CircuitShaders.controlMask(control).toBoolTexture(2);
      var trader = new WglTextureTrader(input);
      trader.dontDeallocCurrentTexture();
      var ctx = new CircuitEvalContext(0, index, 2, control, controlTex, control, trader, new Map());
      try {
        return assertThat(universalNot(ctx).readVec2Outputs(2));
      } finally {
        controlTex.deallocByDepositingInPool();
      }
    };
    assertAbout(0, Controls.NONE).isEqualTo(new Float32Array([3, -4, -1, 2, 7, -8, -5, 6]));
    assertAbout(1, Controls.NONE).isEqualTo(new Float32Array([5, -6, 7, -8, -1, 2, -3, 4]));
    assertAbout(0, Controls.bit(1, true)).isEqualTo(new Float32Array([1, 2, 3, 4, 7, -8, -5, 6]));
    input.deallocByDepositingInPool();
  });
  return {};
});
//# sourceURL=test/gates/Impossible_UniversalNotGate.test.js
;$traceurRuntime.registerModule("test/gates/IncrementGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/IncrementGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/IncrementGates.test.js")).Suite;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/IncrementGates.js", "test/gates/IncrementGates.test.js")),
      offsetShader = $__2.offsetShader,
      IncrementGates = $__2.IncrementGates;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/IncrementGates.test.js")),
      assertThatCircuitShaderActsLikePermutation = $__3.assertThatCircuitShaderActsLikePermutation,
      assertThatGateActsLikePermutation = $__3.assertThatGateActsLikePermutation;
  var ketArgs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/KetShaderUtil.js", "test/gates/IncrementGates.test.js")).ketArgs;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/gates/IncrementGates.test.js")).WglArg;
  var suite = new Suite("ArithmeticGates");
  suite.testUsingWebGL('offsetShader', function() {
    assertThatCircuitShaderActsLikePermutation(3, function(ctx) {
      var $__0;
      return ($__0 = offsetShader).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx, 3), [WglArg.float("amount", 5)]));
    }, function(e) {
      return (e + 5) & 7;
    });
    assertThatCircuitShaderActsLikePermutation(6, function(ctx) {
      var $__0;
      return ($__0 = offsetShader).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx, 6), [WglArg.float("amount", -31)]));
    }, function(e) {
      return (e - 31) & 63;
    });
  });
  suite.testUsingWebGL('IncrementGate', function() {
    assertThatGateActsLikePermutation(IncrementGates.IncrementFamily.ofSize(3), function(e) {
      return (e + 1) & 7;
    });
    assertThatGateActsLikePermutation(IncrementGates.DecrementFamily.ofSize(4), function(e) {
      return (e - 1) & 15;
    });
  });
  return {};
});
//# sourceURL=test/gates/IncrementGates.test.js
;$traceurRuntime.registerModule("test/gates/InputGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/InputGates.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/InputGates.test.js")),
      assertThat = $__1.assertThat,
      Suite = $__1.Suite;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/InputGates.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/InputGates.test.js")).CircuitStats;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/InputGates.test.js")).Gates;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/gates/InputGates.test.js")).Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/gates/InputGates.test.js")).Util;
  var suite = new Suite("InputGates");
  var TEST_GATES = new Map([['$', Gates.ModularIncrementGates.DecrementModRFamily], ['*', Gates.MultiplyAccumulateGates.MultiplyAddInputsFamily], ['X', Gates.HalfTurns.X], ['⊕', Gates.XorGates.XorAFamily], ['A', Gates.InputGates.InputAFamily], ['B', Gates.InputGates.InputBFamily], ['R', Gates.InputGates.InputRFamily], ['∀', Gates.InputGates.InputRevAFamily], ['ᗺ', Gates.InputGates.InputRevBFamily], ['-', undefined], ['/', null]]);
  var circuit = function(diagram) {
    for (var extraGates = [],
        $__0 = 1; $__0 < arguments.length; $__0++)
      extraGates[$__0 - 1] = arguments[$__0];
    return CircuitDefinition.fromTextDiagram(Util.mergeMaps(TEST_GATES, new Map(extraGates)), diagram);
  };
  suite.testUsingWebGL('endianness', function() {
    var output = function(diagram) {
      var stats = CircuitStats.fromCircuitAtTime(circuit(diagram), 0);
      return Seq.range(stats.finalState.height()).filter(function(i) {
        return stats.finalState.cell(0, i).isEqualTo(1);
      }).first();
    };
    assertThat(output("-X-A-\n                       ---/-\n                       ---/-\n                       -----\n                       ---⊕-\n                       ---/-\n                       ---/-")).isEqualTo(17);
    assertThat(output("-X-∀-\n                       ---/-\n                       ---/-\n                       -----\n                       ---⊕-\n                       ---/-\n                       ---/-")).isEqualTo(65);
    assertThat(output("---$-\n                       ---/-\n                       ---/-\n                       ---/-\n                       -X-R-\n                       -X-/-\n                       ---/-\n                       -X-/-")).isEqualTo(186);
    assertThat(output("---*-\n                       ---/-\n                       -X-A-\n                       -X-B-\n                       ---/-")).isEqualTo(13);
    assertThat(output("---*-\n                       ---/-\n                       -X-A-\n                       -X-ᗺ-\n                       ---/-")).isEqualTo(14);
  });
  return {};
});
//# sourceURL=test/gates/InputGates.test.js
;$traceurRuntime.registerModule("test/gates/InterleaveBitsGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/InterleaveBitsGates.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/InterleaveBitsGates.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InterleaveBitsGates.js", "test/gates/InterleaveBitsGates.test.js")),
      interleaveBit = $__2.interleaveBit,
      deinterleaveBit = $__2.deinterleaveBit;
  var suite = new Suite("InterleaveBitsGates");
  suite.test('interleaveBit', function() {
    assertThat(interleaveBit(0, 1)).isEqualTo(0);
    assertThat(interleaveBit(0, 2)).isEqualTo(0);
    assertThat(interleaveBit(1, 2)).isEqualTo(1);
    assertThat(interleaveBit(0, 3)).isEqualTo(0);
    assertThat(interleaveBit(1, 3)).isEqualTo(2);
    assertThat(interleaveBit(2, 3)).isEqualTo(1);
    assertThat(interleaveBit(0, 4)).isEqualTo(0);
    assertThat(interleaveBit(1, 4)).isEqualTo(2);
    assertThat(interleaveBit(2, 4)).isEqualTo(1);
    assertThat(interleaveBit(3, 4)).isEqualTo(3);
    assertThat(interleaveBit(0, 6)).isEqualTo(0);
    assertThat(interleaveBit(1, 6)).isEqualTo(2);
    assertThat(interleaveBit(2, 6)).isEqualTo(4);
    assertThat(interleaveBit(3, 6)).isEqualTo(1);
    assertThat(interleaveBit(4, 6)).isEqualTo(3);
    assertThat(interleaveBit(5, 6)).isEqualTo(5);
    assertThat(interleaveBit(0, 5)).isEqualTo(0);
    assertThat(interleaveBit(1, 5)).isEqualTo(2);
    assertThat(interleaveBit(2, 5)).isEqualTo(4);
    assertThat(interleaveBit(3, 5)).isEqualTo(1);
    assertThat(interleaveBit(4, 5)).isEqualTo(3);
  });
  suite.test('deinterleaveBit', function() {
    assertThat(deinterleaveBit(0, 1)).isEqualTo(0);
    assertThat(deinterleaveBit(0, 2)).isEqualTo(0);
    assertThat(deinterleaveBit(1, 2)).isEqualTo(1);
    assertThat(deinterleaveBit(0, 3)).isEqualTo(0);
    assertThat(deinterleaveBit(2, 3)).isEqualTo(1);
    assertThat(deinterleaveBit(1, 3)).isEqualTo(2);
    assertThat(deinterleaveBit(0, 4)).isEqualTo(0);
    assertThat(deinterleaveBit(2, 4)).isEqualTo(1);
    assertThat(deinterleaveBit(1, 4)).isEqualTo(2);
    assertThat(deinterleaveBit(3, 4)).isEqualTo(3);
    assertThat(deinterleaveBit(0, 6)).isEqualTo(0);
    assertThat(deinterleaveBit(2, 6)).isEqualTo(1);
    assertThat(deinterleaveBit(4, 6)).isEqualTo(2);
    assertThat(deinterleaveBit(1, 6)).isEqualTo(3);
    assertThat(deinterleaveBit(3, 6)).isEqualTo(4);
    assertThat(deinterleaveBit(5, 6)).isEqualTo(5);
    assertThat(deinterleaveBit(0, 5)).isEqualTo(0);
    assertThat(deinterleaveBit(2, 5)).isEqualTo(1);
    assertThat(deinterleaveBit(4, 5)).isEqualTo(2);
    assertThat(deinterleaveBit(1, 5)).isEqualTo(3);
    assertThat(deinterleaveBit(3, 5)).isEqualTo(4);
  });
  suite.test('interleave_vs_deinterleave_bit', function() {
    for (var i = 0; i < 100; i++) {
      var n = Math.floor(Math.random() * 100 + 10);
      var b = Math.floor(Math.random() * n);
      var j = interleaveBit(b, n);
      assertThat(deinterleaveBit(j, n)).withInfo({
        n: n,
        b: b,
        j: j
      }).isEqualTo(b);
    }
  });
  suite.test('interleave_vs_deinterleave_bit', function() {
    for (var i = 0; i < 100; i++) {
      var n = Math.floor(Math.random() * 100 + 10);
      var b = Math.floor(Math.random() * n);
      var j = interleaveBit(b, n);
      assertThat(deinterleaveBit(j, n)).withInfo({
        n: n,
        b: b,
        j: j
      }).isEqualTo(b);
    }
  });
  return {};
});
//# sourceURL=test/gates/InterleaveBitsGates.test.js
;$traceurRuntime.registerModule("test/gates/ModularAdditionGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ModularAdditionGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ModularAdditionGates.test.js")).Suite;
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/ModularAdditionGates.test.js")),
      assertThatGateActsLikePermutation = $__1.assertThatGateActsLikePermutation,
      assertThatCircuitOutputsBasisKet = $__1.assertThatCircuitOutputsBasisKet;
  var ModularAdditionGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ModularAdditionGates.js", "test/gates/ModularAdditionGates.test.js")).ModularAdditionGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InputGates.js", "test/gates/ModularAdditionGates.test.js")).InputGates;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/ModularAdditionGates.test.js")).CircuitDefinition;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/gates/ModularAdditionGates.test.js")).Util;
  var suite = new Suite("ModularAdditionGates");
  suite.testUsingWebGL('plus_A_mod_R_permutation', function() {
    assertThatGateActsLikePermutation(ModularAdditionGates.PlusAModRFamily.ofSize(2), function(t, a, b) {
      return t < b ? (t + a) % b : t;
    }, [2, 2]);
    assertThatGateActsLikePermutation(ModularAdditionGates.PlusAModRFamily.ofSize(3), function(t, a, b) {
      return t < b ? (t + a) % b : t;
    }, [1, 2]);
    assertThatGateActsLikePermutation(ModularAdditionGates.PlusAModRFamily.ofSize(2), function(t, a, b) {
      return t < b ? (t + a) % b : t;
    }, [3, 2]);
  });
  suite.testUsingWebGL('minus_A_mod_R_permutation', function() {
    assertThatGateActsLikePermutation(ModularAdditionGates.MinusAModRFamily.ofSize(2), function(t, a, b) {
      return t < b ? Util.properMod(t - a, b) : t;
    }, [2, 2]);
    assertThatGateActsLikePermutation(ModularAdditionGates.MinusAModRFamily.ofSize(3), function(t, a, b) {
      return t < b ? Util.properMod(t - a, b) : t;
    }, [1, 2]);
    assertThatGateActsLikePermutation(ModularAdditionGates.MinusAModRFamily.ofSize(2), function(t, a, b) {
      return t < b ? Util.properMod(t - a, b) : t;
    }, [3, 2]);
  });
  suite.testUsingWebGL('plus_A_mod_R_no_nan', function() {
    var circuit = CircuitDefinition.fromTextDiagram(new Map([['a', InputGates.SetA.withParam(0)], ['r', InputGates.SetR.withParam(33)], ['p', ModularAdditionGates.PlusAModRFamily], ['-', undefined], ['/', null]]), "-a-p-\n         ---/-\n         -r-/-\n         ---/-\n         ---/-\n         ---/-");
    assertThatCircuitOutputsBasisKet(circuit, 0);
  });
  return {};
});
//# sourceURL=test/gates/ModularAdditionGates.test.js
;$traceurRuntime.registerModule("test/gates/ModularIncrementGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ModularIncrementGates.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ModularIncrementGates.test.js")),
      assertThat = $__0.assertThat,
      Suite = $__0.Suite;
  var assertThatGateActsLikePermutation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/ModularIncrementGates.test.js")).assertThatGateActsLikePermutation;
  var ModularIncrementGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ModularIncrementGates.js", "test/gates/ModularIncrementGates.test.js")).ModularIncrementGates;
  var ModularAdditionGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ModularAdditionGates.js", "test/gates/ModularIncrementGates.test.js")).ModularAdditionGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InputGates.js", "test/gates/ModularIncrementGates.test.js")).InputGates;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/ModularIncrementGates.test.js")).CircuitDefinition;
  var suite = new Suite("ModularIncrementGates");
  suite.testUsingWebGL('mod_too_big_disable', function() {
    var circuit = function(diagram) {
      return CircuitDefinition.fromTextDiagram(new Map([['A', InputGates.InputAFamily], ['B', InputGates.InputBFamily], ['R', InputGates.InputRFamily], ['r', InputGates.SetR.withParam(3)], ['x', ModularIncrementGates.IncrementModRFamily], ['y', ModularIncrementGates.DecrementModRFamily], ['z', ModularAdditionGates.PlusAModRFamily], ['t', ModularAdditionGates.MinusAModRFamily], ['-', undefined], ['/', null]]), diagram);
    };
    var bad = function(col, row, diagram) {
      return assertThat(circuit(diagram).gateAtLocIsDisabledReason(col, row)).isNotEqualTo(undefined);
    };
    var good = function(col, row, diagram) {
      return assertThat(circuit(diagram).gateAtLocIsDisabledReason(col, row)).isEqualTo(undefined);
    };
    bad(1, 2, "-R-\n               -/-\n               -x-");
    bad(1, 0, "-y-\n               -R-\n               -/-");
    good(1, 2, "-R-\n                -/-\n                -y-\n                -/-");
    good(1, 2, "-x-\n                -/-\n                -/-\n                -R-\n                -/-");
    bad(1, 2, "-A-\n               -/-\n               -z-\n               -R-\n               -/-");
    bad(1, 2, "-R-\n               -/-\n               -t-\n               -A-\n               -/-");
    bad(1, 2, "-A-\n               ---\n               -z-\n               -R-\n               -/-");
    good(1, 2, "-A-\n                -/-\n                -z-\n                -R-\n                ---");
    good(1, 2, "-A-\n                -/-\n                -t-\n                -/-\n                -R-\n                -/-");
    good(1, 2, "-A-\n                r/-\n                -t-\n                -/-");
  });
  suite.testUsingWebGL('increment_mod_R', function() {
    assertThatGateActsLikePermutation(ModularIncrementGates.IncrementModRFamily.ofSize(2), function(t, a) {
      return t < a ? (t + 1) % a : t;
    }, [2]);
    assertThatGateActsLikePermutation(ModularIncrementGates.IncrementModRFamily.ofSize(3), function(t, a) {
      return t < a ? (t + 1) % a : t;
    }, [2]);
  });
  suite.testUsingWebGL('decrement_mod_R', function() {
    assertThatGateActsLikePermutation(ModularIncrementGates.DecrementModRFamily.ofSize(3), function(t, a) {
      return t < a ? (t - 1 + a) % a : t;
    }, [3]);
    assertThatGateActsLikePermutation(ModularIncrementGates.DecrementModRFamily.ofSize(3), function(t, a) {
      return t < a ? (t - 1 + a) % a : t;
    }, [2]);
  });
  return {};
});
//# sourceURL=test/gates/ModularIncrementGates.test.js
;$traceurRuntime.registerModule("test/gates/ModularMultiplicationGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ModularMultiplicationGates.test.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ModularMultiplicationGates.test.js")),
      assertThat = $__2.assertThat,
      Suite = $__2.Suite;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ModularMultiplicationGates.js", "test/gates/ModularMultiplicationGates.test.js")),
      MODULAR_INVERSE_SHADER_CODE = $__3.MODULAR_INVERSE_SHADER_CODE,
      POW_MOD_SHADER_CODE = $__3.POW_MOD_SHADER_CODE,
      modularMultiply = $__3.modularMultiply,
      modularUnmultiply = $__3.modularUnmultiply,
      modularPowerMultiply = $__3.modularPowerMultiply,
      ModularMultiplicationGates = $__3.ModularMultiplicationGates;
  var assertThatGateActsLikePermutation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/ModularMultiplicationGates.test.js")).assertThatGateActsLikePermutation;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/ModularMultiplicationGates.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/ModularMultiplicationGates.test.js")).CircuitStats;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/gates/ModularMultiplicationGates.test.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/ModularMultiplicationGates.test.js")).Gates;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/gates/ModularMultiplicationGates.test.js")),
      Outputs = $__9.Outputs,
      makePseudoShaderWithInputsAndOutputAndCode = $__9.makePseudoShaderWithInputsAndOutputAndCode;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/gates/ModularMultiplicationGates.test.js")).Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/gates/ModularMultiplicationGates.test.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/gates/ModularMultiplicationGates.test.js")).WglArg;
  var suite = new Suite("ModularMultiplicationGates");
  suite.testUsingWebGL('MODULAR_INVERSE_SHADER_CODE', function() {
    var testShader = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.float(), MODULAR_INVERSE_SHADER_CODE + "\n        uniform float modulus;\n        float outputFor(float k) {\n            return modular_multiplicative_inverse(k, modulus);\n        }");
    var assertMatches = function(modulus, rangePower) {
      assertThat(testShader(WglArg.float('modulus', modulus)).readVecFloatOutputs(rangePower)).isEqualTo(Seq.range(1 << rangePower).map(function(e) {
        return Util.modular_multiplicative_inverse(e, modulus);
      }).map(function(e) {
        return e === undefined ? -1 : e;
      }).toFloat32Array());
    };
    assertMatches(11, 4);
    assertMatches(15, 4);
    assertMatches(16, 4);
    assertMatches(255, 8);
    assertMatches(65363, 12);
  });
  suite.testUsingWebGL('MODULAR_INVERSE_SHADER_CODE_big_mul_mod', function() {
    var testShader = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.float(), MODULAR_INVERSE_SHADER_CODE + "\n        uniform float modulus;\n        float outputFor(float k) {\n            return big_mul_mod(k * 15.0, k * 7.0, modulus);\n        }");
    assertThat(testShader(WglArg.float('modulus', 65363)).readVecFloatOutputs(12)).isEqualTo(Seq.range(1 << 12).map(function(e) {
      return e * e * 105.0 % 65363;
    }).toFloat32Array());
  });
  suite.testUsingWebGL('POW_MOD_SHADER_CODE', function() {
    var testShader = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.float(), POW_MOD_SHADER_CODE + "\n        uniform float base;\n        uniform float modulus;\n        uniform float factor;\n        float outputFor(float k) {\n            return pow_mod(base, k * factor, modulus);\n        }");
    var assertMatches = function(base, modulus, rangePower) {
      var factor = arguments[3] !== (void 0) ? arguments[3] : 1;
      assertThat(testShader(WglArg.float('base', base), WglArg.float('modulus', modulus), WglArg.float('factor', factor)).readVecFloatOutputs(rangePower)).isEqualTo(Seq.range(1 << rangePower).map(function(e) {
        return modularPowerMultiply(1, base, e * factor, modulus);
      }).map(function(e) {
        return e === undefined ? -1 : e;
      }).toFloat32Array());
    };
    assertMatches(3, 11, 4);
    assertMatches(4, 15, 4);
    assertMatches(7, 16, 4);
    assertMatches(7, 16, 4, -1);
    assertMatches(11, 255, 8);
    assertMatches(14, 65363, 12);
    assertMatches(14, 65363, 12, -1);
  });
  suite.test("modularPowerMultiply", function() {
    assertThat(modularPowerMultiply(8, 23, 0, 37613)).isEqualTo(8);
    assertThat(modularPowerMultiply(3, 2, 12, 255)).isEqualTo(48);
    assertThat(modularPowerMultiply(1, 3, -12, 251)).isEqualTo(173);
  });
  suite.test("modularMultiply_pow2", function() {
    var checkThat = function() {
      for (var args = [],
          $__1 = 0; $__1 < arguments.length; $__1++)
        args[$__1] = arguments[$__1];
      return assertThat(modularMultiply.apply((void 0), $traceurRuntime.spread(args)));
    };
    checkThat(1, 0, 1 << 3).isEqualTo(1);
    checkThat(0, 3, 1 << 3).isEqualTo(0);
    checkThat(1, 3, 1 << 3).isEqualTo(3);
    checkThat(2, 3, 1 << 3).isEqualTo(6);
    checkThat(3, 3, 1 << 3).isEqualTo(1);
    checkThat(4, 3, 1 << 3).isEqualTo(4);
    checkThat(5, 3, 1 << 3).isEqualTo(7);
    checkThat(6, 3, 1 << 3).isEqualTo(2);
    checkThat(7, 3, 1 << 3).isEqualTo(5);
    checkThat(0, 2, 1 << 3).isEqualTo(0);
    checkThat(1, 2, 1 << 3).isEqualTo(1);
    checkThat(2, 2, 1 << 3).isEqualTo(2);
    checkThat(3, 2, 1 << 3).isEqualTo(3);
    checkThat(4, 2, 1 << 3).isEqualTo(4);
    checkThat(5, 2, 1 << 3).isEqualTo(5);
    checkThat(6, 2, 1 << 3).isEqualTo(6);
    checkThat(7, 2, 1 << 3).isEqualTo(7);
    checkThat(0, 6, 1 << 3).isEqualTo(0);
    checkThat(1, 6, 1 << 3).isEqualTo(1);
    checkThat(2, 6, 1 << 3).isEqualTo(2);
    checkThat(3, 6, 1 << 3).isEqualTo(3);
    checkThat(4, 6, 1 << 3).isEqualTo(4);
    checkThat(5, 6, 1 << 3).isEqualTo(5);
    checkThat(6, 6, 1 << 3).isEqualTo(6);
    checkThat(7, 6, 1 << 3).isEqualTo(7);
    checkThat(93, 10011, 1 << 16).isEqualTo(13519);
    checkThat(93 * 4, 10011, 1 << 16).isEqualTo(54076);
    checkThat(93 * 4, 10011 * 2, 1 << 16).isEqualTo(93 * 4);
    checkThat(93 * 8, 10011, 1 << 16).isEqualTo(42616);
  });
  suite.test("modularUnmultiply_pow2", function() {
    var checkThat = function() {
      for (var args = [],
          $__1 = 0; $__1 < arguments.length; $__1++)
        args[$__1] = arguments[$__1];
      return assertThat(modularUnmultiply.apply((void 0), $traceurRuntime.spread(args)));
    };
    checkThat(1, 0, 1 << 3).isEqualTo(1);
    checkThat(0, 3, 1 << 3).isEqualTo(0);
    checkThat(1, 3, 1 << 3).isEqualTo(3);
    checkThat(2, 3, 1 << 3).isEqualTo(6);
    checkThat(3, 3, 1 << 3).isEqualTo(1);
    checkThat(4, 3, 1 << 3).isEqualTo(4);
    checkThat(5, 3, 1 << 3).isEqualTo(7);
    checkThat(6, 3, 1 << 3).isEqualTo(2);
    checkThat(7, 3, 1 << 3).isEqualTo(5);
    checkThat(0, 2, 1 << 3).isEqualTo(0);
    checkThat(1, 2, 1 << 3).isEqualTo(1);
    checkThat(2, 2, 1 << 3).isEqualTo(2);
    checkThat(3, 2, 1 << 3).isEqualTo(3);
    checkThat(4, 2, 1 << 3).isEqualTo(4);
    checkThat(5, 2, 1 << 3).isEqualTo(5);
    checkThat(6, 2, 1 << 3).isEqualTo(6);
    checkThat(7, 2, 1 << 3).isEqualTo(7);
    checkThat(0, 6, 1 << 3).isEqualTo(0);
    checkThat(1, 6, 1 << 3).isEqualTo(1);
    checkThat(2, 6, 1 << 3).isEqualTo(2);
    checkThat(3, 6, 1 << 3).isEqualTo(3);
    checkThat(4, 6, 1 << 3).isEqualTo(4);
    checkThat(5, 6, 1 << 3).isEqualTo(5);
    checkThat(6, 6, 1 << 3).isEqualTo(6);
    checkThat(7, 6, 1 << 3).isEqualTo(7);
    checkThat(93, 56083, 1 << 16).isEqualTo(13519);
  });
  suite.test("modularMultiply_vs_Unmultiply_fuzz", function() {
    for (var repeat = 0; repeat < 100; repeat++) {
      var mod = Math.floor(Math.random() * (1 << 12)) + 1;
      var val = Math.floor(Math.random() * mod);
      var factor = Math.floor(Math.random() * mod);
      var image = modularMultiply(val, factor, mod);
      var actual = modularUnmultiply(image, factor, mod);
      assertThat(actual).withInfo({
        mod: mod,
        val: val,
        factor: factor,
        image: image
      }).isEqualTo(val);
    }
  });
  suite.testUsingWebGL('times_a_mod_b_gate', function() {
    assertThatGateActsLikePermutation(ModularMultiplicationGates.TimesAModRFamily.ofSize(3), modularMultiply, [3, 3]);
    assertThatGateActsLikePermutation(ModularMultiplicationGates.TimesAModRFamily.ofSize(2), modularMultiply, [3, 2]);
  });
  suite.testUsingWebGL('times_a_mod_b_inverse_gate', function() {
    assertThatGateActsLikePermutation(ModularMultiplicationGates.TimesAModRInverseFamily.ofSize(3), modularUnmultiply, [3, 3]);
    assertThatGateActsLikePermutation(ModularMultiplicationGates.TimesAModRInverseFamily.ofSize(2), modularUnmultiply, [3, 2]);
  });
  suite.testUsingWebGL('TimesBToTheAModRFamily', function() {
    var circuit = new CircuitDefinition(8, [new GateColumn([undefined, Gates.HalfTurns.X, Gates.InputGates.SetB.withParam(5), Gates.InputGates.SetA.withParam(6), Gates.InputGates.SetR.withParam(251), undefined, undefined, undefined]), new GateColumn([Gates.ModularMultiplicationGates.TimesBToTheAModRFamily.ofSize(8), undefined, undefined, undefined, undefined, undefined, undefined, undefined])]);
    var stats = CircuitStats.fromCircuitAtTime(circuit, 0);
    assertThat($traceurRuntime.spread(stats.finalState.rawBuffer()).indexOf(1) / 2).isEqualTo(126);
  });
  suite.testUsingWebGL('TimesInverseBToTheAModRFamily', function() {
    var circuit = new CircuitDefinition(8, [new GateColumn([Gates.HalfTurns.X, Gates.HalfTurns.X, Gates.InputGates.SetB.withParam(5), Gates.InputGates.SetA.withParam(3), Gates.InputGates.SetR.withParam(251), undefined, undefined, undefined]), new GateColumn([Gates.ModularMultiplicationGates.TimesInverseBToTheAModRFamily.ofSize(8), undefined, undefined, undefined, undefined, undefined, undefined, undefined])]);
    var stats = CircuitStats.fromCircuitAtTime(circuit, 0);
    assertThat($traceurRuntime.spread(stats.finalState.rawBuffer()).indexOf(1) / 2).isEqualTo(245);
  });
  suite.testUsingWebGL('TimesBToTheAModRFamily_perm', function() {
    assertThatGateActsLikePermutation(Gates.ModularMultiplicationGates.TimesBToTheAModRFamily.ofSize(3), function(v, a, b, r) {
      return modularPowerMultiply(v, b, a, r);
    }, [3, 3, 3]);
  });
  suite.testUsingWebGL('TimesBToTheAModRFamilyInverse_perm', function() {
    assertThatGateActsLikePermutation(Gates.ModularMultiplicationGates.TimesInverseBToTheAModRFamily.ofSize(3), function(v, a, b, r) {
      return modularPowerMultiply(v, b, -a, r);
    }, [3, 3, 3]);
  });
  return {};
});
//# sourceURL=test/gates/ModularMultiplicationGates.test.js
;$traceurRuntime.registerModule("test/gates/ModularMultiplyAccumulateGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ModularMultiplyAccumulateGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ModularMultiplyAccumulateGates.test.js")).Suite;
  var assertThatGateActsLikePermutation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/ModularMultiplyAccumulateGates.test.js")).assertThatGateActsLikePermutation;
  var ModularMultiplyAccumulateGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ModularMultiplyAccumulateGates.js", "test/gates/ModularMultiplyAccumulateGates.test.js")).ModularMultiplyAccumulateGates;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Util.js", "test/gates/ModularMultiplyAccumulateGates.test.js")).Util;
  var suite = new Suite("ModularMultiplyAccumulateGates");
  suite.testUsingWebGL('plus_AB_mod_R_permutation', function() {
    assertThatGateActsLikePermutation(ModularMultiplyAccumulateGates.PlusABModRFamily.ofSize(2), function(t, a, b, r) {
      return t < r ? (t + a * b) % r : t;
    }, [2, 2, 2]);
  });
  suite.testUsingWebGL('minus_AB_mod_R_permutation', function() {
    assertThatGateActsLikePermutation(ModularMultiplyAccumulateGates.MinusABModRFamily.ofSize(2), function(t, a, b, r) {
      return t < r ? Util.properMod(t - a * b, r) : t;
    }, [2, 2, 2]);
  });
  return {};
});
//# sourceURL=test/gates/ModularMultiplyAccumulateGates.test.js
;$traceurRuntime.registerModule("test/gates/MultiplicationGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/MultiplicationGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/MultiplicationGates.test.js")).Suite;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/MultiplicationGates.test.js")).Gates;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/MultiplicationGates.test.js")).CircuitDefinition;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ModularMultiplicationGates.js", "test/gates/MultiplicationGates.test.js")),
      modularMultiply = $__3.modularMultiply,
      modularUnmultiply = $__3.modularUnmultiply;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/MultiplicationGates.test.js")),
      assertThatGateActsLikePermutation = $__4.assertThatGateActsLikePermutation,
      assertThatCircuitOutputsBasisKet = $__4.assertThatCircuitOutputsBasisKet;
  var suite = new Suite("MultiplicationGates");
  suite.testUsingWebGL('multiplication_gate', function() {
    assertThatGateActsLikePermutation(Gates.MultiplicationGates.TimesAFamily.ofSize(4), function(x, a) {
      return modularMultiply(x, a, 1 << 4);
    }, [4]);
    assertThatGateActsLikePermutation(Gates.MultiplicationGates.TimesAFamily.ofSize(2), function(x, a) {
      return modularMultiply(x, a, 1 << 2);
    }, [4]);
  });
  suite.testUsingWebGL('inverse_multiplication_gate', function() {
    assertThatGateActsLikePermutation(Gates.MultiplicationGates.TimesAInverseFamily.ofSize(4), function(x, a) {
      return modularUnmultiply(x, a, 1 << 4);
    }, [4]);
    assertThatGateActsLikePermutation(Gates.MultiplicationGates.TimesAInverseFamily.ofSize(2), function(x, a) {
      return modularUnmultiply(x, a, 1 << 2);
    }, [4]);
  });
  suite.testUsingWebGL('times_big_A', function() {
    var circuit = CircuitDefinition.fromTextDiagram(new Map([['a', Gates.InputGates.SetA.withParam(16385)], ['*', Gates.MultiplicationGates.TimesAFamily], ['X', Gates.HalfTurns.X], ['-', undefined], ['/', null]]), "-a-X-*-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         -----/-\n         ---X-/-\n         -----/-\n         -----/-");
    assertThatCircuitOutputsBasisKet(circuit, 24577);
  });
  return {};
});
//# sourceURL=test/gates/MultiplicationGates.test.js
;$traceurRuntime.registerModule("test/gates/MultiplyAccumulateGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/MultiplyAccumulateGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/MultiplyAccumulateGates.test.js")).Suite;
  var MultiplyAccumulateGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/MultiplyAccumulateGates.js", "test/gates/MultiplyAccumulateGates.test.js")).MultiplyAccumulateGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InputGates.js", "test/gates/MultiplyAccumulateGates.test.js")).InputGates;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/MultiplyAccumulateGates.test.js")),
      assertThatCircuitOutputsBasisKet = $__3.assertThatCircuitOutputsBasisKet,
      assertThatCircuitUpdateActsLikeMatrix = $__3.assertThatCircuitUpdateActsLikeMatrix;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/MultiplyAccumulateGates.test.js")).advanceStateWithCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/MultiplyAccumulateGates.test.js")).CircuitDefinition;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/gates/MultiplyAccumulateGates.test.js")).GateColumn;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/MultiplyAccumulateGates.test.js")).Matrix;
  var suite = new Suite("MultiplyAccumulateGates");
  suite.testUsingWebGL('plus_AB', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(5, [new GateColumn([MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(2), undefined, InputGates.InputAFamily.ofSize(2), undefined, InputGates.InputBFamily.ofSize(1)])]), false);
    }, Matrix.generateTransition(32, function(i) {
      var a = (i >> 2) & 3;
      var b = (i >> 4) & 1;
      var t = i & 3;
      return (a << 2) | (b << 4) | ((t + a * b) & 3);
    }));
  });
  suite.testUsingWebGL('minus_AB', function() {
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(5, [new GateColumn([InputGates.InputAFamily.ofSize(2), undefined, MultiplyAccumulateGates.MultiplySubtractInputsFamily.ofSize(2), undefined, InputGates.InputBFamily.ofSize(1)])]), false).output;
    }, Matrix.generateTransition(32, function(i) {
      var a = i & 3;
      var b = (i >> 4) & 1;
      var t = (i >> 2) & 3;
      return a | (b << 4) | (((t - a * b) & 3) << 2);
    }));
  });
  suite.testUsingWebGL('plus_big_AB', function() {
    var circuit = CircuitDefinition.fromTextDiagram(new Map([['a', InputGates.SetA.withParam((1 << 14) + 1)], ['b', InputGates.SetB.withParam((1 << 14) + 1)], ['*', MultiplyAccumulateGates.MultiplyAddInputsFamily], ['-', undefined], ['/', null]]), "-a-*-\n         ---/-\n         -b-/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-\n         ---/-");
    assertThatCircuitOutputsBasisKet(circuit, 1 + (2 << 14));
  });
  return {};
});
//# sourceURL=test/gates/MultiplyAccumulateGates.test.js
;$traceurRuntime.registerModule("test/gates/ParametrizedRotationGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ParametrizedRotationGates.test.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ParametrizedRotationGates.test.js")),
      assertThat = $__2.assertThat,
      Suite = $__2.Suite;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/ParametrizedRotationGates.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/ParametrizedRotationGates.test.js")).CircuitStats;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/gates/ParametrizedRotationGates.test.js")).Complex;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/ParametrizedRotationGates.test.js")).Gates;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/ParametrizedRotationGates.test.js")).Matrix;
  var suite = new Suite("ParametrizedRotationGates");
  var evalTopQubit = function(diagram) {
    return CircuitStats.fromCircuitAtTime(CircuitDefinition.fromTextDiagram(new Map([['1', Gates.HalfTurns.X], ['H', Gates.HalfTurns.H], ['X', Gates.ParametrizedRotationGates.XToA], ['Y', Gates.ParametrizedRotationGates.YToA], ['Z', Gates.ParametrizedRotationGates.ZToA], ['x', Gates.ParametrizedRotationGates.XToMinusA], ['y', Gates.ParametrizedRotationGates.YToMinusA], ['z', Gates.ParametrizedRotationGates.ZToMinusA], ['A', Gates.InputGates.InputAFamily], ['-', undefined], ['/', null]]), diagram), 0).qubitDensityMatrix(Infinity, 0);
  };
  function state() {
    var $__1;
    for (var row = [],
        $__0 = 0; $__0 < arguments.length; $__0++)
      row[$__0] = arguments[$__0];
    var v = ($__1 = Matrix).row.apply($__1, $traceurRuntime.spread(row));
    return v.adjoint().times(v).times(1 / v.norm2());
  }
  suite.testUsingWebGL('XToA', function() {
    assertThat(evalTopQubit("--X-\n                             --A-\n                             --/-\n                             --/-")).isApproximatelyEqualTo(state(1, 0));
    assertThat(evalTopQubit("--XX-\n                             --AA-\n                             --//-\n                             1-//-")).isApproximatelyEqualTo(state(0, 1));
    assertThat(evalTopQubit("--X-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.XForward.knownMatrixAt(1 / 4).getColumn(0))), 0.0001);
    assertThat(evalTopQubit("1-X-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.XForward.knownMatrixAt(1 / 4).getColumn(1))), 0.0001);
    assertThat(evalTopQubit("--X-\n                             1-A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.XForward.knownMatrixAt(5 / 16).getColumn(0))), 0.0001);
  });
  suite.testUsingWebGL('YToA', function() {
    assertThat(evalTopQubit("--Y-\n                             --A-\n                             --/-\n                             --/-")).isApproximatelyEqualTo(state(1, 0));
    assertThat(evalTopQubit("--YY-\n                             --AA-\n                             --//-\n                             1-//-")).isApproximatelyEqualTo(state(0, 1));
    assertThat(evalTopQubit("--Y-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.YForward.knownMatrixAt(1 / 4).getColumn(0))), 0.0001);
    assertThat(evalTopQubit("--Y-\n                             1-A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.YForward.knownMatrixAt(5 / 16).getColumn(0))), 0.0001);
  });
  suite.testUsingWebGL('ZToA', function() {
    assertThat(evalTopQubit("H-Z-\n                             --A-\n                             --/-\n                             --/-")).isApproximatelyEqualTo(state(1, 1));
    assertThat(evalTopQubit("H-Z-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state(1, Complex.polar(1, Math.PI / 2)), 0.0001);
    assertThat(evalTopQubit("H-ZZ-\n                             --AA-\n                             --//-\n                             1-//-")).isApproximatelyEqualTo(state(1, -1), 0.0001);
    assertThat(evalTopQubit("H-Z-\n                             1-A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state(1, Complex.polar(1, Math.PI * 5 / 8)), 0.0001);
  });
  suite.testUsingWebGL('XToMinusA', function() {
    assertThat(evalTopQubit("--x-\n                             --A-\n                             --/-\n                             --/-")).isApproximatelyEqualTo(state(1, 0));
    assertThat(evalTopQubit("--x-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.XForward.knownMatrixAt(3 / 4).getColumn(0))), 0.0001);
    assertThat(evalTopQubit("--x-\n                             1-A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.XForward.knownMatrixAt(11 / 16).getColumn(0))), 0.0001);
  });
  suite.testUsingWebGL('YToMinusA', function() {
    assertThat(evalTopQubit("--y-\n                             --A-\n                             --/-\n                             --/-")).isApproximatelyEqualTo(state(1, 0));
    assertThat(evalTopQubit("--y-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.YForward.knownMatrixAt(3 / 4).getColumn(0))), 0.0001);
    assertThat(evalTopQubit("--y-\n                             1-A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state.apply((void 0), $traceurRuntime.spread(Gates.Powering.YForward.knownMatrixAt(11 / 16).getColumn(0))), 0.0001);
  });
  suite.testUsingWebGL('ZToMinusA', function() {
    assertThat(evalTopQubit("H-z-\n                             --A-\n                             --/-\n                             --/-")).isApproximatelyEqualTo(state(1, 1));
    assertThat(evalTopQubit("H-z-\n                             --A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state(1, Complex.polar(1, Math.PI * 3 / 2)), 0.0001);
    assertThat(evalTopQubit("H-z-\n                             1-A-\n                             --/-\n                             1-/-")).isApproximatelyEqualTo(state(1, Complex.polar(1, Math.PI * 11 / 8)), 0.0001);
  });
  suite.testUsingWebGL('formulaic_formulas', function() {
    var f = function(text, t) {
      return CircuitStats.fromCircuitAtTime(CircuitDefinition.fromTextDiagram(new Map([['H', Gates.HalfTurns.H], ['t', Gates.ParametrizedRotationGates.FormulaicRotationZ.withParam(text)], ['-', undefined]]), 'Ht'), (t + 1) / 2).finalState.cell(0, 1).ln().imag / Math.PI;
    };
    assertThat(f('0.5', 0.1)).isApproximatelyEqualTo(0.5);
    assertThat(f('0.5', 0.2)).isApproximatelyEqualTo(0.5);
    assertThat(f('t', 0.1)).isApproximatelyEqualTo(0.1);
    assertThat(f('t', 0.2)).isApproximatelyEqualTo(0.2);
    assertThat(f('t t', 0.1)).isApproximatelyEqualTo(0.1 * 0.1);
    assertThat(f('cos(pi t)', 1 / 3)).isApproximatelyEqualTo(0.5);
    assertThat(f('sin(pi t)', 1 / 3)).isApproximatelyEqualTo(Math.sqrt(3 / 4));
    assertThat(f('tan(t)', 1 / 3)).isApproximatelyEqualTo(Math.tan(1 / 3));
    assertThat(f('-t', 1 / 3)).isApproximatelyEqualTo(-1 / 3);
    assertThat(f('t+t', 1 / 3)).isApproximatelyEqualTo(2 / 3);
    assertThat(f('t*t', 1 / 3)).isApproximatelyEqualTo(1 / 9);
    assertThat(f('t-1', 1 / 3)).isApproximatelyEqualTo(-2 / 3);
    assertThat(f('t/2', 1 / 3)).isApproximatelyEqualTo(1 / 6);
    assertThat(f('ln(e)', 1 / 3)).isApproximatelyEqualTo(1);
    assertThat(f('sqrt(t)', 1 / 3)).isApproximatelyEqualTo(Math.sqrt(1 / 3));
    assertThat(f('acos(t)', 1 / 3)).isApproximatelyEqualTo(Math.acos(1 / 3) - 2);
    assertThat(f('asin(t)', 1 / 3)).isApproximatelyEqualTo(Math.asin(1 / 3));
    assertThat(f('atan(t)', 1 / 3)).isApproximatelyEqualTo(Math.atan(1 / 3));
    assertThat(f('ln(t)', 1 / 3)).isApproximatelyEqualTo(Math.log(1 / 3) + 2);
    assertThat(f('exp(t)', 1 / 3)).isApproximatelyEqualTo(Math.exp(1 / 3) - 2);
  });
  suite.testUsingWebGL('formulaic_matrices', function() {
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationZ.withParam('0.5').knownMatrixAt(0.1)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, Complex.I));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationZ.withParam('t').knownMatrixAt(0.75)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, Complex.I));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationZ.withParam('t').knownMatrixAt(1)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, -1));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRz.withParam('0.5 pi').knownMatrixAt(0.1)).isApproximatelyEqualTo(Matrix.square(Complex.polar(1, -Math.PI / 4), 0, 0, Complex.polar(1, Math.PI / 4)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRz.withParam('t pi').knownMatrixAt(0.75)).isApproximatelyEqualTo(Matrix.square(Complex.polar(1, -Math.PI / 4), 0, 0, Complex.polar(1, Math.PI / 4)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRz.withParam('t pi').knownMatrixAt(1)).isApproximatelyEqualTo(Matrix.square(Complex.I.neg(), 0, 0, Complex.I));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationX.withParam('0.5').knownMatrixAt(0.1)).isApproximatelyEqualTo(Matrix.square(new Complex(0.5, 0.5), new Complex(0.5, -0.5), new Complex(0.5, -0.5), new Complex(0.5, 0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationX.withParam('t').knownMatrixAt(0.75)).isApproximatelyEqualTo(Matrix.square(new Complex(0.5, 0.5), new Complex(0.5, -0.5), new Complex(0.5, -0.5), new Complex(0.5, 0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationX.withParam('t').knownMatrixAt(1)).isApproximatelyEqualTo(Matrix.square(0, 1, 1, 0));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRx.withParam('0.5 pi').knownMatrixAt(0.1)).isApproximatelyEqualTo(Matrix.square(1, Complex.I.neg(), Complex.I.neg(), 1).times(Math.sqrt(0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRx.withParam('t pi').knownMatrixAt(0.75)).isApproximatelyEqualTo(Matrix.square(1, Complex.I.neg(), Complex.I.neg(), 1).times(Math.sqrt(0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRx.withParam('t pi').knownMatrixAt(1)).isApproximatelyEqualTo(Matrix.square(0, Complex.I.neg(), Complex.I.neg(), 0));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationY.withParam('0.5').knownMatrixAt(0.1)).isApproximatelyEqualTo(Matrix.square(new Complex(0.5, 0.5), new Complex(-0.5, -0.5), new Complex(0.5, 0.5), new Complex(0.5, 0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationY.withParam('t').knownMatrixAt(0.75)).isApproximatelyEqualTo(Matrix.square(new Complex(0.5, 0.5), new Complex(-0.5, -0.5), new Complex(0.5, 0.5), new Complex(0.5, 0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationY.withParam('t').knownMatrixAt(1)).isApproximatelyEqualTo(Matrix.square(0, Complex.I.neg(), Complex.I, 0));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRy.withParam('0.5 pi').knownMatrixAt(0.1)).isApproximatelyEqualTo(Matrix.square(1, -1, 1, 1).times(Math.sqrt(0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRy.withParam('t pi').knownMatrixAt(0.75)).isApproximatelyEqualTo(Matrix.square(1, -1, 1, 1).times(Math.sqrt(0.5)));
    assertThat(Gates.ParametrizedRotationGates.FormulaicRotationRy.withParam('t pi').knownMatrixAt(1)).isApproximatelyEqualTo(Matrix.square(0, -1, 1, 0));
  });
  return {};
});
//# sourceURL=test/gates/ParametrizedRotationGates.test.js
;$traceurRuntime.registerModule("test/gates/PhaseGradientGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/PhaseGradientGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/PhaseGradientGates.test.js")).Suite;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/PhaseGradientGates.test.js")),
      assertThatCircuitShaderActsLikeMatrix = $__2.assertThatCircuitShaderActsLikeMatrix,
      assertThatGateActsLikePhaser = $__2.assertThatGateActsLikePhaser;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/PhaseGradientGates.js", "test/gates/PhaseGradientGates.test.js")),
      PHASE_GRADIENT_SHADER = $__3.PHASE_GRADIENT_SHADER,
      PhaseGradientGates = $__3.PhaseGradientGates;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/gates/PhaseGradientGates.test.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/PhaseGradientGates.test.js")).Matrix;
  var ketArgs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/KetShaderUtil.js", "test/gates/PhaseGradientGates.test.js")).ketArgs;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/gates/PhaseGradientGates.test.js")).WglArg;
  var suite = new Suite("PhaseGradientGates");
  suite.testUsingWebGL('PHASE_GRADIENT_SHADER', function() {
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      var $__0;
      return ($__0 = PHASE_GRADIENT_SHADER).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx, 3), [WglArg.float('factor', Math.PI / 8)]));
    }, Matrix.generateDiagonal(8, function(i) {
      return Complex.polar(1, i * Math.PI / 8);
    }));
    assertThatCircuitShaderActsLikeMatrix(function(ctx) {
      var $__0;
      return ($__0 = PHASE_GRADIENT_SHADER).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx, 4), [WglArg.float('factor', -Math.PI / 16)]));
    }, Matrix.generateDiagonal(16, function(i) {
      return Complex.polar(1, -i * Math.PI / 16);
    }));
  });
  suite.testUsingWebGL('DynamicPhaseGradientFamily', function() {
    assertThatGateActsLikePhaser(PhaseGradientGates.DynamicPhaseGradientFamily.ofSize(3), function(k) {
      return 0.3 * k;
    }, 0.3);
    assertThatGateActsLikePhaser(PhaseGradientGates.DynamicPhaseDegradientFamily.ofSize(2), function(k) {
      return -0.1 * k;
    }, 0.1);
  });
  return {};
});
//# sourceURL=test/gates/PhaseGradientGates.test.js
;$traceurRuntime.registerModule("test/gates/PivotFlipGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/PivotFlipGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/PivotFlipGates.test.js")).Suite;
  var assertThatCircuitOutputsBasisKet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/PivotFlipGates.test.js")).assertThatCircuitOutputsBasisKet;
  var PivotFlipGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/PivotFlipGates.js", "test/gates/PivotFlipGates.test.js")).PivotFlipGates;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/gates/PivotFlipGates.test.js")).Gates;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/PivotFlipGates.test.js")).CircuitDefinition;
  var suite = new Suite("PivotFlipGates");
  suite.testUsingWebGL('pivot_flip', function() {
    var circ = function(diagram) {
      return CircuitDefinition.fromTextDiagram(new Map([['5', Gates.InputGates.SetA.withParam(5)], ['X', Gates.HalfTurns.X], ['F', PivotFlipGates.FlipUnderA], ['-', undefined], ['/', null]]), diagram);
    };
    assertThatCircuitOutputsBasisKet(circ("-5-F-\n                                           ---/-\n                                           ---/-\n                                           ---/-"), 4);
    assertThatCircuitOutputsBasisKet(circ("-X-5-F-\n                                           -----/-\n                                           -----/-\n                                           -----/-"), 3);
    assertThatCircuitOutputsBasisKet(circ("---5-F-\n                                           -X---/-\n                                           -----/-\n                                           -----/-"), 2);
    assertThatCircuitOutputsBasisKet(circ("-X-5-F-\n                                           -X---/-\n                                           -----/-\n                                           -----/-"), 1);
    assertThatCircuitOutputsBasisKet(circ("---5-F-\n                                           -----/-\n                                           -X---/-\n                                           -----/-"), 0);
    assertThatCircuitOutputsBasisKet(circ("-X-5-F-\n                                           -----/-\n                                           -X---/-\n                                           -----/-"), 5);
    assertThatCircuitOutputsBasisKet(circ("-X-5-F-\n                                           -----/-\n                                           -X---/-\n                                           -X---/-"), 13);
  });
  return {};
});
//# sourceURL=test/gates/PivotFlipGates.test.js
;$traceurRuntime.registerModule("test/gates/ProbabilityDisplay.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/ProbabilityDisplay.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/ProbabilityDisplay.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var amplitudesToProbabilities = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/ProbabilityDisplay.js", "test/gates/ProbabilityDisplay.test.js")).amplitudesToProbabilities;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitShaders.js", "test/gates/ProbabilityDisplay.test.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/gates/ProbabilityDisplay.test.js")).Controls;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/gates/ProbabilityDisplay.test.js")).Shaders;
  var suite = new Suite("ProbabilityDisplay");
  suite.testUsingWebGL("amplitudesToProbabilities", function() {
    var inp = Shaders.vec2Data(new Float32Array([2, 3, 4, 5, 6, 7, 8, 9, 1 / 2, 0, 0, 1 / 4, 0, 1 / 8, 1 / 16, 0])).toVec2Texture(3);
    var con = CircuitShaders.controlMask(Controls.NONE).toBoolTexture(3);
    assertThat(amplitudesToProbabilities(inp, con).readVecFloatOutputs(3)).isApproximatelyEqualTo(new Float32Array([4 + 9, 16 + 25, 36 + 49, 64 + 81, 1 / 4, 1 / 16, 1 / 64, 1 / 256]));
    inp.deallocByDepositingInPool();
    con.deallocByDepositingInPool();
  });
  return {};
});
//# sourceURL=test/gates/ProbabilityDisplay.test.js
;$traceurRuntime.registerModule("test/gates/SampleDisplay.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/SampleDisplay.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/SampleDisplay.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/SampleDisplay.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/gates/SampleDisplay.test.js")).CircuitStats;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Serializer.js", "test/gates/SampleDisplay.test.js")).Serializer;
  var suite = new Suite("SampleDisplay");
  suite.testUsingWebGL("SampleDisplay_SingleZero", function() {
    var stats = CircuitStats.fromCircuitAtTime(Serializer.fromJson(CircuitDefinition, {"cols": [["Sample1"]]}), 0);
    var out = stats.toReadableJson();
    assertThat(out.displays[0].data.probabilities).isApproximatelyEqualTo([1, 0]);
  });
  return {};
});
//# sourceURL=test/gates/SampleDisplay.test.js
;$traceurRuntime.registerModule("test/gates/XorGates.test.js", [], function() {
  "use strict";
  var __moduleName = "test/gates/XorGates.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/gates/XorGates.test.js")).Suite;
  var XorGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/XorGates.js", "test/gates/XorGates.test.js")).XorGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/InputGates.js", "test/gates/XorGates.test.js")).InputGates;
  var assertThatCircuitUpdateActsLikeMatrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../CircuitOperationTestUtil.js", "test/gates/XorGates.test.js")).assertThatCircuitUpdateActsLikeMatrix;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitComputeUtil.js", "test/gates/XorGates.test.js")).advanceStateWithCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/gates/XorGates.test.js")).CircuitDefinition;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/GateColumn.js", "test/gates/XorGates.test.js")).GateColumn;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/gates/XorGates.test.js")).Matrix;
  var suite = new Suite("XorGates");
  suite.testUsingWebGL('xor_a', function() {
    var matrix = Matrix.generateTransition(1 << 6, function(i) {
      var a = (i >> 3) & 3;
      var dst = i & 3;
      var left = i & ~3;
      return (a ^ dst) + left;
    });
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(6, [new GateColumn([XorGates.XorAFamily.ofSize(2), undefined, undefined, InputGates.InputAFamily.ofSize(2), undefined, undefined])]), false);
    }, matrix);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(6, [new GateColumn([XorGates.XorAFamily.ofSize(3), undefined, undefined, InputGates.InputAFamily.ofSize(2), undefined, undefined])]), false);
    }, matrix);
    assertThatCircuitUpdateActsLikeMatrix(function(ctx) {
      return advanceStateWithCircuit(ctx, new CircuitDefinition(6, [new GateColumn([XorGates.XorAFamily.ofSize(2), undefined, undefined, InputGates.InputAFamily.ofSize(3), undefined, undefined])]), false);
    }, matrix);
  });
  return {};
});
//# sourceURL=test/gates/XorGates.test.js
;$traceurRuntime.registerModule("test/KarmaTestRunner.test.js", [], function() {
  "use strict";
  var __moduleName = "test/KarmaTestRunner.test.js";
  var Suite = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TestUtil.js", "test/KarmaTestRunner.test.js")).Suite;
  var tryPromiseRun = function(method) {
    try {
      return Promise.resolve(method());
    } catch (ex) {
      return Promise.reject(ex);
    }
  };
  var promiseRunTest = function(suite, name, method) {
    var result = {
      description: name,
      suite: [suite.name],
      success: false,
      log: [],
      time: undefined
    };
    var status = {
      warn_only: false,
      log: result.log
    };
    var t0;
    var t1;
    var promise = tryPromiseRun(function() {
      t0 = performance.now();
      var result = method(status);
      t1 = performance.now();
      return result;
    });
    var finish = function() {
      result.time = t1 - t0;
      if (result.time > 5000) {
        console.warn((suite.name + "." + name + " took " + Math.ceil(result.time) + "ms to run."));
      }
      __karma__.result(result);
      return result;
    };
    return promise.then(function() {
      result.success = true;
      if (status.warn_only && !status.ignore_warn_only_on_success) {
        console.warn((suite.name + "." + name + " passed, but is set to warn_only (" + status.warn_only + ")"));
      }
      return finish();
    }, function(ex) {
      var msg = String(ex);
      result.log.push(msg);
      if (ex.details !== undefined) {
        result.log.push(ex.details);
      }
      if (ex.stack !== undefined) {
        var stackMsg = String(ex.stack);
        if (stackMsg.startsWith(msg)) {
          stackMsg = stackMsg.substring(msg.length);
        }
        result.log.push(stackMsg);
      }
      if (status.warn_only) {
        var msg$__22 = status.warn_failure_message !== undefined ? status.warn_failure_message : (suite.name + "." + name + " FAILED, but is set to warn_only (" + status.warn_only + ")");
        console.warn(msg$__22);
        if (status.warn_show_error) {
          var $__11 = true;
          var $__12 = false;
          var $__13 = undefined;
          try {
            for (var $__9 = void 0,
                $__8 = (result.log)[Symbol.iterator](); !($__11 = ($__9 = $__8.next()).done); $__11 = true) {
              var logMsg = $__9.value;
              {
                var $__4 = true;
                var $__5 = false;
                var $__6 = undefined;
                try {
                  for (var $__2 = void 0,
                      $__1 = (logMsg.split('\n'))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
                    var line = $__2.value;
                    {
                      console.warn('(ignored) ' + line);
                    }
                  }
                } catch ($__7) {
                  $__5 = true;
                  $__6 = $__7;
                } finally {
                  try {
                    if (!$__4 && $__1.return != null) {
                      $__1.return();
                    }
                  } finally {
                    if ($__5) {
                      throw $__6;
                    }
                  }
                }
              }
            }
          } catch ($__14) {
            $__12 = true;
            $__13 = $__14;
          } finally {
            try {
              if (!$__11 && $__8.return != null) {
                $__8.return();
              }
            } finally {
              if ($__12) {
                throw $__13;
              }
            }
          }
        }
      }
      result.success = status.warn_only;
      return finish();
    });
  };
  __karma__.start = function() {
    var total = 0;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Suite.suites)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var suite = $__2.value;
        {
          total += suite.tests.length + suite.later_tests.length;
          if (suite.tests.length + suite.later_tests.length === 0) {
            console.warn(("Empty test suite: " + suite.name));
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    __karma__.info({total: total});
    var chain = Promise.resolve();
    var $__11 = true;
    var $__12 = false;
    var $__13 = undefined;
    try {
      var $__23 = function() {
        var suite = $__9.value;
        {
          chain = chain.then(function() {
            return new Promise(function(resolver) {
              return setTimeout(function() {
                var suiteResult = Promise.all(suite.tests.map(function(e) {
                  return promiseRunTest(suite, e[0], e[1]);
                }));
                suiteResult.catch(function() {
                  return console.error((suite.name + " suite failed"));
                });
                resolver();
              }, 0);
            });
          });
        }
      };
      for (var $__9 = void 0,
          $__8 = (Suite.suites)[Symbol.iterator](); !($__11 = ($__9 = $__8.next()).done); $__11 = true) {
        $__23();
      }
    } catch ($__14) {
      $__12 = true;
      $__13 = $__14;
    } finally {
      try {
        if (!$__11 && $__8.return != null) {
          $__8.return();
        }
      } finally {
        if ($__12) {
          throw $__13;
        }
      }
    }
    var $__18 = true;
    var $__19 = false;
    var $__20 = undefined;
    try {
      var $__24 = function() {
        var suite = $__16.value;
        {
          chain = chain.then(function() {
            return new Promise(function(resolver) {
              return setTimeout(function() {
                var suiteResult = Promise.all(suite.later_tests.map(function(e) {
                  return promiseRunTest(suite, e[0], e[1]);
                }));
                suiteResult.catch(function() {
                  return console.error((suite.name + " suite failed"));
                });
                resolver();
              }, 0);
            });
          });
        }
      };
      for (var $__16 = void 0,
          $__15 = (Suite.suites)[Symbol.iterator](); !($__18 = ($__16 = $__15.next()).done); $__18 = true) {
        $__24();
      }
    } catch ($__21) {
      $__19 = true;
      $__20 = $__21;
    } finally {
      try {
        if (!$__18 && $__15.return != null) {
          $__15.return();
        }
      } finally {
        if ($__19) {
          throw $__20;
        }
      }
    }
    return chain.then(function() {
      return __karma__.complete();
    });
  };
  return {};
});
//# sourceURL=test/KarmaTestRunner.test.js
;$traceurRuntime.registerModule("test/math/Axis.test.js", [], function() {
  "use strict";
  var __moduleName = "test/math/Axis.test.js";
  var $__28 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/math/Axis.test.js")),
      Suite = $__28.Suite,
      assertThat = $__28.assertThat,
      assertThrows = $__28.assertThrows,
      assertTrue = $__28.assertTrue,
      assertFalse = $__28.assertFalse;
  var Axis = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Axis.js", "test/math/Axis.test.js")).Axis;
  var suite = new Suite("Axis");
  suite.test("isEqualTo", function() {
    var groups = [[new Axis(0, 0, 0), new Axis(0, 0, 0)], [new Axis(1, 0, 0), new Axis(1, 0, 0)], [new Axis(0, 1, 0), new Axis(0, 1, 0)], [new Axis(0, 0, 1), new Axis(0, 0, 1)], [new Axis(1, 2, 3), new Axis(1, 2, 3)], [new Axis(4, 5, 6)]];
    var $__24 = true;
    var $__25 = false;
    var $__26 = undefined;
    try {
      for (var $__22 = void 0,
          $__21 = (groups)[Symbol.iterator](); !($__24 = ($__22 = $__21.next()).done); $__24 = true) {
        var g1 = $__22.value;
        {
          var $__17 = true;
          var $__18 = false;
          var $__19 = undefined;
          try {
            for (var $__15 = void 0,
                $__14 = (groups)[Symbol.iterator](); !($__17 = ($__15 = $__14.next()).done); $__17 = true) {
              var g2 = $__15.value;
              {
                var $__10 = true;
                var $__11 = false;
                var $__12 = undefined;
                try {
                  for (var $__8 = void 0,
                      $__7 = (g1)[Symbol.iterator](); !($__10 = ($__8 = $__7.next()).done); $__10 = true) {
                    var e1 = $__8.value;
                    {
                      var $__3 = true;
                      var $__4 = false;
                      var $__5 = undefined;
                      try {
                        for (var $__1 = void 0,
                            $__0 = (g2)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
                          var e2 = $__1.value;
                          {
                            if (g1 === g2) {
                              assertThat(e1).isEqualTo(e2);
                              assertTrue(e1.isEqualTo(e2));
                            } else {
                              assertThat(e1).isNotEqualTo(e2);
                              assertFalse(e1.isEqualTo(e2));
                            }
                          }
                        }
                      } catch ($__6) {
                        $__4 = true;
                        $__5 = $__6;
                      } finally {
                        try {
                          if (!$__3 && $__0.return != null) {
                            $__0.return();
                          }
                        } finally {
                          if ($__4) {
                            throw $__5;
                          }
                        }
                      }
                    }
                  }
                } catch ($__13) {
                  $__11 = true;
                  $__12 = $__13;
                } finally {
                  try {
                    if (!$__10 && $__7.return != null) {
                      $__7.return();
                    }
                  } finally {
                    if ($__11) {
                      throw $__12;
                    }
                  }
                }
              }
            }
          } catch ($__20) {
            $__18 = true;
            $__19 = $__20;
          } finally {
            try {
              if (!$__17 && $__14.return != null) {
                $__14.return();
              }
            } finally {
              if ($__18) {
                throw $__19;
              }
            }
          }
        }
      }
    } catch ($__27) {
      $__25 = true;
      $__26 = $__27;
    } finally {
      try {
        if (!$__24 && $__21.return != null) {
          $__21.return();
        }
      } finally {
        if ($__25) {
          throw $__26;
        }
      }
    }
    assertThat(new Axis(0, 0, 0)).isNotEqualTo(0);
    assertThat(new Axis(0, 0, 0)).isNotEqualTo("");
  });
  suite.test("parse", function() {
    assertThrows(function() {
      return Axis.parse("");
    });
    assertThrows(function() {
      return Axis.parse("0");
    });
    assertThrows(function() {
      return Axis.parse("abc");
    });
    assertThrows(function() {
      return Axis.parse("x*y");
    });
    assertThrows(function() {
      return Axis.parse("x^y");
    });
    assertThrows(function() {
      return Axis.parse("x/y");
    });
    assertThat(Axis.parse("x")).isEqualTo(new Axis(1, 0, 0));
    assertThat(Axis.parse("y")).isEqualTo(new Axis(0, 1, 0));
    assertThat(Axis.parse("z")).isEqualTo(new Axis(0, 0, 1));
    assertThat(Axis.parse("sqrt --4 x")).isEqualTo(new Axis(2, 0, 0));
    assertThat(Axis.parse("2z+3y-5x-x")).isEqualTo(new Axis(-6, 3, 2));
    assertThat(Axis.parse("2z*6^2+3y-5x-x")).isEqualTo(new Axis(-6, 3, 72));
    assertThat(Axis.parse("2z+")).isEqualTo(new Axis(0, 0, 2));
    assertThat(Axis.parse("2z*")).isEqualTo(new Axis(0, 0, 2));
    assertThat(Axis.parse("(2z)^")).isEqualTo(new Axis(0, 0, 2));
    assertThat(Axis.parse("2z/")).isEqualTo(new Axis(0, 0, 2));
    assertThat(Axis.parse("2z-")).isEqualTo(new Axis(0, 0, 2));
  });
  return {};
});
//# sourceURL=test/math/Axis.test.js
;$traceurRuntime.registerModule("test/math/Complex.test.js", [], function() {
  "use strict";
  var __moduleName = "test/math/Complex.test.js";
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/math/Complex.test.js")),
      Suite = $__7.Suite,
      assertThat = $__7.assertThat,
      assertThrows = $__7.assertThrows,
      assertTrue = $__7.assertTrue;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/math/Complex.test.js")).Complex;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Format.js", "test/math/Complex.test.js")).Format;
  var suite = new Suite("Complex");
  suite.test("isEqualTo", function() {
    var c = new Complex(5, 7);
    assertThat(c).isEqualTo(c);
    assertThat(c).isNotEqualTo(null);
    assertThat(c).isNotEqualTo("");
    assertThat(new Complex(2, 3)).isEqualTo(new Complex(2, 3));
    assertThat(new Complex(2, 3)).isNotEqualTo(new Complex(3, 3));
    assertThat(new Complex(2, 3)).isNotEqualTo(new Complex(2, 4));
    assertThat(new Complex(2, 3)).isNotEqualTo(new Complex(3, 2));
    assertThat(Complex.ZERO).isEqualTo(0);
    assertThat(Complex.ONE).isEqualTo(1);
    assertThat(Complex.ZERO).isNotEqualTo(1);
    assertThat(Complex.I).isNotEqualTo(1);
    assertThat(new Complex(2.5, 0)).isEqualTo(2.5);
    assertThat(new Complex(0, 2.5)).isNotEqualTo(2.5);
  });
  suite.test("polar", function() {
    assertThat(Complex.polar(0, 0)).isEqualTo(0);
    assertThat(Complex.polar(0, 2)).isEqualTo(0);
    assertThat(Complex.polar(0, -5)).isEqualTo(0);
    assertThat(Complex.polar(1, 0)).isEqualTo(1);
    assertThat(Complex.polar(2, 0)).isEqualTo(2);
    assertThat(Complex.polar(1, Math.PI)).isEqualTo(-1);
    assertThat(Complex.polar(1, 3 * Math.PI)).isEqualTo(-1);
    assertThat(Complex.polar(1, -Math.PI)).isEqualTo(-1);
    assertThat(Complex.polar(1, Math.PI / 2)).isEqualTo(Complex.I);
    assertThat(Complex.polar(1, 3 * Math.PI / 2)).isEqualTo(Complex.I.times(-1));
    assertThat(Complex.polar(1, Math.PI / 4)).isEqualTo(new Complex(Math.sqrt(0.5), Math.sqrt(0.5)));
    assertThat(Complex.polar(Math.sqrt(2), Math.PI / 4)).isApproximatelyEqualTo(new Complex(1, 1));
  });
  suite.test("isApproximatelyEqualTo", function() {
    var c = new Complex(5, 7);
    assertThat(c).isApproximatelyEqualTo(c, 0);
    assertThat(c).isApproximatelyEqualTo(c, 1);
    assertThat(c).isNotApproximatelyEqualTo(new Complex(5, 6), 0.5);
    assertThat(c).isApproximatelyEqualTo(new Complex(5, 6), 1);
    assertThat(c).isApproximatelyEqualTo(new Complex(5, 8), 1);
    assertThat(c).isNotApproximatelyEqualTo(null);
    assertThat(c).isNotApproximatelyEqualTo("");
  });
  suite.test("from", function() {
    assertThat(Complex.from(1).real).isEqualTo(1);
    assertThat(Complex.from(1).imag).isEqualTo(0);
    assertThat(Complex.from(-1.5).real).isEqualTo(-1.5);
    assertThat(Complex.from(-1.5).imag).isEqualTo(0);
    assertThat(Complex.from(new Complex(2, 3)).real).isEqualTo(2);
    assertThat(Complex.from(new Complex(2, 3)).imag).isEqualTo(3);
  });
  suite.test("realPartOf", function() {
    assertThat(Complex.realPartOf(1)).isEqualTo(1);
    assertThat(Complex.realPartOf(1.5)).isEqualTo(1.5);
    assertThat(Complex.realPartOf(-2)).isEqualTo(-2);
    assertThat(Complex.realPartOf(new Complex(3, 1))).isEqualTo(3);
    assertThat(Complex.realPartOf(new Complex(5, 0))).isEqualTo(5);
  });
  suite.test("imagPartOf", function() {
    assertThat(Complex.imagPartOf(1)).isEqualTo(0);
    assertThat(Complex.imagPartOf(1.5)).isEqualTo(0);
    assertThat(Complex.imagPartOf(-2)).isEqualTo(0);
    assertThat(Complex.imagPartOf(new Complex(3, 0))).isEqualTo(0);
    assertThat(Complex.imagPartOf(new Complex(3, 1))).isEqualTo(1);
    assertThat(Complex.imagPartOf(new Complex(5, -2))).isEqualTo(-2);
  });
  suite.test("toString", function() {
    assertThat(Complex.ZERO.toString()).isEqualTo("0");
    assertThat(Complex.ONE.toString()).isEqualTo("1");
    assertThat(Complex.I.toString()).isEqualTo("i");
    assertThat(new Complex(1, 1).toString()).isEqualTo("1+i");
    assertThat(new Complex(-1, 0).toString()).isEqualTo("-1");
    assertThat(new Complex(0, -1).toString()).isEqualTo("-i");
    assertThat(new Complex(-1, -1).toString()).isEqualTo("-1-i");
    assertThat(new Complex(2, 0).toString()).isEqualTo("2");
    assertThat(new Complex(0, 2).toString()).isEqualTo("2i");
    assertThat(new Complex(2, 2).toString()).isEqualTo("2+2i");
    assertThat(new Complex(2, -3).toString()).isEqualTo("2-3i");
    assertThat(new Complex(Math.sqrt(1 / 2), -1 / 3).toString()).isEqualTo("\u221A\u00BD-\u2153i");
    assertThat(new Complex(2, -3).toString(Format.CONSISTENT)).isEqualTo("+2.00-3.00i");
    assertThat(new Complex(2, -3).toString(Format.EXACT)).isEqualTo("2-3i");
    assertThat(new Complex(2, -3).toString(Format.MINIFIED)).isEqualTo("2-3i");
    assertThat(new Complex(2, -3).toString(Format.SIMPLIFIED)).isEqualTo("2-3i");
    assertThat(new Complex(-2, -3).toString(Format.CONSISTENT)).isEqualTo("-2.00-3.00i");
    assertThat(new Complex(-2, -3).toString(Format.EXACT)).isEqualTo("-2-3i");
    assertThat(new Complex(-2, -3).toString(Format.MINIFIED)).isEqualTo("-2-3i");
    assertThat(new Complex(-2, -3).toString(Format.SIMPLIFIED)).isEqualTo("-2-3i");
    assertThat(new Complex(0, -1).toString(Format.CONSISTENT)).isEqualTo("+0.00-1.00i");
    assertThat(new Complex(0, -1).toString(Format.EXACT)).isEqualTo("-i");
    assertThat(new Complex(0, -1).toString(Format.MINIFIED)).isEqualTo("-i");
    assertThat(new Complex(0, -1).toString(Format.SIMPLIFIED)).isEqualTo("-i");
    assertThat(new Complex(1 / 3, 0).toString(Format.CONSISTENT)).isEqualTo("+0.33+0.00i");
    assertThat(new Complex(1 / 3, 0).toString(Format.EXACT)).isEqualTo("\u2153");
    assertThat(new Complex(1 / 3, 0).toString(Format.MINIFIED)).isEqualTo("\u2153");
    assertThat(new Complex(1 / 3, 0).toString(Format.SIMPLIFIED)).isEqualTo("\u2153");
  });
  suite.test("toString_perturbed", function() {
    assertThat(new Complex(1 / 3 + 0.00001, 0).toString(Format.CONSISTENT)).isEqualTo("+0.33+0.00i");
    assertThat(new Complex(1 / 3 + 0.00001, 0).toString(Format.EXACT)).isEqualTo("0.3333433333333333");
    assertThat(new Complex(1 / 3 + 0.00001, 0).toString(Format.MINIFIED)).isEqualTo("0.3333433333333333");
    assertThat(new Complex(1 / 3 + 0.00001, 0).toString(Format.SIMPLIFIED)).isEqualTo("\u2153");
  });
  suite.test("parse_raw", function() {
    assertThrows(function() {
      return Complex.parse("");
    });
    assertThrows(function() {
      return Complex.parse("abc");
    });
    assertThrows(function() {
      return Complex.parse("1e_plus1");
    });
    assertThrows(function() {
      return Complex.parse("1e_minus1");
    });
    assertThat(Complex.parse("0")).isEqualTo(Complex.ZERO);
    assertThat(Complex.parse("1")).isEqualTo(Complex.ONE);
    assertThat(Complex.parse("-1")).isEqualTo(new Complex(-1, 0));
    assertThat(Complex.parse("i")).isEqualTo(Complex.I);
    assertThat(Complex.parse("-i")).isEqualTo(new Complex(0, -1));
    assertThat(Complex.parse("2")).isEqualTo(new Complex(2, 0));
    assertThat(Complex.parse("2i")).isEqualTo(new Complex(0, 2));
    assertThat(Complex.parse("-2i")).isEqualTo(new Complex(0, -2));
    assertThat(Complex.parse("3-2i")).isEqualTo(new Complex(3, -2));
    assertThat(Complex.parse("1-i")).isEqualTo(new Complex(1, -1));
    assertThat(Complex.parse("1+i")).isEqualTo(new Complex(1, 1));
    assertThat(Complex.parse("-5+2i")).isEqualTo(new Complex(-5, 2));
    assertThat(Complex.parse("-5-2i")).isEqualTo(new Complex(-5, -2));
    assertThat(Complex.parse("3/2i")).isEqualTo(new Complex(0, 1.5));
    assertThat(Complex.parse("\u221A2-\u2153i")).isEqualTo(new Complex(Math.sqrt(2), -1 / 3));
    assertThat(Complex.parse("1e-10")).isEqualTo(new Complex(0.0000000001, 0));
    assertThat(Complex.parse("1e+10")).isEqualTo(new Complex(10000000000, 0));
    assertThat(Complex.parse("2.5e-10")).isEqualTo(new Complex(0.00000000025, 0));
    assertThat(Complex.parse("2.5E-10")).isEqualTo(new Complex(0.00000000025, 0));
    assertThat(Complex.parse("2.5e+10")).isEqualTo(new Complex(25000000000, 0));
  });
  suite.test("parse_expressions", function() {
    assertThat(Complex.parse("1/3")).isEqualTo(1 / 3);
    assertThat(Complex.parse("2/3/5")).isEqualTo((2 / 3) / 5);
    assertThat(Complex.parse("2/3/5*7/13")).isEqualTo(((((2 / 3) / 5)) * 7) / 13);
    assertThat(Complex.parse("2-3-5")).isEqualTo(-6);
    assertThat(Complex.parse("1/3+2i")).isEqualTo(new Complex(1 / 3, 2));
    assertThat(Complex.parse("(1/3)+2i")).isEqualTo(new Complex(1 / 3, 2));
    assertThat(Complex.parse("1/(3+2i)")).isEqualTo(Complex.ONE.dividedBy(new Complex(3, 2)));
    assertThat(Complex.parse("1/sqrt(3+2i)")).isEqualTo(Complex.ONE.dividedBy(new Complex(3, 2).raisedTo(0.5)));
    assertThat(Complex.parse("i^i")).isEqualTo(0.20787957635076193);
    assertThat(Complex.parse("√i")).isEqualTo(new Complex(Math.sqrt(0.5), Math.sqrt(0.5)));
    assertThat(Complex.parse("√4i")).isEqualTo(new Complex(0, 2));
    assertThat(Complex.parse("sqrt4i")).isEqualTo(new Complex(0, 2));
    assertThat(Complex.parse("sqrt√4i")).isEqualTo(new Complex(0, Math.sqrt(2)));
    assertThat(Complex.parse("sqrt√4-i")).isEqualTo(new Complex(Math.sqrt(2), -1));
    assertThat(Complex.parse("----------1")).isEqualTo(1);
    assertThat(Complex.parse("---------1")).isEqualTo(-1);
    assertThat(Complex.parse("---+--+--1")).isEqualTo(-1);
    assertThat(Complex.parse("0---+--+--1")).isEqualTo(-1);
    assertThat(Complex.parse("0---+--+--1*")).isEqualTo(-1);
    assertThat(Complex.parse("2+3^")).isEqualTo(5);
    assertThat(Complex.parse("cos(45) + i sin(45)")).isApproximatelyEqualTo(new Complex(Math.sqrt(0.5), Math.sqrt(0.5)));
    assertThat(Complex.parse("cos(45) + i (sin 45)")).isApproximatelyEqualTo(new Complex(Math.sqrt(0.5), Math.sqrt(0.5)));
    assertThat(Complex.parse("e^(pi i)")).isApproximatelyEqualTo(-1);
    assertThat(Complex.parse("exp(ln(2))")).isApproximatelyEqualTo(2);
    assertThat(Complex.parse("sin(arcsin(0.5))")).isApproximatelyEqualTo(0.5);
    assertThat(Complex.parse("cos(arccos(0.5))")).isApproximatelyEqualTo(0.5);
    assertThat(Complex.parse("sin(asin(0.5))")).isApproximatelyEqualTo(0.5);
    assertThat(Complex.parse("cos(acos(0.5))")).isApproximatelyEqualTo(0.5);
  });
  suite.test("norm2", function() {
    assertThat(Complex.ZERO.norm2()).isEqualTo(0);
    assertThat(Complex.ONE.norm2()).isEqualTo(1);
    assertThat(Complex.I.norm2()).isEqualTo(1);
    assertThat(new Complex(1, 1).norm2()).isEqualTo(2);
    assertThat(new Complex(2, 0).norm2()).isEqualTo(4);
    assertThat(new Complex(0, 2).norm2()).isEqualTo(4);
    assertThat(new Complex(-2, 0).norm2()).isEqualTo(4);
    assertThat(new Complex(0, -2).norm2()).isEqualTo(4);
    assertThat(new Complex(2, 3).norm2()).isEqualTo(13);
    assertThat(new Complex(-3, -4).norm2()).isEqualTo(25);
  });
  suite.test("abs", function() {
    assertThat(Complex.ZERO.abs()).isEqualTo(0);
    assertThat(Complex.ONE.abs()).isEqualTo(1);
    assertThat(Complex.I.abs()).isEqualTo(1);
    assertThat(new Complex(2, 0).abs()).isEqualTo(2);
    assertThat(new Complex(0, 2).abs()).isEqualTo(2);
    assertThat(new Complex(-2, 0).abs()).isEqualTo(2);
    assertThat(new Complex(0, -2).abs()).isEqualTo(2);
    assertThat(new Complex(2, 3).abs()).isApproximatelyEqualTo(Math.sqrt(13));
    assertThat(new Complex(-3, -4).abs()).isEqualTo(5);
  });
  suite.test("conjugate", function() {
    assertThat(Complex.ZERO.conjugate()).isEqualTo(Complex.ZERO);
    assertThat(new Complex(2, 3).conjugate()).isEqualTo(new Complex(2, -3));
  });
  suite.test("phase", function() {
    assertThat(Complex.ZERO.phase()).isEqualTo(0);
    assertThat(Complex.ONE.phase()).isEqualTo(0);
    assertThat(Complex.I.phase()).isApproximatelyEqualTo(Math.PI / 2);
    assertThat(new Complex(-1, 0).phase()).isApproximatelyEqualTo(Math.PI);
    assertThat(new Complex(0, -1).phase()).isApproximatelyEqualTo(-Math.PI / 2);
    assertThat(new Complex(1, 1).phase()).isApproximatelyEqualTo(Math.PI / 4);
    assertThat(new Complex(2, 1).phase()).isApproximatelyEqualTo(Math.PI * 0.1475836);
  });
  suite.test("unit", function() {
    assertThat(Complex.ZERO.unit().isEqualTo(1));
    assertThat(new Complex(0.5, 0).unit().isEqualTo(1));
    assertThat(Complex.ONE.unit().isEqualTo(1));
    assertThat(new Complex(2, 0).unit().isEqualTo(1));
    assertThat(new Complex(-0.5, 0).unit().isEqualTo(-1));
    assertThat(new Complex(-1, 0).unit().isEqualTo(-1));
    assertThat(new Complex(-2, 0).unit().isEqualTo(-1));
    assertThat(new Complex(0, 0.5).unit().isEqualTo(Complex.I));
    assertThat(Complex.I.unit().isEqualTo(Complex.I));
    assertThat(new Complex(0, 2).unit().isEqualTo(Complex.I));
    assertThat(new Complex(0, -0.5).unit().isEqualTo(Complex.I.times(-1)));
    assertThat(new Complex(0, -1).unit().isEqualTo(Complex.I.times(-1)));
    assertThat(new Complex(0, -2).unit().isEqualTo(Complex.I.times(-1)));
    assertTrue(new Complex(1, 1).unit().minus(new Complex(Math.sqrt(0.5), Math.sqrt(0.5))).norm2() < 0.0000001);
  });
  suite.test("plus", function() {
    assertThat(new Complex(2, 3).plus(new Complex(5, 7))).isEqualTo(new Complex(7, 10));
    assertThat(new Complex(2, 3).plus(5)).isEqualTo(new Complex(7, 3));
  });
  suite.test("minus", function() {
    assertThat(new Complex(2, 3).minus(new Complex(5, 7))).isEqualTo(new Complex(-3, -4));
    assertThat(new Complex(2, 3).minus(5)).isEqualTo(new Complex(-3, 3));
  });
  suite.test("times", function() {
    assertThat(new Complex(2, 3).times(new Complex(5, 7))).isEqualTo(new Complex(-11, 29));
    assertThat(new Complex(2, 3).times(5)).isEqualTo(new Complex(10, 15));
  });
  suite.test("dividedBy", function() {
    assertThrows(function() {
      return Complex.ONE.dividedBy(0);
    });
    assertThat(new Complex(2, 3).dividedBy(new Complex(2, 0))).isEqualTo(new Complex(1, 1.5));
    assertThat(new Complex(2, 3).dividedBy(new Complex(0, 2))).isEqualTo(new Complex(1.5, -1));
    assertThat(new Complex(2, -2).dividedBy(new Complex(1, 1))).isEqualTo(new Complex(0, -2));
  });
  suite.test("sqrts", function() {
    var s = Math.sqrt(0.5);
    assertThat(Complex.ZERO.sqrts()).isEqualTo([0]);
    assertThat(Complex.ONE.sqrts()).isEqualTo([1, -1]);
    assertThat(Complex.I.sqrts()).isApproximatelyEqualTo([new Complex(s, s), new Complex(-s, -s)]);
    assertThat(Complex.ONE.times(-1).sqrts()).isEqualTo([Complex.I, new Complex(0, -1)]);
    assertThat(new Complex(4, 0).sqrts()).isEqualTo([2, -2]);
    assertThat(new Complex(0, -4).sqrts()).isApproximatelyEqualTo([new Complex(s * 2, -s * 2), new Complex(-s * 2, s * 2)]);
  });
  suite.test("rootsOfQuadratic", function() {
    assertThrows(function() {
      return Complex.rootsOfQuadratic(0, 0, 0);
    });
    assertThat(Complex.rootsOfQuadratic(0, 0, 1)).isEqualTo([]);
    assertThat(Complex.rootsOfQuadratic(0, 0, Complex.I)).isEqualTo([]);
    assertThat(Complex.rootsOfQuadratic(0, 1, 1)).isEqualTo([-1]);
    assertThat(Complex.rootsOfQuadratic(0, Complex.I, Complex.I)).isEqualTo([-1]);
    assertThat(Complex.rootsOfQuadratic(0, 2, 3)).isEqualTo([-1.5]);
    assertThat(Complex.rootsOfQuadratic(1, 0, 0)).isEqualTo([0]);
    assertThat(Complex.rootsOfQuadratic(1, 2, 1)).isEqualTo([-1]);
    assertThat(Complex.rootsOfQuadratic(1, 0, 4)).isEqualTo([new Complex(0, -2), new Complex(0, 2)]);
    assertThat(Complex.rootsOfQuadratic(1, 0, 1)).isEqualTo([new Complex(0, -1), Complex.I]);
    assertThat(Complex.rootsOfQuadratic(1, 0, -1)).isEqualTo([-1, 1]);
    assertThat(Complex.rootsOfQuadratic(1, 0, -4)).isEqualTo([-2, 2]);
    assertThat(Complex.rootsOfQuadratic(1, 1, 0)).isEqualTo([-1, 0]);
    assertThat(Complex.rootsOfQuadratic(1, 7, 12)).isEqualTo([-4, -3]);
    assertThat(Complex.rootsOfQuadratic(2, 14, 24)).isEqualTo([-4, -3]);
    var s = Math.sqrt(0.5);
    assertThat(Complex.rootsOfQuadratic(1, 0, new Complex(0, -1))).isApproximatelyEqualTo([new Complex(-s, -s), new Complex(s, s)]);
    assertThat(Complex.rootsOfQuadratic(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13))).isApproximatelyEqualTo([new Complex(-1.06911, 1.85157), new Complex(-1.31551, -1.77465)], 0.0001);
  });
  suite.test("rootsOfQuadratic_fuzz", function() {
    for (var i = 0; i < 100; i++) {
      var theta = 2 * Math.PI * Math.random();
      var phi = Math.acos(2 * Math.random() - 1);
      var a = Math.cos(theta) * Math.sin(phi);
      var b = Math.sin(theta) * Math.sin(phi);
      var c = Math.cos(phi);
      var roots = Complex.rootsOfQuadratic(a, b, c);
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = (roots)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var x = $__1.value;
          {
            var y = x.times(x).times(a).plus(x.times(b)).plus(c);
            assertThat(y).isApproximatelyEqualTo(0);
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
    }
  });
  suite.test("exp", function() {
    var π = Math.PI;
    var i = Complex.I;
    var s = Math.sqrt(0.5);
    assertThat(Complex.ZERO.exp()).isEqualTo(1);
    assertThat(Complex.ONE.exp()).isApproximatelyEqualTo(Math.E);
    assertThat(new Complex(2, 0).exp()).isApproximatelyEqualTo(Math.E * Math.E);
    assertThat(new Complex(2, π).exp()).isApproximatelyEqualTo(-Math.E * Math.E);
    assertThat(i.times(-π).exp()).isEqualTo(-1);
    assertThat(i.times(-π / 2).exp()).isEqualTo(i.neg());
    assertThat(i.times(π / 4).exp()).isEqualTo(new Complex(s, s));
    assertThat(i.times(π / 2).exp()).isEqualTo(i);
    assertThat(i.times(π).exp()).isApproximatelyEqualTo(-1);
    assertThat(i.times(3 * π / 2).exp()).isEqualTo(i.neg());
    assertThat(i.times(2 * π).exp()).isEqualTo(1);
  });
  suite.test("ln", function() {
    var π = Math.PI;
    assertThat(Complex.ONE.ln()).isEqualTo(0);
    assertThat(new Complex(Math.E, 0).ln()).isApproximatelyEqualTo(1);
    assertThat(new Complex(-1, 0).ln()).isApproximatelyEqualTo(new Complex(0, π));
    assertThat(Complex.I.ln()).isApproximatelyEqualTo(new Complex(0, π / 2));
    assertThat(new Complex(Math.E * Math.E, 0).ln()).isApproximatelyEqualTo(new Complex(2, 0));
    assertThat(new Complex(-Math.E * Math.E, 0).ln()).isApproximatelyEqualTo(new Complex(2, π));
    assertThat(Complex.I.ln().isEqualTo(new Complex(0, π / 2)));
    assertThat(new Complex(1, 1).ln().isEqualTo(new Complex(Math.log(2), π / 4)));
    assertThat(Complex.I.neg().ln().isEqualTo(new Complex(0, -π / 2)));
    assertThat(new Complex(-1, -1).ln().isEqualTo(new Complex(Math.log(2), -3 * π / 4)));
  });
  suite.test("neg", function() {
    assertThat(new Complex(3, 5).neg()).isEqualTo(new Complex(-3, -5));
  });
  suite.test("raisedTo", function() {
    var π = Math.PI;
    var i = Complex.I;
    var e = new Complex(Math.E, 0);
    var s = Math.sqrt(0.5);
    assertThat(e.raisedTo(i.times(-π / 2))).isEqualTo(i.neg());
    assertThat(e.raisedTo(i.times(0))).isEqualTo(1);
    assertThat(e.raisedTo(i.times(π / 2))).isEqualTo(i);
    assertThat(e.raisedTo(i.times(π))).isEqualTo(-1);
    assertThat(e.raisedTo(i.times(3 * π / 2))).isEqualTo(i.neg());
    assertThat(e.raisedTo(i.times(2 * π))).isEqualTo(1);
    assertThat(e.raisedTo(i.times(-π / 4))).isEqualTo(new Complex(s, -s));
    assertThat(e.raisedTo(i.times(π / 4))).isEqualTo(new Complex(s, s));
    assertThat(e.raisedTo(i.times(3 * π / 4))).isEqualTo(new Complex(-s, s));
    assertThat(e.raisedTo(i.times(5 * π / 4))).isEqualTo(new Complex(-s, -s));
    assertThat(Complex.ZERO.raisedTo(2)).isEqualTo(0);
    assertThat(Complex.ZERO.raisedTo(new Complex(1, 3))).isEqualTo(0);
    assertThat(new Complex(2, 3).raisedTo(0)).isEqualTo(1);
    assertThat(new Complex(-1, 0).raisedTo(0)).isEqualTo(1);
    assertThat(new Complex(-1, 0).raisedTo(0.5)).isEqualTo(i);
    assertThat(new Complex(-1, 0).raisedTo(-0.5)).isEqualTo(i.neg());
    assertThat(new Complex(-1, 0).raisedTo(1)).isEqualTo(-1);
    assertThat(i.raisedTo(i)).isApproximatelyEqualTo(Math.exp(-π / 2));
    assertThat(new Complex(1, 1).raisedTo(new Complex(1, 1))).isApproximatelyEqualTo(new Complex(0.2739572538301, 0.5837007587586));
    assertThat(new Complex(2, 3).raisedTo(new Complex(5, 7))).isApproximatelyEqualTo(new Complex(0.1525582909989, 0.6079153491494));
  });
  suite.test("trig", function() {
    assertThat(Complex.from(0.2).cos()).isApproximatelyEqualTo(Complex.from(Math.cos(0.2)));
    assertThat(Complex.from(0.2).sin()).isApproximatelyEqualTo(Complex.from(Math.sin(0.2)));
    assertThat(Complex.from(0.2).tan()).isApproximatelyEqualTo(Complex.from(Math.tan(0.2)));
  });
  return {};
});
//# sourceURL=test/math/Complex.test.js
;$traceurRuntime.registerModule("test/math/Matrix.test.js", [], function() {
  "use strict";
  var __moduleName = "test/math/Matrix.test.js";
  var $__21 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/math/Matrix.test.js")),
      Suite = $__21.Suite,
      assertThat = $__21.assertThat,
      assertThrows = $__21.assertThrows,
      assertTrue = $__21.assertTrue,
      assertFalse = $__21.assertFalse;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/math/Matrix.test.js")).Matrix;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/math/Matrix.test.js")).Complex;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/Controls.js", "test/math/Matrix.test.js")).Controls;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Format.js", "test/math/Matrix.test.js")).Format;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/math/Matrix.test.js")).Seq;
  var suite = new Suite("Matrix");
  suite.test("isEqualTo", function() {
    var m = Matrix.fromRows([[new Complex(2, 3), new Complex(5, 7)], [new Complex(11, 13), new Complex(17, 19)]]);
    assertThat(m).isEqualTo(m);
    assertThat(m).isNotEqualTo(null);
    assertThat(m).isNotEqualTo("");
    assertThat(m).isEqualTo(Matrix.fromRows([[new Complex(2, 3), new Complex(5, 7)], [new Complex(11, 13), new Complex(17, 19)]]));
    assertThat(m).isNotEqualTo(Matrix.fromRows([[new Complex(2, 3)]]));
    assertThat(m).isNotEqualTo(Matrix.fromRows([[new Complex(-2, 3), new Complex(5, 7)], [new Complex(11, 13), new Complex(17, 19)]]));
    assertThat(m).isNotEqualTo(Matrix.fromRows([[new Complex(2, 3), new Complex(-5, 7)], [new Complex(11, 13), new Complex(17, 19)]]));
    assertThat(m).isNotEqualTo(Matrix.fromRows([[new Complex(2, 3), new Complex(5, 7)], [new Complex(-11, 13), new Complex(17, 19)]]));
    assertThat(m).isNotEqualTo(Matrix.fromRows([[new Complex(2, 3), new Complex(5, 7)], [new Complex(11, 13), new Complex(-17, 19)]]));
    var col = Matrix.fromRows([[new Complex(2, 3), new Complex(5, 7)]]);
    var row = Matrix.fromRows([[new Complex(2, 3)], [new Complex(5, 7)]]);
    assertThat(col).isEqualTo(col);
    assertThat(row).isEqualTo(row);
    assertThat(row).isNotEqualTo(col);
  });
  suite.test("isApproximatelyEqualTo", function() {
    assertThat(Matrix.row(1, 1)).isNotApproximatelyEqualTo(Matrix.col(1, 1), 0);
    assertThat(Matrix.row(1, 1)).isNotApproximatelyEqualTo(Matrix.square(1, 1, 1, 1), 0);
    assertThat(Matrix.row(1, 1)).isNotApproximatelyEqualTo(Matrix.row(1, 1, 1), 0);
    assertThat(Matrix.row(1, 1)).isApproximatelyEqualTo(Matrix.row(1, 1), 0);
    assertThat(Matrix.solo(1)).isApproximatelyEqualTo(Matrix.solo(1), 0);
    assertThat(Matrix.solo(1)).isApproximatelyEqualTo(Matrix.solo(1), 1 / 4);
    assertThat(Matrix.solo(1.25)).isApproximatelyEqualTo(Matrix.solo(1), 1 / 4);
    assertThat(Matrix.solo(0.75)).isApproximatelyEqualTo(Matrix.solo(1), 1 / 4);
    assertThat(Matrix.solo(1.26)).isNotApproximatelyEqualTo(Matrix.solo(1), 1 / 4);
    assertThat(Matrix.solo(0.74)).isNotApproximatelyEqualTo(Matrix.solo(1), 1 / 4);
    assertThat(Matrix.row(0, 0)).isApproximatelyEqualTo(Matrix.row(0, 0), 1);
    assertThat(Matrix.row(1, 0)).isApproximatelyEqualTo(Matrix.row(0, 0), 1);
    assertThat(Matrix.row(0, 1)).isApproximatelyEqualTo(Matrix.row(0, 0), 1);
    assertThat(Matrix.row(1, 1)).isNotApproximatelyEqualTo(Matrix.row(0, 0), 1);
    assertThat(Matrix.solo(0)).isNotApproximatelyEqualTo(null);
    assertThat(Matrix.solo(0)).isNotApproximatelyEqualTo("");
  });
  suite.test("toString", function() {
    assertThat(Matrix.solo(2).toString()).isEqualTo("{{2}}");
    assertThat(Matrix.square(1, 0, new Complex(0, -1), new Complex(2, -3)).toString()).isEqualTo("{{1, 0}, {-i, 2-3i}}");
    assertThat(Matrix.square(1, 0, 0, 1).toString()).isEqualTo("{{1, 0}, {0, 1}}");
    assertThat(Matrix.identity(3).toString()).isEqualTo("{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}");
    assertThat(Matrix.square(0, 1, new Complex(1 / 3, 1), new Complex(0, 1 / 3 + 0.0000001)).toString(Format.EXACT)).isEqualTo("{{0, 1}, {\u2153+i, 0.3333334333333333i}}");
    assertThat(Matrix.square(0, 1, new Complex(1 / 3, 1), new Complex(0, 1 / 3 + 0.0000001)).toString(Format.SIMPLIFIED)).isEqualTo("{{0, 1}, {\u2153+i, \u2153i}}");
    assertThat(Matrix.square(0, 1, new Complex(1 / 3, 1), new Complex(0, 1 / 3 + 0.0000001)).toString(Format.MINIFIED)).isEqualTo("{{0,1},{\u2153+i,0.3333334333333333i}}");
    assertThat(Matrix.square(0, 1, new Complex(1 / 3, 1), new Complex(0, 1 / 3 + 0.0000001)).toString(Format.CONSISTENT)).isEqualTo("{{+0.00+0.00i, +1.00+0.00i}, {+0.33+1.00i, +0.00+0.33i}}");
  });
  suite.test("parse", function() {
    assertThat(Matrix.parse("{{1}}")).isEqualTo(Matrix.solo(1));
    assertThat(Matrix.parse("{{i}}")).isEqualTo(Matrix.solo(Complex.I));
    assertThat(Matrix.parse("{{\u221A2}}")).isEqualTo(Matrix.square(Math.sqrt(2)));
    assertThat(Matrix.parse("{{½-½i, 5}, {-i, 0}}")).isEqualTo(Matrix.square(new Complex(0.5, -0.5), 5, new Complex(0, -1), 0));
    assertThat(Matrix.parse("{{1, 2, i}}")).isEqualTo(Matrix.row(1, 2, Complex.I));
    assertThat(Matrix.parse("{{1}, {2}, {i}}")).isEqualTo(Matrix.col(1, 2, Complex.I));
  });
  suite.test("generate", function() {
    assertThat(Matrix.generate(3, 2, function(r, c) {
      return r + 10 * c;
    }).toString()).isEqualTo("{{0, 10, 20}, {1, 11, 21}}");
  });
  suite.test("generateDiagonal", function() {
    assertThat(Matrix.generateDiagonal(4, function(e) {
      return new Complex(e, 1);
    })).isEqualTo(Matrix.square(new Complex(0, 1), 0, 0, 0, 0, new Complex(1, 1), 0, 0, 0, 0, new Complex(2, 1), 0, 0, 0, 0, new Complex(3, 1)));
  });
  suite.test("generateTransition", function() {
    assertThat(Matrix.generateTransition(4, function(e) {
      return (e + 1) & 3;
    })).isEqualTo(Matrix.square(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0));
  });
  suite.test("zero", function() {
    assertThat(Matrix.zero(1, 1).toString()).isEqualTo("{{0}}");
    assertThat(Matrix.zero(2, 1).toString()).isEqualTo("{{0, 0}}");
    assertThat(Matrix.zero(1, 2).toString()).isEqualTo("{{0}, {0}}");
    assertThat(Matrix.zero(2, 2).toString()).isEqualTo("{{0, 0}, {0, 0}}");
  });
  suite.test("getColumn", function() {
    var m = Matrix.square(2, 3, 5, 7);
    assertThat(m.getColumn(0)).isEqualTo([2, 5]);
    assertThat(m.getColumn(1)).isEqualTo([3, 7]);
    assertThat(Matrix.col(1, 2, 3).getColumn(0)).isEqualTo([1, 2, 3]);
  });
  suite.test("square", function() {
    var m = Matrix.square(1, new Complex(2, 3), -5.5, 0);
    assertThat(m.rows()).isEqualTo([[1, new Complex(2, 3)], [-5.5, 0]]);
    assertThat(Matrix.solo(1).rows()).isEqualTo([[1]]);
  });
  suite.test("col", function() {
    assertThat(Matrix.col(2, 3, new Complex(0, 5)).toString()).isEqualTo("{{2}, {3}, {5i}}");
  });
  suite.test("row", function() {
    assertThat(Matrix.row(2, 3, new Complex(0, 5)).toString()).isEqualTo("{{2, 3, 5i}}");
  });
  suite.test("size", function() {
    assertThat(Matrix.row(1, 1).width()).isEqualTo(2);
    assertThat(Matrix.row(1, 1).height()).isEqualTo(1);
    assertThat(Matrix.row(1, 1, 3).width()).isEqualTo(3);
    assertThat(Matrix.row(1, 1, 3).height()).isEqualTo(1);
    assertThat(Matrix.col(1, 1).width()).isEqualTo(1);
    assertThat(Matrix.col(1, 1).height()).isEqualTo(2);
    assertThat(Matrix.col(1, 1, 3).width()).isEqualTo(1);
    assertThat(Matrix.col(1, 1, 3).height()).isEqualTo(3);
  });
  suite.test("isUnitary", function() {
    assertFalse(Matrix.row(1, 1).isUnitary(999));
    assertFalse(Matrix.col(1, 1).isUnitary(999));
    assertTrue(Matrix.solo(1).isUnitary(0));
    assertTrue(Matrix.solo(Complex.I).isUnitary(0));
    assertTrue(Matrix.solo(-1).isUnitary(0));
    assertFalse(Matrix.solo(-2).isUnitary(0));
    assertFalse(Matrix.solo(0).isUnitary(0));
    assertTrue(Matrix.solo(-2).isUnitary(999));
    assertTrue(Matrix.square(1, 0, 0, 1).isUnitary(0));
    assertTrue(Matrix.rotation(1).isUnitary(0.001));
    assertTrue(Matrix.PAULI_X.isUnitary(0));
    assertTrue(Matrix.PAULI_Y.isUnitary(0));
    assertTrue(Matrix.PAULI_Z.isUnitary(0));
    assertTrue(Matrix.HADAMARD.isUnitary(0.001));
  });
  suite.test("isApproximatelyHermitian", function() {
    var i = Complex.I;
    assertFalse(Matrix.row(1, 1).isApproximatelyHermitian(999));
    assertFalse(Matrix.col(1, 1).isApproximatelyHermitian(999));
    assertTrue(Matrix.solo(1).isApproximatelyHermitian(0));
    assertTrue(Matrix.solo(0).isApproximatelyHermitian(0));
    assertTrue(Matrix.solo(-1).isApproximatelyHermitian(0));
    assertTrue(Matrix.solo(-2).isApproximatelyHermitian(0));
    assertFalse(Matrix.solo(i).isApproximatelyHermitian(0));
    assertFalse(Matrix.solo(i).isApproximatelyHermitian(0.5));
    assertTrue(Matrix.solo(i).isApproximatelyHermitian(999));
    assertTrue(Matrix.PAULI_X.isApproximatelyHermitian(0));
    assertTrue(Matrix.PAULI_Y.isApproximatelyHermitian(0));
    assertTrue(Matrix.PAULI_Z.isApproximatelyHermitian(0));
    assertTrue(Matrix.HADAMARD.isApproximatelyHermitian(0.001));
    assertTrue(Matrix.square(1, 0, 0, 1).isApproximatelyHermitian(0));
    assertTrue(Matrix.square(1, 1, 1, 1).isApproximatelyHermitian(0));
    assertFalse(Matrix.square(1, 1, 1.5, 1).isApproximatelyHermitian(0));
    assertTrue(Matrix.square(1, 1, 1.5, 1).isApproximatelyHermitian(0.5));
    assertFalse(Matrix.square(1, i, i, 1).isApproximatelyHermitian(0));
    assertTrue(Matrix.square(1, i, i.neg(), 1).isApproximatelyHermitian(0));
    assertTrue(Matrix.square(1, i.neg(), i, 1).isApproximatelyHermitian(0));
    assertFalse(Matrix.square(1, i, i.times(-1.5), 1).isApproximatelyHermitian(0));
    assertTrue(Matrix.square(1, i, i.times(-1.5), 1).isApproximatelyHermitian(0.5));
  });
  suite.test("isIdentity", function() {
    var i = Complex.I;
    assertFalse(Matrix.solo(NaN).isIdentity());
    assertFalse(Matrix.solo(-1).isIdentity());
    assertFalse(Matrix.solo(0).isIdentity());
    assertTrue(Matrix.solo(1).isIdentity());
    assertFalse(Matrix.solo(i).isIdentity());
    assertFalse(Matrix.solo(2).isIdentity());
    assertFalse(Matrix.row(1, 0).isIdentity());
    assertFalse(Matrix.row(1, 1).isIdentity());
    assertFalse(Matrix.col(1, 0).isIdentity());
    assertFalse(Matrix.col(1, 1).isIdentity());
    assertFalse(Matrix.PAULI_X.isIdentity());
    assertFalse(Matrix.PAULI_Y.isIdentity());
    assertFalse(Matrix.PAULI_Z.isIdentity());
    assertFalse(Matrix.HADAMARD.isIdentity());
    assertTrue(Matrix.square(1, 0, 0, 1).isIdentity());
    assertFalse(Matrix.square(1, 1, 1, 1).isIdentity());
    assertFalse(Matrix.square(1, 1, 1.5, 1).isIdentity());
    assertFalse(Matrix.square(1, 1, 1.5, 1).isIdentity());
    assertFalse(Matrix.square(1, i, i, 1).isIdentity());
    assertFalse(Matrix.square(1, i, i.neg(), 1).isIdentity());
    assertTrue(Matrix.square(1, 0, 0, 0, 1, 0, 0, 0, 1).isIdentity());
  });
  suite.test("isScaler", function() {
    var i = Complex.I;
    assertFalse(Matrix.solo(NaN).isScaler());
    assertTrue(Matrix.solo(-1).isScaler());
    assertTrue(Matrix.solo(0).isScaler());
    assertTrue(Matrix.solo(1).isScaler());
    assertTrue(Matrix.solo(i).isScaler());
    assertTrue(Matrix.solo(2).isScaler());
    assertFalse(Matrix.row(1, 0).isScaler());
    assertFalse(Matrix.row(1, 1).isScaler());
    assertFalse(Matrix.col(1, 0).isScaler());
    assertFalse(Matrix.col(1, 1).isScaler());
    assertFalse(Matrix.PAULI_X.isScaler());
    assertFalse(Matrix.PAULI_Y.isScaler());
    assertFalse(Matrix.PAULI_Z.isScaler());
    assertFalse(Matrix.HADAMARD.isScaler());
    assertTrue(Matrix.square(1, 0, 0, 1).isScaler());
    assertTrue(Matrix.square(-1, 0, 0, -1).isScaler());
    assertTrue(Matrix.square(i, 0, 0, i).isScaler());
    assertFalse(Matrix.square(1, 1, 1, 1).isScaler());
    assertFalse(Matrix.square(1, 1, 1.5, 1).isScaler());
    assertFalse(Matrix.square(1, 1, 1.5, 1).isScaler());
    assertFalse(Matrix.square(1, i, i, 1).isScaler());
    assertFalse(Matrix.square(1, i, i.neg(), 1).isScaler());
    assertTrue(Matrix.square(1, 0, 0, 0, 1, 0, 0, 0, 1).isScaler());
    assertTrue(Matrix.square(i, 0, 0, 0, i, 0, 0, 0, i).isScaler());
    assertFalse(Matrix.square(i, 0, 0, 0, 1, 0, 0, 0, i).isScaler());
  });
  suite.test("isPhasedPermutation", function() {
    var i = Complex.I;
    assertTrue(Matrix.solo(-1).isPhasedPermutation());
    assertTrue(Matrix.solo(0).isPhasedPermutation());
    assertTrue(Matrix.solo(1).isPhasedPermutation());
    assertTrue(Matrix.solo(i).isPhasedPermutation());
    assertTrue(Matrix.solo(2).isPhasedPermutation());
    assertFalse(Matrix.row(1, 0).isPhasedPermutation());
    assertFalse(Matrix.row(1, 1).isPhasedPermutation());
    assertFalse(Matrix.col(1, 0).isPhasedPermutation());
    assertFalse(Matrix.col(1, 1).isPhasedPermutation());
    assertTrue(Matrix.PAULI_X.isPhasedPermutation());
    assertTrue(Matrix.PAULI_Y.isPhasedPermutation());
    assertTrue(Matrix.PAULI_Z.isPhasedPermutation());
    assertFalse(Matrix.HADAMARD.isPhasedPermutation());
    assertTrue(Matrix.square(1, 0, 0, 1).isPhasedPermutation());
    assertFalse(Matrix.square(1, 1, 1, 1).isPhasedPermutation());
    assertFalse(Matrix.square(1, 1, 1.5, 1).isPhasedPermutation());
    assertFalse(Matrix.square(1, 1, 1.5, 1).isPhasedPermutation());
    assertFalse(Matrix.square(1, i, i, 1).isPhasedPermutation());
    assertFalse(Matrix.square(1, i, i.neg(), 1).isPhasedPermutation());
    assertTrue(Matrix.square(1, 0, 0, 0, 1, 0, 0, 0, 1).isPhasedPermutation());
    assertTrue(Matrix.square(1, 0, 0, 0, 0, i, 0, 1, 0).isPhasedPermutation());
    assertFalse(Matrix.square(1, 0.1, 0, 1).isPhasedPermutation(0));
    assertFalse(Matrix.square(1, 0.1, 0, 1).isPhasedPermutation(0.05));
    assertTrue(Matrix.square(1, 0.1, 0, 1).isPhasedPermutation(0.2));
    assertTrue(Matrix.solo(NaN).isPhasedPermutation());
    assertFalse(Matrix.square(NaN, NaN, NaN, NaN).isPhasedPermutation());
    assertTrue(Matrix.square(NaN, 0, 0, NaN).isPhasedPermutation());
  });
  suite.test("adjoint", function() {
    var v = Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19));
    var a = Matrix.square(new Complex(2, -3), new Complex(11, -13), new Complex(5, -7), new Complex(17, -19));
    assertThat(v.adjoint()).isEqualTo(a);
    assertThat(Matrix.col(1, 2, Complex.I).adjoint()).isEqualTo(Matrix.row(1, 2, Complex.I.neg()));
  });
  suite.test("transpose", function() {
    var v = Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19));
    var a = Matrix.square(new Complex(2, 3), new Complex(11, 13), new Complex(5, 7), new Complex(17, 19));
    assertThat(v.transpose()).isEqualTo(a);
    assertThat(Matrix.col(1, 2, Complex.I).transpose()).isEqualTo(Matrix.row(1, 2, Complex.I));
  });
  suite.test("times_scalar", function() {
    var v = Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19));
    var a = Matrix.square(new Complex(-2, -3), new Complex(-5, -7), new Complex(-11, -13), new Complex(-17, -19));
    assertThat(v.times(-1)).isEqualTo(a);
    assertThat(v.times(0)).isEqualTo(Matrix.square(0, 0, 0, 0));
    assertThat(v.times(1)).isEqualTo(v);
    assertThat(Matrix.col(2, 3).times(5)).isEqualTo(Matrix.col(10, 15));
    assertThat(Matrix.row(2, 3).times(5)).isEqualTo(Matrix.row(10, 15));
  });
  suite.test("plus", function() {
    assertThat(Matrix.square(2, 3, 5, 7).plus(Matrix.square(11, 13, 17, 19))).isEqualTo(Matrix.square(13, 16, 22, 26));
  });
  suite.test("minus", function() {
    assertThat(Matrix.square(2, 3, 5, 7).minus(Matrix.square(11, 13, 17, 19))).isEqualTo(Matrix.square(-9, -10, -12, -12));
  });
  suite.test("times_matrix", function() {
    assertThat(Matrix.square(2, 3, 5, 7).times(Matrix.square(11, 13, 17, 19))).isEqualTo(Matrix.square(73, 83, 174, 198));
    var x = Matrix.square(new Complex(0.5, -0.5), new Complex(0.5, 0.5), new Complex(0.5, 0.5), new Complex(0.5, -0.5));
    assertThat(x.times(x.adjoint())).isEqualTo(Matrix.identity(2));
    assertThat(Matrix.PAULI_X.times(Matrix.PAULI_Y).times(Matrix.PAULI_Z).times(new Complex(0, -1))).isEqualTo(Matrix.identity(2));
  });
  suite.test("times_ColRow", function() {
    var r = Matrix.row(2, 3, 5);
    var c = Matrix.col(11, 13, 17);
    assertThat(r.times(c).toString()).isEqualTo("{{146}}");
    assertThat(c.times(r).toString()).isEqualTo("{{22, 33, 55}, {26, 39, 65}, {34, 51, 85}}");
    assertThat(c.times(r)).isEqualTo(c.tensorProduct(r));
    assertThat(r.tensorProduct(c)).isEqualTo(c.tensorProduct(r));
  });
  suite.test("norm2", function() {
    assertThat(Matrix.solo(1).norm2()).isEqualTo(1);
    assertThat(Matrix.solo(2).norm2()).isEqualTo(4);
    assertThat(Matrix.row(1, 1).norm2()).isEqualTo(2);
    assertThat(Matrix.col(1, 1).norm2()).isEqualTo(2);
    assertThat(Matrix.square(1, 2, 3, 4).norm2()).isEqualTo(30);
  });
  suite.test("tensorProduct", function() {
    assertThat(Matrix.solo(2).tensorProduct(Matrix.solo(3))).isEqualTo(Matrix.solo(6));
    assertThat(Matrix.solo(new Complex(2, 3)).tensorProduct(Matrix.solo(new Complex(5, 7)))).isEqualTo(Matrix.solo(new Complex(-11, 29)));
    assertThat(Matrix.solo(2).tensorProduct(Matrix.solo(3))).isEqualTo(Matrix.solo(6));
    assertThat(Matrix.PAULI_X.tensorProduct(Matrix.PAULI_Z)).isEqualTo(Matrix.square(0, 0, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, 0));
    assertThat(Matrix.square(2, 3, 5, 7).tensorProduct(Matrix.square(11, 13, 17, 19))).isEqualTo(Matrix.square(22, 26, 33, 39, 34, 38, 51, 57, 55, 65, 77, 91, 85, 95, 119, 133));
  });
  suite.test("tensorPower", function() {
    var i = Complex.I;
    assertThat(Matrix.solo(i).tensorPower(0)).isEqualTo(Matrix.solo(1));
    assertThat(Matrix.solo(i).tensorPower(1)).isEqualTo(Matrix.solo(i));
    assertThat(Matrix.solo(i).tensorPower(2)).isEqualTo(Matrix.solo(-1));
    assertThat(Matrix.solo(i).tensorPower(3)).isEqualTo(Matrix.solo(i.neg()));
    assertThat(Matrix.solo(i).tensorPower(4)).isEqualTo(Matrix.solo(1));
    assertThat(Matrix.solo(i).tensorPower(5)).isEqualTo(Matrix.solo(i));
    assertThat(Matrix.solo(i).tensorPower(1 << 30)).isEqualTo(Matrix.solo(1));
    assertThat(Matrix.solo(i).tensorPower(5 + (1 << 30))).isEqualTo(Matrix.solo(i));
    var r = Matrix.row(1, i);
    assertThat(r.tensorPower(0)).isEqualTo(Matrix.solo(1));
    assertThat(r.tensorPower(1)).isEqualTo(Matrix.row(1, i));
    assertThat(r.tensorPower(2)).isEqualTo(Matrix.row(1, i, i, -1));
    assertThat(r.tensorPower(3)).isEqualTo(Matrix.row(1, i, i, -1, i, -1, -1, i.neg()));
    var c = Matrix.col(1, i);
    assertThat(c.tensorPower(0)).isEqualTo(Matrix.solo(1));
    assertThat(c.tensorPower(1)).isEqualTo(Matrix.col(1, i));
    assertThat(c.tensorPower(2)).isEqualTo(Matrix.col(1, i, i, -1));
    assertThat(c.tensorPower(3)).isEqualTo(Matrix.col(1, i, i, -1, i, -1, -1, i.neg()));
    var s = Matrix.square(1, 2, 3, 4);
    assertThat(s.tensorPower(0)).isEqualTo(Matrix.solo(1));
    assertThat(s.tensorPower(1)).isEqualTo(Matrix.square(1, 2, 3, 4));
    assertThat(s.tensorPower(2)).isEqualTo(Matrix.square(1, 2, 2, 4, 3, 4, 6, 8, 3, 6, 4, 8, 9, 12, 12, 16));
  });
  suite.test("timesQubitOperation", function() {
    var s = Math.sqrt(0.5);
    assertThat(Matrix.col(1, 0, 0, 0).timesQubitOperation(Matrix.HADAMARD, 0, 0, 0)).isEqualTo(Matrix.col(s, s, 0, 0));
    assertThat(Matrix.col(0, 1, 0, 0).timesQubitOperation(Matrix.HADAMARD, 0, 0, 0)).isEqualTo(Matrix.col(s, -s, 0, 0));
    assertThat(Matrix.col(0, 0, 1, 0).timesQubitOperation(Matrix.HADAMARD, 0, 0, 0)).isEqualTo(Matrix.col(0, 0, s, s));
    assertThat(Matrix.col(0, 0, 0, 1).timesQubitOperation(Matrix.HADAMARD, 0, 0, 0)).isEqualTo(Matrix.col(0, 0, s, -s));
    assertThat(Matrix.col(1, 0, 0, 0).timesQubitOperation(Matrix.HADAMARD, 1, 0, 0)).isEqualTo(Matrix.col(s, 0, s, 0));
    assertThat(Matrix.col(0, 1, 0, 0).timesQubitOperation(Matrix.HADAMARD, 1, 0, 0)).isEqualTo(Matrix.col(0, s, 0, s));
    assertThat(Matrix.col(0, 0, 1, 0).timesQubitOperation(Matrix.HADAMARD, 1, 0, 0)).isEqualTo(Matrix.col(s, 0, -s, 0));
    assertThat(Matrix.col(0, 0, 0, 1).timesQubitOperation(Matrix.HADAMARD, 1, 0, 0)).isEqualTo(Matrix.col(0, s, 0, -s));
    assertThat(Matrix.col(2, 3, 0, 0).timesQubitOperation(Matrix.PAULI_X, 1, 1, 0)).isEqualTo(Matrix.col(0, 3, 2, 0));
    assertThat(Matrix.col(2, 3, 0, 0).timesQubitOperation(Matrix.PAULI_X, 1, 1, 1)).isEqualTo(Matrix.col(2, 0, 0, 3));
  });
  suite.test("timesQubitOperation_speed", function() {
    var numQubits = 10;
    var numOps = 100;
    var t0 = performance.now();
    var buf = new Float64Array(2 << numQubits);
    buf[0] = 1;
    var state = new Matrix(1, 1 << numQubits, buf);
    for (var i = 0; i < numOps; i++) {
      state = state.timesQubitOperation(Matrix.HADAMARD, 0, 6, 0);
    }
    var t1 = performance.now();
    assertThat(t1 - t0).isLessThan(100);
  });
  suite.test("fromPauliRotation", function() {
    assertThat(Matrix.fromPauliRotation(0, 0, 0)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(1, 0, 0)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0, 1, 0)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0, 0, 1)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(-1, 0, 0)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0, -1, 0)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0, 0, -1)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0.6, 0.8, 0)).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0.5, 0, 0)).isApproximatelyEqualTo(Matrix.PAULI_X);
    assertThat(Matrix.fromPauliRotation(0, 0.5, 0)).isApproximatelyEqualTo(Matrix.PAULI_Y);
    assertThat(Matrix.fromPauliRotation(0, 0, 0.5)).isApproximatelyEqualTo(Matrix.PAULI_Z);
    assertThat(Matrix.fromPauliRotation(-0.5, 0, 0)).isApproximatelyEqualTo(Matrix.PAULI_X);
    assertThat(Matrix.fromPauliRotation(0, -0.5, 0)).isApproximatelyEqualTo(Matrix.PAULI_Y);
    assertThat(Matrix.fromPauliRotation(0, 0, -0.5)).isApproximatelyEqualTo(Matrix.PAULI_Z);
    assertThat(Matrix.fromPauliRotation(Math.sqrt(0.125), 0, Math.sqrt(0.125))).isApproximatelyEqualTo(Matrix.HADAMARD);
    assertThat(Matrix.fromPauliRotation(-0.25, 0, 0).times(Matrix.fromPauliRotation(0.25, 0, 0))).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0, -0.25, 0).times(Matrix.fromPauliRotation(0, 0.25, 0))).isApproximatelyEqualTo(Matrix.identity(2));
    assertThat(Matrix.fromPauliRotation(0, 0, -0.25).times(Matrix.fromPauliRotation(0, 0, 0.25))).isApproximatelyEqualTo(Matrix.identity(2));
    var s1 = Matrix.fromPauliRotation(0.1, 0.15, 0.25);
    var s2 = Matrix.fromPauliRotation(0.2, 0.3, 0.5);
    assertThat(s1.times(s1)).isApproximatelyEqualTo(s2);
  });
  suite.test("fromWireSwap", function() {
    assertThat(Matrix.fromWireSwap(2, 0, 1).toString()).isEqualTo("{{1, 0, 0, 0}, {0, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 1}}");
    var _ = 0;
    assertThat(Matrix.square(1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, 1)).isEqualTo(Matrix.fromWireSwap(4, 1, 3));
  });
  suite.test("identity", function() {
    assertThat(Matrix.identity(1).toString()).isEqualTo("{{1}}");
    assertThat(Matrix.identity(2).toString()).isEqualTo("{{1, 0}, {0, 1}}");
    assertThat(Matrix.identity(3).toString()).isEqualTo("{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}");
    assertThat(Matrix.identity(4).toString()).isEqualTo("{{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}}");
  });
  suite.test("rotation", function() {
    var s = Math.sqrt(0.5);
    var t = Math.PI * 2;
    assertThat(Matrix.rotation(0)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.rotation(t / 8)).isApproximatelyEqualTo(Matrix.square(s, -s, s, s));
    assertThat(Matrix.rotation(t * 2 / 8)).isApproximatelyEqualTo(Matrix.square(0, -1, 1, 0));
    assertThat(Matrix.rotation(t * 3 / 8)).isApproximatelyEqualTo(Matrix.square(-s, -s, s, -s));
    assertThat(Matrix.rotation(t * 4 / 8)).isApproximatelyEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.rotation(t * 5 / 8)).isApproximatelyEqualTo(Matrix.square(-s, s, -s, -s));
    assertThat(Matrix.rotation(t * 6 / 8)).isApproximatelyEqualTo(Matrix.square(0, 1, -1, 0));
    assertThat(Matrix.rotation(t * 7 / 8)).isApproximatelyEqualTo(Matrix.square(s, s, -s, s));
    assertThat(Matrix.rotation(t)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
  });
  var assertSvdDecompositionWorksFor = function(m) {
    var $__9 = m.singularValueDecomposition(0.000001, 100),
        U = $__9.U,
        S = $__9.S,
        V = $__9.V;
    assertThat(U.isUnitary(0.00001)).withInfo({
      m: m,
      U: U,
      S: S,
      V: V,
      test: "U isUnitary"
    }).isEqualTo(true);
    assertThat(V.isUnitary(0.00001)).withInfo({
      m: m,
      U: U,
      S: S,
      V: V,
      test: "V isUnitary"
    }).isEqualTo(true);
    assertThat(S.isDiagonal(0.00001)).withInfo({
      m: m,
      U: U,
      S: S,
      V: V,
      test: "S diagonal"
    }).isEqualTo(true);
    assertThat(Seq.range(S.width()).every(function(i) {
      return Math.abs(S.cell(i, i).phase()) < 0.000001;
    })).withInfo({
      m: m,
      U: U,
      S: S,
      V: V,
      test: "S is positive"
    }).isEqualTo(true);
    assertThat(U.times(S).times(V)).withInfo({
      m: m,
      U: U,
      S: S,
      V: V
    }).isApproximatelyEqualTo(m, 0.001);
  };
  suite.test("singularValueDecomposition", function() {
    assertThat(Matrix.zero(2, 2).singularValueDecomposition()).isEqualTo({
      U: Matrix.identity(2),
      S: Matrix.zero(2, 2),
      V: Matrix.identity(2)
    });
    assertThat(Matrix.identity(2).singularValueDecomposition()).isEqualTo({
      U: Matrix.identity(2),
      S: Matrix.identity(2),
      V: Matrix.identity(2)
    });
    assertSvdDecompositionWorksFor(Matrix.square(1, Complex.I.times(2), 3, 4));
    assertSvdDecompositionWorksFor(Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19)));
    assertSvdDecompositionWorksFor(Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19), new Complex(23, 29), new Complex(31, 37), new Complex(41, 43), new Complex(47, 53), new Complex(59, 61)));
    assertSvdDecompositionWorksFor(Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19), new Complex(-23, 29), new Complex(31, 37), new Complex(41, -43), new Complex(47, -53), new Complex(59, 61)));
    assertSvdDecompositionWorksFor(Matrix.generateDiagonal(4, function(k) {
      return Complex.polar(1, Math.PI * 2 / 3 * k);
    }));
  });
  suite.test("singularValueDecomposition_randomized", function() {
    for (var k = 1; k < 5; k++) {
      var m = Matrix.generate(k, k, function() {
        return new Complex(Math.random() - 0.5, Math.random() - 0.5);
      });
      assertSvdDecompositionWorksFor(m);
    }
  });
  suite.test("closestUnitary", function() {
    var i = Complex.I;
    var ni = i.neg();
    assertThat(Matrix.square(0, 0, 0, 0).closestUnitary()).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.square(2, 0, 0, 0.0001).closestUnitary()).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.square(0, 0.5, 0.0001, 0).closestUnitary()).isApproximatelyEqualTo(Matrix.square(0, 1, 1, 0));
    assertThat(Matrix.square(1.01, i, -1, ni).closestUnitary()).isApproximatelyEqualTo(Matrix.square(1, 0, 0, ni));
    var m = Matrix.square(1, 1, 1, 1, 1, i, -1, ni, 1, -1, 1, -1, 1, ni, -1, i);
    assertThat(m.closestUnitary(0.001)).isApproximatelyEqualTo(m.times(0.5));
    var m2 = Matrix.generateDiagonal(4, function(k) {
      return Complex.polar(1, Math.PI * 2 / 3 * k);
    });
    assertThat(m2.closestUnitary(0.001)).isApproximatelyEqualTo(m2);
  });
  suite.test("eigenDecomposition", function() {
    var s = Math.sqrt(0.5);
    var z = Math.sqrt(2);
    assertThat(Matrix.identity(2).eigenDecomposition()).isEqualTo([{
      val: 1,
      vec: Matrix.col(1, 0)
    }, {
      val: 1,
      vec: Matrix.col(0, 1)
    }]);
    assertThat(Matrix.PAULI_X.eigenDecomposition()).isApproximatelyEqualTo([{
      val: -1,
      vec: Matrix.col(s, -s)
    }, {
      val: 1,
      vec: Matrix.col(s, s)
    }]);
    assertThat(Matrix.PAULI_Y.eigenDecomposition()).isApproximatelyEqualTo([{
      val: -1,
      vec: Matrix.col(s, new Complex(0, -s))
    }, {
      val: 1,
      vec: Matrix.col(s, new Complex(0, s))
    }]);
    assertThat(Matrix.PAULI_Z.eigenDecomposition()).isEqualTo([{
      val: -1,
      vec: Matrix.col(0, 1)
    }, {
      val: 1,
      vec: Matrix.col(1, 0)
    }]);
    assertThat(Matrix.square(1, 1, 1, -1).eigenDecomposition()).isApproximatelyEqualTo([{
      val: -z,
      vec: Matrix.col(1 - z, 1).times(-1 / Math.sqrt(4 - 2 * z))
    }, {
      val: z,
      vec: Matrix.col(1 + z, 1).times(1 / Math.sqrt(4 + 2 * z))
    }]);
    assertThat(Matrix.HADAMARD.eigenDecomposition()).isApproximatelyEqualTo([{
      val: -1,
      vec: Matrix.col(1 - z, 1).times(-1 / Math.sqrt(4 - 2 * z))
    }, {
      val: 1,
      vec: Matrix.col(1 + z, 1).times(1 / Math.sqrt(4 + 2 * z))
    }]);
  });
  suite.test("liftApply", function() {
    var i = Complex.I;
    var mi = Complex.I.times(-1);
    var s = Math.sqrt(0.5);
    var tExpI = function(t) {
      return (function(c) {
        return c.times(i).times(t).exp();
      });
    };
    var tPow = function(t) {
      return (function(c) {
        return c.raisedTo(t);
      });
    };
    assertThat(Matrix.PAULI_X.liftApply(tExpI(Math.PI))).isApproximatelyEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.PAULI_X.liftApply(tExpI(Math.PI / 2))).isApproximatelyEqualTo(Matrix.square(0, i, i, 0));
    assertThat(Matrix.PAULI_X.liftApply(tExpI(Math.PI / 4))).isApproximatelyEqualTo(Matrix.square(1, i, i, 1).times(s));
    assertThat(Matrix.PAULI_Y.liftApply(tExpI(Math.PI))).isApproximatelyEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.PAULI_Y.liftApply(tExpI(Math.PI / 2))).isApproximatelyEqualTo(Matrix.square(0, 1, -1, 0));
    assertThat(Matrix.PAULI_Y.liftApply(tExpI(Math.PI / 4))).isApproximatelyEqualTo(Matrix.square(s, s, -s, s));
    assertThat(Matrix.PAULI_Z.liftApply(tExpI(Math.PI))).isApproximatelyEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.PAULI_Z.liftApply(tExpI(Math.PI / 2))).isApproximatelyEqualTo(Matrix.square(i, 0, 0, mi));
    assertThat(Matrix.PAULI_Z.liftApply(tExpI(Math.PI / 4))).isApproximatelyEqualTo(Matrix.square(new Complex(s, s), 0, 0, new Complex(s, -s)));
    assertThat(Matrix.PAULI_X.liftApply(tPow(0.5))).isApproximatelyEqualTo(Matrix.square(i, 1, 1, i).times(new Complex(0.5, -0.5)));
    assertThat(Matrix.PAULI_X.liftApply(tPow(-0.5))).isApproximatelyEqualTo(Matrix.square(mi, 1, 1, mi).times(new Complex(0.5, 0.5)));
    assertThat(Matrix.PAULI_Y.liftApply(tPow(0.5))).isApproximatelyEqualTo(Matrix.square(1, -1, 1, 1).times(new Complex(0.5, 0.5)));
    assertThat(Matrix.PAULI_Y.liftApply(tPow(-0.5))).isApproximatelyEqualTo(Matrix.square(1, 1, -1, 1).times(new Complex(0.5, -0.5)));
    assertThat(Matrix.PAULI_Z.liftApply(tPow(0.5))).isApproximatelyEqualTo(Matrix.square(1, 0, 0, i));
    assertThat(Matrix.PAULI_Z.liftApply(tPow(-0.5))).isApproximatelyEqualTo(Matrix.square(1, 0, 0, mi));
  });
  suite.test("trace", function() {
    assertThat(Matrix.solo(NaN).trace().abs()).isEqualTo(NaN);
    assertThat(Matrix.identity(2).trace()).isEqualTo(2);
    assertThat(Matrix.identity(10).trace()).isEqualTo(10);
    assertThat(Matrix.PAULI_X.trace()).isEqualTo(0);
    assertThat(Matrix.PAULI_Y.trace()).isEqualTo(0);
    assertThat(Matrix.PAULI_Z.trace()).isEqualTo(0);
    assertThat(Matrix.HADAMARD.trace()).isApproximatelyEqualTo(0);
    assertThat(Matrix.square(1, 2, 3, 4).trace()).isEqualTo(5);
    assertThat(Matrix.square(0, 1, 2, 3, 4, 5, 6, 7, 8).trace()).isEqualTo(12);
  });
  suite.test("qubitDensityMatrixToBlochVector", function() {
    assertThrows(function() {
      return Matrix.solo(1).qubitDensityMatrixToBlochVector();
    });
    assertThrows(function() {
      return Matrix.square(1, 0, 0, 0, 0, 0, 0, 0, 0).qubitDensityMatrixToBlochVector();
    });
    assertThrows(function() {
      return Matrix.identity(2).qubitDensityMatrixToBlochVector();
    });
    assertThrows(function() {
      return Matrix.square(1, 1, -1, 0).qubitDensityMatrixToBlochVector();
    });
    assertThrows(function() {
      return Matrix.square(1, 1, 0, 0).qubitDensityMatrixToBlochVector();
    });
    assertThrows(function() {
      return Matrix.square(1, Complex.I, Complex.I, 0).qubitDensityMatrixToBlochVector();
    });
    assertThat(Matrix.identity(2).times(0.5).qubitDensityMatrixToBlochVector()).isEqualTo([0, 0, 0]);
    var f = function() {
      var $__12,
          $__13;
      for (var m = [],
          $__8 = 0; $__8 < arguments.length; $__8++)
        m[$__8] = arguments[$__8];
      return ($__12 = Matrix).col.apply($__12, $traceurRuntime.spread(m)).times(($__13 = Matrix).col.apply($__13, $traceurRuntime.spread(m)).adjoint());
    };
    var i = Complex.I;
    var mi = i.times(-1);
    assertThat(f(1, 0).qubitDensityMatrixToBlochVector()).isEqualTo([0, 0, -1]);
    assertThat(f(0, 1).qubitDensityMatrixToBlochVector()).isEqualTo([0, 0, 1]);
    assertThat(f(1, 1).times(0.5).qubitDensityMatrixToBlochVector()).isEqualTo([-1, 0, 0]);
    assertThat(f(1, -1).times(0.5).qubitDensityMatrixToBlochVector()).isEqualTo([1, 0, 0]);
    assertThat(f(1, i).times(0.5).qubitDensityMatrixToBlochVector()).isEqualTo([0, -1, 0]);
    assertThat(f(1, mi).times(0.5).qubitDensityMatrixToBlochVector()).isEqualTo([0, 1, 0]);
  });
  suite.test("determinant", function() {
    assertThrows(function() {
      return Matrix.col(1, 2).determinant();
    });
    assertThrows(function() {
      return Matrix.row(1, 2).determinant();
    });
    assertThat(Matrix.solo(1).determinant()).isEqualTo(1);
    assertThat(Matrix.solo(2).determinant()).isEqualTo(2);
    assertThat(Matrix.square(1, 2, 3, 4).determinant()).isEqualTo(-2);
    assertThat(Matrix.square(2, 3, 5, 7).determinant()).isEqualTo(-1);
    assertThat(Matrix.square(1, 2, 3, 4, 5, 6, 7, 8, 9).determinant()).isEqualTo(0);
    assertThat(Matrix.square(2, 3, 5, 7, 11, 13, 17, 19, 23).determinant()).isEqualTo(-78);
  });
  suite.test("fromAngleAxisPhaseRotation", function() {
    var π = Math.PI;
    var i = Complex.I;
    var s = Math.sqrt(0.5);
    var is = Complex.I.times(s);
    var mis = is.neg();
    var mi = Complex.I.times(-1);
    assertThat(Matrix.fromAngleAxisPhaseRotation(0, [1, 0, 0], 0)).isEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(0, [0, 1, 0], 0)).isEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(0, [0, 0, 1], 0)).isEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(0, [s, 0, s], 0)).isEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(0, [1, 0, 0], π / 2)).isEqualTo(Matrix.square(i, 0, 0, i));
    assertThat(Matrix.fromAngleAxisPhaseRotation(0, [1, 0, 0], π)).isEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(-π / 2, [1, 0, 0], 0)).isEqualTo(Matrix.square(s, is, is, s));
    assertThat(Matrix.fromAngleAxisPhaseRotation(π / 2, [1, 0, 0], 0)).isEqualTo(Matrix.square(s, mis, mis, s));
    assertThat(Matrix.fromAngleAxisPhaseRotation(π, [1, 0, 0], 0)).isEqualTo(Matrix.square(0, mi, mi, 0));
    assertThat(Matrix.fromAngleAxisPhaseRotation(2 * π, [1, 0, 0], 0)).isEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(-π / 2, [0, 1, 0], 0)).isEqualTo(Matrix.square(s, s, -s, s));
    assertThat(Matrix.fromAngleAxisPhaseRotation(π / 2, [0, 1, 0], 0)).isEqualTo(Matrix.square(s, -s, s, s));
    assertThat(Matrix.fromAngleAxisPhaseRotation(π, [0, 1, 0], 0)).isEqualTo(Matrix.square(0, -1, 1, 0));
    assertThat(Matrix.fromAngleAxisPhaseRotation(2 * π, [0, 1, 0], 0)).isEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(-π / 2, [0, 0, 1], 0)).isEqualTo(Matrix.square(new Complex(s, s), 0, 0, new Complex(s, -s)));
    assertThat(Matrix.fromAngleAxisPhaseRotation(π / 2, [0, 0, 1], 0)).isEqualTo(Matrix.square(new Complex(s, -s), 0, 0, new Complex(s, s)));
    assertThat(Matrix.fromAngleAxisPhaseRotation(π, [0, 0, 1], 0)).isEqualTo(Matrix.square(mi, 0, 0, i));
    assertThat(Matrix.fromAngleAxisPhaseRotation(2 * π, [0, 0, 1], 0)).isEqualTo(Matrix.square(-1, 0, 0, -1));
    assertThat(Matrix.fromAngleAxisPhaseRotation(-π, [s, 0, s], 0)).isEqualTo(Matrix.square(is, is, is, is.times(-1)));
    assertThat(Matrix.fromAngleAxisPhaseRotation(-π, [s, 0, s], -π / 2)).isEqualTo(Matrix.square(s, s, s, -s));
  });
  suite.test("qubitOperationToAngleAxisRotation", function() {
    var $__10,
        $__11;
    assertThrows(function() {
      return Matrix.solo(1).qubitOperationToAngleAxisRotation();
    });
    assertThrows(function() {
      return Matrix.square(1, 2, 3, 4).qubitOperationToAngleAxisRotation();
    });
    var $__9 = [Matrix.identity(2), Matrix.PAULI_X, Matrix.PAULI_Y, Matrix.PAULI_Z],
        w = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
        x = ($__11 = $__10.next()).done ? void 0 : $__11.value,
        y = ($__11 = $__10.next()).done ? void 0 : $__11.value,
        z = ($__11 = $__10.next()).done ? void 0 : $__11.value;
    var π = Math.PI;
    var i = Complex.I;
    var mi = i.neg();
    var s = Math.sqrt(0.5);
    assertThat(w.qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: 0,
      axis: [1, 0, 0],
      phase: 0
    });
    assertThat(x.qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [1, 0, 0],
      phase: π / 2
    });
    assertThat(y.qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [0, 1, 0],
      phase: π / 2
    });
    assertThat(z.qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [0, 0, 1],
      phase: π / 2
    });
    assertThat(w.times(i).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: 0,
      axis: [1, 0, 0],
      phase: π / 2
    });
    assertThat(x.times(i).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [1, 0, 0],
      phase: π
    });
    assertThat(y.times(i).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [0, 1, 0],
      phase: π
    });
    assertThat(z.times(i).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [0, 0, 1],
      phase: π
    });
    assertThat(w.times(mi).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: 0,
      axis: [1, 0, 0],
      phase: -π / 2
    });
    assertThat(x.times(mi).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [1, 0, 0],
      phase: 0
    });
    assertThat(y.times(mi).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [0, 1, 0],
      phase: 0
    });
    assertThat(z.times(mi).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [0, 0, 1],
      phase: 0
    });
    assertThat(Matrix.HADAMARD.qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π,
      axis: [s, 0, s],
      phase: π / 2
    });
    assertThat(Matrix.square(1, i, i, 1).times(s).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: -π / 2,
      axis: [1, 0, 0],
      phase: 0
    });
    assertThat(Matrix.square(s, s, -s, s).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: -π / 2,
      axis: [0, 1, 0],
      phase: 0
    });
    assertThat(Matrix.square(1, 0, 0, i).qubitOperationToAngleAxisRotation()).isEqualTo({
      angle: π / 2,
      axis: [0, 0, 1],
      phase: π / 4
    });
  });
  suite.test("qubitOperationToAngleAxisRotation_vs_fromAngleAxisPhaseRotation_randomized", function() {
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (Seq.range(100))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var _ = $__2.value;
        {
          var phase = Math.random() * Math.PI * 2;
          var angle = Math.random() * Math.PI * 4;
          var a = Math.random() * Math.PI * 2;
          var b = Math.acos(Math.random() * 2 - 1);
          var axis = [Math.cos(a) * Math.sin(b), Math.sin(a) * Math.sin(b), Math.cos(b)];
          var U = Matrix.fromAngleAxisPhaseRotation(angle, axis, phase);
          var $__9 = U.qubitOperationToAngleAxisRotation(),
              angle2 = $__9.angle,
              axis2 = $__9.axis,
              phase2 = $__9.phase;
          var U2 = Matrix.fromAngleAxisPhaseRotation(angle2, axis2, phase2);
          assertThat(U2).withInfo({
            angle: angle,
            axis: axis,
            phase: phase
          }).isApproximatelyEqualTo(U);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  });
  suite.test("cross3", function() {
    var $__10,
        $__11;
    var $__9 = [Matrix.col(1, 0, 0), Matrix.col(0, 1, 0), Matrix.col(0, 0, 1)],
        x = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
        y = ($__11 = $__10.next()).done ? void 0 : $__11.value,
        z = ($__11 = $__10.next()).done ? void 0 : $__11.value;
    var zero = Matrix.col(0, 0, 0);
    assertThat(zero.cross3(zero)).isEqualTo(zero);
    assertThat(x.cross3(zero)).isEqualTo(zero);
    assertThat(y.cross3(zero)).isEqualTo(zero);
    assertThat(z.cross3(zero)).isEqualTo(zero);
    assertThat(x.cross3(y)).isEqualTo(z);
    assertThat(y.cross3(z)).isEqualTo(x);
    assertThat(z.cross3(x)).isEqualTo(y);
    assertThat(y.cross3(x)).isEqualTo(z.times(-1));
    assertThat(z.cross3(y)).isEqualTo(x.times(-1));
    assertThat(x.cross3(z)).isEqualTo(y.times(-1));
    assertThat(x.times(2).cross3(y.times(3))).isEqualTo(z.times(6));
    assertThat(x.plus(y).cross3(y)).isEqualTo(z);
  });
  suite.test("isUpperTriangular", function() {
    assertTrue(Matrix.solo(NaN).isUpperTriangular());
    assertTrue(Matrix.solo(0).isUpperTriangular());
    assertTrue(Matrix.solo(1).isUpperTriangular());
    assertFalse(Matrix.col(1, 2).isUpperTriangular());
    assertTrue(Matrix.row(1, 2).isUpperTriangular());
    assertTrue(Matrix.square(1, 0, 0, 0).isUpperTriangular());
    assertTrue(Matrix.square(0, 1, 0, 0).isUpperTriangular());
    assertFalse(Matrix.square(0, 0, 1, 0).isUpperTriangular());
    assertTrue(Matrix.square(0, 0, 0, 1).isUpperTriangular());
    assertTrue(Matrix.square(1, 2, 0, 4).isUpperTriangular());
    assertTrue(Matrix.square(1, NaN, 0, 4).isUpperTriangular());
    assertFalse(Matrix.square(1, 0, 2, 4).isUpperTriangular());
    assertFalse(Matrix.square(1, 0, NaN, 4).isUpperTriangular());
    assertFalse(Matrix.square(1, 2, 3, 4).isUpperTriangular());
    assertFalse(Matrix.square(1, 2, NaN, 4).isUpperTriangular());
    assertFalse(Matrix.square(1, 2, Complex.I, 4).isUpperTriangular());
    assertFalse(Matrix.square(1, 2, 3, 4).isUpperTriangular(2.9));
    assertTrue(Matrix.square(1, 2, 3, 4).isUpperTriangular(3.1));
    assertTrue(Matrix.square(1, 2, 3, 0, 5, 6, 0, 0, 7).isUpperTriangular(0));
    assertFalse(Matrix.square(1, 2, 3, 0, 5, 6, 0.01, 0, 7).isUpperTriangular(0));
    assertTrue(Matrix.square(1, 2, 3, 0, 5, 6, 0.01, 0, 7).isUpperTriangular(0.1));
  });
  suite.test("isLowerTriangular", function() {
    assertTrue(Matrix.solo(NaN).isLowerTriangular());
    assertTrue(Matrix.solo(0).isLowerTriangular());
    assertTrue(Matrix.solo(1).isLowerTriangular());
    assertTrue(Matrix.col(1, 2).isLowerTriangular());
    assertFalse(Matrix.row(1, 2).isLowerTriangular());
    assertTrue(Matrix.square(1, 0, 0, 0).isLowerTriangular());
    assertFalse(Matrix.square(0, 1, 0, 0).isLowerTriangular());
    assertTrue(Matrix.square(0, 0, 1, 0).isLowerTriangular());
    assertTrue(Matrix.square(0, 0, 0, 1).isLowerTriangular());
    assertFalse(Matrix.square(1, 2, 0, 4).isLowerTriangular());
    assertFalse(Matrix.square(1, NaN, 0, 4).isLowerTriangular());
    assertTrue(Matrix.square(1, 0, 2, 4).isLowerTriangular());
    assertTrue(Matrix.square(1, 0, NaN, 4).isLowerTriangular());
    assertFalse(Matrix.square(1, 2, 3, 4).isLowerTriangular());
    assertFalse(Matrix.square(1, 2, NaN, 4).isLowerTriangular());
    assertFalse(Matrix.square(1, 2, Complex.I, 4).isLowerTriangular());
    assertFalse(Matrix.square(1, 3, 2, 4).isLowerTriangular(2.9));
    assertTrue(Matrix.square(1, 3, 2, 4).isLowerTriangular(3.1));
    assertFalse(Matrix.square(1, 2, 3, 0, 5, 6, 0, 0, 7).isLowerTriangular(0));
    assertTrue(Matrix.square(1, 0, 0, 2, 5, 0, 3, 6, 7).isLowerTriangular(0));
    assertFalse(Matrix.square(1, 0, 0.01, 2, 5, 0, 3, 6, 7).isLowerTriangular(0));
    assertTrue(Matrix.square(1, 0, 0.01, 2, 5, 0, 3, 6, 7).isLowerTriangular(0.1));
  });
  var assertQrDecompositionWorksFor = function(m) {
    var $__9 = m.qrDecomposition(),
        Q = $__9.Q,
        R = $__9.R;
    assertThat(Q.isUnitary(0.00001)).withInfo({
      m: m,
      Q: Q,
      R: R,
      test: "isUnitary"
    }).isEqualTo(true);
    assertThat(R.isUpperTriangular(0.00001)).withInfo({
      m: m,
      Q: Q,
      R: R,
      test: "isUpperTriangular"
    }).isEqualTo(true);
    assertThat(Q.times(R)).withInfo({
      m: m,
      Q: Q,
      R: R
    }).isApproximatelyEqualTo(m);
  };
  suite.test("qrDecomposition", function() {
    assertThrows(function() {
      return Matrix.col(2, 3).qrDecomposition();
    });
    assertThrows(function() {
      return Matrix.row(2, 3).qrDecomposition();
    });
    assertThat(Matrix.solo(0).qrDecomposition()).isEqualTo({
      Q: Matrix.solo(1),
      R: Matrix.solo(0)
    });
    assertThat(Matrix.solo(1).qrDecomposition()).isEqualTo({
      Q: Matrix.solo(1),
      R: Matrix.solo(1)
    });
    assertThat(Matrix.square(2, 3, 0, 5).qrDecomposition()).isEqualTo({
      Q: Matrix.square(1, 0, 0, 1),
      R: Matrix.square(2, 3, 0, 5)
    });
    assertThat(Matrix.square(2, 0, 3, 5).qrDecomposition()).isApproximatelyEqualTo({
      Q: Matrix.square(0.5547, -0.83205, 0.83205, 0.5547),
      R: Matrix.square(3.60555, 4.16025, 0, 2.7735)
    }, 0.0001);
    assertQrDecompositionWorksFor(Matrix.square(0, 0, 1, 0));
    assertQrDecompositionWorksFor(Matrix.square(0, 1, 0, 0));
    assertQrDecompositionWorksFor(Matrix.square(2, 0, 3, 5));
    assertQrDecompositionWorksFor(Matrix.square(-1, Complex.I, Complex.I, 1));
    assertQrDecompositionWorksFor(Matrix.square(2, 3, 5, 7, new Complex(11, 13), 17, 19, 23, 29));
  });
  suite.test("qrDecomposition_randomized", function() {
    for (var k = 1; k < 6; k++) {
      var m = Matrix.generate(k, k, function() {
        return new Complex(Math.random() - 0.5, Math.random() - 0.5);
      });
      assertQrDecompositionWorksFor(m);
    }
  });
  var assertLqDecompositionWorksFor = function(m) {
    var $__9 = m.lqDecomposition(),
        L = $__9.L,
        Q = $__9.Q;
    assertThat(Q.isUnitary(0.00001)).withInfo({
      m: m,
      L: L,
      Q: Q,
      test: "isUnitary"
    }).isEqualTo(true);
    assertThat(L.isLowerTriangular(0.00001)).withInfo({
      m: m,
      L: L,
      Q: Q,
      test: "isLowerTriangular"
    }).isEqualTo(true);
    assertThat(L.times(Q)).withInfo({
      m: m,
      L: L,
      Q: Q
    }).isApproximatelyEqualTo(m);
  };
  suite.test("lqDecomposition", function() {
    assertThrows(function() {
      return Matrix.col(2, 3).lqDecomposition();
    });
    assertThrows(function() {
      return Matrix.row(2, 3).lqDecomposition();
    });
    assertThat(Matrix.solo(0).lqDecomposition()).isEqualTo({
      L: Matrix.solo(0),
      Q: Matrix.solo(1)
    });
    assertThat(Matrix.solo(1).lqDecomposition()).isEqualTo({
      L: Matrix.solo(1),
      Q: Matrix.solo(1)
    });
    assertThat(Matrix.square(2, 3, 0, 5).lqDecomposition()).isApproximatelyEqualTo({
      L: Matrix.square(3.60555, 0, 4.16025, 2.7735),
      Q: Matrix.square(0.5547, 0.83205, -0.83205, 0.5547)
    }, 0.0001);
    assertThat(Matrix.square(2, 0, 3, 5).lqDecomposition()).isEqualTo({
      L: Matrix.square(2, 0, 3, 5),
      Q: Matrix.square(1, 0, 0, 1)
    });
    assertLqDecompositionWorksFor(Matrix.square(0, 0, 1, 0));
    assertLqDecompositionWorksFor(Matrix.square(0, 1, 0, 0));
    assertLqDecompositionWorksFor(Matrix.square(2, 0, 3, 5));
    assertLqDecompositionWorksFor(Matrix.square(-1, Complex.I, Complex.I, 1));
    assertLqDecompositionWorksFor(Matrix.square(2, 3, 5, 7, new Complex(11, 13), 17, 19, 23, 29));
  });
  suite.test("lqDecomposition_randomized", function() {
    for (var k = 1; k < 6; k++) {
      var m = Matrix.generate(k, k, function() {
        return new Complex(Math.random() - 0.5, Math.random() - 0.5);
      });
      assertLqDecompositionWorksFor(m);
    }
  });
  suite.test("eigenvalueMagnitudes", function() {
    assertThat(Matrix.HADAMARD.eigenvalueMagnitudes(0.001, 3)).isEqualTo([1, 1]);
    assertThat(Matrix.PAULI_X.eigenvalueMagnitudes(0.001)).isEqualTo([1, 1]);
    assertThat(Matrix.PAULI_Y.eigenvalueMagnitudes(0.001)).isEqualTo([1, 1]);
    assertThat(Matrix.PAULI_Z.eigenvalueMagnitudes(0.001)).isEqualTo([1, 1]);
    assertThat(Matrix.identity(5).eigenvalueMagnitudes(0.001)).isEqualTo([1, 1, 1, 1, 1]);
    assertThat(Matrix.square(1, 1, 1, 1).eigenvalueMagnitudes(0.001)).isApproximatelyEqualTo([2, 0]);
    assertThat(Matrix.square(1, -1, -1, 1).eigenvalueMagnitudes(0.001)).isApproximatelyEqualTo([2, 0]);
    assertThat(Matrix.square(1, 1, 0, 1, 1, 0, 0, 0, 0).eigenvalueMagnitudes(0.001)).isApproximatelyEqualTo([2, 0, 0]);
  });
  suite.test("isDiagonal", function() {
    assertTrue(Matrix.solo(NaN).isDiagonal());
    assertTrue(Matrix.solo(0).isDiagonal());
    assertTrue(Matrix.solo(1).isDiagonal());
    assertFalse(Matrix.col(0, 0).isDiagonal());
    assertFalse(Matrix.row(0, 0).isDiagonal());
    assertTrue(Matrix.square(1, 0, 0, 0).isDiagonal());
    assertFalse(Matrix.square(0, 1, 0, 0).isDiagonal());
    assertFalse(Matrix.square(0, NaN, 0, 0).isDiagonal());
    assertFalse(Matrix.square(0, 0, 1, 0).isDiagonal());
    assertTrue(Matrix.square(0, 0, 0, 1).isDiagonal());
    assertTrue(Matrix.square(new Complex(2, 3), 0, 0, 0).isDiagonal());
    assertFalse(Matrix.square(0, new Complex(2, 3), 0, 0).isDiagonal());
    assertFalse(Matrix.square(0, 0, new Complex(2, 3), 0).isDiagonal());
    assertTrue(Matrix.square(0, 0, 0, new Complex(2, 3)).isDiagonal());
    assertTrue(Matrix.square(-10, 0, 0, 0, Infinity, 0, 0, 0, Complex.I).isDiagonal());
    assertFalse(Matrix.square(-10, 0.1, 0, 0, Infinity, 0, 0, 0, Complex.I).isDiagonal());
    assertTrue(Matrix.square(-10, 0.1, 0, 0, Infinity, 0, 0, 0, Complex.I).isDiagonal(0.2));
  });
  suite.test("hasNaN", function() {
    assertTrue(Matrix.solo(NaN).hasNaN());
    assertFalse(Matrix.solo(0).hasNaN());
    assertTrue(Matrix.solo(new Complex(0, NaN)).hasNaN());
    assertTrue(Matrix.square(0, 0, NaN, 0).hasNaN());
    assertFalse(Matrix.square(0, 0, 0, 0).hasNaN());
  });
  suite.test("expandedForQubitInRegister", function() {
    var _ = 0;
    assertThat(Matrix.square(2, 3, 5, 7).expandedForQubitInRegister(0, 3, Controls.NONE)).isEqualTo(Matrix.square(2, 3, _, _, _, _, _, _, 5, 7, _, _, _, _, _, _, _, _, 2, 3, _, _, _, _, _, _, 5, 7, _, _, _, _, _, _, _, _, 2, 3, _, _, _, _, _, _, 5, 7, _, _, _, _, _, _, _, _, 2, 3, _, _, _, _, _, _, 5, 7));
    assertThat(Matrix.square(2, 3, 5, 7).expandedForQubitInRegister(1, 3, Controls.NONE)).isEqualTo(Matrix.square(2, _, 3, _, _, _, _, _, _, 2, _, 3, _, _, _, _, 5, _, 7, _, _, _, _, _, _, 5, _, 7, _, _, _, _, _, _, _, _, 2, _, 3, _, _, _, _, _, _, 2, _, 3, _, _, _, _, 5, _, 7, _, _, _, _, _, _, 5, _, 7));
    assertThat(Matrix.square(2, 3, 5, 7).expandedForQubitInRegister(2, 3, Controls.NONE)).isEqualTo(Matrix.square(2, _, _, _, 3, _, _, _, _, 2, _, _, _, 3, _, _, _, _, 2, _, _, _, 3, _, _, _, _, 2, _, _, _, 3, 5, _, _, _, 7, _, _, _, _, 5, _, _, _, 7, _, _, _, _, 5, _, _, _, 7, _, _, _, _, 5, _, _, _, 7));
    assertThat(Matrix.square(2, 3, 5, 7).expandedForQubitInRegister(0, 3, Controls.bit(1, true))).isEqualTo(Matrix.square(1, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, 2, 3, _, _, _, _, _, _, 5, 7, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, 2, 3, _, _, _, _, _, _, 5, 7));
    assertThat(Matrix.square(2, 3, 5, 7).expandedForQubitInRegister(0, 3, Controls.bit(2, false))).isEqualTo(Matrix.square(2, 3, _, _, _, _, _, _, 5, 7, _, _, _, _, _, _, _, _, 2, 3, _, _, _, _, _, _, 5, 7, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, 1, _, _, _, _, _, _, _, _, 1));
  });
  suite.test("applyToStateVectorAtQubitWithControls", function() {
    var $__12,
        $__13,
        $__14,
        $__15,
        $__16,
        $__17,
        $__18,
        $__19,
        $__20;
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__12 = Matrix).col.apply($__12, $traceurRuntime.spread(new Array(8).fill(1))), 0, Controls.NONE)).isEqualTo(Matrix.col(2, 3, 2, 3, 2, 3, 2, 3));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__13 = Matrix).col.apply($__13, $traceurRuntime.spread(new Array(8).fill(1))), 1, Controls.NONE)).isEqualTo(Matrix.col(2, 2, 3, 3, 2, 2, 3, 3));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__14 = Matrix).col.apply($__14, $traceurRuntime.spread(new Array(8).fill(1))), 2, Controls.NONE)).isEqualTo(Matrix.col(2, 2, 2, 2, 3, 3, 3, 3));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__15 = Matrix).col.apply($__15, $traceurRuntime.spread(new Array(8).fill(1))), 2, Controls.bit(0, false))).isEqualTo(Matrix.col(2, 1, 2, 1, 3, 1, 3, 1));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__16 = Matrix).col.apply($__16, $traceurRuntime.spread(new Array(8).fill(1))), 2, Controls.bit(0, true))).isEqualTo(Matrix.col(1, 2, 1, 2, 1, 3, 1, 3));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__17 = Matrix).col.apply($__17, $traceurRuntime.spread(new Array(8).fill(1))), 2, Controls.bit(1, false))).isEqualTo(Matrix.col(2, 2, 1, 1, 3, 3, 1, 1));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__18 = Matrix).col.apply($__18, $traceurRuntime.spread(new Array(8).fill(1))), 0, Controls.bit(2, false))).isEqualTo(Matrix.col(2, 3, 2, 3, 1, 1, 1, 1));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__19 = Matrix).col.apply($__19, $traceurRuntime.spread(new Array(8).fill(1))), 0, Controls.bit(2, true))).isEqualTo(Matrix.col(1, 1, 1, 1, 2, 3, 2, 3));
    assertThat(Matrix.square(2, 0, 0, 3).applyToStateVectorAtQubitWithControls(($__20 = Matrix).col.apply($__20, $traceurRuntime.spread(new Array(8).fill(1))), 1, Controls.bit(0, false).and(Controls.bit(2, true)))).isEqualTo(Matrix.col(1, 1, 1, 1, 2, 1, 3, 1));
    var m = Matrix.square(new Complex(2, 3), new Complex(5, 7), new Complex(11, 13), new Complex(17, 19));
    var v = Matrix.col(new Complex(108, 109), new Complex(112, 113));
    var p = m.times(v);
    assertThat(m.applyToStateVectorAtQubitWithControls(Matrix.col(new Complex(100, 101), new Complex(102, 103), new Complex(104, 105), new Complex(106, 107), new Complex(108, 109), new Complex(110, 111), new Complex(112, 113), new Complex(114, 115)), 1, Controls.bit(0, false).and(Controls.bit(2, true)))).isEqualTo(Matrix.col(new Complex(100, 101), new Complex(102, 103), new Complex(104, 105), new Complex(106, 107), p.cell(0, 0), new Complex(110, 111), p.cell(0, 1), new Complex(114, 115)));
  });
  return {};
});
//# sourceURL=test/math/Matrix.test.js
;$traceurRuntime.registerModule("test/math/Point.test.js", [], function() {
  "use strict";
  var __moduleName = "test/math/Point.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/math/Point.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat,
      assertTrue = $__0.assertTrue,
      assertFalse = $__0.assertFalse;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Point.js", "test/math/Point.test.js")).Point;
  var suite = new Suite("Point");
  suite.test("isEqualTo", function() {
    var p = new Point(2, 3);
    assertTrue(p.isEqualTo(p));
    assertFalse(p.isEqualTo(null));
    assertFalse(p.isEqualTo(""));
    assertTrue(p.isEqualTo(new Point(2, 3)));
    assertFalse(p.isEqualTo(new Point(2, 4)));
    assertFalse(p.isEqualTo(new Point(1, 3)));
    assertThat(p).isEqualTo(new Point(2, 3));
    assertThat(p).isNotEqualTo(new Point(2, 4));
  });
  suite.test("toString", function() {
    assertThat(new Point(2, 3).toString()).isEqualTo("(x: 2, y: 3)");
  });
  suite.test("offsetBy", function() {
    assertThat(new Point(2, 3).offsetBy(5, 7)).isEqualTo(new Point(7, 10));
  });
  suite.test("plus", function() {
    assertThat(new Point(2, 3).plus(new Point(5, 7))).isEqualTo(new Point(7, 10));
  });
  suite.test("minus", function() {
    assertThat(new Point(2, 3).minus(new Point(5, 7))).isEqualTo(new Point(-3, -4));
  });
  suite.test("times", function() {
    assertThat(new Point(2, 3).times(5)).isEqualTo(new Point(10, 15));
  });
  suite.test("distanceTo", function() {
    assertThat(new Point(2, 3).distanceTo(new Point(3, 3))).isEqualTo(1);
    assertThat(new Point(2, 3).distanceTo(new Point(4, 3))).isEqualTo(2);
    assertThat(new Point(2, 2).distanceTo(new Point(2, 3))).isEqualTo(1);
    assertThat(new Point(2, 2).distanceTo(new Point(2, 4))).isEqualTo(2);
    assertThat(new Point(0, 0).distanceTo(new Point(4, 3))).isEqualTo(5);
  });
  return {};
});
//# sourceURL=test/math/Point.test.js
;$traceurRuntime.registerModule("test/math/Rect.test.js", [], function() {
  "use strict";
  var __moduleName = "test/math/Rect.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/math/Rect.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat,
      assertTrue = $__0.assertTrue,
      assertFalse = $__0.assertFalse;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Rect.js", "test/math/Rect.test.js")).Rect;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Point.js", "test/math/Rect.test.js")).Point;
  var suite = new Suite("Rect");
  suite.test("isEqualTo", function() {
    var r = new Rect(2, 3, 5, 7);
    assertThat(r).isEqualTo(r);
    assertThat(r).isEqualTo(new Rect(2, 3, 5, 7));
    assertThat(new Rect(1, 2, 3, 4)).isEqualTo(new Rect(1, 2, 3, 4));
    assertThat(r).isNotEqualTo(new Rect(1, 2, 3, 4));
    assertThat(r).isNotEqualTo(new Rect(1, 2, 5, 7));
    assertThat(r).isNotEqualTo(new Rect(2, 1, 5, 7));
    assertThat(r).isNotEqualTo(new Rect(2, 3, 1, 7));
    assertThat(r).isNotEqualTo(new Rect(2, 3, 5, 1));
    assertThat(r).isNotEqualTo(new Rect(2, 2, 5, 7));
    assertThat(r).isNotEqualTo(new Rect(3, 3, 5, 7));
    assertThat(r).isNotEqualTo(new Rect(2, 3, 5, 5));
    assertThat(r).isNotEqualTo(new Rect(2, 3, 7, 7));
  });
  suite.test("isApproximatelyEqualTo", function() {
    var r = new Rect(2, 3, 5, 7);
    assertFalse(r.isApproximatelyEqualTo(null, 0));
    assertFalse(r.isApproximatelyEqualTo("", 0));
    assertFalse(r.isApproximatelyEqualTo([], 0));
    assertTrue(r.isApproximatelyEqualTo(new Rect(2, 3, 5, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2.1, 3, 5, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3.1, 5, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3, 5.1, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3, 5, 7.1), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2.3, 3, 5, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3.3, 5, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3, 5.3, 7), 0));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3, 5, 7.3), 0));
    assertTrue(r.isApproximatelyEqualTo(new Rect(2, 3, 5, 7), 0.2));
    assertTrue(r.isApproximatelyEqualTo(new Rect(2.1, 3, 5, 7), 0.2));
    assertTrue(r.isApproximatelyEqualTo(new Rect(2, 3.1, 5, 7), 0.2));
    assertTrue(r.isApproximatelyEqualTo(new Rect(2, 3, 5.1, 7), 0.2));
    assertTrue(r.isApproximatelyEqualTo(new Rect(2, 3, 5, 7.1), 0.2));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2.3, 3, 5, 7), 0.2));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3.3, 5, 7), 0.2));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3, 5.3, 7), 0.2));
    assertFalse(r.isApproximatelyEqualTo(new Rect(2, 3, 5, 7.3), 0.2));
    assertThat(r).isApproximatelyEqualTo(new Rect(2, 3, 5, 7));
    assertThat(r).isNotApproximatelyEqualTo(new Rect(3, 3, 5, 7));
  });
  suite.test("toString", function() {
    assertThat(new Rect(2, 3, 5, 7).toString()).isEqualTo("[2:7]x[3:10]");
  });
  suite.test("centeredSquareWithRadius", function() {
    assertThat(Rect.centeredSquareWithRadius(new Point(2, 3), 5)).isEqualTo(new Rect(-3, -2, 10, 10));
  });
  suite.test("center", function() {
    assertThat(new Rect(2, 3, 5, 7).center()).isEqualTo(new Point(4.5, 6.5));
    assertThat(new Rect(2, 3, 5, 6).center()).isEqualTo(new Point(4.5, 6));
  });
  suite.test("topLeft", function() {
    assertThat(new Rect(2, 3, 5, 7).topLeft()).isEqualTo(new Point(2, 3));
  });
  suite.test("topRight", function() {
    assertThat(new Rect(2, 3, 5, 7).topRight()).isEqualTo(new Point(7, 3));
  });
  suite.test("bottomLeft", function() {
    assertThat(new Rect(2, 3, 5, 7).bottomLeft()).isEqualTo(new Point(2, 10));
  });
  suite.test("bottomRight", function() {
    assertThat(new Rect(2, 3, 5, 7).bottomRight()).isEqualTo(new Point(7, 10));
  });
  suite.test("centerLeft", function() {
    assertThat(new Rect(2, 3, 5, 7).centerLeft()).isEqualTo(new Point(2, 6.5));
  });
  suite.test("centerRight", function() {
    assertThat(new Rect(2, 3, 5, 7).centerRight()).isEqualTo(new Point(7, 6.5));
  });
  suite.test("topCenter", function() {
    assertThat(new Rect(2, 3, 5, 7).topCenter()).isEqualTo(new Point(4.5, 3));
  });
  suite.test("bottomCenter", function() {
    assertThat(new Rect(2, 3, 5, 7).bottomCenter()).isEqualTo(new Point(4.5, 10));
  });
  suite.test("right", function() {
    assertThat(new Rect(2, 3, 5, 7).right()).isEqualTo(7);
  });
  suite.test("bottom", function() {
    assertThat(new Rect(2, 3, 5, 7).bottom()).isEqualTo(10);
  });
  suite.test("skipLeft", function() {
    assertThat(new Rect(2, 3, 5, 7).skipLeft(0)).isEqualTo(new Rect(2, 3, 5, 7));
    assertThat(new Rect(2, 3, 5, 7).skipLeft(1)).isEqualTo(new Rect(3, 3, 4, 7));
    assertThat(new Rect(2, 3, 5, 7).skipLeft(4)).isEqualTo(new Rect(6, 3, 1, 7));
    assertThat(new Rect(2, 3, 5, 7).skipLeft(5)).isEqualTo(new Rect(7, 3, 0, 7));
    assertThat(new Rect(2, 3, 5, 7).skipLeft(6)).isEqualTo(new Rect(7, 3, 0, 7));
  });
  suite.test("skipRight", function() {
    assertThat(new Rect(2, 3, 5, 7).skipRight(0)).isEqualTo(new Rect(2, 3, 5, 7));
    assertThat(new Rect(2, 3, 5, 7).skipRight(1)).isEqualTo(new Rect(2, 3, 4, 7));
    assertThat(new Rect(2, 3, 5, 7).skipRight(4)).isEqualTo(new Rect(2, 3, 1, 7));
    assertThat(new Rect(2, 3, 5, 7).skipRight(5)).isEqualTo(new Rect(2, 3, 0, 7));
    assertThat(new Rect(2, 3, 5, 7).skipRight(6)).isEqualTo(new Rect(2, 3, 0, 7));
  });
  suite.test("skipTop", function() {
    assertThat(new Rect(2, 3, 5, 7).skipTop(0)).isEqualTo(new Rect(2, 3, 5, 7));
    assertThat(new Rect(2, 3, 5, 7).skipTop(1)).isEqualTo(new Rect(2, 4, 5, 6));
    assertThat(new Rect(2, 3, 5, 7).skipTop(6)).isEqualTo(new Rect(2, 9, 5, 1));
    assertThat(new Rect(2, 3, 5, 7).skipTop(7)).isEqualTo(new Rect(2, 10, 5, 0));
    assertThat(new Rect(2, 3, 5, 7).skipTop(8)).isEqualTo(new Rect(2, 10, 5, 0));
  });
  suite.test("skipBottom", function() {
    assertThat(new Rect(2, 3, 5, 7).skipBottom(0)).isEqualTo(new Rect(2, 3, 5, 7));
    assertThat(new Rect(2, 3, 5, 7).skipBottom(1)).isEqualTo(new Rect(2, 3, 5, 6));
    assertThat(new Rect(2, 3, 5, 7).skipBottom(6)).isEqualTo(new Rect(2, 3, 5, 1));
    assertThat(new Rect(2, 3, 5, 7).skipBottom(7)).isEqualTo(new Rect(2, 3, 5, 0));
    assertThat(new Rect(2, 3, 5, 7).skipBottom(8)).isEqualTo(new Rect(2, 3, 5, 0));
  });
  suite.test("takeLeft", function() {
    assertThat(new Rect(2, 3, 5, 7).takeLeft(-1)).isEqualTo(new Rect(2, 3, 0, 7));
    assertThat(new Rect(2, 3, 5, 7).takeLeft(0)).isEqualTo(new Rect(2, 3, 0, 7));
    assertThat(new Rect(2, 3, 5, 7).takeLeft(1)).isEqualTo(new Rect(2, 3, 1, 7));
    assertThat(new Rect(2, 3, 5, 7).takeLeft(4)).isEqualTo(new Rect(2, 3, 4, 7));
    assertThat(new Rect(2, 3, 5, 7).takeLeft(5)).isEqualTo(new Rect(2, 3, 5, 7));
  });
  suite.test("takeRight", function() {
    assertThat(new Rect(2, 3, 5, 7).takeRight(-1)).isEqualTo(new Rect(7, 3, 0, 7));
    assertThat(new Rect(2, 3, 5, 7).takeRight(0)).isEqualTo(new Rect(7, 3, 0, 7));
    assertThat(new Rect(2, 3, 5, 7).takeRight(1)).isEqualTo(new Rect(6, 3, 1, 7));
    assertThat(new Rect(2, 3, 5, 7).takeRight(4)).isEqualTo(new Rect(3, 3, 4, 7));
    assertThat(new Rect(2, 3, 5, 7).takeRight(5)).isEqualTo(new Rect(2, 3, 5, 7));
  });
  suite.test("TakeTop", function() {
    assertThat(new Rect(2, 3, 5, 7).takeTop(-1)).isEqualTo(new Rect(2, 3, 5, 0));
    assertThat(new Rect(2, 3, 5, 7).takeTop(0)).isEqualTo(new Rect(2, 3, 5, 0));
    assertThat(new Rect(2, 3, 5, 7).takeTop(1)).isEqualTo(new Rect(2, 3, 5, 1));
    assertThat(new Rect(2, 3, 5, 7).takeTop(6)).isEqualTo(new Rect(2, 3, 5, 6));
    assertThat(new Rect(2, 3, 5, 7).takeTop(7)).isEqualTo(new Rect(2, 3, 5, 7));
  });
  suite.test("takeBottom", function() {
    assertThat(new Rect(2, 3, 5, 7).takeBottom(-1)).isEqualTo(new Rect(2, 10, 5, 0));
    assertThat(new Rect(2, 3, 5, 7).takeBottom(0)).isEqualTo(new Rect(2, 10, 5, 0));
    assertThat(new Rect(2, 3, 5, 7).takeBottom(1)).isEqualTo(new Rect(2, 9, 5, 1));
    assertThat(new Rect(2, 3, 5, 7).takeBottom(6)).isEqualTo(new Rect(2, 4, 5, 6));
    assertThat(new Rect(2, 3, 5, 7).takeBottom(7)).isEqualTo(new Rect(2, 3, 5, 7));
  });
  suite.test("paddedBy", function() {
    assertThat(new Rect(2, 3, 5, 7).paddedBy(0)).isEqualTo(new Rect(2, 3, 5, 7));
    assertThat(new Rect(2, 3, 5, 7).paddedBy(1)).isEqualTo(new Rect(1, 2, 7, 9));
    assertThat(new Rect(2, 3, 5, 7).paddedBy(2)).isEqualTo(new Rect(0, 1, 9, 11));
  });
  suite.test("containsPoint", function() {
    var r = new Rect(2, 3, 5, 7);
    assertTrue(r.containsPoint(r.center()));
    assertTrue(r.containsPoint(r.topLeft()));
    assertFalse(r.containsPoint(r.topRight()));
    assertFalse(r.containsPoint(r.bottomLeft()));
    assertFalse(r.containsPoint(r.bottomRight()));
    assertFalse(r.containsPoint(new Point(2 - 0.001, 5)));
    assertTrue(r.containsPoint(new Point(2 + 0.001, 5)));
    assertFalse(r.containsPoint(new Point(5, 3 - 0.001)));
    assertTrue(r.containsPoint(new Point(5, 3 + 0.001)));
    assertTrue(r.containsPoint(new Point(7 - 0.001, 5)));
    assertFalse(r.containsPoint(new Point(7 + 0.001, 5)));
    assertTrue(r.containsPoint(new Point(5, 10 - 0.001)));
    assertFalse(r.containsPoint(new Point(5, 10 + 0.001)));
  });
  suite.test("takeLeftProportion", function() {
    assertThat(new Rect(2, 3, 5, 7).takeLeftProportion(0.25)).isEqualTo(new Rect(2, 3, 1.25, 7));
  });
  suite.test("takeRightProportion", function() {
    assertThat(new Rect(2, 3, 5, 7).takeRightProportion(0.25)).isEqualTo(new Rect(5.75, 3, 1.25, 7));
  });
  suite.test("takeTopProportion", function() {
    assertThat(new Rect(2, 3, 5, 7).takeTopProportion(0.25)).isEqualTo(new Rect(2, 3, 5, 1.75));
  });
  suite.test("takeBottomProportion", function() {
    assertThat(new Rect(2, 3, 5, 7).takeBottomProportion(0.25)).isEqualTo(new Rect(2, 8.25, 5, 1.75));
  });
  suite.test("leftHalf", function() {
    assertThat(new Rect(2, 3, 5, 7).leftHalf()).isEqualTo(new Rect(2, 3, 2.5, 7));
  });
  suite.test("rightHalf", function() {
    assertThat(new Rect(2, 3, 5, 7).rightHalf()).isEqualTo(new Rect(4.5, 3, 2.5, 7));
  });
  suite.test("topHalf", function() {
    assertThat(new Rect(2, 3, 5, 7).topHalf()).isEqualTo(new Rect(2, 3, 5, 3.5));
  });
  suite.test("bottomHalf", function() {
    assertThat(new Rect(2, 3, 5, 7).bottomHalf()).isEqualTo(new Rect(2, 6.5, 5, 3.5));
  });
  suite.test("shiftedBy", function() {
    assertThat(new Rect(2, 3, 5, 7).shiftedBy(11, 13)).isEqualTo(new Rect(13, 16, 5, 7));
  });
  suite.test("proportionalShiftedBy", function() {
    assertThat(new Rect(2, 3, 5, 7).proportionalShiftedBy(11, 13)).isEqualTo(new Rect(57, 94, 5, 7));
  });
  suite.test("withX", function() {
    assertThat(new Rect(2, 3, 5, 7).withX(11)).isEqualTo(new Rect(11, 3, 5, 7));
  });
  suite.test("withY", function() {
    assertThat(new Rect(2, 3, 5, 7).withY(11)).isEqualTo(new Rect(2, 11, 5, 7));
  });
  suite.test("withW", function() {
    assertThat(new Rect(2, 3, 5, 7).withW(11)).isEqualTo(new Rect(2, 3, 11, 7));
  });
  suite.test("withH", function() {
    assertThat(new Rect(2, 3, 5, 7).withH(11)).isEqualTo(new Rect(2, 3, 5, 11));
  });
  suite.test("scaledOutwardBy", function() {
    assertThat(new Rect(2, 3, 5, 7).scaledOutwardBy(0)).isEqualTo(new Rect(4.5, 6.5, 0, 0));
    assertThat(new Rect(2, 3, 5, 7).scaledOutwardBy(0.5)).isEqualTo(new Rect(3.25, 4.75, 2.5, 3.5));
    assertThat(new Rect(2, 3, 5, 7).scaledOutwardBy(2)).isEqualTo(new Rect(-0.5, -0.5, 10, 14));
  });
  suite.test("snapInside", function() {
    assertThat(new Rect(10, 20, 50, 70).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(9, 20, 50, 70).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(11, 20, 50, 70).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(10, 19, 50, 70).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(10, 21, 50, 70).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(10, 20, 500, 70).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(10, 20, 50, 700).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 50, 70));
    assertThat(new Rect(-1000, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 21, 10, 10));
    assertThat(new Rect(9, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 21, 10, 10));
    assertThat(new Rect(10, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 21, 10, 10));
    assertThat(new Rect(11, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 21, 10, 10));
    assertThat(new Rect(49, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(49, 21, 10, 10));
    assertThat(new Rect(50, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(50, 21, 10, 10));
    assertThat(new Rect(51, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(50, 21, 10, 10));
    assertThat(new Rect(1000, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(50, 21, 10, 10));
    assertThat(new Rect(11, -1000, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 20, 10, 10));
    assertThat(new Rect(11, 19, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 20, 10, 10));
    assertThat(new Rect(11, 20, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 20, 10, 10));
    assertThat(new Rect(11, 21, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 21, 10, 10));
    assertThat(new Rect(11, 79, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 79, 10, 10));
    assertThat(new Rect(11, 80, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 80, 10, 10));
    assertThat(new Rect(11, 81, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 80, 10, 10));
    assertThat(new Rect(11, 1000, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(11, 80, 10, 10));
    assertThat(new Rect(-100, -100, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 20, 10, 10));
    assertThat(new Rect(+100, -100, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(50, 20, 10, 10));
    assertThat(new Rect(+100, +100, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(50, 80, 10, 10));
    assertThat(new Rect(-100, +100, 10, 10).snapInside(new Rect(10, 20, 50, 70))).isEqualTo(new Rect(10, 80, 10, 10));
  });
  return {};
});
//# sourceURL=test/math/Rect.test.js
;$traceurRuntime.registerModule("test/TestUtil.js", [], function() {
  "use strict";
  var __moduleName = "test/TestUtil.js";
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/browser/Polyfills.js", "test/TestUtil.js"));
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/base/Describe.js", "test/TestUtil.js")).describe;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/base/Equate.js", "test/TestUtil.js")).equate;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/webgl/WglTexturePool.js", "test/TestUtil.js")).WglTexturePool;
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/webgl/ShaderCoders.js", "test/TestUtil.js")),
      changeShaderCoder = $__16.changeShaderCoder,
      canTestFloatShaders = $__16.canTestFloatShaders;
  var SHADER_CODER_BYTES = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/webgl/ShaderCoders_intoBytes.js", "test/TestUtil.js")).SHADER_CODER_BYTES;
  var SHADER_CODER_FLOATS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/webgl/ShaderCoders_intoFloats.js", "test/TestUtil.js")).SHADER_CODER_FLOATS;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/base/DetailedError.js", "test/TestUtil.js")).DetailedError;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../src/Config.js", "test/TestUtil.js")).Config;
  Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS = true;
  var assertionSubjectIndexForNextTest = 1;
  function isArrayIsh(value) {
    return Array.isArray(value) || value instanceof Float32Array || value instanceof Float64Array || value instanceof Int8Array || value instanceof Int16Array || value instanceof Int32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Uint32Array;
  }
  function fail(message) {
    throw new Error(message);
  }
  function sanityCheck(subject) {
    if (subject instanceof Map) {
      for (var k in subject) {
        if (subject.hasOwnProperty(k)) {
          throw new Error(("Map has property 'map[" + k + "]' instead of entry 'map.get(" + k + ")'. Probably a mistake."));
        }
      }
    }
  }
  function isApproximatelyEqualToHelper(subject, other, epsilon) {
    if (subject === null) {
      return other === null;
    } else if (subject === undefined) {
      return other === undefined;
    } else if (subject.isApproximatelyEqualTo !== undefined) {
      return subject.isApproximatelyEqualTo(other, epsilon);
    } else if (typeof subject === 'number') {
      return subject === other || (isNaN(subject) && isNaN(other)) || (typeof other === 'number' && Math.abs(subject - other) < epsilon);
    } else if (isArrayIsh(subject)) {
      if (!isArrayIsh(other) || other.length !== subject.length) {
        return false;
      }
      for (var i = 0; i < subject.length; i++) {
        if (!isApproximatelyEqualToHelper(subject[i], other[i], epsilon)) {
          return false;
        }
      }
      return true;
    } else if (subject instanceof Object && subject.toString() === "[object Object]") {
      return isApproximatelyEqualToHelperDestructured(subject, other, epsilon);
    } else if (subject === other) {
      return true;
    } else {
      fail('Expected ' + describe(subject) + ' to have an isApproximatelyEqualTo method');
      return false;
    }
  }
  function isApproximatelyEqualToHelperDestructured(subject, other, epsilon) {
    var keys = [];
    for (var subjectKey in subject) {
      if (subject.hasOwnProperty(subjectKey)) {
        keys.push(subjectKey);
      }
    }
    for (var otherKey in other) {
      if (other.hasOwnProperty(otherKey) && !subject.hasOwnProperty(otherKey)) {
        return false;
      }
    }
    return keys.every(function(key) {
      return other.hasOwnProperty(key) && isApproximatelyEqualToHelper(subject[key], other[key], epsilon);
    });
  }
  var AssertionSubject = function() {
    function AssertionSubject(subject) {
      var id = arguments[1];
      var info = arguments[2];
      sanityCheck(subject);
      assertionSubjectIndexForNextTest += 1;
      this.subject = subject;
      this.id = id;
      this.info = info;
    }
    return ($traceurRuntime.createClass)(AssertionSubject, {
      withInfo: function(newInfo) {
        return new AssertionSubject(this.subject, this.id, newInfo);
      },
      _fail: function(message) {
        var idMessage = this.id === undefined ? message : (message + " (" + this.id + ")");
        var infoMessage = this.info === undefined ? idMessage : (idMessage + " (info: " + describe(this.info) + ")");
        fail(infoMessage);
      },
      _failExpected: function(relation, expected) {
        var act = describe(this.subject);
        var exp = describe(expected);
        if (act.length + exp.length < 50) {
          this._fail(("Got <" + act + "> but expected it " + relation + " <" + exp + ">."));
        } else {
          this._fail(("Got <\n\t" + act + "\n> but expected it " + relation + " <\n\t" + exp + "\n>."));
        }
      },
      iteratesAs: function() {
        for (var items = [],
            $__11 = 0; $__11 < arguments.length; $__11++)
          items[$__11] = arguments[$__11];
        var actualItems = [];
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this.subject)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              if (actualItems.length > items.length * 2 + 100) {
                actualItems.push("{...}");
                break;
              }
              actualItems.push(item);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        new AssertionSubject(actualItems, this.id).isEqualTo(items);
      },
      is: function(other) {
        if (!Object.is(this.subject, other)) {
          this._failExpected('to be the same object reference as', other);
        }
      },
      isEqualTo: function(other) {
        if (!equate(this.subject, other)) {
          this._failExpected('to equal', other);
        }
      },
      isGreaterThan: function(other) {
        if (!(this.subject > other)) {
          this._failExpected('to be greater than', other);
        }
      },
      isLessThan: function(other) {
        if (!(this.subject < other)) {
          this._failExpected('to be less than', other);
        }
      },
      isNotEqualTo: function(other) {
        if (equate(this.subject, other)) {
          this._failExpected('to NOT equal', other);
        }
      },
      isApproximatelyEqualTo: function(other) {
        var epsilon = arguments[1] !== (void 0) ? arguments[1] : 0.000001;
        if (!isApproximatelyEqualToHelper(this.subject, other, epsilon)) {
          this._failExpected('to approximately equal', other);
        }
      },
      isNotApproximatelyEqualTo: function(other) {
        var epsilon = arguments[1] !== (void 0) ? arguments[1] : 0.000001;
        if (isApproximatelyEqualToHelper(this.subject, other, epsilon)) {
          this._failExpected('to NOT approximately equal', other);
        }
      }
    }, {});
  }();
  function assertThat(subject, extraArgCatcher) {
    if (extraArgCatcher !== undefined) {
      fail('Extra assertThat arg');
    }
    return new AssertionSubject(subject, 'assertThat #' + assertionSubjectIndexForNextTest);
  }
  function assertTrue(subject) {
    assertThat(subject).isEqualTo(true);
  }
  function assertFalse(subject) {
    assertThat(subject).isEqualTo(false);
  }
  function assertThrows(func, extraArgCatcher) {
    if (extraArgCatcher !== undefined) {
      fail('Extra assertThrows arg');
    }
    try {
      func();
    } catch (ex) {
      return new AssertionSubject(ex, 'assertThrows');
    }
    fail('Expected an exception to be thrown by ' + func);
    return undefined;
  }
  var __webGLSupportPresent = undefined;
  var __onlyPartialWebGLSupportPresent = undefined;
  function isWebGLSupportPresent() {
    if (__webGLSupportPresent === undefined) {
      __webGLSupportPresent = false;
      if (window.WebGLRenderingContext !== undefined) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (ctx instanceof WebGLRenderingContext) {
          __webGLSupportPresent = true;
          var shader = ctx.createShader(WebGLRenderingContext.VERTEX_SHADER);
          ctx.shaderSource(shader, "\n                    precision highp float;\n                    precision highp int;\n                    attribute vec2 position;\n                    void main() {gl_Position = vec4(position, 0, 1);}");
          ctx.compileShader(shader);
          var term = "extension `GL_ARB_gpu_shader5' unsupported";
          __onlyPartialWebGLSupportPresent = ctx.getShaderInfoLog(shader).indexOf(term) !== -1;
          if (__onlyPartialWebGLSupportPresent) {
            Config.IGNORED_WEBGL_INFO_TERMS.push(term);
            console.log('Only partial WebGL support is present. Some tests may fail and be ignored.');
          }
        }
      }
    }
    return __webGLSupportPresent;
  }
  function isOnlyPartialWebGLSupportPresent() {
    return isWebGLSupportPresent() && __onlyPartialWebGLSupportPresent;
  }
  var promiseImageDataFromSrc = function(src) {
    var img = document.createElement('img');
    img.src = src;
    return new Promise(function(resolve) {
      img.onload = resolve;
    }).then(function() {
      var canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      var ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    });
  };
  var meanSquaredError = function(data1, data2) {
    if (data1.length !== data2.length) {
      return false;
    }
    var err = 0;
    for (var i = 0; i < data1.length; i++) {
      var e = data1[i] - data2[i];
      err += e * e;
    }
    return err / data1.length;
  };
  var isFirstByteCoderWebGlTest = true;
  var isFirstFloatCoderWebGlTest = true;
  var Suite = function() {
    function Suite(name) {
      Suite.suites.push(this);
      this.tests = [];
      this.later_tests = [];
      this.name = name;
    }
    return ($traceurRuntime.createClass)(Suite, {
      test: function(name, method) {
        var later = arguments[2] !== (void 0) ? arguments[2] : false;
        var $__3 = this;
        (later ? this.later_tests : this.tests).push([name, function(status) {
          assertionSubjectIndexForNextTest = 1;
          var result = method(status);
          if (result === undefined && assertionSubjectIndexForNextTest === 1) {
            console.warn(("No assertions in test '" + name + "' of suite '" + $__3.name + "'."));
          }
          return result;
        }]);
      },
      testUsingWebGL: function(name, method) {
        var needsFloatSupport = arguments[2] !== (void 0) ? arguments[2] : false;
        var $__3 = this;
        var wrappedMethod = function(caseName, status, subNeedFloats) {
          if (subNeedFloats && !canTestFloatShaders()) {
            var msg = ("Skipping " + $__3.name + "." + caseName + " due to lack of WebGL float texture support.");
            console.warn(msg);
            status.log.push(msg);
            assertThat(undefined);
            return;
          }
          if (!isWebGLSupportPresent()) {
            var msg$__12 = ("Skipping " + $__3.name + "." + caseName + " due to lack of WebGL support.");
            console.warn(msg$__12);
            status.log.push(msg$__12);
            assertThat(undefined);
            return;
          } else if (isOnlyPartialWebGLSupportPresent()) {
            status.warn_only = true;
            status.ignore_warn_only_on_success = true;
            status.warn_failure_message = ("Ignoring " + $__3.name + "." + caseName + " failure due to lack of WebGL support.");
            status.warn_show_error = true;
          }
          var preTexCount = WglTexturePool.getUnReturnedTextureCount();
          method(status);
          var gain = WglTexturePool.getUnReturnedTextureCount() - preTexCount;
          if (gain > 0) {
            throw new DetailedError("Unreturned textures.", {unreturned_increase: gain});
          }
          if (gain < 0) {
            throw new DetailedError("Extra returned textures.", {extra_returns: -gain});
          }
          status.wasWebGLTest = true;
        };
        this.test(name + '[byte-coder]', function(status) {
          if (isFirstByteCoderWebGlTest) {
            changeShaderCoder(SHADER_CODER_BYTES);
            isFirstByteCoderWebGlTest = false;
          }
          wrappedMethod(name + '[byte-coder]', status, needsFloatSupport);
        }, false);
        this.test(name + '[float-coder]', function(status) {
          if (isFirstFloatCoderWebGlTest) {
            changeShaderCoder(SHADER_CODER_FLOATS);
            isFirstFloatCoderWebGlTest = false;
          }
          wrappedMethod(name + '[float-coder]', status, true);
        }, true);
      },
      testUsingWebGLFloatTextures: function(name, method) {
        this.testUsingWebGL(name, method, true);
      },
      canvasAppearanceTest: function(name, width, height, method, expectedSrc) {
        var tolerance = arguments[5] !== (void 0) ? arguments[5] : 256;
        this.test(name, function(status) {
          var actualCanvas = document.createElement("canvas");
          actualCanvas.width = width;
          actualCanvas.height = height;
          method(actualCanvas, status);
          var actualData = actualCanvas.getContext("2d").getImageData(0, 0, actualCanvas.width, actualCanvas.height);
          return promiseImageDataFromSrc(expectedSrc).then(function(expectedData) {
            var mse = meanSquaredError(actualData.data, expectedData.data);
            if (expectedData.width !== actualData.width || expectedData.height !== actualData.height || mse > tolerance) {
              var actualSrc = actualCanvas.toDataURL("image/png");
              fail(("Drawn image <\n\n" + actualSrc + "\n\n> differed with MSE=" + mse + " from <\n" + expectedSrc + "\n>."));
            }
          });
        });
      }
    }, {});
  }();
  Suite.suites = [];
  return {
    get fail() {
      return fail;
    },
    get AssertionSubject() {
      return AssertionSubject;
    },
    get assertThat() {
      return assertThat;
    },
    get assertTrue() {
      return assertTrue;
    },
    get assertFalse() {
      return assertFalse;
    },
    get assertThrows() {
      return assertThrows;
    },
    get Suite() {
      return Suite;
    }
  };
});
//# sourceURL=test/TestUtil.js
;$traceurRuntime.registerModule("test/ui/DisplayedCircuit.test.js", [], function() {
  "use strict";
  var __moduleName = "test/ui/DisplayedCircuit.test.js";
  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/ui/DisplayedCircuit.test.js")),
      Suite = $__13.Suite,
      assertThat = $__13.assertThat,
      assertThrows = $__13.assertThrows;
  var DisplayedCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/ui/DisplayedCircuit.js", "test/ui/DisplayedCircuit.test.js")).DisplayedCircuit;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitDefinition.js", "test/ui/DisplayedCircuit.test.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/circuit/CircuitStats.js", "test/ui/DisplayedCircuit.test.js")).CircuitStats;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/gates/AllGates.js", "test/ui/DisplayedCircuit.test.js")).Gates;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Point.js", "test/ui/DisplayedCircuit.test.js")).Point;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/RestartableRng.js", "test/ui/DisplayedCircuit.test.js")).RestartableRng;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/ui/Hand.js", "test/ui/DisplayedCircuit.test.js")).Hand;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/draw/Painter.js", "test/ui/DisplayedCircuit.test.js")).Painter;
  var COMMON_GATES = new Map([['X', Gates.HalfTurns.X], ['Y', Gates.HalfTurns.Y], ['Z', Gates.HalfTurns.Z], ['H', Gates.HalfTurns.H], ['Q', Gates.FourierTransformGates.FourierTransformFamily], ['•', Gates.Controls.Control], ['◦', Gates.Controls.AntiControl], ['M', Gates.Special.Measurement], ['%', Gates.Displays.ChanceDisplay], ['@', Gates.Displays.BlochSphereDisplay], ['s', Gates.Special.SwapHalf], ['!', Gates.PostSelectionGates.PostSelectOn], ['-', undefined], ['+', undefined], ['0', null], ['1', null], ['2', null], ['3', null], ['4', null], ['5', null], ['6', null], ['7', null], ['8', null], ['9', null], ['/', null]]);
  var circuit = function(diagramText) {
    for (var extraGateEntries = [],
        $__8 = 1; $__8 < arguments.length; $__8++)
      extraGateEntries[$__8 - 1] = arguments[$__8];
    return CircuitDefinition.fromTextDiagram(new Map($traceurRuntime.spread(COMMON_GATES.entries(), extraGateEntries)), diagramText);
  };
  var displayedCircuit = function(diagramText) {
    for (var extraGateEntries = [],
        $__9 = 1; $__9 < arguments.length; $__9++)
      extraGateEntries[$__9 - 1] = arguments[$__9];
    return DisplayedCircuit.fromTextDiagram(new Map($traceurRuntime.spread(COMMON_GATES.entries(), extraGateEntries)), diagramText);
  };
  var simulateDrag = function(diagramText) {
    var options = arguments[1] !== (void 0) ? arguments[1] : {};
    for (var extraGateEntries = [],
        $__10 = 2; $__10 < arguments.length; $__10++)
      extraGateEntries[$__10 - 2] = arguments[$__10];
    var duplicate = options.duplicate || false;
    var wholeColumn = options.wholeColumn || false;
    var $__11 = displayedCircuit.apply((void 0), $traceurRuntime.spread([diagramText], extraGateEntries)),
        beforeGrab = $__11.circuit,
        pts = $__11.pts;
    var $__12 = beforeGrab.tryGrab(Hand.EMPTY.withPos(pts[0]), duplicate, wholeColumn),
        afterGrab = $__12.newCircuit,
        fullHand = $__12.newHand;
    var hovers = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (pts)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var pt = $__2.value;
        {
          hovers.push(afterGrab.previewDrop(fullHand.withPos(pt)));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var afterDrop = afterGrab.afterDropping(fullHand.withPos(pts[pts.length - 1]));
    var afterDropAndTidy = afterDrop.afterTidyingUp();
    return {
      beforeGrab: beforeGrab,
      afterGrab: afterGrab,
      hovers: hovers,
      afterDrop: afterDrop,
      afterDropAndTidy: afterDropAndTidy
    };
  };
  var suite = new Suite("DisplayedCircuit");
  suite.test("constructor_vs_isEqualTo", function() {
    var d1 = CircuitDefinition.fromTextDiagram(COMMON_GATES, "+H+\n                                                              X+Y");
    var d2 = CircuitDefinition.fromTextDiagram(COMMON_GATES, "++++\n                                                              ZHHH");
    assertThrows(function() {
      return new DisplayedCircuit(23, "not a circuit", undefined, undefined, undefined);
    });
    assertThrows(function() {
      return new DisplayedCircuit("not a number", d1, undefined, undefined, undefined);
    });
    var c1 = new DisplayedCircuit(45, d1, undefined, undefined, undefined);
    var c2 = new DisplayedCircuit(67, d2, 1, {
      col: 1,
      row: 1,
      resizeStyle: true
    }, 1);
    assertThat(c1.top).isEqualTo(45);
    assertThat(c1.circuitDefinition).isEqualTo(d1);
    assertThat(c1).isEqualTo(c1);
    assertThat(c1).isNotEqualTo(c2);
    assertThat(c2).isEqualTo(c2);
    assertThat(c2).isNotEqualTo(c1);
    assertThat(c1).isEqualTo(new DisplayedCircuit(45, d1, undefined, undefined, undefined));
    assertThat(c1).isNotEqualTo(new DisplayedCircuit(46, d1, undefined, undefined, undefined));
    assertThat(c1).isNotEqualTo(new DisplayedCircuit(45, d2, undefined, undefined, undefined));
    assertThat(c1).isNotEqualTo(new DisplayedCircuit(45, d1, 1, undefined, undefined));
    assertThat(c1).isNotEqualTo(new DisplayedCircuit(45, d1, undefined, {
      col: 1,
      row: 1,
      resizeStyle: false
    }, undefined));
    assertThat(c1).isNotEqualTo(new DisplayedCircuit(45, d1, undefined, undefined, 0));
    assertThat(c2).isEqualTo(new DisplayedCircuit(67, d2, 1, {
      col: 1,
      row: 1,
      resizeStyle: true
    }, 1));
    assertThat(c2).isNotEqualTo(new DisplayedCircuit(68, d2, 1, {
      col: 1,
      row: 1,
      resizeStyle: true
    }, 1));
    assertThat(c2).isNotEqualTo(new DisplayedCircuit(67, d1, 1, {
      col: 1,
      row: 1,
      resizeStyle: true
    }, 1));
    assertThat(c2).isNotEqualTo(new DisplayedCircuit(67, d2, 2, {
      col: 1,
      row: 1,
      resizeStyle: true
    }, 1));
    assertThat(c2).isNotEqualTo(new DisplayedCircuit(67, d2, 1, {
      col: 2,
      row: 1,
      resizeStyle: true
    }, 1));
    assertThat(c2).isNotEqualTo(new DisplayedCircuit(67, d2, 1, {
      col: 2,
      row: 1,
      resizeStyle: true
    }, 2));
  });
  suite.test("bootstrap_diagram", function() {
    assertThat(displayedCircuit("|\n                                 |-X-D//-\n                                 |   ///\n                                 |-+-///-\n                                 |", ['D', Gates.Displays.DensityMatrixDisplay2])).isEqualTo({
      circuit: new DisplayedCircuit(10, circuit("XD/\n                     +//", ['D', Gates.Displays.DensityMatrixDisplay2]), undefined, undefined, undefined),
      pts: []
    });
    assertThat(displayedCircuit("|\n                                 |-+-H-+-\n                                 |\n                                 |-+-Y-+-\n                                 |")).isEqualTo({
      circuit: new DisplayedCircuit(10, circuit("+H+\n                     +Y+"), undefined, undefined, undefined),
      pts: []
    });
    assertThat(displayedCircuit("|01\n                                 |2+-H-+-\n                                 |  3\n                                 |-+-Y4+-\n                                 |  5^   ")).isEqualTo({
      circuit: new DisplayedCircuit(10, circuit("+H+\n                     +Y+"), undefined, undefined, undefined),
      pts: [new Point(35.5, 10.5), new Point(60.5, 10.5), new Point(35.5, 35.5), new Point(85.5, 60.5), new Point(135.5, 85.5), new Point(110.5, 85.5)]
    });
  });
  suite.test("indexOfDisplayedRowAt", function() {
    var $__11 = displayedCircuit("|0\n                                           |1+-+-\n                                           |   2\n                                           |-+3+-\n                                           |  4"),
        circuit = $__11.circuit,
        pts = $__11.pts;
    assertThat(circuit.indexOfDisplayedRowAt(-9999)).isEqualTo(undefined);
    assertThat(circuit.indexOfDisplayedRowAt(+9999)).isEqualTo(undefined);
    assertThat(circuit.indexOfDisplayedRowAt(pts[0].y)).isEqualTo(0);
    assertThat(circuit.indexOfDisplayedRowAt(pts[1].y)).isEqualTo(0);
    assertThat(circuit.indexOfDisplayedRowAt(pts[2].y)).isEqualTo(1);
    assertThat(circuit.indexOfDisplayedRowAt(pts[3].y)).isEqualTo(1);
    assertThat(circuit.indexOfDisplayedRowAt(pts[4].y)).isEqualTo(undefined);
  });
  suite.testUsingWebGL("drawCircuitCompletes_QuantumTeleportation", function() {
    var teleportCircuit = CircuitDefinition.fromTextDiagram(new Map([['X', Gates.HalfTurns.X], ['Z', Gates.HalfTurns.Z], ['H', Gates.HalfTurns.H], ['M', Gates.Special.Measurement], ['•', Gates.Controls.Control], ['@', Gates.Displays.BlochSphereDisplay], ['t', Gates.Powering.YForward], ['-', undefined], ['=', undefined], ['|', undefined]]), "------t@--•-H-M===•===\n         -H-•------X---M=•=|===\n         ---X------------X-Z-@-");
    var stats = CircuitStats.fromCircuitAtTime(teleportCircuit, 0.1);
    var displayed = DisplayedCircuit.empty(0).withCircuit(teleportCircuit);
    var canvas = document.createElement("canvas");
    canvas.width = 1000;
    canvas.height = 1000;
    var painter = new Painter(canvas, new RestartableRng());
    displayed.paint(painter, Hand.EMPTY, stats);
    var inputState = stats.qubitDensityMatrix(7, 0);
    var outputState = stats.qubitDensityMatrix(Infinity, 2);
    assertThat(outputState).isApproximatelyEqualTo(inputState);
  });
  suite.test("dragXIntoCNot", function() {
    var drag = simulateDrag("|\n                             |-H-•-X-\n                             |    0^\n                             |-+3421-\n                             |");
    assertThat(drag.beforeGrab.circuitDefinition).isEqualTo(circuit("H•X\n                                                                     ---"));
    assertThat(drag.afterGrab.circuitDefinition).isEqualTo(circuit("H•-\n                                                                    ---"));
    assertThat(drag.hovers.map(function(e) {
      return e.circuitDefinition;
    })).isEqualTo([circuit("H•X\n                 ---"), circuit("H•-\n                 --X"), circuit("H•--\n                 --X-"), circuit("H-•-\n                 -X--"), circuit("H•-\n                 -X-")]);
    assertThat(drag.afterDrop.circuitDefinition).isEqualTo(circuit("H•-\n                                                                    -X-"));
    assertThat(drag.afterDropAndTidy.circuitDefinition).isEqualTo(circuit("H•\n                                                                           -X"));
  });
  suite.test("resizeQft", function() {
    var drag = simulateDrag("|\n                             |-Q-\n                             | 1\n                             |-/-\n                             | 0\n                             |-+-\n                             |\n                             |-+-\n                             | 2");
    assertThat(drag.beforeGrab.circuitDefinition).isEqualTo(circuit("Q\n                                                                     /\n                                                                     -\n                                                                     -"));
    assertThat(drag.afterGrab.circuitDefinition).isEqualTo(circuit("Q\n                                                                    /\n                                                                    -\n                                                                    -"));
    assertThat(drag.hovers.map(function(e) {
      return e.circuitDefinition;
    })).isEqualTo([circuit("Q\n                 /\n                 -\n                 -"), circuit("Q\n                 -\n                 -\n                 -"), circuit("Q\n                 /\n                 /\n                 /")]);
    assertThat(drag.afterDrop.circuitDefinition).isEqualTo(circuit("Q\n                                                                    /\n                                                                    /\n                                                                    /"));
    assertThat(drag.afterDropAndTidy.circuitDefinition).isEqualTo(circuit("Q\n                                                                           /\n                                                                           /\n                                                                           /"));
  });
  suite.test("dragQft", function() {
    var drag = simulateDrag("|\n                             |-Q-\n                             | 0\n                             |-/-\n                             |\n                             |-+-\n                             | 1\n                             |-+-\n                             |");
    assertThat(drag.beforeGrab.circuitDefinition).isEqualTo(circuit("Q\n                                                                     /\n                                                                     -\n                                                                     -"));
    assertThat(drag.afterGrab.circuitDefinition).isEqualTo(circuit("-\n                                                                    -\n                                                                    -\n                                                                    -"));
    assertThat(drag.hovers.map(function(e) {
      return e.circuitDefinition;
    })).isEqualTo([circuit("Q\n                 /\n                 -\n                 -"), circuit("-\n                 -\n                 Q\n                 /")]);
    assertThat(drag.afterDrop.circuitDefinition).isEqualTo(circuit("-\n                                                                    -\n                                                                    Q\n                                                                    /"));
    assertThat(drag.afterDropAndTidy.circuitDefinition).isEqualTo(circuit("-\n                                                                           -\n                                                                           Q\n                                                                           /"));
  });
  return {};
});
//# sourceURL=test/ui/DisplayedCircuit.test.js
;$traceurRuntime.registerModule("test/ui/forge.test.js", [], function() {
  "use strict";
  var __moduleName = "test/ui/forge.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/ui/forge.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat,
      assertThrows = $__0.assertThrows;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/ui/forge.test.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Matrix.js", "test/ui/forge.test.js")).Matrix;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/ui/forge.js", "test/ui/forge.test.js")),
      parseUserMatrix = $__3.parseUserMatrix,
      parseUserRotation = $__3.parseUserRotation;
  var suite = new Suite("forge");
  suite.test("parseUserMatrix", function() {
    assertThrows(function() {
      return parseUserMatrix("bad", false);
    });
    assertThrows(function() {
      return parseUserMatrix("{{1}}", false);
    });
    assertThrows(function() {
      return parseUserMatrix("{{1, 0}}", false);
    });
    assertThrows(function() {
      return parseUserMatrix("{{1, 0}, {2, 3}, {4, 5}}", false);
    });
    assertThrows(function() {
      return parseUserMatrix("{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}}", false);
    });
    assertThrows(function() {
      return parseUserMatrix("((1, i), (i, 1))", false);
    });
    assertThat(parseUserMatrix("0", false)).isEqualTo(Matrix.square(0, 0, 0, 0));
    assertThat(parseUserMatrix("1, 2", false)).isEqualTo(Matrix.square(1, 2, 0, 0));
    assertThat(parseUserMatrix("1, 2, 3+i, i^2", false)).isEqualTo(Matrix.square(1, 2, new Complex(3, 1), -1));
    assertThat(parseUserMatrix("0,0,0,0,0", false)).isEqualTo(Matrix.zero(4, 4));
    assertThat(parseUserMatrix("0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", false)).isEqualTo(Matrix.zero(8, 8));
    var s = Math.sqrt(0.5);
    var si = new Complex(0, s);
    assertThat(parseUserMatrix("0", true)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(parseUserMatrix("1", true)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(parseUserMatrix("2", true)).isApproximatelyEqualTo(Matrix.square(1, 0, 0, 1));
    assertThat(parseUserMatrix("1, 1", true)).isApproximatelyEqualTo(Matrix.square(s, s, -s, s));
    assertThat(parseUserMatrix("1, i, i, 1", true)).isApproximatelyEqualTo(Matrix.square(s, si, si, s));
    assertThat(parseUserMatrix("{{1, i}, {i, 1}}", true)).isApproximatelyEqualTo(Matrix.square(s, si, si, s));
    assertThat(parseUserMatrix("[[1, i], [i, 1]]", true)).isApproximatelyEqualTo(Matrix.square(s, si, si, s));
    assertThat(parseUserMatrix("0,0,0,0,0", true)).isApproximatelyEqualTo(Matrix.identity(4));
    assertThat(parseUserMatrix("0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0", true)).isApproximatelyEqualTo(Matrix.identity(8));
  });
  suite.test("parseUserRotation", function() {
    var s = Math.sqrt(0.5);
    var si = new Complex(0, s);
    assertThat(parseUserRotation("180", "90", "X")).isEqualTo(Matrix.PAULI_X);
    assertThat(parseUserRotation("180", "90", "Y")).isEqualTo(Matrix.PAULI_Y);
    assertThat(parseUserRotation("180", "90", "Z")).isEqualTo(Matrix.PAULI_Z);
    assertThat(parseUserRotation("180", "90", "X+Z")).isEqualTo(Matrix.HADAMARD);
    assertThat(parseUserRotation("90", "45", "X")).isEqualTo(Matrix.fromPauliRotation(0.25, 0, 0));
    assertThat(parseUserRotation("-2*45", "2^3-8", "X")).isEqualTo(Matrix.square(s, si, si, s));
  });
  return {};
});
//# sourceURL=test/ui/forge.test.js
;$traceurRuntime.registerModule("test/ui/MathPainter.test.js", [], function() {
  "use strict";
  var __moduleName = "test/ui/MathPainter.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/ui/MathPainter.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/draw/MathPainter.js", "test/ui/MathPainter.test.js")).MathPainter;
  var suite = new Suite("MathPainter");
  suite.test("describeProbability_middle", function() {
    assertThat(MathPainter.describeProbability(1 / 3, 0)).isEqualTo("33%");
    assertThat(MathPainter.describeProbability(1 / 3, 1)).isEqualTo("33.3%");
    assertThat(MathPainter.describeProbability(1 / 3, 2)).isEqualTo("33.33%");
    assertThat(MathPainter.describeProbability(1 / 2, 0)).isEqualTo("50%");
    assertThat(MathPainter.describeProbability(1 / 2, 1)).isEqualTo("50.0%");
    assertThat(MathPainter.describeProbability(1 / 2, 2)).isEqualTo("50.00%");
    assertThat(MathPainter.describeProbability(2 / 3, 0)).isEqualTo("67%");
    assertThat(MathPainter.describeProbability(2 / 3, 1)).isEqualTo("66.7%");
    assertThat(MathPainter.describeProbability(2 / 3, 2)).isEqualTo("66.67%");
  });
  suite.test("describeProbability_borders", function() {
    assertThat(MathPainter.describeProbability(0, 0)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0, 1)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0, 2)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.00001, 0)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.00001, 1)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.00001, 2)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.004, 0)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.0004, 0)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.0004, 1)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.0004, 2)).isEqualTo("0.04%");
    assertThat(MathPainter.describeProbability(0.006, 0)).isEqualTo("1%");
    assertThat(MathPainter.describeProbability(0.0006, 0)).isEqualTo("Off");
    assertThat(MathPainter.describeProbability(0.0006, 1)).isEqualTo("0.1%");
    assertThat(MathPainter.describeProbability(0.0006, 2)).isEqualTo("0.06%");
    assertThat(MathPainter.describeProbability(0.996, 0)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(0.9996, 0)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(0.9996, 1)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(0.9996, 2)).isEqualTo("99.96%");
    assertThat(MathPainter.describeProbability(0.994, 0)).isEqualTo("99%");
    assertThat(MathPainter.describeProbability(0.9994, 0)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(0.9994, 1)).isEqualTo("99.9%");
    assertThat(MathPainter.describeProbability(0.9994, 2)).isEqualTo("99.94%");
    assertThat(MathPainter.describeProbability(0.99999, 0)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(0.99999, 1)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(0.99999, 2)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(1, 0)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(1, 1)).isEqualTo("On");
    assertThat(MathPainter.describeProbability(1, 2)).isEqualTo("On");
  });
  return {};
});
//# sourceURL=test/ui/MathPainter.test.js
;$traceurRuntime.registerModule("test/ui/Painter.test.js", [], function() {
  "use strict";
  var __moduleName = "test/ui/Painter.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/ui/Painter.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/draw/Painter.js", "test/ui/Painter.test.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Point.js", "test/ui/Painter.test.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Rect.js", "test/ui/Painter.test.js")).Rect;
  var suite = new Suite("Painter");
  suite.test("paintableArea", function() {
    var c = document.createElement("canvas");
    c.width = 23;
    c.height = 34;
    assertThat(new Painter(c).paintableArea()).isEqualTo(new Rect(0, 0, 23, 34));
  });
  suite.canvasAppearanceTest("clear", 20, 20, function(canvas) {
    var painter = new Painter(canvas);
    painter.clear('#123456');
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAHklEQVQ4jWMQMgn7T03MMGrgqIGjBo4aOGrgSDUQACM' + 'egk9y1eLzAAAAAElFTkSuQmCC');
  suite.canvasAppearanceTest("strokeRect", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    painter.strokeRect(new Rect(5, 10, 15, 20), "blue", 4);
    painter.strokeRect(new Rect(2.5, 3.5, 5, 17), "red", 1);
    painter.strokeRect(new Rect(20, 30, 5, 7), "red", 1);
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAkUlEQVRYhe3UQQqEMBBE0TpajlY3y9FqViOO9MJQkUS' + 'mPvTGhf1AWiD9SwJUzWrXUYUJcKQA3VTcSfXs/gQY4Czg7TcEGGCAAb4eWM02QH9JgO6SAN0lAbpLlgCd2RDY0EVQBCWAp2lbAAmqo12BXQC3ARL8+cR' + 'f6CSgV4UJcKQA3c5X+9AVewloF9zs/2Aa7gP137GCEm+UmAAAAABJRU5ErkJggg==');
  suite.canvasAppearanceTest("strokeCircle", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    painter.strokeCircle(new Point(5, 10), 15, "blue", 3);
    painter.strokeCircle(new Point(20, 13), 5, "green", 1);
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAABdklEQVRYhe2XMUtCURSAP2pqsSkoLJwC/0OzDS9rT2i' + 'LVolwelCXcFGHpvwB/QYbw8WpocnBUUyEGl0TT8O7wrV3pRD03uB+cJb74N2PezjnngtLIUWQKYjoeFnuPytFioaggNy7NrIgZUNwArLv2siCdAzJR9c' + '2FiQyBMeubRYgXUMycm1jQWqGYNO1jYW5Ymm7tklzcXxF6US42RMqO18oWig8SbWiwd3GO4WKsN0Xsq8PKOooBigaruUiFAPOT/OpSq6S1ZIOTzJJZR3' + 'EFOwZ3+soWi4FR8TkFhZJlRwK5YOgvc3E5FCMXArOUmxv1B6kOCLe+iQzTF91XhQJwNnlkOsDoVARdt+edFo9aTOz4jh8FkrRlNvNDxQjTxq11wOr1yP' + '/XM8TkD5I1rUVejDtWOSOVr1xVzfasr6yMjryeq32o88ZaV3LyaU2/i0may6IP4uNk0fR2l9uEiX3p7STSUTGOnp6renpOyMQCAQCgUDgH/ANRQswZ2g' + 'MMfAAAAAASUVORK5CYII=');
  suite.canvasAppearanceTest("fillCircle", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    painter.fillCircle(new Point(5, 10), 15, "blue");
    painter.fillCircle(new Point(20, 13), 5, "green");
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAA/0lEQVRYhe3WIWtCYRSH8ScsGMyXpYFZ65phLM4yLIp' + 'pwTAVsfgBXr+DWBZkcR9ADGbBbtgnsFgWjX+D9wZFFLx4PZPzwEm3/Lgv7+EFpBQzARW5bqmAAs1AD5aBAnWtA+egJ8tAgZrWgT/WgStQwTJQoFe7wGg' + 'pqo0vAk0CJTvA3J94/xCBwxkTyN8e+NY5hktmeFtgtDyFSybtcacAPo/OAwe0HPh/jxiJStvwJUnWTK26trtmdtMjUIqXtLFFbfzBavrJ/wt6vDLuYuB' + '3Bn/uIuAC1ANFGeEANAVtTqA28UX4BOUyhO0h86AXUB3Uj6cOKu++eZ7neZ7neXfaFuFxi8XufliHAAAAAElFTkSuQmCC');
  suite.canvasAppearanceTest("printLine_simple", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    var r = new Rect(5, 5, 30, 30);
    painter.strokeRect(r, "green");
    var used = painter.printLine("test", r, 0, "black", 12, "monospace");
    assertThat(used).isApproximatelyEqualTo(new Rect(5, 18.5, 28, 12), 2.5);
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAA1klEQVRYhe2YwQ3CMAxF/zaskVPFIB0kl06SQbhkEhY' + 'pBwo1lgkpTkmF/o96iB39/+SoPRSgqKMpIiB2W6EGMCLi0gHunlkJWHGwsapzCejNJaA3l4DeXAJ6cwnozSWgN5eA3tzXg3kHFNtzE+AZCcCsHmk8qp6' + 'W7KWlNhQ9G09Q1k8ArmI/LTWr996zIaA1iVlByfrQA3D8bPTUrhNMopOxTkOHlgD03vb8EnDCelVyavoa5YuSUb5i2/Nfv4O/EwG9IqBXGwEP/fModIB' + '7rOC8B4pqrhsoxyh6D5LV0gAAAABJRU5ErkJggg==', 1000);
  suite.canvasAppearanceTest("printLine_aligned", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    painter.clear("gray");
    var used1 = painter.printLine("A", new Rect(0, 0, 40, 40).leftHalf(), 0, "red", 24, "monospace");
    var used2 = painter.printLine("long", new Rect(0, 0, 40, 40).rightHalf(), 1, "green", 24, "monospace");
    assertThat(used1).isApproximatelyEqualTo(new Rect(0, 12, 14.4, 24), 2.5);
    assertThat(used2).isApproximatelyEqualTo(new Rect(20, 23.25, 20, 9), 2.5);
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAABYUlEQVRYhe3WoW7DMBQF0MdKzIKMwsyCzALDCg2L/QH' + '5hfsL5cWjY4NlZUNlZWVDQ0FFd6CzV6WNmm7T7EkGV6riqjp+z8+NAGDOkdSAAizA1IACLMDUgAIswNSAAvwz4MEYUuQqx7rOA3iZbddxUIpPqxUpwnX' + 'f5wU81jX3TUMAHJTirm3zAW68J0W48Z4AuGtbvldVPsAxaAxODnyvqquWvmkdW54UODUUYWiSA/dNc/NaWfc9KcJn59ICT4vFzbsw5GDMrB9VUFT4nYp' + 'H4MtyydNiMfnFe+vjGMzbzGzgwZi7FRqU4rbrvgXU0BRIrKyGjs8EQg8fqy8QGpjPtQfO2NQZvQfs0LHDeWMOjhaWHj5iw7qFpYOLUAd3Bs6d0kf++uY' + 'ALewkMHyWQamrYRhfyq/Wzh6Y864lJiButTi09nKoQosF8lXBHGNg8gSGympoAv/phTXXFGABpk4B/jQftjpRyNhAo6oAAAAASUVORK5CYII=', 1000);
  suite.canvasAppearanceTest("strokePolygon", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    painter.strokePolygon([new Point(2.5, 4.5), new Point(22.5, 4.5), new Point(14.5, 13), new Point(4, 13)], "red", 1);
    painter.strokePolygon([new Point(12, 10), new Point(39, 34), new Point(10, 33)], "blue", 3);
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAACYElEQVRYhe2XPWgUURSFv0IJAUGMXYIWUfEHixSJKQT' + 'TRYjiDyRgoeBWoqlE2EJSJCCIRFtjJYtNEAkIajCNiLFxIzbBYmGRoBERCStoLNIci3kJl5fMuJt5M7HYC6/Zd++539y9c9iFZjTjPwjBNoEyOP0hIec' + 'FXQF0jgt+C86H4LLCk4JLCRnddWh0Cb4LLoZkWxW/KbiTkDEAKibUHxB8ElwJDucanBG8SMi47FZrfIPadrci1zOBc006BZ8TMopm/0umbqfgnWAkMzj' + 'T7Kdgd8ztXe8lnT7F812CV4LbmcM5wLeCvpjbR76LHKRSK3OslAucA3wgeCwY9c8RPlZj7G4B1Jsn5Do4wWg7X76tQg3y5LUHuQw6nRtkDPqiAdoTAWn' + 'ZAy1sJeCKAWlxn/W6r9hCxnpllnBtBqDm3XWC5jzIdV6ZNeBh07yywf0O0LQHWcoTsM80nk3IK/leGcFnDzhkmk79I3fcg5yL1iBbwGHTcKKO/KIHuZC' + 'xV2rMNBurs6aQo1dqwjQabqAuL6/UlGkw1GBtHl6pWSMe82MisT5rr1TFCB/apEaWXqmaEW1LqVUK7JVqMWIr6eDWNEN6pfYaocUwgBDQK9VtRD6EA4R' + 'AXqkBI/AyLCAE8Mq1v5sCvQdddU9+AXQW1A86AeoBHQXtA3VEL5Na6+yRxis1CPrlFTd6/oCWQF9BVdA8qAx6A5oBPQU9A/3YpFdqe0rAFKfu0C3QPdB' + '90EPQpHvyGTeJsptM1U1qyU0uL8A0oVa3kx2g/W5Xe9zungSdcztdAF0D3QCNRENpRjO2Nv4CO0/DOtNuBZYAAAAASUVORK5CYII=');
  suite.canvasAppearanceTest("fillPolygon", 40, 40, function(canvas) {
    var painter = new Painter(canvas);
    painter.fillPolygon([new Point(2.5, 4.5), new Point(22.5, 4.5), new Point(14.5, 13), new Point(4, 13)], "red");
    painter.fillPolygon([new Point(12, 10), new Point(39, 34), new Point(10, 33)], "blue");
  }, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAABgklEQVRYhe3VIUgDUQDG8X9YGKIYjIIOBBHB4owTjKJ' + 'YxKIomATBMLAIKwvK4ppjRcPQIpoc2AazCoLBOlZETBYxLHyWQx5Dz2333jvDffCFu/Tj7vE9SJLkn0SQExQtdsY2cFMgSy0JUraBWUu4smDYKi4Ajgh' + 'eIuIqgjHrOAPZiIA7E4w7wwXA6oC4S8GUU1wAPAyDfJJWnnL3+xvBrHNcAFwLA7bICKQNrtQhJUFdMO8FFwCnw4BNFr8fV6i/HlPY8YbrLVrvMt+CcnG' + 'rjGjvhw97D1qNWxZEhV/+/hNoK24doHLIEW2D9uMG1v6YxHfQUZzAux63uwQajQP40McFcwqa8A1s93kLXoDmfOGGQB8DXNW+tlKTA+B8bqWyEYA+tlL' + 'LEYGut1LbFoAut1J5S0BXW6kTy0DbW6mqA6Cwt5W6dgQUdrZSTYdAEX0r9ewYKKJtpd48AEW0rVQalDG6AFoyumv0AFQ0WgGdB62BGkYfQS2jHVB+QGS' + 'SJEn+Vb4Ae+TXYBV8z6IAAAAASUVORK5CYII=');
  return {};
});
//# sourceURL=test/ui/Painter.test.js
;$traceurRuntime.registerModule("test/ui/WidgetPainter.test.js", [], function() {
  "use strict";
  var __moduleName = "test/ui/WidgetPainter.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/ui/WidgetPainter.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var WidgetPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/draw/WidgetPainter.js", "test/ui/WidgetPainter.test.js")).WidgetPainter;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Format.js", "test/ui/WidgetPainter.test.js")).Format;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/math/Complex.js", "test/ui/WidgetPainter.test.js")).Complex;
  var suite = new Suite("WidgetPainter");
  suite.test("describeAxis", function() {
    var s = Math.sqrt(2);
    assertThat(WidgetPainter.describeAxis([1, 0, 0], Format.SIMPLIFIED)).isEqualTo("X");
    assertThat(WidgetPainter.describeAxis([0, 1, 0], Format.SIMPLIFIED)).isEqualTo("Y");
    assertThat(WidgetPainter.describeAxis([0, 0, 1], Format.SIMPLIFIED)).isEqualTo("Z");
    assertThat(WidgetPainter.describeAxis([s, s, 0], Format.SIMPLIFIED)).isEqualTo("X + Y");
    assertThat(WidgetPainter.describeAxis([0, s, s], Format.SIMPLIFIED)).isEqualTo("Y + Z");
    assertThat(WidgetPainter.describeAxis([s, 0, s], Format.SIMPLIFIED)).isEqualTo("X + Z");
    assertThat(WidgetPainter.describeAxis([-s, s, 0], Format.SIMPLIFIED)).isEqualTo("-X + Y");
    assertThat(WidgetPainter.describeAxis([0, -s, s], Format.SIMPLIFIED)).isEqualTo("-Y + Z");
    assertThat(WidgetPainter.describeAxis([s, 0, -s], Format.SIMPLIFIED)).isEqualTo("X - Z");
    assertThat(WidgetPainter.describeAxis([1, -1, 1], Format.SIMPLIFIED)).isEqualTo("X - Y + Z");
    assertThat(WidgetPainter.describeAxis([1, 0.5, 0.25], Format.SIMPLIFIED)).isEqualTo("X + ½·Y + ¼·Z");
    assertThat(WidgetPainter.describeAxis([1, 0.5, 0.25], Format.CONSISTENT)).isEqualTo("X + 0.50·Y + 0.25·Z");
  });
  suite.test("describeKet", function() {
    assertThat(WidgetPainter.describeKet(1, 0, 1, Format.SIMPLIFIED)).isEqualTo('|0⟩');
    assertThat(WidgetPainter.describeKet(1, 1, 1, Format.SIMPLIFIED)).isEqualTo('|1⟩');
    assertThat(WidgetPainter.describeKet(2, 0, 1, Format.SIMPLIFIED)).isEqualTo('|00⟩');
    assertThat(WidgetPainter.describeKet(2, 1, 1, Format.SIMPLIFIED)).isEqualTo('|01⟩');
    assertThat(WidgetPainter.describeKet(2, 2, 1, Format.SIMPLIFIED)).isEqualTo('|10⟩');
    assertThat(WidgetPainter.describeKet(2, 3, 1, Format.SIMPLIFIED)).isEqualTo('|11⟩');
    assertThat(WidgetPainter.describeKet(2, 0, new Complex(-1, 0), Format.SIMPLIFIED)).isEqualTo('-|00⟩');
    assertThat(WidgetPainter.describeKet(2, 1, Complex.I, Format.SIMPLIFIED)).isEqualTo('i|01⟩');
    assertThat(WidgetPainter.describeKet(2, 2, new Complex(0, -1), Format.SIMPLIFIED)).isEqualTo('-i|10⟩');
    assertThat(WidgetPainter.describeKet(2, 3, new Complex(1, 1), Format.SIMPLIFIED)).isEqualTo('(1+i)·|11⟩');
  });
  return {};
});
//# sourceURL=test/ui/WidgetPainter.test.js
;$traceurRuntime.registerModule("test/webgl/ShaderCoders_Base.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/ShaderCoders_Base.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/ShaderCoders_Base.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat;
  var BOOL_TYPE_CODER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders_Base.js", "test/webgl/ShaderCoders_Base.test.js")).BOOL_TYPE_CODER;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/webgl/ShaderCoders_Base.test.js")),
      combinedShaderPartsWithCode = $__3.combinedShaderPartsWithCode,
      shaderWithOutputPartAndArgs = $__3.shaderWithOutputPartAndArgs;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/webgl/ShaderCoders_Base.test.js")).Shaders;
  var suite = new Suite("ShaderCoders_Base");
  suite.testUsingWebGLFloatTextures("boolInputs", function() {
    var $__0;
    var inp = BOOL_TYPE_CODER.inputPartGetter('a');
    var shader = combinedShaderPartsWithCode([inp], "\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            float k = xy.y * 4.0 + xy.x;\n            gl_FragColor = vec4(read_a(k), k, 0.0, 0.0);\n        }");
    var tex = Shaders.data(new Uint8Array([255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0])).toRawByteTexture(2);
    assertThat(($__0 = shader).withArgs.apply($__0, $traceurRuntime.spread(inp.argsFor(tex))).readRawFloatOutputs(2)).isEqualTo(new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 1, 3, 0, 0]));
    tex.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("boolOutputs", function() {
    var output = BOOL_TYPE_CODER.outputPart;
    var shader = combinedShaderPartsWithCode([output], "\n        bool outputFor(float k) {\n            return floor(mod(k + 0.5, 3.0)) == 1.0;\n        }");
    assertThat(shaderWithOutputPartAndArgs(shader, output, []).readBoolOutputs(3)).isEqualTo(new Uint8Array([0, 1, 0, 0, 1, 0, 0, 1]));
  });
  return {};
});
//# sourceURL=test/webgl/ShaderCoders_Base.test.js
;$traceurRuntime.registerModule("test/webgl/ShaderCoders_intoBytes.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/ShaderCoders_intoBytes.test.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/ShaderCoders_intoBytes.test.js")),
      Suite = $__1.Suite,
      assertThat = $__1.assertThat,
      assertThrows = $__1.assertThrows;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders_intoBytes.js", "test/webgl/ShaderCoders_intoBytes.test.js")),
      bytesAsFloats = $__2.bytesAsFloats,
      floatsAsBytes = $__2.floatsAsBytes,
      PACK_FLOAT_INTO_BYTES_CODE = $__2.PACK_FLOAT_INTO_BYTES_CODE,
      SHADER_CODER_BYTES = $__2.SHADER_CODER_BYTES,
      UNPACK_BYTES_INTO_FLOAT_CODE = $__2.UNPACK_BYTES_INTO_FLOAT_CODE;
  var SHADER_CODER_FLOATS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders_intoFloats.js", "test/webgl/ShaderCoders_intoBytes.test.js")).SHADER_CODER_FLOATS;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/webgl/ShaderCoders_intoBytes.test.js")),
      combinedShaderPartsWithCode = $__4.combinedShaderPartsWithCode,
      shaderWithOutputPartAndArgs = $__4.shaderWithOutputPartAndArgs;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/webgl/ShaderCoders_intoBytes.test.js")).Seq;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/webgl/ShaderCoders_intoBytes.test.js")).Shaders;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/webgl/ShaderCoders_intoBytes.test.js")).WglArg;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglShader.js", "test/webgl/ShaderCoders_intoBytes.test.js")).WglShader;
  var suite = new Suite("ShaderCoders_intoBytes");
  var INTERESTING_FLOATS = new Float32Array([0, 0.5, 1, 2, -1, 1.1, 42, 16777215, 16777216, 16777218, 0.9999999403953552, 1.0000001192092896, Math.pow(2.0, -126), 0.9999999403953552 * Math.pow(2.0, 128), Math.PI, Math.E, 16211.8955078125]);
  function randomFloat32Array(length) {
    var floats = new Float32Array(length);
    for (var i = 0; i < floats.length; i++) {
      floats[i] = (Math.random() - 0.5) * Math.pow(2, 16) + (Math.random() - 0.5) + (Math.random() - 0.5) / Math.pow(2, 16);
    }
    return floats;
  }
  function variedFloat32Array(length) {
    return new Float32Array($traceurRuntime.spread(INTERESTING_FLOATS, randomFloat32Array(length - INTERESTING_FLOATS.length)));
  }
  suite.test("floatsAsBytes", function() {
    assertThat(floatsAsBytes(new Float32Array([0]))).isEqualTo(new Uint8Array([0, 0, 0, 0]));
    assertThat(floatsAsBytes(new Float32Array([1]))).isEqualTo(new Uint8Array([0, 0, 128, 63]));
    assertThat(floatsAsBytes(new Float32Array([2]))).isEqualTo(new Uint8Array([0, 0, 0, 64]));
    assertThat(floatsAsBytes(new Float32Array([-1]))).isEqualTo(new Uint8Array([0, 0, 128, 191]));
    assertThat(floatsAsBytes(new Float32Array([1.1]))).isEqualTo(new Uint8Array([205, 204, 140, 63]));
    assertThat(floatsAsBytes(new Float32Array([-0.1]))).isEqualTo(new Uint8Array([205, 204, 204, 189]));
  });
  suite.test("bytesAsFloats", function() {
    assertThat(bytesAsFloats(new Uint8Array([0, 0, 0, 0]))).isEqualTo(new Float32Array([0]));
    assertThat(bytesAsFloats(new Uint8Array([0, 0, 128, 63]))).isEqualTo(new Float32Array([1]));
    assertThat(bytesAsFloats(new Uint8Array([0, 0, 0, 64]))).isEqualTo(new Float32Array([2]));
    assertThat(bytesAsFloats(new Uint8Array([0, 0, 128, 191]))).isEqualTo(new Float32Array([-1]));
    assertThat(bytesAsFloats(new Uint8Array([205, 204, 140, 63]))).isEqualTo(new Float32Array([1.1]));
    assertThat(bytesAsFloats(new Uint8Array([205, 204, 204, 189]))).isEqualTo(new Float32Array([-0.1]));
  });
  suite.test("floatsAsBytes_vs_bytesAsFloats_roundTrip", function() {
    var floats = randomFloat32Array(64);
    var bytes = floatsAsBytes(floats);
    assertThat(bytesAsFloats(bytes)).isEqualTo(floats);
  });
  suite.testUsingWebGLFloatTextures("decodeInterestingFloatsWithShader", function() {
    var shader = new WglShader(UNPACK_BYTES_INTO_FLOAT_CODE + "\n        uniform sampler2D tex;\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            vec2 uv = xy / vec2(8.0, 8.0);\n            vec4 bytes = texture2D(tex, uv);\n            float f = _gen_unpackBytesIntoFloat(bytes);\n            gl_FragColor = vec4(f, 0.0, 0.0, 0.0);\n        }");
    var floats = variedFloat32Array(64);
    var bytes = floatsAsBytes(floats);
    var tex = Shaders.data(bytes).toRawByteTexture(6);
    var outFloats = shader.withArgs(WglArg.texture('tex', tex)).readRawFloatOutputs(6);
    var packedOutFloats = new Float32Array(outFloats.length >> 2);
    for (var i = 0; i < packedOutFloats.length; i++) {
      packedOutFloats[i] = outFloats[i << 2];
    }
    tex.deallocByDepositingInPool();
    assertThat(packedOutFloats).isEqualTo(floats);
  });
  suite.testUsingWebGL("generateEncodedInterestingFloatsWithShader", function() {
    var shader = new WglShader(PACK_FLOAT_INTO_BYTES_CODE + ("\n        uniform float vals[64];\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            float k = xy.y * 8.0 + xy.x;\n            float f = 0.0;\n            " + Seq.range(64).mapWithIndex(function(i) {
      return ("if (k == " + i + ".0) f = vals[" + i + "];");
    }).join('\n            ') + "\n            gl_FragColor = _gen_packFloatIntoBytes(f);\n        }"));
    var inFloats = variedFloat32Array(64);
    var outBytes = shader.withArgs(WglArg.float_array('vals', inFloats)).readRawByteOutputs(6);
    var outFloats = bytesAsFloats(outBytes);
    assertThat(outFloats).isEqualTo(inFloats);
  });
  suite.testUsingWebGLFloatTextures("encodeInterestingFloatsWithShader", function() {
    var shader = new WglShader(PACK_FLOAT_INTO_BYTES_CODE + "\n        uniform sampler2D tex;\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            vec2 uv = xy / vec2(8.0, 8.0);\n            float f = texture2D(tex, uv).x;\n            gl_FragColor = _gen_packFloatIntoBytes(f);\n        }");
    var floats = variedFloat32Array(64);
    var spreadOutFloats = new Float32Array(floats.length << 2);
    for (var i = 0; i < floats.length; i++) {
      spreadOutFloats[i << 2] = floats[i];
    }
    var tex = Shaders.data(spreadOutFloats).toRawFloatTexture(6);
    var outBytes = shader.withArgs(WglArg.texture('tex', tex)).readRawByteOutputs(6);
    var outFloats = bytesAsFloats(outBytes);
    tex.deallocByDepositingInPool();
    assertThat(outFloats).isEqualTo(floats);
  });
  suite.testUsingWebGLFloatTextures("input_wrongType", function() {
    assertThrows(function() {
      var tex = Shaders.data(new Float32Array([0, 0, 0, 0])).toRawFloatTexture(0);
      try {
        SHADER_CODER_BYTES.float.inputPartGetter('a').argsFor(tex);
      } finally {
        tex.deallocByDepositingInPool();
      }
    });
    assertThrows(function() {
      var tex = Shaders.data(new Float32Array([0, 0, 0, 0])).toRawFloatTexture(0);
      try {
        SHADER_CODER_BYTES.vec2.inputPartGetter('a').argsFor(tex);
      } finally {
        tex.deallocByDepositingInPool();
      }
    });
    assertThrows(function() {
      var tex = Shaders.data(new Float32Array([0, 0, 0, 0])).toRawFloatTexture(0);
      try {
        SHADER_CODER_BYTES.vec4.inputPartGetter('a').argsFor(tex);
      } finally {
        tex.deallocByDepositingInPool();
      }
    });
  });
  suite.testUsingWebGL("bytes_passthrough_vec2", function() {
    var input = SHADER_CODER_BYTES.vec2.inputPartGetter('prev');
    var output = SHADER_CODER_BYTES.vec2.outputPart;
    var shader = combinedShaderPartsWithCode([input, output], "\n        vec2 outputFor(float k) {\n            return read_prev(k);\n        }");
    var floats = randomFloat32Array(64);
    var bytes = floatsAsBytes(floats);
    var tex = Shaders.data(bytes).toRawByteTexture(6);
    var configuredShader = shaderWithOutputPartAndArgs(shader, output, input.argsFor(tex));
    var outFloats = bytesAsFloats(configuredShader.readRawByteOutputs(6));
    tex.deallocByDepositingInPool();
    assertThat(outFloats).isEqualTo(floats);
  });
  suite.testUsingWebGL("bytes_passthrough_vec4", function() {
    var input = SHADER_CODER_BYTES.vec4.inputPartGetter('prev');
    var output = SHADER_CODER_BYTES.vec4.outputPart;
    var shader = combinedShaderPartsWithCode([input, output], "\n        vec4 outputFor(float k) {\n            return read_prev(k);\n        }");
    var floats = randomFloat32Array(64);
    floats[0] = 0;
    floats[1] = 1;
    floats[2] = 1.1;
    floats[3] = -1;
    floats[4] = 2;
    var bytes = floatsAsBytes(floats);
    var tex = Shaders.data(bytes).toRawByteTexture(6);
    var configuredShader = shaderWithOutputPartAndArgs(shader, output, input.argsFor(tex));
    var outFloats = bytesAsFloats(configuredShader.readRawByteOutputs(6));
    tex.deallocByDepositingInPool();
    assertThat(outFloats).isEqualTo(floats);
  });
  suite.testUsingWebGL("bytes_zip_through", function() {
    var inputA = SHADER_CODER_BYTES.vec4.inputPartGetter('a');
    var inputB = SHADER_CODER_BYTES.vec4.inputPartGetter('b');
    var output = SHADER_CODER_BYTES.vec4.outputPart;
    var shader = combinedShaderPartsWithCode([inputA, inputB, output], "\n        vec4 outputFor(float k) {\n            return read_a(k) + read_b(15.0 - k);\n        }");
    var floatsA = randomFloat32Array(64);
    var floatsB = randomFloat32Array(64);
    var bytesA = floatsAsBytes(floatsA);
    var bytesB = floatsAsBytes(floatsB);
    var texA = Shaders.data(bytesA).toRawByteTexture(6);
    var texB = Shaders.data(bytesB).toRawByteTexture(6);
    var configuredShader = shaderWithOutputPartAndArgs(shader, output, $traceurRuntime.spread(inputA.argsFor(texA), inputB.argsFor(texB)));
    var outFloats = bytesAsFloats(configuredShader.readRawByteOutputs(6));
    texA.deallocByDepositingInPool();
    texB.deallocByDepositingInPool();
    var expectedFloats = new Float32Array(floatsA);
    for (var i = 0; i < expectedFloats.length; i++) {
      var r = i % 4;
      var q = i >> 2;
      expectedFloats[i] += floatsB[(15 - q) * 4 + r];
    }
    assertThat(outFloats).withInfo({
      floatsA: floatsA,
      floatsB: floatsB
    }).isEqualTo(expectedFloats);
  });
  suite.testUsingWebGL("bytes_encoding_precision", function() {
    var inputA = SHADER_CODER_BYTES.vec2.inputPartGetter('a');
    var output = SHADER_CODER_BYTES.vec2.outputPart;
    var shader = combinedShaderPartsWithCode([inputA, output], "\n        vec2 outputFor(float k) { return read_a(k); }");
    var floatsIn = bytesAsFloats(new Uint8Array([96, 38, 84, 190, 97, 38, 84, 62, 97, 38, 84, 190, 98, 38, 84, 62]));
    var bytesIn = floatsAsBytes(floatsIn);
    var texA = Shaders.data(bytesIn).toRawByteTexture(2);
    var bytesOut = shaderWithOutputPartAndArgs(shader, output, $traceurRuntime.spread(inputA.argsFor(texA))).readRawByteOutputs(2);
    var floatsOut = bytesAsFloats(bytesOut);
    texA.deallocByDepositingInPool();
    assertThat(bytesOut).isEqualTo(bytesIn);
    assertThat(floatsOut).isEqualTo(floatsIn);
  });
  suite.testUsingWebGL("testByteToByteStability", function() {
    var shader = new WglShader("\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            xy *= 1.0;\n            gl_FragColor = vec4(\n                mod(xy.y, 64.0),\n                mod(xy.x, 64.0),\n                floor(xy.y / 64.0),\n                1.0 + floor(xy.x / 64.0)) / 255.0;\n        }\n    ");
    var sizePower = 16;
    var tex = shader.withArgs().toRawByteTexture(sizePower);
    var bytesToBytesShader = combinedShaderPartsWithCode([SHADER_CODER_BYTES.vec4.inputPartGetter('prev'), SHADER_CODER_BYTES.vec4.outputPart], 'vec4 outputFor(float k) { return read_prev(k); }');
    var reBytes = shaderWithOutputPartAndArgs(bytesToBytesShader, SHADER_CODER_BYTES.vec4.outputPart, $traceurRuntime.spread(SHADER_CODER_BYTES.vec4.inputPartGetter('prev').argsFor(tex))).readRawByteOutputs(sizePower);
    var bytes = tex.readPixels();
    tex.deallocByDepositingInPool();
    assertThat(reBytes).isEqualTo(bytes);
  });
  suite.testUsingWebGLFloatTextures("testByteToFloatToByteStability", function() {
    var shader = new WglShader("\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            gl_FragColor = vec4(\n                mod(xy.y, 64.0),\n                mod(xy.x, 64.0),\n                floor(xy.y / 64.0),\n                1.0 + floor(xy.x / 64.0)) / 255.0;\n        }\n    ");
    var sizePower = 16;
    var tex = shader.withArgs().toRawByteTexture(sizePower);
    var bytesToFloatsShader = combinedShaderPartsWithCode([SHADER_CODER_BYTES.vec4.inputPartGetter('prev'), SHADER_CODER_FLOATS.vec4.outputPart], 'vec4 outputFor(float k) { return read_prev(k); }');
    var texAsFloats = shaderWithOutputPartAndArgs(bytesToFloatsShader, SHADER_CODER_FLOATS.vec4.outputPart, $traceurRuntime.spread(SHADER_CODER_BYTES.vec4.inputPartGetter('prev').argsFor(tex))).toRawFloatTexture(sizePower - 2);
    var floatsToBytesShader = combinedShaderPartsWithCode([SHADER_CODER_FLOATS.vec4.inputPartGetter('prev'), SHADER_CODER_BYTES.vec4.outputPart], 'vec4 outputFor(float k) { return read_prev(k); }');
    var reBytes = shaderWithOutputPartAndArgs(floatsToBytesShader, SHADER_CODER_BYTES.vec4.outputPart, $traceurRuntime.spread(SHADER_CODER_FLOATS.vec4.inputPartGetter('prev').argsFor(texAsFloats))).readRawByteOutputs(sizePower);
    var bytes = tex.readPixels();
    tex.deallocByDepositingInPool();
    texAsFloats.deallocByDepositingInPool();
    assertThat(reBytes).isEqualTo(bytes);
  });
  return {};
});
//# sourceURL=test/webgl/ShaderCoders_intoBytes.test.js
;$traceurRuntime.registerModule("test/webgl/ShaderCoders_intoFloats.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/ShaderCoders_intoFloats.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/ShaderCoders_intoFloats.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat,
      assertThrows = $__0.assertThrows;
  var SHADER_CODER_FLOATS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders_intoFloats.js", "test/webgl/ShaderCoders_intoFloats.test.js")).SHADER_CODER_FLOATS;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/webgl/ShaderCoders_intoFloats.test.js")).Shaders;
  var suite = new Suite("ShaderCoders");
  suite.testUsingWebGLFloatTextures("packed", function() {
    assertThat(SHADER_CODER_FLOATS.float.dataToPixels(new Float32Array([1, 2, 3, 4]))).isEqualTo(new Float32Array([1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]));
    assertThat(SHADER_CODER_FLOATS.vec2.dataToPixels(new Float32Array([1, 2, 3, 4]))).isEqualTo(new Float32Array([1, 2, 0, 0, 3, 4, 0, 0]));
    assertThat(SHADER_CODER_FLOATS.vec4.dataToPixels(new Float32Array([1, 2, 3, 4]))).isEqualTo(new Float32Array([1, 2, 3, 4]));
  });
  suite.testUsingWebGLFloatTextures("input_wrongType", function() {
    assertThrows(function() {
      var tex = Shaders.data(new Uint8Array([0, 0, 0, 0])).toRawByteTexture(0);
      try {
        SHADER_CODER_FLOATS.float.inputPartGetter('a').argsFor(tex);
      } finally {
        tex.deallocByDepositingInPool();
      }
    });
    assertThrows(function() {
      var tex = Shaders.data(new Uint8Array([0, 0, 0, 0])).toRawByteTexture(0);
      try {
        SHADER_CODER_FLOATS.vec2.inputPartGetter('a').argsFor(tex);
      } finally {
        tex.deallocByDepositingInPool();
      }
    });
    assertThrows(function() {
      var tex = Shaders.data(new Uint8Array([0, 0, 0, 0])).toRawByteTexture(0);
      try {
        SHADER_CODER_FLOATS.vec4.inputPartGetter('a').argsFor(tex);
      } finally {
        tex.deallocByDepositingInPool();
      }
    });
  });
  return {};
});
//# sourceURL=test/webgl/ShaderCoders_intoFloats.test.js
;$traceurRuntime.registerModule("test/webgl/ShaderCoders.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/ShaderCoders.test.js";
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/ShaderCoders.test.js")),
      Suite = $__8.Suite,
      assertThat = $__8.assertThat;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/webgl/ShaderCoders.test.js")),
      combinedShaderPartsWithCode = $__9.combinedShaderPartsWithCode,
      shaderWithOutputPartAndArgs = $__9.shaderWithOutputPartAndArgs;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/webgl/ShaderCoders.test.js")).currentShaderCoder;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/webgl/ShaderCoders.test.js")).Shaders;
  var suite = new Suite("ShaderCoders");
  function randomFloat32Array(length) {
    var floats = new Float32Array(length);
    for (var i = 0; i < floats.length; i++) {
      floats[i] = (Math.random() - 0.5) * Math.pow(2, 16) + (Math.random() - 0.5) + (Math.random() - 0.5) / Math.pow(2, 16);
    }
    return floats;
  }
  suite.testUsingWebGLFloatTextures("packUnpack", function() {
    var data = randomFloat32Array(64);
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = ([currentShaderCoder().float, currentShaderCoder().vec2, currentShaderCoder().vec4])[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var coder = $__1.value;
        {
          var packed = coder.dataToPixels(data);
          var unpacked = coder.pixelsToData(packed);
          assertThat(unpacked).isEqualTo(data);
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
  });
  suite.testUsingWebGLFloatTextures("floatInput", function() {
    var $__7;
    var param = currentShaderCoder().float.inputPartGetter('fancy');
    var shader = combinedShaderPartsWithCode([param], "\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            float k = xy.y * 4.0 + xy.x;\n            gl_FragColor = vec4(\n                read_fancy(k * 4.0),\n                read_fancy(k * 4.0 + 1.0),\n                read_fancy(k * 4.0 + 2.0),\n                read_fancy(k * 4.0 + 3.0));\n        }");
    var floats = randomFloat32Array(64);
    var spread = currentShaderCoder().float.dataToPixels(floats);
    var texSquare = Shaders.data(spread).toVecFloatTexture(6);
    assertThat(($__7 = shader).withArgs.apply($__7, $traceurRuntime.spread(param.argsFor(texSquare))).readRawFloatOutputs(4)).isEqualTo(floats);
    texSquare.deallocByDepositingInPool();
  });
  suite.testUsingWebGLFloatTextures("vec2Input", function() {
    var $__7;
    var param = currentShaderCoder().vec2.inputPartGetter('fancy');
    var shader = combinedShaderPartsWithCode([param], "\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            float k = xy.y * 4.0 + xy.x;\n            vec2 a1 = read_fancy(k * 2.0);\n            vec2 a2 = read_fancy(k * 2.0 + 1.0);\n            gl_FragColor = vec4(a1, a2);\n        }");
    var floats = randomFloat32Array(64);
    var spread = currentShaderCoder().vec2.dataToPixels(floats);
    var texSquare = Shaders.data(spread).toVec2Texture(5);
    assertThat(($__7 = shader).withArgs.apply($__7, $traceurRuntime.spread(param.argsFor(texSquare))).readRawFloatOutputs(4)).isEqualTo(floats);
    texSquare.deallocByDepositingInPool();
  });
  suite.testUsingWebGLFloatTextures("vec4Input", function() {
    var $__7;
    var param = currentShaderCoder().vec4.inputPartGetter('test_input');
    var shader = combinedShaderPartsWithCode([param], "\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            float k = xy.y * 4.0 + xy.x;\n            gl_FragColor = read_test_input(k);\n        }");
    var floats = randomFloat32Array(64);
    var spread = currentShaderCoder().vec4.dataToPixels(floats);
    var texSquare = Shaders.data(spread).toVec4Texture(4);
    assertThat(($__7 = shader).withArgs.apply($__7, $traceurRuntime.spread(param.argsFor(texSquare))).readRawFloatOutputs(4)).isEqualTo(floats);
    texSquare.deallocByDepositingInPool();
  });
  suite.testUsingWebGL("floatOutput", function() {
    var output = currentShaderCoder().float.outputPart;
    var shader = combinedShaderPartsWithCode([output], "\n        float outputFor(float k) {\n            return k + 0.75;\n        }");
    assertThat(shaderWithOutputPartAndArgs(shader, output, []).readVecFloatOutputs(2)).isEqualTo(new Float32Array([0.75, 1.75, 2.75, 3.75]));
  });
  suite.testUsingWebGL("vec2Output", function() {
    var output = currentShaderCoder().vec2.outputPart;
    var shader = combinedShaderPartsWithCode([output], "\n        vec2 outputFor(float k) {\n            return vec2(k, k + 0.5);\n        }");
    assertThat(shaderWithOutputPartAndArgs(shader, output, []).readVec2Outputs(1)).isEqualTo(new Float32Array([0, 0.5, 1, 1.5]));
    assertThat(shaderWithOutputPartAndArgs(shader, output, []).readVec2Outputs(2)).isEqualTo(new Float32Array([0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5]));
  });
  suite.testUsingWebGL("vec4Output", function() {
    var output = currentShaderCoder().vec4.outputPart;
    var shader = combinedShaderPartsWithCode([output], "\n        vec4 outputFor(float k) {\n            return vec4(k, k + 0.25, k + 0.5, k + 0.75);\n        }");
    assertThat(shaderWithOutputPartAndArgs(shader, output, []).readVec4Outputs(1)).isEqualTo(new Float32Array([0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75]));
    assertThat(shaderWithOutputPartAndArgs(shader, output, []).readVec4Outputs(2)).isEqualTo(new Float32Array([0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75]));
  });
  return {};
});
//# sourceURL=test/webgl/ShaderCoders.test.js
;$traceurRuntime.registerModule("test/webgl/Shaders.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/Shaders.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/Shaders.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat,
      assertThrows = $__0.assertThrows;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/Shaders.js", "test/webgl/Shaders.test.js")).Shaders;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/webgl/Shaders.test.js")),
      Outputs = $__2.Outputs,
      makePseudoShaderWithInputsAndOutputAndCode = $__2.makePseudoShaderWithInputsAndOutputAndCode;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglShader.js", "test/webgl/Shaders.test.js")).WglShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTexture.js", "test/webgl/Shaders.test.js")).WglTexture;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/webgl/Shaders.test.js")).Seq;
  var suite = new Suite("Shaders");
  suite.testUsingWebGLFloatTextures("color", function() {
    assertThat(Shaders.color(2, 3, -5, 7.5).readRawFloatOutputs(2)).isEqualTo(new Float32Array([2, 3, -5, 7.5, 2, 3, -5, 7.5, 2, 3, -5, 7.5, 2, 3, -5, 7.5]));
    assertThat(Shaders.color(1.5, 2, 0, 121).readRawFloatOutputs(3)).isEqualTo(new Float32Array([1.5, 2, 0, 121, 1.5, 2, 0, 121, 1.5, 2, 0, 121, 1.5, 2, 0, 121, 1.5, 2, 0, 121, 1.5, 2, 0, 121, 1.5, 2, 0, 121, 1.5, 2, 0, 121]));
  });
  suite.testUsingWebGLFloatTextures("passthrough", function() {
    var coords = new WglShader("\n        void main() {\n            gl_FragColor = vec4(gl_FragCoord.x-0.5, gl_FragCoord.y-0.5, 0.0, 0.0);\n        }").withArgs();
    var input = new WglTexture(2, 4, WebGLRenderingContext.FLOAT);
    coords.renderTo(input);
    var result = new WglTexture(2, 4, WebGLRenderingContext.FLOAT);
    Shaders.passthrough(input).renderTo(result);
    assertThat(result.readPixels()).isEqualTo(new Float32Array([0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 1, 2, 0, 0, 0, 3, 0, 0, 1, 3, 0, 0]));
    input.ensureDeinitialized();
    result.ensureDeinitialized();
  });
  suite.testUsingWebGLFloatTextures("data-floats", function() {
    var data2x2 = new Float32Array([0, 0.003, 42, -5, Math.PI, Math.E, Math.sqrt(2), 0.1, 1, 0.5, -1, -2, Math.log(3), Math.sin(5), Math.cos(7), Math.exp(11)]);
    assertThat(Shaders.data(data2x2).readRawFloatOutputs(2)).isEqualTo(data2x2);
    var data2x4 = new Float32Array(Seq.range(2 * 4 * 4).map(function(e) {
      return e * e + (e - Math.sqrt(2)) / 3;
    }).toArray());
    assertThat(Shaders.data(data2x4).readRawFloatOutputs(3)).isEqualTo(data2x4);
    assertThrows(function() {
      return Shaders.data(data2x4).readRawFloatOutputs(2);
    });
  });
  suite.testUsingWebGL("data-bytes", function() {
    var bytes4x4 = new Uint8Array(Seq.range(4 * 4 * 4).map(function(e) {
      return Math.floor(Math.random() * 256);
    }).toArray());
    assertThat(Shaders.data(bytes4x4).readRawByteOutputs(4)).isEqualTo(bytes4x4);
  });
  suite.testUsingWebGL("sumFold", function() {
    var raws = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.float(), "\n        float outputFor(float k) {\n            return k*k;\n        }\n    ")().toVecFloatTexture(3);
    assertThat(Shaders.sumFoldFloat(raws).readVecFloatOutputs(2)).isEqualTo(new Float32Array([16, 1 + 25, 4 + 36, 9 + 49]));
    assertThat(Shaders.sumFoldFloatAdjacents(raws).readVecFloatOutputs(2)).isEqualTo(new Float32Array([1, 4 + 9, 16 + 25, 36 + 49]));
    raws.deallocByDepositingInPool();
    var coords = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec2(), "\n        vec2 outputFor(float k) {\n            return vec2(mod(k, 2.0), floor(k/2.0));\n        }\n    ")().toVec2Texture(3);
    assertThat(Shaders.sumFoldVec2(coords).readVec2Outputs(2)).isEqualTo(new Float32Array([0, 2, 2, 2, 0, 4, 2, 4]));
    assertThat(Shaders.sumFoldVec2Adjacents(coords).readVec2Outputs(2)).isEqualTo(new Float32Array([1, 0, 1, 2, 1, 4, 1, 6]));
    coords.deallocByDepositingInPool();
    var solid = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec4(), "\n        vec4 outputFor(float k) {\n            return vec4(2.0, 3.0, 5.0, 7.0);\n        }\n    ")().toVec4Texture(2);
    assertThat(Shaders.sumFoldVec4(solid).readVec4Outputs(1)).isEqualTo(new Float32Array([4, 6, 10, 14, 4, 6, 10, 14]));
    solid.deallocByDepositingInPool();
  });
  return {};
});
//# sourceURL=test/webgl/Shaders.test.js
;$traceurRuntime.registerModule("test/webgl/WglArg.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/WglArg.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/WglArg.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/webgl/WglArg.test.js")).WglArg;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglShader.js", "test/webgl/WglArg.test.js")).WglShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTexture.js", "test/webgl/WglArg.test.js")).WglTexture;
  var suite = new Suite("WglArg");
  suite.testUsingWebGLFloatTextures("bool", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform bool arg;\n        void main() {\n            gl_FragColor = vec4(arg ? 1.0 : -1.0, 0.0, 0.0, 0.0);\n        }");
    shader.withArgs(WglArg.bool("arg", true)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([1, 0, 0, 0]));
    shader.withArgs(WglArg.bool("arg", false)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([-1, 0, 0, 0]));
  });
  suite.testUsingWebGLFloatTextures("float", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform float arg;\n        void main() {\n            gl_FragColor = vec4(arg, 0.0, 0.0, 0.0);\n        }");
    shader.withArgs(WglArg.float("arg", Math.PI)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([Math.PI, 0, 0, 0]));
    shader.withArgs(WglArg.float("arg", Math.E)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([Math.E, 0, 0, 0]));
  });
  suite.testUsingWebGLFloatTextures("int", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform int arg;\n        void main() {\n            gl_FragColor = vec4(float(arg), 0.0, 0.0, 0.0);\n        }");
    shader.withArgs(WglArg.int("arg", 2)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([2, 0, 0, 0]));
    shader.withArgs(WglArg.int("arg", 3)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([3, 0, 0, 0]));
  });
  suite.testUsingWebGLFloatTextures("vec2", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform vec2 arg;\n        void main() {\n            gl_FragColor = vec4(arg.x, arg.y, 0.0, 0.0);\n        }");
    shader.withArgs(WglArg.vec2("arg", 2, 3)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([2, 3, 0, 0]));
    shader.withArgs(WglArg.vec2("arg", Math.E, Math.PI)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([Math.E, Math.PI, 0, 0]));
  });
  suite.testUsingWebGLFloatTextures("vec4", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform vec4 arg;\n        void main() {\n            gl_FragColor = vec4(arg.r, arg.g, arg.b, arg.a);\n        }");
    shader.withArgs(WglArg.vec4("arg", 2, 3, 5, 7)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([2, 3, 5, 7]));
    shader.withArgs(WglArg.vec4("arg", Math.E, Math.PI, Infinity, NaN)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([Math.E, Math.PI, Infinity, NaN]));
  });
  suite.testUsingWebGLFloatTextures("mat4", function() {
    var texture = new WglTexture(4, 1);
    var shader = new WglShader("\n        uniform mat4 arg;\n        void main() {\n            if (gl_FragCoord.x == 0.5) {\n                gl_FragColor = arg[0];\n            } else if (gl_FragCoord.x == 1.5) {\n                gl_FragColor = arg[1];\n            } else if (gl_FragCoord.x == 2.5) {\n                gl_FragColor = arg[2];\n            } else if (gl_FragCoord.x == 3.5) {\n                gl_FragColor = arg[3];\n            }\n        }");
    var vals = new Float32Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
    shader.withArgs(WglArg.mat4("arg", vals)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(vals);
  });
  suite.testUsingWebGLFloatTextures("texture", function() {
    var srcTexture = new WglTexture(1, 1);
    new WglShader("void main(){gl_FragColor=vec4(1, 2, 3, 5);}").withArgs().renderTo(srcTexture);
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform sampler2D arg;\n        void main() {\n            gl_FragColor = texture2D(arg, vec2(0.5, 0.5));\n        }");
    shader.withArgs(WglArg.texture("arg", srcTexture)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([1, 2, 3, 5]));
  });
  suite.testUsingWebGLFloatTextures("float_array", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform float arg[2];\n        void main() {\n            gl_FragColor = vec4(arg[0], arg[1], 0.0, 0.0);\n        }");
    shader.withArgs(WglArg.float_array("arg", new Float32Array([2, 3]))).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([2, 3, 0, 0]));
  });
  suite.testUsingWebGLFloatTextures("vec2_array", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform vec2 arg[2];\n        void main() {\n            gl_FragColor = vec4(arg[0], arg[1]);\n        }");
    shader.withArgs(WglArg.vec2_array("arg", new Float32Array([2, 3, 5, 7]))).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([2, 3, 5, 7]));
  });
  suite.testUsingWebGLFloatTextures("vec4_array", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform vec4 arg[1];\n        void main() {\n            gl_FragColor = arg[0];\n        }");
    shader.withArgs(WglArg.vec4_array("arg", new Float32Array([2, 3, 5, 7]))).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([2, 3, 5, 7]));
  });
  suite.testUsingWebGLFloatTextures("mat4_array", function() {
    var texture = new WglTexture(1, 1);
    var shader = new WglShader("\n        uniform mat4 arg[2];\n        void main() {\n            gl_FragColor = arg[0][1];\n        }");
    shader.withArgs(WglArg.mat4_array("arg", new Float32Array([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9]))).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([11, 13, 17, 19]));
  });
  return {};
});
//# sourceURL=test/webgl/WglArg.test.js
;$traceurRuntime.registerModule("test/webgl/WglShader.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/WglShader.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/WglShader.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglShader.js", "test/webgl/WglShader.test.js")).WglShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTexture.js", "test/webgl/WglShader.test.js")).WglTexture;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/base/Seq.js", "test/webgl/WglShader.test.js")).Seq;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglContext.js", "test/webgl/WglShader.test.js")).initializedWglContext;
  var suite = new Suite("WglShader");
  suite.testUsingWebGL("renderTo_large", function() {
    var tex = new WglTexture(256, 256, WebGLRenderingContext.UNSIGNED_BYTE);
    new WglShader("void main(){gl_FragColor=vec4(3.0,3.0,3.0,3.0)/255.0;}").withArgs().renderTo(tex);
    var expected = new Uint8Array(Seq.repeat(3, 4 * tex.width * tex.height).toArray());
    assertThat(tex.readPixels()).isEqualTo(expected);
  });
  suite.testUsingWebGLFloatTextures("renderTo_empty", function() {
    var tex = new WglTexture(0, 0);
    new WglShader("void main(){gl_FragColor=vec4(0.0,0.0,0.0,0.0);}").withArgs().renderTo(tex);
    assertThat(tex.readPixels()).isEqualTo(new Float32Array([]));
  });
  suite.testUsingWebGL("readPixels_bytes_all", function() {
    var shader = new WglShader("\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            float s = (xy.y*8.0 + xy.x)*4.0;\n            gl_FragColor = vec4(\n                (s+0.0)/255.0,\n                (s+1.0)/255.0,\n                (s+2.0)/255.0,\n                (s+3.0)/255.0);\n        }").withArgs();
    var tex = new WglTexture(8, 8, WebGLRenderingContext.UNSIGNED_BYTE);
    shader.renderTo(tex);
    assertThat(tex.readPixels()).isEqualTo(new Uint8Array(Seq.range(256).toArray()));
    tex.ensureDeinitialized();
  });
  suite.testUsingWebGLFloatTextures("changeSourceAfterInvalidate", function() {
    var tex = new WglTexture(1, 1);
    var flag = true;
    var shader = new WglShader(function() {
      return flag ? "void main(){gl_FragColor=vec4(-5.0,-6.0,7.0,8.0);}" : "void main(){gl_FragColor=vec4(1.0,2.0,3.0,4.0);}";
    });
    shader.withArgs().renderTo(tex);
    assertThat(tex.readPixels()).isEqualTo(new Float32Array([-5, -6, 7, 8]));
    flag = false;
    initializedWglContext().invalidateExistingResources();
    shader.withArgs().renderTo(tex);
    assertThat(tex.readPixels()).isEqualTo(new Float32Array([1, 2, 3, 4]));
  });
  return {};
});
//# sourceURL=test/webgl/WglShader.test.js
;$traceurRuntime.registerModule("test/webgl/WglTexture.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/WglTexture.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/WglTexture.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglArg.js", "test/webgl/WglTexture.test.js")).WglArg;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglShader.js", "test/webgl/WglTexture.test.js")).WglShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTexture.js", "test/webgl/WglTexture.test.js")).WglTexture;
  var suite = new Suite("WglTexture");
  suite.test("properties", function() {
    var t = new WglTexture(8, 16, WebGLRenderingContext.UNSIGNED_BYTE);
    assertThat(t.width).isEqualTo(8);
    assertThat(t.height).isEqualTo(16);
    assertThat(t.pixelType).isEqualTo(WebGLRenderingContext.UNSIGNED_BYTE);
    assertThat(t.sizePower()).isEqualTo(7);
    assertThat(t.toString()).isNotEqualTo(undefined);
  });
  suite.testUsingWebGL("readPixels_bytes", function() {
    var w = 2;
    var h = 2;
    var shader = new WglShader("\n        uniform float v;\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(0.5, 0.5);\n            gl_FragColor = vec4(xy / 255.0, v, 128.0/255.0);\n        }");
    var texture = new WglTexture(w, h, WebGLRenderingContext.UNSIGNED_BYTE);
    shader.withArgs(WglArg.float("v", 10 / 255)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Uint8Array([0, 0, 10, 128, 1, 0, 10, 128, 0, 1, 10, 128, 1, 1, 10, 128]));
  });
  suite.testUsingWebGLFloatTextures("readPixels_floats", function() {
    var w = 2;
    var h = 2;
    var shader = new WglShader("\n        uniform float v;\n        void main() {\n            gl_FragColor = vec4(gl_FragCoord.xy, v, 254.5);\n        }");
    var texture = new WglTexture(w, h);
    shader.withArgs(WglArg.float("v", 192.25)).renderTo(texture);
    assertThat(texture.readPixels()).isEqualTo(new Float32Array([0.5, 0.5, 192.25, 254.5, 1.5, 0.5, 192.25, 254.5, 0.5, 1.5, 192.25, 254.5, 1.5, 1.5, 192.25, 254.5]));
  });
  suite.testUsingWebGL("readPixels_empty", function() {
    assertThat(new WglTexture(0, 0).readPixels()).isEqualTo(new Float32Array([]));
  });
  return {};
});
//# sourceURL=test/webgl/WglTexture.test.js
;$traceurRuntime.registerModule("test/webgl/WglTexturePool.test.js", [], function() {
  "use strict";
  var __moduleName = "test/webgl/WglTexturePool.test.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TestUtil.js", "test/webgl/WglTexturePool.test.js")),
      Suite = $__0.Suite,
      assertThat = $__0.assertThat;
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/ShaderCoders.js", "test/webgl/WglTexturePool.test.js")),
      currentShaderCoder = $__1.currentShaderCoder,
      Outputs = $__1.Outputs,
      makePseudoShaderWithInputsAndOutputAndCode = $__1.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../src/webgl/WglTexturePool.js", "test/webgl/WglTexturePool.test.js")).WglTexturePool;
  var suite = new Suite("WglTexturePool");
  suite.testUsingWebGL("takeBoolTex", function() {
    var t = WglTexturePool.takeBoolTex(2);
    makePseudoShaderWithInputsAndOutputAndCode([], Outputs.bool(), "bool outputFor(float k) {\n            return k == 2.0;\n        }")().renderTo(t);
    assertThat(t.readPixels()).isEqualTo(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 0, 0]));
    t.deallocByDepositingInPool();
  });
  suite.testUsingWebGLFloatTextures("takeVec2Tex", function() {
    var t = WglTexturePool.takeVec2Tex(2);
    makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec2(), "vec2 outputFor(float k) {\n            return vec2(k / 4.0, k * k);\n        }")().renderTo(t);
    assertThat(currentShaderCoder().vec2.pixelsToData(t.readPixels())).isEqualTo(new Float32Array([0, 0, 0.25, 1, 0.5, 4, 0.75, 9]));
    t.deallocByDepositingInPool();
  });
  suite.testUsingWebGLFloatTextures("takeVec4Tex", function() {
    var t = WglTexturePool.takeVec4Tex(2);
    makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec4(), "vec4 outputFor(float k) {\n            return vec4(k, k / 4.0, k * k, 5.0);\n        }")().renderTo(t);
    assertThat(currentShaderCoder().vec4.pixelsToData(t.readPixels())).isEqualTo(new Float32Array([0, 0, 0, 5, 1, 0.25, 1, 5, 2, 0.5, 4, 5, 3, 0.75, 9, 5]));
    t.deallocByDepositingInPool();
  });
  return {};
});
//# sourceURL=test/webgl/WglTexturePool.test.js
;$traceurRuntime.getModule("test/base/Describe.test.js");
$traceurRuntime.getModule("test/base/DetailedError.test.js");
$traceurRuntime.getModule("test/base/Equate.test.js");
$traceurRuntime.getModule("test/base/Format.test.js");
$traceurRuntime.getModule("test/base/Obs.test.js");
$traceurRuntime.getModule("test/base/RestartableRng.test.js");
$traceurRuntime.getModule("test/base/Revision.test.js");
$traceurRuntime.getModule("test/base/Seq.test.js");
$traceurRuntime.getModule("test/base/Util.test.js");
$traceurRuntime.getModule("test/circuit/CircuitComputeUtil.test.js");
$traceurRuntime.getModule("test/circuit/CircuitDefinition.test.js");
$traceurRuntime.getModule("test/circuit/CircuitShaders.test.js");
$traceurRuntime.getModule("test/circuit/CircuitStats.test.js");
$traceurRuntime.getModule("test/circuit/Controls.test.js");
$traceurRuntime.getModule("test/circuit/Gate.test.js");
$traceurRuntime.getModule("test/circuit/GateColumn.test.js");
$traceurRuntime.getModule("test/circuit/GateShaders.test.js");
$traceurRuntime.getModule("test/circuit/KetShaderUtil.test.js");
$traceurRuntime.getModule("test/circuit/Serializer.test.js");
$traceurRuntime.getModule("test/gates/AllGates.test.js");
$traceurRuntime.getModule("test/gates/AmplitudeDisplay.test.js");
$traceurRuntime.getModule("test/gates/ArithmeticGates.test.js");
$traceurRuntime.getModule("test/gates/BitCountGates.test.js");
$traceurRuntime.getModule("test/gates/ComparisonGates.test.js");
$traceurRuntime.getModule("test/gates/Controls.test.js");
$traceurRuntime.getModule("test/gates/CycleBitsGates.test.js");
$traceurRuntime.getModule("test/gates/DensityMatrixDisplay.test.js");
$traceurRuntime.getModule("test/gates/Detector.test.js");
$traceurRuntime.getModule("test/gates/ExponentiatingGates.test.js");
$traceurRuntime.getModule("test/gates/FourierTransformGates.test.js");
$traceurRuntime.getModule("test/gates/Impossible_UniversalNotGate.test.js");
$traceurRuntime.getModule("test/gates/IncrementGates.test.js");
$traceurRuntime.getModule("test/gates/InputGates.test.js");
$traceurRuntime.getModule("test/gates/InterleaveBitsGates.test.js");
$traceurRuntime.getModule("test/gates/ModularAdditionGates.test.js");
$traceurRuntime.getModule("test/gates/ModularIncrementGates.test.js");
$traceurRuntime.getModule("test/gates/ModularMultiplicationGates.test.js");
$traceurRuntime.getModule("test/gates/ModularMultiplyAccumulateGates.test.js");
$traceurRuntime.getModule("test/gates/MultiplicationGates.test.js");
$traceurRuntime.getModule("test/gates/MultiplyAccumulateGates.test.js");
$traceurRuntime.getModule("test/gates/ParametrizedRotationGates.test.js");
$traceurRuntime.getModule("test/gates/PhaseGradientGates.test.js");
$traceurRuntime.getModule("test/gates/PivotFlipGates.test.js");
$traceurRuntime.getModule("test/gates/ProbabilityDisplay.test.js");
$traceurRuntime.getModule("test/gates/SampleDisplay.test.js");
$traceurRuntime.getModule("test/gates/XorGates.test.js");
$traceurRuntime.getModule("test/KarmaTestRunner.test.js");
$traceurRuntime.getModule("test/math/Axis.test.js");
$traceurRuntime.getModule("test/math/Complex.test.js");
$traceurRuntime.getModule("test/math/Matrix.test.js");
$traceurRuntime.getModule("test/math/Point.test.js");
$traceurRuntime.getModule("test/math/Rect.test.js");
$traceurRuntime.getModule("test/ui/DisplayedCircuit.test.js");
$traceurRuntime.getModule("test/ui/forge.test.js");
$traceurRuntime.getModule("test/ui/MathPainter.test.js");
$traceurRuntime.getModule("test/ui/Painter.test.js");
$traceurRuntime.getModule("test/ui/WidgetPainter.test.js");
$traceurRuntime.getModule("test/webgl/ShaderCoders_Base.test.js");
$traceurRuntime.getModule("test/webgl/ShaderCoders_intoBytes.test.js");
$traceurRuntime.getModule("test/webgl/ShaderCoders_intoFloats.test.js");
$traceurRuntime.getModule("test/webgl/ShaderCoders.test.js");
$traceurRuntime.getModule("test/webgl/Shaders.test.js");
$traceurRuntime.getModule("test/webgl/WglArg.test.js");
$traceurRuntime.getModule("test/webgl/WglShader.test.js");
$traceurRuntime.getModule("test/webgl/WglTexture.test.js");
$traceurRuntime.getModule("test/webgl/WglTexturePool.test.js");